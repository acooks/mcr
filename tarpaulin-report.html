<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","acooks","mcr","experiments","poc_io_uring_af_packet","src","main.rs"],"content":"//! Proof-of-Concept: io_uring with AF_PACKET Sockets\n//!\n//! This binary is a minimal, self-contained example demonstrating how to use the\n//! `tokio-uring` runtime to asynchronously read raw packets from an `AF_PACKET`\n//! socket.\n//!\n//! It establishes the correct pattern for integrating a raw file descriptor,\n//! obtained via `libc` calls, into the `tokio-uring` ecosystem.\n//!\n//! ## Usage:\n//!\n//! ```sh\n//! sudo target/debug/poc_io_uring_af_packet \u003cINTERFACE_NAME\u003e\n//! ```\n//! e.g.\n//! ```sh\n//! sudo target/debug/poc_io_uring_af_packet eth0\n//! ```\n\nuse anyhow::Result;\nuse std::ffi::CString;\nuse std::mem;\nuse std::os::unix::io::{AsRawFd, FromRawFd, OwnedFd};\n\n/// Creates and binds an AF_PACKET socket using direct libc calls.\n/// This function is a self-contained copy of the logic in `worker::data_plane`.\n/// It requires root privileges to execute successfully.\nfn setup_ingress_socket(interface_name: \u0026str) -\u003e Result\u003cOwnedFd\u003e {\n    // 1. Convert the interface name to a CString for libc.\n    let if_name = CString::new(interface_name)?;\n    // 2. Get the interface index.\n    let if_index = unsafe { libc::if_nametoindex(if_name.as_ptr()) };\n    if if_index == 0 {\n        return Err(anyhow::anyhow!(\n            \"Interface '{}' not found (errno: {})\",\n            interface_name,\n            std::io::Error::last_os_error()\n        ));\n    }\n\n    // 3. Create an AF_PACKET, SOCK_RAW socket.\n    // We convert ETH_P_ALL to network byte order.\n    let fd = unsafe {\n        libc::socket(\n            libc::AF_PACKET,\n            libc::SOCK_RAW,\n            (libc::ETH_P_ALL as u16).to_be() as i32,\n        )\n    };\n    if fd \u003c 0 {\n        return Err(anyhow::anyhow!(\n            \"Failed to create AF_PACKET socket (errno: {})\",\n            std::io::Error::last_os_error()\n        ));\n    }\n\n    // 4. Construct the sockaddr_ll struct for binding.\n    let mut sockaddr_ll: libc::sockaddr_ll = unsafe { mem::zeroed() };\n    sockaddr_ll.sll_family = libc::AF_PACKET as u16;\n    sockaddr_ll.sll_protocol = (libc::ETH_P_ALL as u16).to_be();\n    sockaddr_ll.sll_ifindex = if_index as i32;\n\n    // 5. Bind the socket to the specified interface.\n    let bind_result = unsafe {\n        libc::bind(\n            fd,\n            \u0026sockaddr_ll as *const _ as *const libc::sockaddr,\n            mem::size_of::\u003clibc::sockaddr_ll\u003e() as u32,\n        )\n    };\n    if bind_result \u003c 0 {\n        return Err(anyhow::anyhow!(\n            \"Failed to bind to interface '{}' (errno: {})\",\n            interface_name,\n            std::io::Error::last_os_error()\n        ));\n    }\n\n    println!(\n        \"Successfully created and bound AF_PACKET socket (fd: {}) to interface '{}' (index: {}).\",\n        fd, interface_name, if_index\n    );\n\n    // 6. Safely wrap the raw file descriptor in an OwnedFd.\n    Ok(unsafe { OwnedFd::from_raw_fd(fd) })\n}\n\nfn main() -\u003e Result\u003c()\u003e {\n    // Get the interface name from the command line arguments.\n    let args: Vec\u003cString\u003e = std::env::args().collect();\n    if args.len() != 2 {\n        eprintln!(\"Usage: {} \u003cINTERFACE_NAME\u003e\", args[0]);\n        std::process::exit(1);\n    }\n    let interface_name = \u0026args[1];\n\n    // Use tokio_uring::start to run an async main function on a tokio-uring runtime.\n    tokio_uring::start(async {\n        // --- Setup Phase ---\n        // Create the raw socket. This part requires privileges.\n        let socket_fd = setup_ingress_socket(interface_name).expect(\"Failed to setup socket\");\n\n        // Convert the `OwnedFd` into a `tokio_uring::fs::File`. This is the\n        // critical step that allows `tokio-uring` to manage the raw file descriptor.\n        // We must wrap this in an `unsafe` block because we are responsible for\n        // ensuring the file descriptor is valid.\n        let uring_file = unsafe { tokio_uring::fs::File::from_raw_fd(socket_fd.as_raw_fd()) };\n\n        // Pre-allocate a buffer for reading packets.\n        // The `read_at` operation in tokio-uring takes ownership of the buffer and\n        // returns it, so we need to re-assign it in the loop.\n        let mut buffer = vec![0u8; 2048]; // A common MTU size\n\n        println!(\"Starting to read packets using io_uring...\");\n\n        // --- I/O Loop ---\n        loop {\n            // Submit a `read_at` operation to the io_uring at offset 0.\n            // For a raw socket, the offset is ignored, but the API requires it.\n            // This does not block the thread. It submits the request to the kernel\n            // and returns a Future.\n            let read_future = uring_file.read_at(buffer, 0);\n\n            // `await` the future. The runtime will suspend this task and work on\n            // other things until the kernel signals that the read operation is complete.\n            let (res, b) = read_future.await;\n\n            // The buffer is returned along with the result. We take it back.\n            buffer = b;\n            let bytes_read = res.expect(\"Read operation failed\");\n\n            if bytes_read \u003e 0 {\n                // For this PoC, we just print the number of bytes read.\n                // In the real application, this is where we would parse the\n                // Ethernet frame and process the packet.\n                println!(\"Read {} bytes from the wire.\", bytes_read);\n            }\n        }\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","experiments","poc_tokio_uring_concurrency","src","main.rs"],"content":"//! Proof-of-Concept: Task Management in a Single-Threaded `tokio-uring` Runtime\n//!\n//! This binary demonstrates the correct concurrency pattern for managing multiple\n//! long-running, concurrent tasks within a single-threaded `tokio-uring` runtime.\n//!\n//! ## Problem\n//!\n//! `tokio-uring` creates a single-threaded runtime. Types used with it (like\n//! `tokio_uring::fs::File`) are often `!Send` and `!Sync`, meaning they cannot be\n//! passed between threads. This conflicts with `tokio::spawn`, which is for\n//! multi-threaded environments. The solution is to use `tokio::task::spawn_local`\n//! to ensure tasks are managed by the single-threaded scheduler.\n//!\n//! This PoC also demonstrates how to manage these locally-spawned tasks,\n//! including dynamically stopping and starting one of them, which is a requirement\n//! for the main application's `run_flow_task`.\n//!\n//! ## Usage\n//!\n//! ```sh\n//! cargo run\n//! ```\n\nuse anyhow::Result;\nuse std::time::Duration;\nuse tokio::sync::mpsc;\nuse tokio::task::{spawn_local, JoinHandle};\n\n/// Simulates a long-running, static task like the control plane listener.\nasync fn control_task() {\n    println!(\"[Control Task] Started.\");\n    let mut interval = tokio::time::interval(Duration::from_secs(3));\n    loop {\n        interval.tick().await;\n        println!(\"[Control Task] Running...\");\n    }\n}\n\n/// Simulates a long-running, static task like the stats aggregator.\nasync fn stats_task() {\n    println!(\"[Stats Task] Started.\");\n    let mut interval = tokio::time::interval(Duration::from_secs(5));\n    loop {\n        interval.tick().await;\n        println!(\"[Stats Task] Running...\");\n    }\n}\n\n/// Simulates a dynamic, replaceable task like a `run_flow_task`.\nasync fn replaceable_task(id: u32) {\n    println!(\"[Flow Task {}] Started.\", id);\n    let mut interval = tokio::time::interval(Duration::from_secs(1));\n    loop {\n        interval.tick().await;\n        println!(\"[Flow Task {}] Reading packet...\", id);\n    }\n}\n\n/// The main manager that orchestrates all other tasks.\nasync fn run_manager() -\u003e Result\u003c()\u003e {\n    println!(\"[Manager] Starting...\");\n\n    // --- Spawn static, long-running tasks ---\n    // We use `spawn_local` because we are in a single-threaded runtime.\n    // These tasks will run concurrently with the manager's main loop.\n    spawn_local(control_task());\n    spawn_local(stats_task());\n\n    // --- Set up for dynamic tasks ---\n    // A channel to receive commands to change the dynamic task.\n    let (command_tx, mut command_rx) = mpsc::channel(10);\n\n    // A handle to the currently running dynamic task, so we can abort it.\n    let mut flow_task_handle: Option\u003cJoinHandle\u003c()\u003e\u003e = None;\n\n    // --- Simulate external commands ---\n    // Spawn a local task that sends commands to the manager.\n    spawn_local(async move {\n        println!(\"[Command Simulator] Sending START(1) in 2s...\");\n        tokio::time::sleep(Duration::from_secs(2)).await;\n        command_tx.send(1).await.unwrap();\n\n        println!(\"[Command Simulator] Sending START(2) in 4s...\");\n        tokio::time::sleep(Duration::from_secs(4)).await;\n        command_tx.send(2).await.unwrap();\n\n        println!(\"[Command Simulator] Sending STOP in 3s...\");\n        tokio::time::sleep(Duration::from_secs(3)).await;\n        command_tx.send(99).await.unwrap(); // 99 means STOP\n    });\n\n    println!(\"[Manager] Entering main select loop...\");\n    // --- Main Event Loop ---\n    loop {\n        tokio::select! {\n            // Listen for a command from the channel.\n            Some(flow_id) = command_rx.recv() =\u003e {\n                println!(\"[Manager] Received command: START({})\", flow_id);\n\n                // 1. If a flow task is already running, abort it.\n                if let Some(handle) = flow_task_handle.take() {\n                    println!(\"[Manager] Aborting previous flow task.\");\n                    handle.abort();\n                }\n\n                // 2. If the command is not STOP, spawn a new replaceable task.\n                if flow_id != 99 {\n                    println!(\"[Manager] Spawning new flow task: {}.\", flow_id);\n                    flow_task_handle = Some(spawn_local(replaceable_task(flow_id)));\n                } else {\n                    println!(\"[Manager] Received STOP command. No task running.\");\n                }\n            }\n        }\n    }\n}\n\nfn main() -\u003e Result\u003c()\u003e {\n    // Start the single-threaded `tokio-uring` runtime.\n    tokio_uring::start(run_manager())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","build.rs"],"content":"use cfg_aliases::cfg_aliases;\n\nfn main() {\n    cfg_aliases! {\n        android: { target_os = \"android\" },\n        dragonfly: { target_os = \"dragonfly\" },\n        ios: { target_os = \"ios\" },\n        freebsd: { target_os = \"freebsd\" },\n        illumos: { target_os = \"illumos\" },\n        linux: { target_os = \"linux\" },\n        macos: { target_os = \"macos\" },\n        netbsd: { target_os = \"netbsd\" },\n        openbsd: { target_os = \"openbsd\" },\n        solaris: { target_os = \"solaris\" },\n        watchos: { target_os = \"watchos\" },\n        tvos: { target_os = \"tvos\" },\n        visionos: { target_os = \"visionos\" },\n\n\n        // cfg aliases we would like to use\n        apple_targets: { any(ios, macos, watchos, tvos, visionos) },\n        bsd: { any(freebsd, dragonfly, netbsd, openbsd, apple_targets) },\n        bsd_without_apple: { any(freebsd, dragonfly, netbsd, openbsd) },\n        linux_android: { any(android, linux) },\n        freebsdlike: { any(dragonfly, freebsd) },\n        netbsdlike: { any(netbsd, openbsd) },\n        solarish: { any(illumos, solaris) },\n    }\n\n    // Below are custom cfg values set during some CI steps.\n    println!(\"cargo:rustc-check-cfg=cfg(fbsd14)\");\n    println!(\"cargo:rustc-check-cfg=cfg(qemu)\");\n    // Cygwin target, added in 1.86\n    println!(\"cargo:rustc-check-cfg=cfg(target_os, values(\\\"cygwin\\\"))\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","dir.rs"],"content":"//! List directory contents\n\nuse crate::errno::Errno;\nuse crate::fcntl::{self, OFlag};\nuse crate::sys;\nuse crate::{NixPath, Result};\nuse cfg_if::cfg_if;\nuse std::ffi;\nuse std::os::unix::io::{AsRawFd, IntoRawFd, RawFd};\nuse std::ptr;\n\n#[cfg(target_os = \"linux\")]\nuse libc::{dirent64 as dirent, readdir64_r as readdir_r};\n\n#[cfg(not(target_os = \"linux\"))]\nuse libc::{dirent, readdir_r};\n\n/// An open directory.\n///\n/// This is a lower-level interface than [`std::fs::ReadDir`]. Notable differences:\n///    * can be opened from a file descriptor (as returned by [`openat`][openat],\n///      perhaps before knowing if the path represents a file or directory).\n///    * implements [`AsFd`][AsFd], so it can be passed to [`fstat`][fstat],\n///      [`openat`][openat], etc. The file descriptor continues to be owned by the\n///      `Dir`, so callers must not keep a `RawFd` after the `Dir` is dropped.\n///    * can be iterated through multiple times without closing and reopening the file\n///      descriptor. Each iteration rewinds when finished.\n///    * returns entries for `.` (current directory) and `..` (parent directory).\n///    * returns entries' names as a [`CStr`][cstr] (no allocation or conversion beyond whatever libc\n///      does).\n///\n/// [AsFd]: std::os::fd::AsFd\n/// [fstat]: crate::sys::stat::fstat\n/// [openat]: crate::fcntl::openat\n/// [cstr]: std::ffi::CStr\n///\n/// # Examples\n///\n/// Traverse the current directory, and print entries' names:\n///\n/// ```\n/// use nix::dir::Dir;\n/// use nix::fcntl::OFlag;\n/// use nix::sys::stat::Mode;\n///\n/// let mut cwd = Dir::open(\".\", OFlag::O_RDONLY | OFlag::O_CLOEXEC, Mode::empty()).unwrap();\n/// for res_entry in cwd.iter() {\n///     let entry = res_entry.unwrap();\n///     println!(\"File name: {}\", entry.file_name().to_string_lossy());\n/// }\n/// ```\n#[derive(Debug, Eq, Hash, PartialEq)]\npub struct Dir(ptr::NonNull\u003clibc::DIR\u003e);\n\nimpl Dir {\n    /// Opens the given path as with `fcntl::open`.\n    pub fn open\u003cP: ?Sized + NixPath\u003e(\n        path: \u0026P,\n        oflag: OFlag,\n        mode: sys::stat::Mode,\n    ) -\u003e Result\u003cSelf\u003e {\n        let fd = fcntl::open(path, oflag, mode)?;\n        Dir::from_fd(fd)\n    }\n\n    /// Opens the given path as with `fcntl::openat`.\n    pub fn openat\u003cFd: std::os::fd::AsFd, P: ?Sized + NixPath\u003e(\n        dirfd: Fd,\n        path: \u0026P,\n        oflag: OFlag,\n        mode: sys::stat::Mode,\n    ) -\u003e Result\u003cSelf\u003e {\n        let fd = fcntl::openat(dirfd, path, oflag, mode)?;\n        Dir::from_fd(fd)\n    }\n\n    /// Converts from a descriptor-based object, closing the descriptor on success or failure.\n    ///\n    /// # Safety\n    ///\n    /// It is only safe if `fd` is an owned file descriptor.\n    #[inline]\n    #[deprecated(\n        since = \"0.30.0\",\n        note = \"Deprecate this since it is not I/O-safe, use from_fd instead.\"\n    )]\n    pub unsafe fn from\u003cF: IntoRawFd\u003e(fd: F) -\u003e Result\u003cSelf\u003e {\n        use std::os::fd::FromRawFd;\n        use std::os::fd::OwnedFd;\n\n        // SAFETY:\n        //\n        // This is indeed unsafe is `fd` it not an owned fd.\n        let owned_fd = unsafe { OwnedFd::from_raw_fd(fd.into_raw_fd()) };\n        Dir::from_fd(owned_fd)\n    }\n\n    /// Converts from a file descriptor, closing it on failure.\n    ///\n    /// # Examples\n    ///\n    /// `ENOTDIR` would be returned if `fd` does not refer to a directory:\n    ///\n    /// ```should_panic\n    /// use std::os::fd::OwnedFd;\n    /// use nix::dir::Dir;\n    ///\n    /// let temp_file = tempfile::tempfile().unwrap();\n    /// let temp_file_fd: OwnedFd = temp_file.into();\n    /// let never = Dir::from_fd(temp_file_fd).unwrap();\n    /// ```\n    #[doc(alias(\"fdopendir\"))]\n    pub fn from_fd(fd: std::os::fd::OwnedFd) -\u003e Result\u003cSelf\u003e {\n        // take the ownership as the constructed `Dir` is now the owner\n        let raw_fd = fd.into_raw_fd();\n        let d = ptr::NonNull::new(unsafe { libc::fdopendir(raw_fd) })\n            .ok_or(Errno::last())?;\n        Ok(Dir(d))\n    }\n\n    /// Returns an iterator of `Result\u003cEntry\u003e` which rewinds when finished.\n    pub fn iter(\u0026mut self) -\u003e Iter {\n        Iter(self)\n    }\n}\n\n// `Dir` is not `Sync`. With the current implementation, it could be, but according to\n// https://www.gnu.org/software/libc/manual/html_node/Reading_002fClosing-Directory.html,\n// future versions of POSIX are likely to obsolete `readdir_r` and specify that it's unsafe to\n// call `readdir` simultaneously from multiple threads.\n//\n// `Dir` is safe to pass from one thread to another, as it's not reference-counted.\nunsafe impl Send for Dir {}\n\nimpl std::os::fd::AsFd for Dir {\n    fn as_fd(\u0026self) -\u003e std::os::fd::BorrowedFd {\n        let raw_fd = self.as_raw_fd();\n\n        // SAFETY:\n        //\n        // `raw_fd` should be open and valid for the lifetime of the returned\n        // `BorrowedFd` as it is extracted from `\u0026self`.\n        unsafe { std::os::fd::BorrowedFd::borrow_raw(raw_fd) }\n    }\n}\n\nimpl AsRawFd for Dir {\n    fn as_raw_fd(\u0026self) -\u003e RawFd {\n        unsafe { libc::dirfd(self.0.as_ptr()) }\n    }\n}\n\nimpl Drop for Dir {\n    fn drop(\u0026mut self) {\n        let e = Errno::result(unsafe { libc::closedir(self.0.as_ptr()) });\n        if !std::thread::panicking() \u0026\u0026 e == Err(Errno::EBADF) {\n            panic!(\"Closing an invalid file descriptor!\");\n        };\n    }\n}\n\n// The pass by mut is technically needless only because the inner NonNull is\n// Copy.  But philosophically we're mutating the Dir, so we pass by mut.\n#[allow(clippy::needless_pass_by_ref_mut)]\nfn next(dir: \u0026mut Dir) -\u003e Option\u003cResult\u003cEntry\u003e\u003e {\n    unsafe {\n        // Note: POSIX specifies that portable applications should dynamically allocate a\n        // buffer with room for a `d_name` field of size `pathconf(..., _PC_NAME_MAX)` plus 1\n        // for the NUL byte. It doesn't look like the std library does this; it just uses\n        // fixed-sized buffers (and libc's dirent seems to be sized so this is appropriate).\n        // Probably fine here too then.\n        let mut ent = std::mem::MaybeUninit::\u003cdirent\u003e::uninit();\n        let mut result = ptr::null_mut();\n        if let Err(e) = Errno::result(readdir_r(\n            dir.0.as_ptr(),\n            ent.as_mut_ptr(),\n            \u0026mut result,\n        )) {\n            return Some(Err(e));\n        }\n        if result.is_null() {\n            return None;\n        }\n        assert_eq!(result, ent.as_mut_ptr());\n        Some(Ok(Entry(ent.assume_init())))\n    }\n}\n\n/// Return type of [`Dir::iter`].\n#[derive(Debug, Eq, Hash, PartialEq)]\npub struct Iter\u003c'd\u003e(\u0026'd mut Dir);\n\nimpl Iterator for Iter\u003c'_\u003e {\n    type Item = Result\u003cEntry\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        next(self.0)\n    }\n}\n\nimpl Drop for Iter\u003c'_\u003e {\n    fn drop(\u0026mut self) {\n        unsafe { libc::rewinddir((self.0).0.as_ptr()) }\n    }\n}\n\n/// The return type of [Dir::into_iter]\n#[derive(Debug, Eq, Hash, PartialEq)]\npub struct OwningIter(Dir);\n\nimpl Iterator for OwningIter {\n    type Item = Result\u003cEntry\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        next(\u0026mut self.0)\n    }\n}\n\n/// The file descriptor continues to be owned by the `OwningIter`,\n/// so callers must not keep a `RawFd` after the `OwningIter` is dropped.\nimpl AsRawFd for OwningIter {\n    fn as_raw_fd(\u0026self) -\u003e RawFd {\n        self.0.as_raw_fd()\n    }\n}\n\nimpl IntoIterator for Dir {\n    type Item = Result\u003cEntry\u003e;\n    type IntoIter = OwningIter;\n\n    /// Creates a owning iterator, that is, one that takes ownership of the\n    /// `Dir`. The `Dir` cannot be used after calling this.  This can be useful\n    /// when you have a function that both creates a `Dir` instance and returns\n    /// an `Iterator`.\n    ///\n    /// Example:\n    ///\n    /// ```\n    /// use nix::{dir::Dir, fcntl::OFlag, sys::stat::Mode};\n    /// use std::{iter::Iterator, string::String};\n    ///\n    /// fn ls_upper(dirname: \u0026str) -\u003e impl Iterator\u003cItem=String\u003e {\n    ///     let d = Dir::open(dirname, OFlag::O_DIRECTORY, Mode::S_IXUSR).unwrap();\n    ///     d.into_iter().map(|x| x.unwrap().file_name().as_ref().to_string_lossy().to_ascii_uppercase())\n    /// }\n    /// ```\n    fn into_iter(self) -\u003e Self::IntoIter {\n        OwningIter(self)\n    }\n}\n\n/// A directory entry, similar to `std::fs::DirEntry`.\n///\n/// Note that unlike the std version, this may represent the `.` or `..` entries.\n#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]\n#[repr(transparent)]\npub struct Entry(dirent);\n\n/// Type of file referenced by a directory entry\n#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]\npub enum Type {\n    /// FIFO (Named pipe)\n    Fifo,\n    /// Character device\n    CharacterDevice,\n    /// Directory\n    Directory,\n    /// Block device\n    BlockDevice,\n    /// Regular file\n    File,\n    /// Symbolic link\n    Symlink,\n    /// Unix-domain socket\n    Socket,\n}\n\nimpl Entry {\n    /// Returns the inode number (`d_ino`) of the underlying `dirent`.\n    #[allow(clippy::useless_conversion)] // Not useless on all OSes\n    // The cast is not unnecessary on all platforms.\n    #[allow(clippy::unnecessary_cast)]\n    pub fn ino(\u0026self) -\u003e u64 {\n        cfg_if! {\n            if #[cfg(any(target_os = \"aix\",\n                         target_os = \"emscripten\",\n                         target_os = \"fuchsia\",\n                         target_os = \"haiku\",\n                         target_os = \"hurd\",\n                         target_os = \"cygwin\",\n                         solarish,\n                         linux_android,\n                         apple_targets))] {\n                self.0.d_ino as u64\n            } else {\n                u64::from(self.0.d_fileno)\n            }\n        }\n    }\n\n    /// Returns the bare file name of this directory entry without any other leading path component.\n    pub fn file_name(\u0026self) -\u003e \u0026ffi::CStr {\n        unsafe { ffi::CStr::from_ptr(self.0.d_name.as_ptr()) }\n    }\n\n    /// Returns the type of this directory entry, if known.\n    ///\n    /// See platform `readdir(3)` or `dirent(5)` manpage for when the file type is known;\n    /// notably, some Linux filesystems don't implement this. The caller should use `stat` or\n    /// `fstat` if this returns `None`.\n    pub fn file_type(\u0026self) -\u003e Option\u003cType\u003e {\n        #[cfg(not(any(solarish, target_os = \"aix\", target_os = \"haiku\")))]\n        match self.0.d_type {\n            libc::DT_FIFO =\u003e Some(Type::Fifo),\n            libc::DT_CHR =\u003e Some(Type::CharacterDevice),\n            libc::DT_DIR =\u003e Some(Type::Directory),\n            libc::DT_BLK =\u003e Some(Type::BlockDevice),\n            libc::DT_REG =\u003e Some(Type::File),\n            libc::DT_LNK =\u003e Some(Type::Symlink),\n            libc::DT_SOCK =\u003e Some(Type::Socket),\n            /* libc::DT_UNKNOWN | */ _ =\u003e None,\n        }\n\n        // illumos, Solaris, and Haiku systems do not have the d_type member at all:\n        #[cfg(any(solarish, target_os = \"aix\", target_os = \"haiku\"))]\n        None\n    }\n}\n","traces":[{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","home","acooks","mcr","nix-0.30.1","src","env.rs"],"content":"//! Environment variables\nuse cfg_if::cfg_if;\nuse std::fmt;\n\n/// Indicates that [`clearenv`] failed for some unknown reason\n#[derive(Clone, Copy, Debug)]\npub struct ClearEnvError;\n\nimpl fmt::Display for ClearEnvError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"clearenv failed\")\n    }\n}\n\nimpl std::error::Error for ClearEnvError {}\n\n/// Clear the environment of all name-value pairs.\n///\n/// On platforms where libc provides `clearenv()`, it will be used. libc's\n/// `clearenv()` is documented to return an error code but not set errno; if the\n/// return value indicates a failure, this function will return\n/// [`ClearEnvError`].\n///\n/// On platforms where libc does not provide `clearenv()`, a fallback\n/// implementation will be used that iterates over all environment variables and\n/// removes them one-by-one.\n///\n/// # Safety\n///\n/// This function is not threadsafe and can cause undefined behavior in\n/// combination with `std::env` or other program components that access the\n/// environment. See, for example, the discussion on `std::env::remove_var`; this\n/// function is a case of an \"inherently unsafe non-threadsafe API\" dealing with\n/// the environment.\n///\n///  The caller must ensure no other threads access the process environment while\n///  this function executes and that no raw pointers to an element of libc's\n///  `environ` is currently held. The latter is not an issue if the only other\n///  environment access in the program is via `std::env`, but the requirement on\n///  thread safety must still be upheld.\npub unsafe fn clearenv() -\u003e std::result::Result\u003c(), ClearEnvError\u003e {\n    cfg_if! {\n        if #[cfg(any(linux_android,\n                     target_os = \"fuchsia\",\n                     target_os = \"wasi\",\n                     target_env = \"uclibc\",\n                     target_os = \"emscripten\"))] {\n            let ret = unsafe { libc::clearenv() };\n        } else {\n            use std::env;\n            for (name, _) in env::vars_os() {\n                env::remove_var(name);\n            }\n            let ret = 0;\n        }\n    }\n\n    if ret == 0 {\n        Ok(())\n    } else {\n        Err(ClearEnvError)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","errno.rs"],"content":"//! Safe wrappers around errno functions\n//!\n//! # Example\n//! ```\n//! use nix::errno::Errno;\n//!\n//! Errno::EIO.set();\n//! assert_eq!(Errno::last(), Errno::EIO);\n//!\n//! Errno::clear();\n//! assert_eq!(Errno::last(), Errno::from_raw(0));\n//! ```\n\nuse crate::Result;\nuse cfg_if::cfg_if;\nuse libc::{c_int, c_void};\nuse std::{error, fmt, io};\n\npub use self::consts::*;\n\ncfg_if! {\n    if #[cfg(any(target_os = \"freebsd\",\n                 apple_targets,))] {\n        unsafe fn errno_location() -\u003e *mut c_int {\n            unsafe { libc::__error() }\n        }\n    } else if #[cfg(any(target_os = \"android\", netbsdlike, target_os = \"cygwin\"))] {\n        unsafe fn errno_location() -\u003e *mut c_int {\n            unsafe { libc::__errno() }\n        }\n    } else if #[cfg(any(target_os = \"linux\",\n                        target_os = \"redox\",\n                        target_os = \"dragonfly\",\n                        target_os = \"fuchsia\",\n                        target_os = \"hurd\",\n                        target_os = \"emscripten\"))] {\n        unsafe fn errno_location() -\u003e *mut c_int {\n            unsafe { libc::__errno_location() }\n        }\n    } else if #[cfg(solarish)] {\n        unsafe fn errno_location() -\u003e *mut c_int {\n            unsafe { libc::___errno() }\n        }\n    } else if #[cfg(any(target_os = \"haiku\",))] {\n        unsafe fn errno_location() -\u003e *mut c_int {\n            unsafe { libc::_errnop() }\n        }\n    } else if #[cfg(any(target_os = \"aix\"))] {\n        unsafe fn errno_location() -\u003e *mut c_int {\n            unsafe { libc::_Errno() }\n        }\n    }\n}\n\n/// Returns the platform-specific value of errno\n#[deprecated(since = \"0.28.0\", note = \"please use `Errno::last_raw()` instead\")]\npub fn errno() -\u003e i32 {\n    Errno::last_raw()\n}\n\nimpl Errno {\n    /// Returns the current value of errno\n    pub fn last() -\u003e Self {\n        Self::from_raw(Self::last_raw())\n    }\n\n    /// Returns the current raw i32 value of errno\n    pub fn last_raw() -\u003e i32 {\n        unsafe { *errno_location() }\n    }\n\n    /// Sets the value of errno.\n    ///\n    /// # Example\n    /// ```\n    /// use nix::errno::Errno;\n    ///\n    /// Errno::EIO.set();\n    ///\n    /// assert_eq!(Errno::last(), Errno::EIO);\n    /// ```\n    pub fn set(self) {\n        Self::set_raw(self as i32)\n    }\n\n    /// Sets the raw i32 value of errno.\n    pub fn set_raw(errno: i32) {\n        // Safe because errno is a thread-local variable\n        unsafe {\n            *errno_location() = errno;\n        }\n    }\n\n    #[deprecated(\n        since = \"0.28.0\",\n        note = \"please use `Errno::from_raw()` instead\"\n    )]\n    pub const fn from_i32(err: i32) -\u003e Errno {\n        Self::from_raw(err)\n    }\n\n    pub const fn from_raw(err: i32) -\u003e Errno {\n        #[allow(deprecated)]\n        from_i32(err)\n    }\n\n    pub fn desc(self) -\u003e \u0026'static str {\n        desc(self)\n    }\n\n    /// Sets the platform-specific errno to no-error\n    ///\n    /// ```\n    /// use nix::errno::Errno;\n    ///\n    /// Errno::EIO.set();\n    ///\n    /// Errno::clear();\n    ///\n    /// let err = Errno::last();\n    /// assert_ne!(err, Errno::EIO);\n    /// assert_eq!(err, Errno::from_raw(0));\n    /// ```\n    pub fn clear() {\n        Self::set_raw(0)\n    }\n\n    /// Returns `Ok(value)` if it does not contain the sentinel value. This\n    /// should not be used when `-1` is not the errno sentinel value.\n    #[inline]\n    pub fn result\u003cS: ErrnoSentinel + PartialEq\u003cS\u003e\u003e(value: S) -\u003e Result\u003cS\u003e {\n        if value == S::sentinel() {\n            Err(Self::last())\n        } else {\n            Ok(value)\n        }\n    }\n}\n\n/// The sentinel value indicates that a function failed and more detailed\n/// information about the error can be found in `errno`\npub trait ErrnoSentinel: Sized {\n    fn sentinel() -\u003e Self;\n}\n\nimpl ErrnoSentinel for isize {\n    fn sentinel() -\u003e Self {\n        -1\n    }\n}\n\nimpl ErrnoSentinel for i32 {\n    fn sentinel() -\u003e Self {\n        -1\n    }\n}\n\nimpl ErrnoSentinel for i64 {\n    fn sentinel() -\u003e Self {\n        -1\n    }\n}\n\nimpl ErrnoSentinel for *mut c_void {\n    fn sentinel() -\u003e Self {\n        -1isize as *mut c_void\n    }\n}\n\nimpl ErrnoSentinel for libc::sighandler_t {\n    fn sentinel() -\u003e Self {\n        libc::SIG_ERR\n    }\n}\n\nimpl error::Error for Errno {}\n\nimpl fmt::Display for Errno {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        write!(f, \"{:?}: {}\", self, self.desc())\n    }\n}\n\nimpl From\u003cErrno\u003e for io::Error {\n    fn from(err: Errno) -\u003e Self {\n        io::Error::from_raw_os_error(err as i32)\n    }\n}\n\nimpl TryFrom\u003cio::Error\u003e for Errno {\n    type Error = io::Error;\n\n    fn try_from(ioerror: io::Error) -\u003e std::result::Result\u003cSelf, io::Error\u003e {\n        ioerror.raw_os_error().map(Errno::from_raw).ok_or(ioerror)\n    }\n}\n\nfn desc(errno: Errno) -\u003e \u0026'static str {\n    use self::Errno::*;\n    match errno {\n        UnknownErrno =\u003e \"Unknown errno\",\n        EPERM =\u003e \"Operation not permitted\",\n        ENOENT =\u003e \"No such file or directory\",\n        ESRCH =\u003e \"No such process\",\n        EINTR =\u003e \"Interrupted system call\",\n        EIO =\u003e \"I/O error\",\n        ENXIO =\u003e \"No such device or address\",\n        E2BIG =\u003e \"Argument list too long\",\n        ENOEXEC =\u003e \"Exec format error\",\n        EBADF =\u003e \"Bad file number\",\n        ECHILD =\u003e \"No child processes\",\n        EAGAIN =\u003e \"Try again\",\n        ENOMEM =\u003e \"Out of memory\",\n        EACCES =\u003e \"Permission denied\",\n        EFAULT =\u003e \"Bad address\",\n        #[cfg(not(target_os = \"haiku\"))]\n        ENOTBLK =\u003e \"Block device required\",\n        EBUSY =\u003e \"Device or resource busy\",\n        EEXIST =\u003e \"File exists\",\n        EXDEV =\u003e \"Cross-device link\",\n        ENODEV =\u003e \"No such device\",\n        ENOTDIR =\u003e \"Not a directory\",\n        EISDIR =\u003e \"Is a directory\",\n        EINVAL =\u003e \"Invalid argument\",\n        ENFILE =\u003e \"File table overflow\",\n        EMFILE =\u003e \"Too many open files\",\n        ENOTTY =\u003e \"Not a typewriter\",\n        ETXTBSY =\u003e \"Text file busy\",\n        EFBIG =\u003e \"File too large\",\n        ENOSPC =\u003e \"No space left on device\",\n        ESPIPE =\u003e \"Illegal seek\",\n        EROFS =\u003e \"Read-only file system\",\n        EMLINK =\u003e \"Too many links\",\n        EPIPE =\u003e \"Broken pipe\",\n        EDOM =\u003e \"Math argument out of domain of func\",\n        ERANGE =\u003e \"Math result not representable\",\n        EDEADLK =\u003e \"Resource deadlock would occur\",\n        ENAMETOOLONG =\u003e \"File name too long\",\n        ENOLCK =\u003e \"No record locks available\",\n        ENOSYS =\u003e \"Function not implemented\",\n        ENOTEMPTY =\u003e \"Directory not empty\",\n        ELOOP =\u003e \"Too many symbolic links encountered\",\n        ENOMSG =\u003e \"No message of desired type\",\n        EIDRM =\u003e \"Identifier removed\",\n        EINPROGRESS =\u003e \"Operation now in progress\",\n        EALREADY =\u003e \"Operation already in progress\",\n        ENOTSOCK =\u003e \"Socket operation on non-socket\",\n        EDESTADDRREQ =\u003e \"Destination address required\",\n        EMSGSIZE =\u003e \"Message too long\",\n        EPROTOTYPE =\u003e \"Protocol wrong type for socket\",\n        ENOPROTOOPT =\u003e \"Protocol not available\",\n        EPROTONOSUPPORT =\u003e \"Protocol not supported\",\n        #[cfg(not(target_os = \"haiku\"))]\n        ESOCKTNOSUPPORT =\u003e \"Socket type not supported\",\n        #[cfg(not(target_os = \"haiku\"))]\n        EPFNOSUPPORT =\u003e \"Protocol family not supported\",\n        #[cfg(not(target_os = \"haiku\"))]\n        EAFNOSUPPORT =\u003e \"Address family not supported by protocol\",\n        EADDRINUSE =\u003e \"Address already in use\",\n        EADDRNOTAVAIL =\u003e \"Cannot assign requested address\",\n        ENETDOWN =\u003e \"Network is down\",\n        ENETUNREACH =\u003e \"Network is unreachable\",\n        ENETRESET =\u003e \"Network dropped connection because of reset\",\n        ECONNABORTED =\u003e \"Software caused connection abort\",\n        ECONNRESET =\u003e \"Connection reset by peer\",\n        ENOBUFS =\u003e \"No buffer space available\",\n        EISCONN =\u003e \"Transport endpoint is already connected\",\n        ENOTCONN =\u003e \"Transport endpoint is not connected\",\n        ESHUTDOWN =\u003e \"Cannot send after transport endpoint shutdown\",\n        #[cfg(not(target_os = \"haiku\"))]\n        ETOOMANYREFS =\u003e \"Too many references: cannot splice\",\n        ETIMEDOUT =\u003e \"Connection timed out\",\n        ECONNREFUSED =\u003e \"Connection refused\",\n        EHOSTDOWN =\u003e \"Host is down\",\n        EHOSTUNREACH =\u003e \"No route to host\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"aix\",\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ECHRNG =\u003e \"Channel number out of range\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"aix\",\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EL2NSYNC =\u003e \"Level 2 not synchronized\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"aix\",\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EL3HLT =\u003e \"Level 3 halted\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"aix\",\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EL3RST =\u003e \"Level 3 reset\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"aix\",\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ELNRNG =\u003e \"Link number out of range\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"aix\",\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EUNATCH =\u003e \"Protocol driver not attached\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"aix\",\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ENOCSI =\u003e \"No CSI structure available\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"aix\",\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EL2HLT =\u003e \"Level 2 halted\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EBADE =\u003e \"Invalid exchange\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EBADR =\u003e \"Invalid request descriptor\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EXFULL =\u003e \"Exchange full\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ENOANO =\u003e \"No anode\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EBADRQC =\u003e \"Invalid request code\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EBADSLT =\u003e \"Invalid slot\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EBFONT =\u003e \"Bad font file format\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"hurd\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ENOSTR =\u003e \"Device not a stream\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"hurd\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ENODATA =\u003e \"No data available\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"hurd\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ETIME =\u003e \"Timer expired\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"hurd\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ENOSR =\u003e \"Out of streams resources\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ENONET =\u003e \"Machine is not on the network\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ENOPKG =\u003e \"Package not installed\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"hurd\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EREMOTE =\u003e \"Object is remote\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"aix\",\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n        ))]\n        ENOLINK =\u003e \"Link has been severed\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EADV =\u003e \"Advertise error\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ESRMNT =\u003e \"Srmount error\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ECOMM =\u003e \"Communication error on send\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"aix\",\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EPROTO =\u003e \"Protocol error\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"aix\",\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n        ))]\n        EMULTIHOP =\u003e \"Multihop attempted\",\n\n        #[cfg(any(\n            linux_android,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EDOTDOT =\u003e \"RFS specific error\",\n\n        #[cfg(any(\n            linux_android,\n            target_os = \"aix\",\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EBADMSG =\u003e \"Not a data message\",\n\n        #[cfg(solarish)]\n        EBADMSG =\u003e \"Trying to read unreadable message\",\n\n        #[cfg(any(\n            linux_android,\n            target_os = \"aix\",\n            target_os = \"fuchsia\",\n            target_os = \"haiku\",\n            target_os = \"hurd\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EOVERFLOW =\u003e \"Value too large for defined data type\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ENOTUNIQ =\u003e \"Name not unique on network\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EBADFD =\u003e \"File descriptor in bad state\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EREMCHG =\u003e \"Remote address changed\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ELIBACC =\u003e \"Can not access a needed shared library\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ELIBBAD =\u003e \"Accessing a corrupted shared library\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ELIBSCN =\u003e \".lib section in a.out corrupted\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ELIBMAX =\u003e \"Attempting to link in too many shared libraries\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"hurd\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ELIBEXEC =\u003e \"Cannot exec a shared library directly\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"aix\",\n            target_os = \"fuchsia\",\n            target_os = \"openbsd\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EILSEQ =\u003e \"Illegal byte sequence\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"aix\",\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n        ))]\n        ERESTART =\u003e \"Interrupted system call should be restarted\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ESTRPIPE =\u003e \"Streams pipe error\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EUSERS =\u003e \"Too many users\",\n\n        #[cfg(any(\n            linux_android,\n            target_os = \"fuchsia\",\n            target_os = \"netbsd\",\n            target_os = \"redox\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EOPNOTSUPP =\u003e \"Operation not supported on transport endpoint\",\n\n        #[cfg(any(\n            linux_android,\n            target_os = \"fuchsia\",\n            target_os = \"hurd\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ESTALE =\u003e \"Stale file handle\",\n\n        #[cfg(any(\n            linux_android,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n        ))]\n        EUCLEAN =\u003e \"Structure needs cleaning\",\n\n        #[cfg(any(\n            linux_android,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n        ))]\n        ENOTNAM =\u003e \"Not a XENIX named type file\",\n\n        #[cfg(any(\n            linux_android,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n        ))]\n        ENAVAIL =\u003e \"No XENIX semaphores available\",\n\n        #[cfg(any(\n            linux_android,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n        ))]\n        EISNAM =\u003e \"Is a named type file\",\n\n        #[cfg(any(\n            linux_android,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n        ))]\n        EREMOTEIO =\u003e \"Remote I/O error\",\n\n        #[cfg(any(\n            linux_android,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EDQUOT =\u003e \"Quota exceeded\",\n\n        #[cfg(any(\n            linux_android,\n            target_os = \"fuchsia\",\n            target_os = \"openbsd\",\n            target_os = \"dragonfly\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ENOMEDIUM =\u003e \"No medium found\",\n\n        #[cfg(any(\n            linux_android,\n            target_os = \"fuchsia\",\n            target_os = \"openbsd\",\n            target_os = \"emscripten\",\n        ))]\n        EMEDIUMTYPE =\u003e \"Wrong medium type\",\n\n        #[cfg(any(\n            linux_android,\n            solarish,\n            target_os = \"fuchsia\",\n            target_os = \"haiku\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ECANCELED =\u003e \"Operation canceled\",\n\n        #[cfg(any(\n            linux_android,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n        ))]\n        ENOKEY =\u003e \"Required key not available\",\n\n        #[cfg(any(\n            linux_android,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n        ))]\n        EKEYEXPIRED =\u003e \"Key has expired\",\n\n        #[cfg(any(\n            linux_android,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n        ))]\n        EKEYREVOKED =\u003e \"Key has been revoked\",\n\n        #[cfg(any(\n            linux_android,\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n        ))]\n        EKEYREJECTED =\u003e \"Key was rejected by service\",\n\n        #[cfg(any(\n            linux_android,\n            target_os = \"aix\",\n            target_os = \"fuchsia\",\n            target_os = \"hurd\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        EOWNERDEAD =\u003e \"Owner died\",\n\n        #[cfg(solarish)]\n        EOWNERDEAD =\u003e \"Process died with lock\",\n\n        #[cfg(any(\n            linux_android,\n            target_os = \"aix\",\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"cygwin\",\n        ))]\n        ENOTRECOVERABLE =\u003e \"State not recoverable\",\n\n        #[cfg(solarish)]\n        ENOTRECOVERABLE =\u003e \"Lock is not recoverable\",\n\n        #[cfg(any(\n            all(target_os = \"linux\", not(target_arch = \"mips\")),\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n        ))]\n        ERFKILL =\u003e \"Operation not possible due to RF-kill\",\n\n        #[cfg(any(\n            all(target_os = \"linux\", not(target_arch = \"mips\")),\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n        ))]\n        EHWPOISON =\u003e \"Memory page has hardware error\",\n\n        #[cfg(freebsdlike)]\n        EDOOFUS =\u003e \"Programming error\",\n\n        #[cfg(any(\n            freebsdlike,\n            target_os = \"hurd\",\n            target_os = \"redox\",\n            target_os = \"cygwin\"\n        ))]\n        EMULTIHOP =\u003e \"Multihop attempted\",\n\n        #[cfg(any(\n            freebsdlike,\n            target_os = \"hurd\",\n            target_os = \"redox\",\n            target_os = \"cygwin\"\n        ))]\n        ENOLINK =\u003e \"Link has been severed\",\n\n        #[cfg(target_os = \"freebsd\")]\n        ENOTCAPABLE =\u003e \"Capabilities insufficient\",\n\n        #[cfg(target_os = \"freebsd\")]\n        ECAPMODE =\u003e \"Not permitted in capability mode\",\n\n        #[cfg(any(bsd, target_os = \"hurd\"))]\n        ENEEDAUTH =\u003e \"Need authenticator\",\n\n        #[cfg(any(bsd, target_os = \"redox\", solarish))]\n        EOVERFLOW =\u003e \"Value too large to be stored in data type\",\n\n        #[cfg(any(\n            freebsdlike,\n            apple_targets,\n            target_os = \"netbsd\",\n            target_os = \"redox\",\n            target_os = \"haiku\",\n            target_os = \"hurd\"\n        ))]\n        EILSEQ =\u003e \"Illegal byte sequence\",\n\n        #[cfg(any(bsd, target_os = \"haiku\"))]\n        ENOATTR =\u003e \"Attribute not found\",\n\n        #[cfg(any(\n            bsd,\n            target_os = \"redox\",\n            target_os = \"haiku\",\n            target_os = \"hurd\"\n        ))]\n        EBADMSG =\u003e \"Bad message\",\n\n        #[cfg(any(\n            bsd,\n            target_os = \"haiku\",\n            target_os = \"hurd\",\n            target_os = \"redox\"\n        ))]\n        EPROTO =\u003e \"Protocol error\",\n\n        #[cfg(any(\n            freebsdlike,\n            apple_targets,\n            target_os = \"openbsd\",\n            target_os = \"hurd\"\n        ))]\n        ENOTRECOVERABLE =\u003e \"State not recoverable\",\n\n        #[cfg(any(freebsdlike, apple_targets, target_os = \"openbsd\"))]\n        EOWNERDEAD =\u003e \"Previous owner died\",\n\n        #[cfg(any(\n            bsd,\n            target_os = \"aix\",\n            solarish,\n            target_os = \"haiku\",\n            target_os = \"hurd\",\n            target_os = \"cygwin\"\n        ))]\n        ENOTSUP =\u003e \"Operation not supported\",\n\n        #[cfg(any(\n            bsd,\n            target_os = \"aix\",\n            target_os = \"hurd\",\n            target_os = \"cygwin\"\n        ))]\n        EPROCLIM =\u003e \"Too many processes\",\n\n        #[cfg(any(\n            bsd,\n            target_os = \"aix\",\n            target_os = \"hurd\",\n            target_os = \"redox\"\n        ))]\n        EUSERS =\u003e \"Too many users\",\n\n        #[cfg(any(\n            bsd,\n            solarish,\n            target_os = \"redox\",\n            target_os = \"aix\",\n            target_os = \"haiku\",\n            target_os = \"hurd\"\n        ))]\n        EDQUOT =\u003e \"Disc quota exceeded\",\n\n        #[cfg(any(\n            bsd,\n            solarish,\n            target_os = \"redox\",\n            target_os = \"aix\",\n            target_os = \"haiku\"\n        ))]\n        ESTALE =\u003e \"Stale NFS file handle\",\n\n        #[cfg(any(bsd, target_os = \"aix\", target_os = \"redox\"))]\n        EREMOTE =\u003e \"Too many levels of remote in path\",\n\n        #[cfg(any(bsd, target_os = \"hurd\"))]\n        EBADRPC =\u003e \"RPC struct is bad\",\n\n        #[cfg(any(bsd, target_os = \"hurd\"))]\n        ERPCMISMATCH =\u003e \"RPC version wrong\",\n\n        #[cfg(any(bsd, target_os = \"hurd\"))]\n        EPROGUNAVAIL =\u003e \"RPC prog. not avail\",\n\n        #[cfg(any(bsd, target_os = \"hurd\"))]\n        EPROGMISMATCH =\u003e \"Program version wrong\",\n\n        #[cfg(any(bsd, target_os = \"hurd\"))]\n        EPROCUNAVAIL =\u003e \"Bad procedure for program\",\n\n        #[cfg(any(bsd, target_os = \"hurd\", target_os = \"cygwin\"))]\n        EFTYPE =\u003e \"Inappropriate file type or format\",\n\n        #[cfg(any(bsd, target_os = \"hurd\"))]\n        EAUTH =\u003e \"Authentication error\",\n\n        #[cfg(any(\n            bsd,\n            target_os = \"aix\",\n            target_os = \"hurd\",\n            target_os = \"redox\"\n        ))]\n        ECANCELED =\u003e \"Operation canceled\",\n\n        #[cfg(apple_targets)]\n        EPWROFF =\u003e \"Device power is off\",\n\n        #[cfg(apple_targets)]\n        EDEVERR =\u003e \"Device error, e.g. paper out\",\n\n        #[cfg(apple_targets)]\n        EBADEXEC =\u003e \"Bad executable\",\n\n        #[cfg(apple_targets)]\n        EBADARCH =\u003e \"Bad CPU type in executable\",\n\n        #[cfg(apple_targets)]\n        ESHLIBVERS =\u003e \"Shared library version mismatch\",\n\n        #[cfg(apple_targets)]\n        EBADMACHO =\u003e \"Malformed Macho file\",\n\n        #[cfg(any(apple_targets, target_os = \"netbsd\", target_os = \"haiku\"))]\n        EMULTIHOP =\u003e \"Reserved\",\n\n        #[cfg(any(\n            apple_targets,\n            target_os = \"aix\",\n            target_os = \"netbsd\",\n            target_os = \"redox\"\n        ))]\n        ENODATA =\u003e \"No message available on STREAM\",\n\n        #[cfg(any(apple_targets, target_os = \"netbsd\", target_os = \"haiku\"))]\n        ENOLINK =\u003e \"Reserved\",\n\n        #[cfg(any(\n            apple_targets,\n            target_os = \"aix\",\n            target_os = \"netbsd\",\n            target_os = \"redox\"\n        ))]\n        ENOSR =\u003e \"No STREAM resources\",\n\n        #[cfg(any(\n            apple_targets,\n            target_os = \"aix\",\n            target_os = \"netbsd\",\n            target_os = \"redox\"\n        ))]\n        ENOSTR =\u003e \"Not a STREAM\",\n\n        #[cfg(any(\n            apple_targets,\n            target_os = \"aix\",\n            target_os = \"netbsd\",\n            target_os = \"redox\"\n        ))]\n        ETIME =\u003e \"STREAM ioctl timeout\",\n\n        #[cfg(any(apple_targets, solarish, target_os = \"aix\"))]\n        EOPNOTSUPP =\u003e \"Operation not supported on socket\",\n\n        #[cfg(apple_targets)]\n        ENOPOLICY =\u003e \"No such policy registered\",\n\n        #[cfg(apple_targets)]\n        EQFULL =\u003e \"Interface output queue is full\",\n\n        #[cfg(any(target_os = \"openbsd\", target_os = \"hurd\"))]\n        EOPNOTSUPP =\u003e \"Operation not supported\",\n\n        #[cfg(target_os = \"openbsd\")]\n        EIPSEC =\u003e \"IPsec processing failure\",\n\n        #[cfg(target_os = \"dragonfly\")]\n        EASYNC =\u003e \"Async\",\n\n        #[cfg(any(solarish, target_os = \"cygwin\"))]\n        EDEADLOCK =\u003e \"Resource deadlock would occur\",\n\n        #[cfg(solarish)]\n        ELOCKUNMAPPED =\u003e \"Locked lock was unmapped\",\n\n        #[cfg(solarish)]\n        ENOTACTIVE =\u003e \"Facility is not active\",\n\n        #[cfg(target_os = \"hurd\")]\n        EBACKGROUND =\u003e \"Inappropriate operation for background process\",\n\n        #[cfg(target_os = \"hurd\")]\n        EDIED =\u003e \"Translator died\",\n\n        #[cfg(target_os = \"hurd\")]\n        EGREGIOUS =\u003e \"You really blew it this time\",\n\n        #[cfg(target_os = \"hurd\")]\n        EIEIO =\u003e \"Computer bought the farm\",\n\n        #[cfg(target_os = \"hurd\")]\n        EGRATUITOUS =\u003e \"Gratuitous error\",\n    }\n}\n\n#[cfg(any(linux_android, target_os = \"fuchsia\", target_os = \"emscripten\"))]\nmod consts {\n    #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum Errno {\n        UnknownErrno = 0,\n        EPERM = libc::EPERM,\n        ENOENT = libc::ENOENT,\n        ESRCH = libc::ESRCH,\n        EINTR = libc::EINTR,\n        EIO = libc::EIO,\n        ENXIO = libc::ENXIO,\n        E2BIG = libc::E2BIG,\n        ENOEXEC = libc::ENOEXEC,\n        EBADF = libc::EBADF,\n        ECHILD = libc::ECHILD,\n        EAGAIN = libc::EAGAIN,\n        ENOMEM = libc::ENOMEM,\n        EACCES = libc::EACCES,\n        EFAULT = libc::EFAULT,\n        ENOTBLK = libc::ENOTBLK,\n        EBUSY = libc::EBUSY,\n        EEXIST = libc::EEXIST,\n        EXDEV = libc::EXDEV,\n        ENODEV = libc::ENODEV,\n        ENOTDIR = libc::ENOTDIR,\n        EISDIR = libc::EISDIR,\n        EINVAL = libc::EINVAL,\n        ENFILE = libc::ENFILE,\n        EMFILE = libc::EMFILE,\n        ENOTTY = libc::ENOTTY,\n        ETXTBSY = libc::ETXTBSY,\n        EFBIG = libc::EFBIG,\n        ENOSPC = libc::ENOSPC,\n        ESPIPE = libc::ESPIPE,\n        EROFS = libc::EROFS,\n        EMLINK = libc::EMLINK,\n        EPIPE = libc::EPIPE,\n        EDOM = libc::EDOM,\n        ERANGE = libc::ERANGE,\n        EDEADLK = libc::EDEADLK,\n        ENAMETOOLONG = libc::ENAMETOOLONG,\n        ENOLCK = libc::ENOLCK,\n        ENOSYS = libc::ENOSYS,\n        ENOTEMPTY = libc::ENOTEMPTY,\n        ELOOP = libc::ELOOP,\n        ENOMSG = libc::ENOMSG,\n        EIDRM = libc::EIDRM,\n        ECHRNG = libc::ECHRNG,\n        EL2NSYNC = libc::EL2NSYNC,\n        EL3HLT = libc::EL3HLT,\n        EL3RST = libc::EL3RST,\n        ELNRNG = libc::ELNRNG,\n        EUNATCH = libc::EUNATCH,\n        ENOCSI = libc::ENOCSI,\n        EL2HLT = libc::EL2HLT,\n        EBADE = libc::EBADE,\n        EBADR = libc::EBADR,\n        EXFULL = libc::EXFULL,\n        ENOANO = libc::ENOANO,\n        EBADRQC = libc::EBADRQC,\n        EBADSLT = libc::EBADSLT,\n        EBFONT = libc::EBFONT,\n        ENOSTR = libc::ENOSTR,\n        ENODATA = libc::ENODATA,\n        ETIME = libc::ETIME,\n        ENOSR = libc::ENOSR,\n        ENONET = libc::ENONET,\n        ENOPKG = libc::ENOPKG,\n        EREMOTE = libc::EREMOTE,\n        ENOLINK = libc::ENOLINK,\n        EADV = libc::EADV,\n        ESRMNT = libc::ESRMNT,\n        ECOMM = libc::ECOMM,\n        EPROTO = libc::EPROTO,\n        EMULTIHOP = libc::EMULTIHOP,\n        EDOTDOT = libc::EDOTDOT,\n        EBADMSG = libc::EBADMSG,\n        EOVERFLOW = libc::EOVERFLOW,\n        ENOTUNIQ = libc::ENOTUNIQ,\n        EBADFD = libc::EBADFD,\n        EREMCHG = libc::EREMCHG,\n        ELIBACC = libc::ELIBACC,\n        ELIBBAD = libc::ELIBBAD,\n        ELIBSCN = libc::ELIBSCN,\n        ELIBMAX = libc::ELIBMAX,\n        ELIBEXEC = libc::ELIBEXEC,\n        EILSEQ = libc::EILSEQ,\n        ERESTART = libc::ERESTART,\n        ESTRPIPE = libc::ESTRPIPE,\n        EUSERS = libc::EUSERS,\n        ENOTSOCK = libc::ENOTSOCK,\n        EDESTADDRREQ = libc::EDESTADDRREQ,\n        EMSGSIZE = libc::EMSGSIZE,\n        EPROTOTYPE = libc::EPROTOTYPE,\n        ENOPROTOOPT = libc::ENOPROTOOPT,\n        EPROTONOSUPPORT = libc::EPROTONOSUPPORT,\n        ESOCKTNOSUPPORT = libc::ESOCKTNOSUPPORT,\n        EOPNOTSUPP = libc::EOPNOTSUPP,\n        EPFNOSUPPORT = libc::EPFNOSUPPORT,\n        EAFNOSUPPORT = libc::EAFNOSUPPORT,\n        EADDRINUSE = libc::EADDRINUSE,\n        EADDRNOTAVAIL = libc::EADDRNOTAVAIL,\n        ENETDOWN = libc::ENETDOWN,\n        ENETUNREACH = libc::ENETUNREACH,\n        ENETRESET = libc::ENETRESET,\n        ECONNABORTED = libc::ECONNABORTED,\n        ECONNRESET = libc::ECONNRESET,\n        ENOBUFS = libc::ENOBUFS,\n        EISCONN = libc::EISCONN,\n        ENOTCONN = libc::ENOTCONN,\n        ESHUTDOWN = libc::ESHUTDOWN,\n        ETOOMANYREFS = libc::ETOOMANYREFS,\n        ETIMEDOUT = libc::ETIMEDOUT,\n        ECONNREFUSED = libc::ECONNREFUSED,\n        EHOSTDOWN = libc::EHOSTDOWN,\n        EHOSTUNREACH = libc::EHOSTUNREACH,\n        EALREADY = libc::EALREADY,\n        EINPROGRESS = libc::EINPROGRESS,\n        ESTALE = libc::ESTALE,\n        EUCLEAN = libc::EUCLEAN,\n        ENOTNAM = libc::ENOTNAM,\n        ENAVAIL = libc::ENAVAIL,\n        EISNAM = libc::EISNAM,\n        EREMOTEIO = libc::EREMOTEIO,\n        EDQUOT = libc::EDQUOT,\n        ENOMEDIUM = libc::ENOMEDIUM,\n        EMEDIUMTYPE = libc::EMEDIUMTYPE,\n        ECANCELED = libc::ECANCELED,\n        ENOKEY = libc::ENOKEY,\n        EKEYEXPIRED = libc::EKEYEXPIRED,\n        EKEYREVOKED = libc::EKEYREVOKED,\n        EKEYREJECTED = libc::EKEYREJECTED,\n        EOWNERDEAD = libc::EOWNERDEAD,\n        ENOTRECOVERABLE = libc::ENOTRECOVERABLE,\n        #[cfg(not(any(target_os = \"android\", target_arch = \"mips\")))]\n        ERFKILL = libc::ERFKILL,\n        #[cfg(not(any(target_os = \"android\", target_arch = \"mips\")))]\n        EHWPOISON = libc::EHWPOISON,\n    }\n\n    impl Errno {\n        pub const EWOULDBLOCK: Errno = Errno::EAGAIN;\n        pub const EDEADLOCK: Errno = Errno::EDEADLK;\n        pub const ENOTSUP: Errno = Errno::EOPNOTSUPP;\n    }\n\n    #[deprecated(\n        since = \"0.28.0\",\n        note = \"please use `Errno::from_raw()` instead\"\n    )]\n    pub const fn from_i32(e: i32) -\u003e Errno {\n        use self::Errno::*;\n\n        match e {\n            libc::EPERM =\u003e EPERM,\n            libc::ENOENT =\u003e ENOENT,\n            libc::ESRCH =\u003e ESRCH,\n            libc::EINTR =\u003e EINTR,\n            libc::EIO =\u003e EIO,\n            libc::ENXIO =\u003e ENXIO,\n            libc::E2BIG =\u003e E2BIG,\n            libc::ENOEXEC =\u003e ENOEXEC,\n            libc::EBADF =\u003e EBADF,\n            libc::ECHILD =\u003e ECHILD,\n            libc::EAGAIN =\u003e EAGAIN,\n            libc::ENOMEM =\u003e ENOMEM,\n            libc::EACCES =\u003e EACCES,\n            libc::EFAULT =\u003e EFAULT,\n            libc::ENOTBLK =\u003e ENOTBLK,\n            libc::EBUSY =\u003e EBUSY,\n            libc::EEXIST =\u003e EEXIST,\n            libc::EXDEV =\u003e EXDEV,\n            libc::ENODEV =\u003e ENODEV,\n            libc::ENOTDIR =\u003e ENOTDIR,\n            libc::EISDIR =\u003e EISDIR,\n            libc::EINVAL =\u003e EINVAL,\n            libc::ENFILE =\u003e ENFILE,\n            libc::EMFILE =\u003e EMFILE,\n            libc::ENOTTY =\u003e ENOTTY,\n            libc::ETXTBSY =\u003e ETXTBSY,\n            libc::EFBIG =\u003e EFBIG,\n            libc::ENOSPC =\u003e ENOSPC,\n            libc::ESPIPE =\u003e ESPIPE,\n            libc::EROFS =\u003e EROFS,\n            libc::EMLINK =\u003e EMLINK,\n            libc::EPIPE =\u003e EPIPE,\n            libc::EDOM =\u003e EDOM,\n            libc::ERANGE =\u003e ERANGE,\n            libc::EDEADLK =\u003e EDEADLK,\n            libc::ENAMETOOLONG =\u003e ENAMETOOLONG,\n            libc::ENOLCK =\u003e ENOLCK,\n            libc::ENOSYS =\u003e ENOSYS,\n            libc::ENOTEMPTY =\u003e ENOTEMPTY,\n            libc::ELOOP =\u003e ELOOP,\n            libc::ENOMSG =\u003e ENOMSG,\n            libc::EIDRM =\u003e EIDRM,\n            libc::ECHRNG =\u003e ECHRNG,\n            libc::EL2NSYNC =\u003e EL2NSYNC,\n            libc::EL3HLT =\u003e EL3HLT,\n            libc::EL3RST =\u003e EL3RST,\n            libc::ELNRNG =\u003e ELNRNG,\n            libc::EUNATCH =\u003e EUNATCH,\n            libc::ENOCSI =\u003e ENOCSI,\n            libc::EL2HLT =\u003e EL2HLT,\n            libc::EBADE =\u003e EBADE,\n            libc::EBADR =\u003e EBADR,\n            libc::EXFULL =\u003e EXFULL,\n            libc::ENOANO =\u003e ENOANO,\n            libc::EBADRQC =\u003e EBADRQC,\n            libc::EBADSLT =\u003e EBADSLT,\n            libc::EBFONT =\u003e EBFONT,\n            libc::ENOSTR =\u003e ENOSTR,\n            libc::ENODATA =\u003e ENODATA,\n            libc::ETIME =\u003e ETIME,\n            libc::ENOSR =\u003e ENOSR,\n            libc::ENONET =\u003e ENONET,\n            libc::ENOPKG =\u003e ENOPKG,\n            libc::EREMOTE =\u003e EREMOTE,\n            libc::ENOLINK =\u003e ENOLINK,\n            libc::EADV =\u003e EADV,\n            libc::ESRMNT =\u003e ESRMNT,\n            libc::ECOMM =\u003e ECOMM,\n            libc::EPROTO =\u003e EPROTO,\n            libc::EMULTIHOP =\u003e EMULTIHOP,\n            libc::EDOTDOT =\u003e EDOTDOT,\n            libc::EBADMSG =\u003e EBADMSG,\n            libc::EOVERFLOW =\u003e EOVERFLOW,\n            libc::ENOTUNIQ =\u003e ENOTUNIQ,\n            libc::EBADFD =\u003e EBADFD,\n            libc::EREMCHG =\u003e EREMCHG,\n            libc::ELIBACC =\u003e ELIBACC,\n            libc::ELIBBAD =\u003e ELIBBAD,\n            libc::ELIBSCN =\u003e ELIBSCN,\n            libc::ELIBMAX =\u003e ELIBMAX,\n            libc::ELIBEXEC =\u003e ELIBEXEC,\n            libc::EILSEQ =\u003e EILSEQ,\n            libc::ERESTART =\u003e ERESTART,\n            libc::ESTRPIPE =\u003e ESTRPIPE,\n            libc::EUSERS =\u003e EUSERS,\n            libc::ENOTSOCK =\u003e ENOTSOCK,\n            libc::EDESTADDRREQ =\u003e EDESTADDRREQ,\n            libc::EMSGSIZE =\u003e EMSGSIZE,\n            libc::EPROTOTYPE =\u003e EPROTOTYPE,\n            libc::ENOPROTOOPT =\u003e ENOPROTOOPT,\n            libc::EPROTONOSUPPORT =\u003e EPROTONOSUPPORT,\n            libc::ESOCKTNOSUPPORT =\u003e ESOCKTNOSUPPORT,\n            libc::EOPNOTSUPP =\u003e EOPNOTSUPP,\n            libc::EPFNOSUPPORT =\u003e EPFNOSUPPORT,\n            libc::EAFNOSUPPORT =\u003e EAFNOSUPPORT,\n            libc::EADDRINUSE =\u003e EADDRINUSE,\n            libc::EADDRNOTAVAIL =\u003e EADDRNOTAVAIL,\n            libc::ENETDOWN =\u003e ENETDOWN,\n            libc::ENETUNREACH =\u003e ENETUNREACH,\n            libc::ENETRESET =\u003e ENETRESET,\n            libc::ECONNABORTED =\u003e ECONNABORTED,\n            libc::ECONNRESET =\u003e ECONNRESET,\n            libc::ENOBUFS =\u003e ENOBUFS,\n            libc::EISCONN =\u003e EISCONN,\n            libc::ENOTCONN =\u003e ENOTCONN,\n            libc::ESHUTDOWN =\u003e ESHUTDOWN,\n            libc::ETOOMANYREFS =\u003e ETOOMANYREFS,\n            libc::ETIMEDOUT =\u003e ETIMEDOUT,\n            libc::ECONNREFUSED =\u003e ECONNREFUSED,\n            libc::EHOSTDOWN =\u003e EHOSTDOWN,\n            libc::EHOSTUNREACH =\u003e EHOSTUNREACH,\n            libc::EALREADY =\u003e EALREADY,\n            libc::EINPROGRESS =\u003e EINPROGRESS,\n            libc::ESTALE =\u003e ESTALE,\n            libc::EUCLEAN =\u003e EUCLEAN,\n            libc::ENOTNAM =\u003e ENOTNAM,\n            libc::ENAVAIL =\u003e ENAVAIL,\n            libc::EISNAM =\u003e EISNAM,\n            libc::EREMOTEIO =\u003e EREMOTEIO,\n            libc::EDQUOT =\u003e EDQUOT,\n            libc::ENOMEDIUM =\u003e ENOMEDIUM,\n            libc::EMEDIUMTYPE =\u003e EMEDIUMTYPE,\n            libc::ECANCELED =\u003e ECANCELED,\n            libc::ENOKEY =\u003e ENOKEY,\n            libc::EKEYEXPIRED =\u003e EKEYEXPIRED,\n            libc::EKEYREVOKED =\u003e EKEYREVOKED,\n            libc::EKEYREJECTED =\u003e EKEYREJECTED,\n            libc::EOWNERDEAD =\u003e EOWNERDEAD,\n            libc::ENOTRECOVERABLE =\u003e ENOTRECOVERABLE,\n            #[cfg(not(any(target_os = \"android\", target_arch = \"mips\")))]\n            libc::ERFKILL =\u003e ERFKILL,\n            #[cfg(not(any(target_os = \"android\", target_arch = \"mips\")))]\n            libc::EHWPOISON =\u003e EHWPOISON,\n            _ =\u003e UnknownErrno,\n        }\n    }\n}\n\n#[cfg(apple_targets)]\nmod consts {\n    #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum Errno {\n        UnknownErrno = 0,\n        EPERM = libc::EPERM,\n        ENOENT = libc::ENOENT,\n        ESRCH = libc::ESRCH,\n        EINTR = libc::EINTR,\n        EIO = libc::EIO,\n        ENXIO = libc::ENXIO,\n        E2BIG = libc::E2BIG,\n        ENOEXEC = libc::ENOEXEC,\n        EBADF = libc::EBADF,\n        ECHILD = libc::ECHILD,\n        EDEADLK = libc::EDEADLK,\n        ENOMEM = libc::ENOMEM,\n        EACCES = libc::EACCES,\n        EFAULT = libc::EFAULT,\n        ENOTBLK = libc::ENOTBLK,\n        EBUSY = libc::EBUSY,\n        EEXIST = libc::EEXIST,\n        EXDEV = libc::EXDEV,\n        ENODEV = libc::ENODEV,\n        ENOTDIR = libc::ENOTDIR,\n        EISDIR = libc::EISDIR,\n        EINVAL = libc::EINVAL,\n        ENFILE = libc::ENFILE,\n        EMFILE = libc::EMFILE,\n        ENOTTY = libc::ENOTTY,\n        ETXTBSY = libc::ETXTBSY,\n        EFBIG = libc::EFBIG,\n        ENOSPC = libc::ENOSPC,\n        ESPIPE = libc::ESPIPE,\n        EROFS = libc::EROFS,\n        EMLINK = libc::EMLINK,\n        EPIPE = libc::EPIPE,\n        EDOM = libc::EDOM,\n        ERANGE = libc::ERANGE,\n        EAGAIN = libc::EAGAIN,\n        EINPROGRESS = libc::EINPROGRESS,\n        EALREADY = libc::EALREADY,\n        ENOTSOCK = libc::ENOTSOCK,\n        EDESTADDRREQ = libc::EDESTADDRREQ,\n        EMSGSIZE = libc::EMSGSIZE,\n        EPROTOTYPE = libc::EPROTOTYPE,\n        ENOPROTOOPT = libc::ENOPROTOOPT,\n        EPROTONOSUPPORT = libc::EPROTONOSUPPORT,\n        ESOCKTNOSUPPORT = libc::ESOCKTNOSUPPORT,\n        ENOTSUP = libc::ENOTSUP,\n        EPFNOSUPPORT = libc::EPFNOSUPPORT,\n        EAFNOSUPPORT = libc::EAFNOSUPPORT,\n        EADDRINUSE = libc::EADDRINUSE,\n        EADDRNOTAVAIL = libc::EADDRNOTAVAIL,\n        ENETDOWN = libc::ENETDOWN,\n        ENETUNREACH = libc::ENETUNREACH,\n        ENETRESET = libc::ENETRESET,\n        ECONNABORTED = libc::ECONNABORTED,\n        ECONNRESET = libc::ECONNRESET,\n        ENOBUFS = libc::ENOBUFS,\n        EISCONN = libc::EISCONN,\n        ENOTCONN = libc::ENOTCONN,\n        ESHUTDOWN = libc::ESHUTDOWN,\n        ETOOMANYREFS = libc::ETOOMANYREFS,\n        ETIMEDOUT = libc::ETIMEDOUT,\n        ECONNREFUSED = libc::ECONNREFUSED,\n        ELOOP = libc::ELOOP,\n        ENAMETOOLONG = libc::ENAMETOOLONG,\n        EHOSTDOWN = libc::EHOSTDOWN,\n        EHOSTUNREACH = libc::EHOSTUNREACH,\n        ENOTEMPTY = libc::ENOTEMPTY,\n        EPROCLIM = libc::EPROCLIM,\n        EUSERS = libc::EUSERS,\n        EDQUOT = libc::EDQUOT,\n        ESTALE = libc::ESTALE,\n        EREMOTE = libc::EREMOTE,\n        EBADRPC = libc::EBADRPC,\n        ERPCMISMATCH = libc::ERPCMISMATCH,\n        EPROGUNAVAIL = libc::EPROGUNAVAIL,\n        EPROGMISMATCH = libc::EPROGMISMATCH,\n        EPROCUNAVAIL = libc::EPROCUNAVAIL,\n        ENOLCK = libc::ENOLCK,\n        ENOSYS = libc::ENOSYS,\n        EFTYPE = libc::EFTYPE,\n        EAUTH = libc::EAUTH,\n        ENEEDAUTH = libc::ENEEDAUTH,\n        EPWROFF = libc::EPWROFF,\n        EDEVERR = libc::EDEVERR,\n        EOVERFLOW = libc::EOVERFLOW,\n        EBADEXEC = libc::EBADEXEC,\n        EBADARCH = libc::EBADARCH,\n        ESHLIBVERS = libc::ESHLIBVERS,\n        EBADMACHO = libc::EBADMACHO,\n        ECANCELED = libc::ECANCELED,\n        EIDRM = libc::EIDRM,\n        ENOMSG = libc::ENOMSG,\n        EILSEQ = libc::EILSEQ,\n        ENOATTR = libc::ENOATTR,\n        EBADMSG = libc::EBADMSG,\n        EMULTIHOP = libc::EMULTIHOP,\n        ENODATA = libc::ENODATA,\n        ENOLINK = libc::ENOLINK,\n        ENOSR = libc::ENOSR,\n        ENOSTR = libc::ENOSTR,\n        EPROTO = libc::EPROTO,\n        ETIME = libc::ETIME,\n        EOPNOTSUPP = libc::EOPNOTSUPP,\n        ENOPOLICY = libc::ENOPOLICY,\n        ENOTRECOVERABLE = libc::ENOTRECOVERABLE,\n        EOWNERDEAD = libc::EOWNERDEAD,\n        EQFULL = libc::EQFULL,\n    }\n\n    impl Errno {\n        pub const ELAST: Errno = Errno::EQFULL;\n        pub const EWOULDBLOCK: Errno = Errno::EAGAIN;\n        pub const EDEADLOCK: Errno = Errno::EDEADLK;\n    }\n\n    #[deprecated(\n        since = \"0.28.0\",\n        note = \"please use `Errno::from_raw()` instead\"\n    )]\n    pub const fn from_i32(e: i32) -\u003e Errno {\n        use self::Errno::*;\n\n        match e {\n            libc::EPERM =\u003e EPERM,\n            libc::ENOENT =\u003e ENOENT,\n            libc::ESRCH =\u003e ESRCH,\n            libc::EINTR =\u003e EINTR,\n            libc::EIO =\u003e EIO,\n            libc::ENXIO =\u003e ENXIO,\n            libc::E2BIG =\u003e E2BIG,\n            libc::ENOEXEC =\u003e ENOEXEC,\n            libc::EBADF =\u003e EBADF,\n            libc::ECHILD =\u003e ECHILD,\n            libc::EDEADLK =\u003e EDEADLK,\n            libc::ENOMEM =\u003e ENOMEM,\n            libc::EACCES =\u003e EACCES,\n            libc::EFAULT =\u003e EFAULT,\n            libc::ENOTBLK =\u003e ENOTBLK,\n            libc::EBUSY =\u003e EBUSY,\n            libc::EEXIST =\u003e EEXIST,\n            libc::EXDEV =\u003e EXDEV,\n            libc::ENODEV =\u003e ENODEV,\n            libc::ENOTDIR =\u003e ENOTDIR,\n            libc::EISDIR =\u003e EISDIR,\n            libc::EINVAL =\u003e EINVAL,\n            libc::ENFILE =\u003e ENFILE,\n            libc::EMFILE =\u003e EMFILE,\n            libc::ENOTTY =\u003e ENOTTY,\n            libc::ETXTBSY =\u003e ETXTBSY,\n            libc::EFBIG =\u003e EFBIG,\n            libc::ENOSPC =\u003e ENOSPC,\n            libc::ESPIPE =\u003e ESPIPE,\n            libc::EROFS =\u003e EROFS,\n            libc::EMLINK =\u003e EMLINK,\n            libc::EPIPE =\u003e EPIPE,\n            libc::EDOM =\u003e EDOM,\n            libc::ERANGE =\u003e ERANGE,\n            libc::EAGAIN =\u003e EAGAIN,\n            libc::EINPROGRESS =\u003e EINPROGRESS,\n            libc::EALREADY =\u003e EALREADY,\n            libc::ENOTSOCK =\u003e ENOTSOCK,\n            libc::EDESTADDRREQ =\u003e EDESTADDRREQ,\n            libc::EMSGSIZE =\u003e EMSGSIZE,\n            libc::EPROTOTYPE =\u003e EPROTOTYPE,\n            libc::ENOPROTOOPT =\u003e ENOPROTOOPT,\n            libc::EPROTONOSUPPORT =\u003e EPROTONOSUPPORT,\n            libc::ESOCKTNOSUPPORT =\u003e ESOCKTNOSUPPORT,\n            libc::ENOTSUP =\u003e ENOTSUP,\n            libc::EPFNOSUPPORT =\u003e EPFNOSUPPORT,\n            libc::EAFNOSUPPORT =\u003e EAFNOSUPPORT,\n            libc::EADDRINUSE =\u003e EADDRINUSE,\n            libc::EADDRNOTAVAIL =\u003e EADDRNOTAVAIL,\n            libc::ENETDOWN =\u003e ENETDOWN,\n            libc::ENETUNREACH =\u003e ENETUNREACH,\n            libc::ENETRESET =\u003e ENETRESET,\n            libc::ECONNABORTED =\u003e ECONNABORTED,\n            libc::ECONNRESET =\u003e ECONNRESET,\n            libc::ENOBUFS =\u003e ENOBUFS,\n            libc::EISCONN =\u003e EISCONN,\n            libc::ENOTCONN =\u003e ENOTCONN,\n            libc::ESHUTDOWN =\u003e ESHUTDOWN,\n            libc::ETOOMANYREFS =\u003e ETOOMANYREFS,\n            libc::ETIMEDOUT =\u003e ETIMEDOUT,\n            libc::ECONNREFUSED =\u003e ECONNREFUSED,\n            libc::ELOOP =\u003e ELOOP,\n            libc::ENAMETOOLONG =\u003e ENAMETOOLONG,\n            libc::EHOSTDOWN =\u003e EHOSTDOWN,\n            libc::EHOSTUNREACH =\u003e EHOSTUNREACH,\n            libc::ENOTEMPTY =\u003e ENOTEMPTY,\n            libc::EPROCLIM =\u003e EPROCLIM,\n            libc::EUSERS =\u003e EUSERS,\n            libc::EDQUOT =\u003e EDQUOT,\n            libc::ESTALE =\u003e ESTALE,\n            libc::EREMOTE =\u003e EREMOTE,\n            libc::EBADRPC =\u003e EBADRPC,\n            libc::ERPCMISMATCH =\u003e ERPCMISMATCH,\n            libc::EPROGUNAVAIL =\u003e EPROGUNAVAIL,\n            libc::EPROGMISMATCH =\u003e EPROGMISMATCH,\n            libc::EPROCUNAVAIL =\u003e EPROCUNAVAIL,\n            libc::ENOLCK =\u003e ENOLCK,\n            libc::ENOSYS =\u003e ENOSYS,\n            libc::EFTYPE =\u003e EFTYPE,\n            libc::EAUTH =\u003e EAUTH,\n            libc::ENEEDAUTH =\u003e ENEEDAUTH,\n            libc::EPWROFF =\u003e EPWROFF,\n            libc::EDEVERR =\u003e EDEVERR,\n            libc::EOVERFLOW =\u003e EOVERFLOW,\n            libc::EBADEXEC =\u003e EBADEXEC,\n            libc::EBADARCH =\u003e EBADARCH,\n            libc::ESHLIBVERS =\u003e ESHLIBVERS,\n            libc::EBADMACHO =\u003e EBADMACHO,\n            libc::ECANCELED =\u003e ECANCELED,\n            libc::EIDRM =\u003e EIDRM,\n            libc::ENOMSG =\u003e ENOMSG,\n            libc::EILSEQ =\u003e EILSEQ,\n            libc::ENOATTR =\u003e ENOATTR,\n            libc::EBADMSG =\u003e EBADMSG,\n            libc::EMULTIHOP =\u003e EMULTIHOP,\n            libc::ENODATA =\u003e ENODATA,\n            libc::ENOLINK =\u003e ENOLINK,\n            libc::ENOSR =\u003e ENOSR,\n            libc::ENOSTR =\u003e ENOSTR,\n            libc::EPROTO =\u003e EPROTO,\n            libc::ETIME =\u003e ETIME,\n            libc::EOPNOTSUPP =\u003e EOPNOTSUPP,\n            libc::ENOPOLICY =\u003e ENOPOLICY,\n            libc::ENOTRECOVERABLE =\u003e ENOTRECOVERABLE,\n            libc::EOWNERDEAD =\u003e EOWNERDEAD,\n            libc::EQFULL =\u003e EQFULL,\n            _ =\u003e UnknownErrno,\n        }\n    }\n}\n\n#[cfg(target_os = \"freebsd\")]\nmod consts {\n    #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum Errno {\n        UnknownErrno = 0,\n        EPERM = libc::EPERM,\n        ENOENT = libc::ENOENT,\n        ESRCH = libc::ESRCH,\n        EINTR = libc::EINTR,\n        EIO = libc::EIO,\n        ENXIO = libc::ENXIO,\n        E2BIG = libc::E2BIG,\n        ENOEXEC = libc::ENOEXEC,\n        EBADF = libc::EBADF,\n        ECHILD = libc::ECHILD,\n        EDEADLK = libc::EDEADLK,\n        ENOMEM = libc::ENOMEM,\n        EACCES = libc::EACCES,\n        EFAULT = libc::EFAULT,\n        ENOTBLK = libc::ENOTBLK,\n        EBUSY = libc::EBUSY,\n        EEXIST = libc::EEXIST,\n        EXDEV = libc::EXDEV,\n        ENODEV = libc::ENODEV,\n        ENOTDIR = libc::ENOTDIR,\n        EISDIR = libc::EISDIR,\n        EINVAL = libc::EINVAL,\n        ENFILE = libc::ENFILE,\n        EMFILE = libc::EMFILE,\n        ENOTTY = libc::ENOTTY,\n        ETXTBSY = libc::ETXTBSY,\n        EFBIG = libc::EFBIG,\n        ENOSPC = libc::ENOSPC,\n        ESPIPE = libc::ESPIPE,\n        EROFS = libc::EROFS,\n        EMLINK = libc::EMLINK,\n        EPIPE = libc::EPIPE,\n        EDOM = libc::EDOM,\n        ERANGE = libc::ERANGE,\n        EAGAIN = libc::EAGAIN,\n        EINPROGRESS = libc::EINPROGRESS,\n        EALREADY = libc::EALREADY,\n        ENOTSOCK = libc::ENOTSOCK,\n        EDESTADDRREQ = libc::EDESTADDRREQ,\n        EMSGSIZE = libc::EMSGSIZE,\n        EPROTOTYPE = libc::EPROTOTYPE,\n        ENOPROTOOPT = libc::ENOPROTOOPT,\n        EPROTONOSUPPORT = libc::EPROTONOSUPPORT,\n        ESOCKTNOSUPPORT = libc::ESOCKTNOSUPPORT,\n        ENOTSUP = libc::ENOTSUP,\n        EPFNOSUPPORT = libc::EPFNOSUPPORT,\n        EAFNOSUPPORT = libc::EAFNOSUPPORT,\n        EADDRINUSE = libc::EADDRINUSE,\n        EADDRNOTAVAIL = libc::EADDRNOTAVAIL,\n        ENETDOWN = libc::ENETDOWN,\n        ENETUNREACH = libc::ENETUNREACH,\n        ENETRESET = libc::ENETRESET,\n        ECONNABORTED = libc::ECONNABORTED,\n        ECONNRESET = libc::ECONNRESET,\n        ENOBUFS = libc::ENOBUFS,\n        EISCONN = libc::EISCONN,\n        ENOTCONN = libc::ENOTCONN,\n        ESHUTDOWN = libc::ESHUTDOWN,\n        ETOOMANYREFS = libc::ETOOMANYREFS,\n        ETIMEDOUT = libc::ETIMEDOUT,\n        ECONNREFUSED = libc::ECONNREFUSED,\n        ELOOP = libc::ELOOP,\n        ENAMETOOLONG = libc::ENAMETOOLONG,\n        EHOSTDOWN = libc::EHOSTDOWN,\n        EHOSTUNREACH = libc::EHOSTUNREACH,\n        ENOTEMPTY = libc::ENOTEMPTY,\n        EPROCLIM = libc::EPROCLIM,\n        EUSERS = libc::EUSERS,\n        EDQUOT = libc::EDQUOT,\n        ESTALE = libc::ESTALE,\n        EREMOTE = libc::EREMOTE,\n        EBADRPC = libc::EBADRPC,\n        ERPCMISMATCH = libc::ERPCMISMATCH,\n        EPROGUNAVAIL = libc::EPROGUNAVAIL,\n        EPROGMISMATCH = libc::EPROGMISMATCH,\n        EPROCUNAVAIL = libc::EPROCUNAVAIL,\n        ENOLCK = libc::ENOLCK,\n        ENOSYS = libc::ENOSYS,\n        EFTYPE = libc::EFTYPE,\n        EAUTH = libc::EAUTH,\n        ENEEDAUTH = libc::ENEEDAUTH,\n        EIDRM = libc::EIDRM,\n        ENOMSG = libc::ENOMSG,\n        EOVERFLOW = libc::EOVERFLOW,\n        ECANCELED = libc::ECANCELED,\n        EILSEQ = libc::EILSEQ,\n        ENOATTR = libc::ENOATTR,\n        EDOOFUS = libc::EDOOFUS,\n        EBADMSG = libc::EBADMSG,\n        EMULTIHOP = libc::EMULTIHOP,\n        ENOLINK = libc::ENOLINK,\n        EPROTO = libc::EPROTO,\n        ENOTCAPABLE = libc::ENOTCAPABLE,\n        ECAPMODE = libc::ECAPMODE,\n        ENOTRECOVERABLE = libc::ENOTRECOVERABLE,\n        EOWNERDEAD = libc::EOWNERDEAD,\n    }\n\n    impl Errno {\n        pub const ELAST: Errno = Errno::EOWNERDEAD;\n        pub const EWOULDBLOCK: Errno = Errno::EAGAIN;\n        pub const EDEADLOCK: Errno = Errno::EDEADLK;\n        pub const EOPNOTSUPP: Errno = Errno::ENOTSUP;\n    }\n\n    #[deprecated(\n        since = \"0.28.0\",\n        note = \"please use `Errno::from_raw()` instead\"\n    )]\n    pub const fn from_i32(e: i32) -\u003e Errno {\n        use self::Errno::*;\n\n        match e {\n            libc::EPERM =\u003e EPERM,\n            libc::ENOENT =\u003e ENOENT,\n            libc::ESRCH =\u003e ESRCH,\n            libc::EINTR =\u003e EINTR,\n            libc::EIO =\u003e EIO,\n            libc::ENXIO =\u003e ENXIO,\n            libc::E2BIG =\u003e E2BIG,\n            libc::ENOEXEC =\u003e ENOEXEC,\n            libc::EBADF =\u003e EBADF,\n            libc::ECHILD =\u003e ECHILD,\n            libc::EDEADLK =\u003e EDEADLK,\n            libc::ENOMEM =\u003e ENOMEM,\n            libc::EACCES =\u003e EACCES,\n            libc::EFAULT =\u003e EFAULT,\n            libc::ENOTBLK =\u003e ENOTBLK,\n            libc::EBUSY =\u003e EBUSY,\n            libc::EEXIST =\u003e EEXIST,\n            libc::EXDEV =\u003e EXDEV,\n            libc::ENODEV =\u003e ENODEV,\n            libc::ENOTDIR =\u003e ENOTDIR,\n            libc::EISDIR =\u003e EISDIR,\n            libc::EINVAL =\u003e EINVAL,\n            libc::ENFILE =\u003e ENFILE,\n            libc::EMFILE =\u003e EMFILE,\n            libc::ENOTTY =\u003e ENOTTY,\n            libc::ETXTBSY =\u003e ETXTBSY,\n            libc::EFBIG =\u003e EFBIG,\n            libc::ENOSPC =\u003e ENOSPC,\n            libc::ESPIPE =\u003e ESPIPE,\n            libc::EROFS =\u003e EROFS,\n            libc::EMLINK =\u003e EMLINK,\n            libc::EPIPE =\u003e EPIPE,\n            libc::EDOM =\u003e EDOM,\n            libc::ERANGE =\u003e ERANGE,\n            libc::EAGAIN =\u003e EAGAIN,\n            libc::EINPROGRESS =\u003e EINPROGRESS,\n            libc::EALREADY =\u003e EALREADY,\n            libc::ENOTSOCK =\u003e ENOTSOCK,\n            libc::EDESTADDRREQ =\u003e EDESTADDRREQ,\n            libc::EMSGSIZE =\u003e EMSGSIZE,\n            libc::EPROTOTYPE =\u003e EPROTOTYPE,\n            libc::ENOPROTOOPT =\u003e ENOPROTOOPT,\n            libc::EPROTONOSUPPORT =\u003e EPROTONOSUPPORT,\n            libc::ESOCKTNOSUPPORT =\u003e ESOCKTNOSUPPORT,\n            libc::ENOTSUP =\u003e ENOTSUP,\n            libc::EPFNOSUPPORT =\u003e EPFNOSUPPORT,\n            libc::EAFNOSUPPORT =\u003e EAFNOSUPPORT,\n            libc::EADDRINUSE =\u003e EADDRINUSE,\n            libc::EADDRNOTAVAIL =\u003e EADDRNOTAVAIL,\n            libc::ENETDOWN =\u003e ENETDOWN,\n            libc::ENETUNREACH =\u003e ENETUNREACH,\n            libc::ENETRESET =\u003e ENETRESET,\n            libc::ECONNABORTED =\u003e ECONNABORTED,\n            libc::ECONNRESET =\u003e ECONNRESET,\n            libc::ENOBUFS =\u003e ENOBUFS,\n            libc::EISCONN =\u003e EISCONN,\n            libc::ENOTCONN =\u003e ENOTCONN,\n            libc::ESHUTDOWN =\u003e ESHUTDOWN,\n            libc::ETOOMANYREFS =\u003e ETOOMANYREFS,\n            libc::ETIMEDOUT =\u003e ETIMEDOUT,\n            libc::ECONNREFUSED =\u003e ECONNREFUSED,\n            libc::ELOOP =\u003e ELOOP,\n            libc::ENAMETOOLONG =\u003e ENAMETOOLONG,\n            libc::EHOSTDOWN =\u003e EHOSTDOWN,\n            libc::EHOSTUNREACH =\u003e EHOSTUNREACH,\n            libc::ENOTEMPTY =\u003e ENOTEMPTY,\n            libc::EPROCLIM =\u003e EPROCLIM,\n            libc::EUSERS =\u003e EUSERS,\n            libc::EDQUOT =\u003e EDQUOT,\n            libc::ESTALE =\u003e ESTALE,\n            libc::EREMOTE =\u003e EREMOTE,\n            libc::EBADRPC =\u003e EBADRPC,\n            libc::ERPCMISMATCH =\u003e ERPCMISMATCH,\n            libc::EPROGUNAVAIL =\u003e EPROGUNAVAIL,\n            libc::EPROGMISMATCH =\u003e EPROGMISMATCH,\n            libc::EPROCUNAVAIL =\u003e EPROCUNAVAIL,\n            libc::ENOLCK =\u003e ENOLCK,\n            libc::ENOSYS =\u003e ENOSYS,\n            libc::EFTYPE =\u003e EFTYPE,\n            libc::EAUTH =\u003e EAUTH,\n            libc::ENEEDAUTH =\u003e ENEEDAUTH,\n            libc::EIDRM =\u003e EIDRM,\n            libc::ENOMSG =\u003e ENOMSG,\n            libc::EOVERFLOW =\u003e EOVERFLOW,\n            libc::ECANCELED =\u003e ECANCELED,\n            libc::EILSEQ =\u003e EILSEQ,\n            libc::ENOATTR =\u003e ENOATTR,\n            libc::EDOOFUS =\u003e EDOOFUS,\n            libc::EBADMSG =\u003e EBADMSG,\n            libc::EMULTIHOP =\u003e EMULTIHOP,\n            libc::ENOLINK =\u003e ENOLINK,\n            libc::EPROTO =\u003e EPROTO,\n            libc::ENOTCAPABLE =\u003e ENOTCAPABLE,\n            libc::ECAPMODE =\u003e ECAPMODE,\n            libc::ENOTRECOVERABLE =\u003e ENOTRECOVERABLE,\n            libc::EOWNERDEAD =\u003e EOWNERDEAD,\n            _ =\u003e UnknownErrno,\n        }\n    }\n}\n\n#[cfg(target_os = \"dragonfly\")]\nmod consts {\n    #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum Errno {\n        UnknownErrno = 0,\n        EPERM = libc::EPERM,\n        ENOENT = libc::ENOENT,\n        ESRCH = libc::ESRCH,\n        EINTR = libc::EINTR,\n        EIO = libc::EIO,\n        ENXIO = libc::ENXIO,\n        E2BIG = libc::E2BIG,\n        ENOEXEC = libc::ENOEXEC,\n        EBADF = libc::EBADF,\n        ECHILD = libc::ECHILD,\n        EDEADLK = libc::EDEADLK,\n        ENOMEM = libc::ENOMEM,\n        EACCES = libc::EACCES,\n        EFAULT = libc::EFAULT,\n        ENOTBLK = libc::ENOTBLK,\n        EBUSY = libc::EBUSY,\n        EEXIST = libc::EEXIST,\n        EXDEV = libc::EXDEV,\n        ENODEV = libc::ENODEV,\n        ENOTDIR = libc::ENOTDIR,\n        EISDIR = libc::EISDIR,\n        EINVAL = libc::EINVAL,\n        ENFILE = libc::ENFILE,\n        EMFILE = libc::EMFILE,\n        ENOTTY = libc::ENOTTY,\n        ETXTBSY = libc::ETXTBSY,\n        EFBIG = libc::EFBIG,\n        ENOSPC = libc::ENOSPC,\n        ESPIPE = libc::ESPIPE,\n        EROFS = libc::EROFS,\n        EMLINK = libc::EMLINK,\n        EPIPE = libc::EPIPE,\n        EDOM = libc::EDOM,\n        ERANGE = libc::ERANGE,\n        EAGAIN = libc::EAGAIN,\n        EINPROGRESS = libc::EINPROGRESS,\n        EALREADY = libc::EALREADY,\n        ENOTSOCK = libc::ENOTSOCK,\n        EDESTADDRREQ = libc::EDESTADDRREQ,\n        EMSGSIZE = libc::EMSGSIZE,\n        EPROTOTYPE = libc::EPROTOTYPE,\n        ENOPROTOOPT = libc::ENOPROTOOPT,\n        EPROTONOSUPPORT = libc::EPROTONOSUPPORT,\n        ESOCKTNOSUPPORT = libc::ESOCKTNOSUPPORT,\n        ENOTSUP = libc::ENOTSUP,\n        EPFNOSUPPORT = libc::EPFNOSUPPORT,\n        EAFNOSUPPORT = libc::EAFNOSUPPORT,\n        EADDRINUSE = libc::EADDRINUSE,\n        EADDRNOTAVAIL = libc::EADDRNOTAVAIL,\n        ENETDOWN = libc::ENETDOWN,\n        ENETUNREACH = libc::ENETUNREACH,\n        ENETRESET = libc::ENETRESET,\n        ECONNABORTED = libc::ECONNABORTED,\n        ECONNRESET = libc::ECONNRESET,\n        ENOBUFS = libc::ENOBUFS,\n        EISCONN = libc::EISCONN,\n        ENOTCONN = libc::ENOTCONN,\n        ESHUTDOWN = libc::ESHUTDOWN,\n        ETOOMANYREFS = libc::ETOOMANYREFS,\n        ETIMEDOUT = libc::ETIMEDOUT,\n        ECONNREFUSED = libc::ECONNREFUSED,\n        ELOOP = libc::ELOOP,\n        ENAMETOOLONG = libc::ENAMETOOLONG,\n        EHOSTDOWN = libc::EHOSTDOWN,\n        EHOSTUNREACH = libc::EHOSTUNREACH,\n        ENOTEMPTY = libc::ENOTEMPTY,\n        EPROCLIM = libc::EPROCLIM,\n        EUSERS = libc::EUSERS,\n        EDQUOT = libc::EDQUOT,\n        ESTALE = libc::ESTALE,\n        EREMOTE = libc::EREMOTE,\n        EBADRPC = libc::EBADRPC,\n        ERPCMISMATCH = libc::ERPCMISMATCH,\n        EPROGUNAVAIL = libc::EPROGUNAVAIL,\n        EPROGMISMATCH = libc::EPROGMISMATCH,\n        EPROCUNAVAIL = libc::EPROCUNAVAIL,\n        ENOLCK = libc::ENOLCK,\n        ENOSYS = libc::ENOSYS,\n        EFTYPE = libc::EFTYPE,\n        EAUTH = libc::EAUTH,\n        ENEEDAUTH = libc::ENEEDAUTH,\n        EIDRM = libc::EIDRM,\n        ENOMSG = libc::ENOMSG,\n        EOVERFLOW = libc::EOVERFLOW,\n        ECANCELED = libc::ECANCELED,\n        EILSEQ = libc::EILSEQ,\n        ENOATTR = libc::ENOATTR,\n        EDOOFUS = libc::EDOOFUS,\n        EBADMSG = libc::EBADMSG,\n        EMULTIHOP = libc::EMULTIHOP,\n        ENOLINK = libc::ENOLINK,\n        EPROTO = libc::EPROTO,\n        ENOMEDIUM = libc::ENOMEDIUM,\n        ENOTRECOVERABLE = libc::ENOTRECOVERABLE,\n        EOWNERDEAD = libc::EOWNERDEAD,\n        EASYNC = libc::EASYNC,\n    }\n\n    impl Errno {\n        pub const ELAST: Errno = Errno::EASYNC;\n        pub const EWOULDBLOCK: Errno = Errno::EAGAIN;\n        pub const EDEADLOCK: Errno = Errno::EDEADLK;\n        pub const EOPNOTSUPP: Errno = Errno::ENOTSUP;\n    }\n\n    #[deprecated(\n        since = \"0.28.0\",\n        note = \"please use `Errno::from_raw()` instead\"\n    )]\n    pub const fn from_i32(e: i32) -\u003e Errno {\n        use self::Errno::*;\n\n        match e {\n            libc::EPERM =\u003e EPERM,\n            libc::ENOENT =\u003e ENOENT,\n            libc::ESRCH =\u003e ESRCH,\n            libc::EINTR =\u003e EINTR,\n            libc::EIO =\u003e EIO,\n            libc::ENXIO =\u003e ENXIO,\n            libc::E2BIG =\u003e E2BIG,\n            libc::ENOEXEC =\u003e ENOEXEC,\n            libc::EBADF =\u003e EBADF,\n            libc::ECHILD =\u003e ECHILD,\n            libc::EDEADLK =\u003e EDEADLK,\n            libc::ENOMEM =\u003e ENOMEM,\n            libc::EACCES =\u003e EACCES,\n            libc::EFAULT =\u003e EFAULT,\n            libc::ENOTBLK =\u003e ENOTBLK,\n            libc::EBUSY =\u003e EBUSY,\n            libc::EEXIST =\u003e EEXIST,\n            libc::EXDEV =\u003e EXDEV,\n            libc::ENODEV =\u003e ENODEV,\n            libc::ENOTDIR =\u003e ENOTDIR,\n            libc::EISDIR =\u003e EISDIR,\n            libc::EINVAL =\u003e EINVAL,\n            libc::ENFILE =\u003e ENFILE,\n            libc::EMFILE =\u003e EMFILE,\n            libc::ENOTTY =\u003e ENOTTY,\n            libc::ETXTBSY =\u003e ETXTBSY,\n            libc::EFBIG =\u003e EFBIG,\n            libc::ENOSPC =\u003e ENOSPC,\n            libc::ESPIPE =\u003e ESPIPE,\n            libc::EROFS =\u003e EROFS,\n            libc::EMLINK =\u003e EMLINK,\n            libc::EPIPE =\u003e EPIPE,\n            libc::EDOM =\u003e EDOM,\n            libc::ERANGE =\u003e ERANGE,\n            libc::EAGAIN =\u003e EAGAIN,\n            libc::EINPROGRESS =\u003e EINPROGRESS,\n            libc::EALREADY =\u003e EALREADY,\n            libc::ENOTSOCK =\u003e ENOTSOCK,\n            libc::EDESTADDRREQ =\u003e EDESTADDRREQ,\n            libc::EMSGSIZE =\u003e EMSGSIZE,\n            libc::EPROTOTYPE =\u003e EPROTOTYPE,\n            libc::ENOPROTOOPT =\u003e ENOPROTOOPT,\n            libc::EPROTONOSUPPORT =\u003e EPROTONOSUPPORT,\n            libc::ESOCKTNOSUPPORT =\u003e ESOCKTNOSUPPORT,\n            libc::ENOTSUP =\u003e ENOTSUP,\n            libc::EPFNOSUPPORT =\u003e EPFNOSUPPORT,\n            libc::EAFNOSUPPORT =\u003e EAFNOSUPPORT,\n            libc::EADDRINUSE =\u003e EADDRINUSE,\n            libc::EADDRNOTAVAIL =\u003e EADDRNOTAVAIL,\n            libc::ENETDOWN =\u003e ENETDOWN,\n            libc::ENETUNREACH =\u003e ENETUNREACH,\n            libc::ENETRESET =\u003e ENETRESET,\n            libc::ECONNABORTED =\u003e ECONNABORTED,\n            libc::ECONNRESET =\u003e ECONNRESET,\n            libc::ENOBUFS =\u003e ENOBUFS,\n            libc::EISCONN =\u003e EISCONN,\n            libc::ENOTCONN =\u003e ENOTCONN,\n            libc::ESHUTDOWN =\u003e ESHUTDOWN,\n            libc::ETOOMANYREFS =\u003e ETOOMANYREFS,\n            libc::ETIMEDOUT =\u003e ETIMEDOUT,\n            libc::ECONNREFUSED =\u003e ECONNREFUSED,\n            libc::ELOOP =\u003e ELOOP,\n            libc::ENAMETOOLONG =\u003e ENAMETOOLONG,\n            libc::EHOSTDOWN =\u003e EHOSTDOWN,\n            libc::EHOSTUNREACH =\u003e EHOSTUNREACH,\n            libc::ENOTEMPTY =\u003e ENOTEMPTY,\n            libc::EPROCLIM =\u003e EPROCLIM,\n            libc::EUSERS =\u003e EUSERS,\n            libc::EDQUOT =\u003e EDQUOT,\n            libc::ESTALE =\u003e ESTALE,\n            libc::EREMOTE =\u003e EREMOTE,\n            libc::EBADRPC =\u003e EBADRPC,\n            libc::ERPCMISMATCH =\u003e ERPCMISMATCH,\n            libc::EPROGUNAVAIL =\u003e EPROGUNAVAIL,\n            libc::EPROGMISMATCH =\u003e EPROGMISMATCH,\n            libc::EPROCUNAVAIL =\u003e EPROCUNAVAIL,\n            libc::ENOLCK =\u003e ENOLCK,\n            libc::ENOSYS =\u003e ENOSYS,\n            libc::EFTYPE =\u003e EFTYPE,\n            libc::EAUTH =\u003e EAUTH,\n            libc::ENEEDAUTH =\u003e ENEEDAUTH,\n            libc::EIDRM =\u003e EIDRM,\n            libc::ENOMSG =\u003e ENOMSG,\n            libc::EOVERFLOW =\u003e EOVERFLOW,\n            libc::ECANCELED =\u003e ECANCELED,\n            libc::EILSEQ =\u003e EILSEQ,\n            libc::ENOATTR =\u003e ENOATTR,\n            libc::EDOOFUS =\u003e EDOOFUS,\n            libc::EBADMSG =\u003e EBADMSG,\n            libc::EMULTIHOP =\u003e EMULTIHOP,\n            libc::ENOLINK =\u003e ENOLINK,\n            libc::EPROTO =\u003e EPROTO,\n            libc::ENOMEDIUM =\u003e ENOMEDIUM,\n            libc::EASYNC =\u003e EASYNC,\n            _ =\u003e UnknownErrno,\n        }\n    }\n}\n\n#[cfg(target_os = \"openbsd\")]\nmod consts {\n    #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum Errno {\n        UnknownErrno = 0,\n        EPERM = libc::EPERM,\n        ENOENT = libc::ENOENT,\n        ESRCH = libc::ESRCH,\n        EINTR = libc::EINTR,\n        EIO = libc::EIO,\n        ENXIO = libc::ENXIO,\n        E2BIG = libc::E2BIG,\n        ENOEXEC = libc::ENOEXEC,\n        EBADF = libc::EBADF,\n        ECHILD = libc::ECHILD,\n        EDEADLK = libc::EDEADLK,\n        ENOMEM = libc::ENOMEM,\n        EACCES = libc::EACCES,\n        EFAULT = libc::EFAULT,\n        ENOTBLK = libc::ENOTBLK,\n        EBUSY = libc::EBUSY,\n        EEXIST = libc::EEXIST,\n        EXDEV = libc::EXDEV,\n        ENODEV = libc::ENODEV,\n        ENOTDIR = libc::ENOTDIR,\n        EISDIR = libc::EISDIR,\n        EINVAL = libc::EINVAL,\n        ENFILE = libc::ENFILE,\n        EMFILE = libc::EMFILE,\n        ENOTTY = libc::ENOTTY,\n        ETXTBSY = libc::ETXTBSY,\n        EFBIG = libc::EFBIG,\n        ENOSPC = libc::ENOSPC,\n        ESPIPE = libc::ESPIPE,\n        EROFS = libc::EROFS,\n        EMLINK = libc::EMLINK,\n        EPIPE = libc::EPIPE,\n        EDOM = libc::EDOM,\n        ERANGE = libc::ERANGE,\n        EAGAIN = libc::EAGAIN,\n        EINPROGRESS = libc::EINPROGRESS,\n        EALREADY = libc::EALREADY,\n        ENOTSOCK = libc::ENOTSOCK,\n        EDESTADDRREQ = libc::EDESTADDRREQ,\n        EMSGSIZE = libc::EMSGSIZE,\n        EPROTOTYPE = libc::EPROTOTYPE,\n        ENOPROTOOPT = libc::ENOPROTOOPT,\n        EPROTONOSUPPORT = libc::EPROTONOSUPPORT,\n        ESOCKTNOSUPPORT = libc::ESOCKTNOSUPPORT,\n        EOPNOTSUPP = libc::EOPNOTSUPP,\n        EPFNOSUPPORT = libc::EPFNOSUPPORT,\n        EAFNOSUPPORT = libc::EAFNOSUPPORT,\n        EADDRINUSE = libc::EADDRINUSE,\n        EADDRNOTAVAIL = libc::EADDRNOTAVAIL,\n        ENETDOWN = libc::ENETDOWN,\n        ENETUNREACH = libc::ENETUNREACH,\n        ENETRESET = libc::ENETRESET,\n        ECONNABORTED = libc::ECONNABORTED,\n        ECONNRESET = libc::ECONNRESET,\n        ENOBUFS = libc::ENOBUFS,\n        EISCONN = libc::EISCONN,\n        ENOTCONN = libc::ENOTCONN,\n        ESHUTDOWN = libc::ESHUTDOWN,\n        ETOOMANYREFS = libc::ETOOMANYREFS,\n        ETIMEDOUT = libc::ETIMEDOUT,\n        ECONNREFUSED = libc::ECONNREFUSED,\n        ELOOP = libc::ELOOP,\n        ENAMETOOLONG = libc::ENAMETOOLONG,\n        EHOSTDOWN = libc::EHOSTDOWN,\n        EHOSTUNREACH = libc::EHOSTUNREACH,\n        ENOTEMPTY = libc::ENOTEMPTY,\n        EPROCLIM = libc::EPROCLIM,\n        EUSERS = libc::EUSERS,\n        EDQUOT = libc::EDQUOT,\n        ESTALE = libc::ESTALE,\n        EREMOTE = libc::EREMOTE,\n        EBADRPC = libc::EBADRPC,\n        ERPCMISMATCH = libc::ERPCMISMATCH,\n        EPROGUNAVAIL = libc::EPROGUNAVAIL,\n        EPROGMISMATCH = libc::EPROGMISMATCH,\n        EPROCUNAVAIL = libc::EPROCUNAVAIL,\n        ENOLCK = libc::ENOLCK,\n        ENOSYS = libc::ENOSYS,\n        EFTYPE = libc::EFTYPE,\n        EAUTH = libc::EAUTH,\n        ENEEDAUTH = libc::ENEEDAUTH,\n        EIPSEC = libc::EIPSEC,\n        ENOATTR = libc::ENOATTR,\n        EILSEQ = libc::EILSEQ,\n        ENOMEDIUM = libc::ENOMEDIUM,\n        EMEDIUMTYPE = libc::EMEDIUMTYPE,\n        EOVERFLOW = libc::EOVERFLOW,\n        ECANCELED = libc::ECANCELED,\n        EIDRM = libc::EIDRM,\n        ENOMSG = libc::ENOMSG,\n        ENOTSUP = libc::ENOTSUP,\n        EBADMSG = libc::EBADMSG,\n        ENOTRECOVERABLE = libc::ENOTRECOVERABLE,\n        EOWNERDEAD = libc::EOWNERDEAD,\n        EPROTO = libc::EPROTO,\n    }\n\n    impl Errno {\n        pub const ELAST: Errno = Errno::ENOTSUP;\n        pub const EWOULDBLOCK: Errno = Errno::EAGAIN;\n    }\n\n    #[deprecated(\n        since = \"0.28.0\",\n        note = \"please use `Errno::from_raw()` instead\"\n    )]\n    pub const fn from_i32(e: i32) -\u003e Errno {\n        use self::Errno::*;\n\n        match e {\n            libc::EPERM =\u003e EPERM,\n            libc::ENOENT =\u003e ENOENT,\n            libc::ESRCH =\u003e ESRCH,\n            libc::EINTR =\u003e EINTR,\n            libc::EIO =\u003e EIO,\n            libc::ENXIO =\u003e ENXIO,\n            libc::E2BIG =\u003e E2BIG,\n            libc::ENOEXEC =\u003e ENOEXEC,\n            libc::EBADF =\u003e EBADF,\n            libc::ECHILD =\u003e ECHILD,\n            libc::EDEADLK =\u003e EDEADLK,\n            libc::ENOMEM =\u003e ENOMEM,\n            libc::EACCES =\u003e EACCES,\n            libc::EFAULT =\u003e EFAULT,\n            libc::ENOTBLK =\u003e ENOTBLK,\n            libc::EBUSY =\u003e EBUSY,\n            libc::EEXIST =\u003e EEXIST,\n            libc::EXDEV =\u003e EXDEV,\n            libc::ENODEV =\u003e ENODEV,\n            libc::ENOTDIR =\u003e ENOTDIR,\n            libc::EISDIR =\u003e EISDIR,\n            libc::EINVAL =\u003e EINVAL,\n            libc::ENFILE =\u003e ENFILE,\n            libc::EMFILE =\u003e EMFILE,\n            libc::ENOTTY =\u003e ENOTTY,\n            libc::ETXTBSY =\u003e ETXTBSY,\n            libc::EFBIG =\u003e EFBIG,\n            libc::ENOSPC =\u003e ENOSPC,\n            libc::ESPIPE =\u003e ESPIPE,\n            libc::EROFS =\u003e EROFS,\n            libc::EMLINK =\u003e EMLINK,\n            libc::EPIPE =\u003e EPIPE,\n            libc::EDOM =\u003e EDOM,\n            libc::ERANGE =\u003e ERANGE,\n            libc::EAGAIN =\u003e EAGAIN,\n            libc::EINPROGRESS =\u003e EINPROGRESS,\n            libc::EALREADY =\u003e EALREADY,\n            libc::ENOTSOCK =\u003e ENOTSOCK,\n            libc::EDESTADDRREQ =\u003e EDESTADDRREQ,\n            libc::EMSGSIZE =\u003e EMSGSIZE,\n            libc::EPROTOTYPE =\u003e EPROTOTYPE,\n            libc::ENOPROTOOPT =\u003e ENOPROTOOPT,\n            libc::EPROTONOSUPPORT =\u003e EPROTONOSUPPORT,\n            libc::ESOCKTNOSUPPORT =\u003e ESOCKTNOSUPPORT,\n            libc::EOPNOTSUPP =\u003e EOPNOTSUPP,\n            libc::EPFNOSUPPORT =\u003e EPFNOSUPPORT,\n            libc::EAFNOSUPPORT =\u003e EAFNOSUPPORT,\n            libc::EADDRINUSE =\u003e EADDRINUSE,\n            libc::EADDRNOTAVAIL =\u003e EADDRNOTAVAIL,\n            libc::ENETDOWN =\u003e ENETDOWN,\n            libc::ENETUNREACH =\u003e ENETUNREACH,\n            libc::ENETRESET =\u003e ENETRESET,\n            libc::ECONNABORTED =\u003e ECONNABORTED,\n            libc::ECONNRESET =\u003e ECONNRESET,\n            libc::ENOBUFS =\u003e ENOBUFS,\n            libc::EISCONN =\u003e EISCONN,\n            libc::ENOTCONN =\u003e ENOTCONN,\n            libc::ESHUTDOWN =\u003e ESHUTDOWN,\n            libc::ETOOMANYREFS =\u003e ETOOMANYREFS,\n            libc::ETIMEDOUT =\u003e ETIMEDOUT,\n            libc::ECONNREFUSED =\u003e ECONNREFUSED,\n            libc::ELOOP =\u003e ELOOP,\n            libc::ENAMETOOLONG =\u003e ENAMETOOLONG,\n            libc::EHOSTDOWN =\u003e EHOSTDOWN,\n            libc::EHOSTUNREACH =\u003e EHOSTUNREACH,\n            libc::ENOTEMPTY =\u003e ENOTEMPTY,\n            libc::EPROCLIM =\u003e EPROCLIM,\n            libc::EUSERS =\u003e EUSERS,\n            libc::EDQUOT =\u003e EDQUOT,\n            libc::ESTALE =\u003e ESTALE,\n            libc::EREMOTE =\u003e EREMOTE,\n            libc::EBADRPC =\u003e EBADRPC,\n            libc::ERPCMISMATCH =\u003e ERPCMISMATCH,\n            libc::EPROGUNAVAIL =\u003e EPROGUNAVAIL,\n            libc::EPROGMISMATCH =\u003e EPROGMISMATCH,\n            libc::EPROCUNAVAIL =\u003e EPROCUNAVAIL,\n            libc::ENOLCK =\u003e ENOLCK,\n            libc::ENOSYS =\u003e ENOSYS,\n            libc::EFTYPE =\u003e EFTYPE,\n            libc::EAUTH =\u003e EAUTH,\n            libc::ENEEDAUTH =\u003e ENEEDAUTH,\n            libc::EIPSEC =\u003e EIPSEC,\n            libc::ENOATTR =\u003e ENOATTR,\n            libc::EILSEQ =\u003e EILSEQ,\n            libc::ENOMEDIUM =\u003e ENOMEDIUM,\n            libc::EMEDIUMTYPE =\u003e EMEDIUMTYPE,\n            libc::EOVERFLOW =\u003e EOVERFLOW,\n            libc::ECANCELED =\u003e ECANCELED,\n            libc::EIDRM =\u003e EIDRM,\n            libc::ENOMSG =\u003e ENOMSG,\n            libc::ENOTSUP =\u003e ENOTSUP,\n            libc::EBADMSG =\u003e EBADMSG,\n            libc::ENOTRECOVERABLE =\u003e ENOTRECOVERABLE,\n            libc::EOWNERDEAD =\u003e EOWNERDEAD,\n            libc::EPROTO =\u003e EPROTO,\n            _ =\u003e UnknownErrno,\n        }\n    }\n}\n\n#[cfg(target_os = \"netbsd\")]\nmod consts {\n    #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum Errno {\n        UnknownErrno = 0,\n        EPERM = libc::EPERM,\n        ENOENT = libc::ENOENT,\n        ESRCH = libc::ESRCH,\n        EINTR = libc::EINTR,\n        EIO = libc::EIO,\n        ENXIO = libc::ENXIO,\n        E2BIG = libc::E2BIG,\n        ENOEXEC = libc::ENOEXEC,\n        EBADF = libc::EBADF,\n        ECHILD = libc::ECHILD,\n        EDEADLK = libc::EDEADLK,\n        ENOMEM = libc::ENOMEM,\n        EACCES = libc::EACCES,\n        EFAULT = libc::EFAULT,\n        ENOTBLK = libc::ENOTBLK,\n        EBUSY = libc::EBUSY,\n        EEXIST = libc::EEXIST,\n        EXDEV = libc::EXDEV,\n        ENODEV = libc::ENODEV,\n        ENOTDIR = libc::ENOTDIR,\n        EISDIR = libc::EISDIR,\n        EINVAL = libc::EINVAL,\n        ENFILE = libc::ENFILE,\n        EMFILE = libc::EMFILE,\n        ENOTTY = libc::ENOTTY,\n        ETXTBSY = libc::ETXTBSY,\n        EFBIG = libc::EFBIG,\n        ENOSPC = libc::ENOSPC,\n        ESPIPE = libc::ESPIPE,\n        EROFS = libc::EROFS,\n        EMLINK = libc::EMLINK,\n        EPIPE = libc::EPIPE,\n        EDOM = libc::EDOM,\n        ERANGE = libc::ERANGE,\n        EAGAIN = libc::EAGAIN,\n        EINPROGRESS = libc::EINPROGRESS,\n        EALREADY = libc::EALREADY,\n        ENOTSOCK = libc::ENOTSOCK,\n        EDESTADDRREQ = libc::EDESTADDRREQ,\n        EMSGSIZE = libc::EMSGSIZE,\n        EPROTOTYPE = libc::EPROTOTYPE,\n        ENOPROTOOPT = libc::ENOPROTOOPT,\n        EPROTONOSUPPORT = libc::EPROTONOSUPPORT,\n        ESOCKTNOSUPPORT = libc::ESOCKTNOSUPPORT,\n        EOPNOTSUPP = libc::EOPNOTSUPP,\n        EPFNOSUPPORT = libc::EPFNOSUPPORT,\n        EAFNOSUPPORT = libc::EAFNOSUPPORT,\n        EADDRINUSE = libc::EADDRINUSE,\n        EADDRNOTAVAIL = libc::EADDRNOTAVAIL,\n        ENETDOWN = libc::ENETDOWN,\n        ENETUNREACH = libc::ENETUNREACH,\n        ENETRESET = libc::ENETRESET,\n        ECONNABORTED = libc::ECONNABORTED,\n        ECONNRESET = libc::ECONNRESET,\n        ENOBUFS = libc::ENOBUFS,\n        EISCONN = libc::EISCONN,\n        ENOTCONN = libc::ENOTCONN,\n        ESHUTDOWN = libc::ESHUTDOWN,\n        ETOOMANYREFS = libc::ETOOMANYREFS,\n        ETIMEDOUT = libc::ETIMEDOUT,\n        ECONNREFUSED = libc::ECONNREFUSED,\n        ELOOP = libc::ELOOP,\n        ENAMETOOLONG = libc::ENAMETOOLONG,\n        EHOSTDOWN = libc::EHOSTDOWN,\n        EHOSTUNREACH = libc::EHOSTUNREACH,\n        ENOTEMPTY = libc::ENOTEMPTY,\n        EPROCLIM = libc::EPROCLIM,\n        EUSERS = libc::EUSERS,\n        EDQUOT = libc::EDQUOT,\n        ESTALE = libc::ESTALE,\n        EREMOTE = libc::EREMOTE,\n        EBADRPC = libc::EBADRPC,\n        ERPCMISMATCH = libc::ERPCMISMATCH,\n        EPROGUNAVAIL = libc::EPROGUNAVAIL,\n        EPROGMISMATCH = libc::EPROGMISMATCH,\n        EPROCUNAVAIL = libc::EPROCUNAVAIL,\n        ENOLCK = libc::ENOLCK,\n        ENOSYS = libc::ENOSYS,\n        EFTYPE = libc::EFTYPE,\n        EAUTH = libc::EAUTH,\n        ENEEDAUTH = libc::ENEEDAUTH,\n        EIDRM = libc::EIDRM,\n        ENOMSG = libc::ENOMSG,\n        EOVERFLOW = libc::EOVERFLOW,\n        EILSEQ = libc::EILSEQ,\n        ENOTSUP = libc::ENOTSUP,\n        ECANCELED = libc::ECANCELED,\n        EBADMSG = libc::EBADMSG,\n        ENODATA = libc::ENODATA,\n        ENOSR = libc::ENOSR,\n        ENOSTR = libc::ENOSTR,\n        ETIME = libc::ETIME,\n        ENOATTR = libc::ENOATTR,\n        EMULTIHOP = libc::EMULTIHOP,\n        ENOLINK = libc::ENOLINK,\n        EPROTO = libc::EPROTO,\n    }\n\n    impl Errno {\n        pub const ELAST: Errno = Errno::ENOTSUP;\n        pub const EWOULDBLOCK: Errno = Errno::EAGAIN;\n    }\n\n    #[deprecated(\n        since = \"0.28.0\",\n        note = \"please use `Errno::from_raw()` instead\"\n    )]\n    pub const fn from_i32(e: i32) -\u003e Errno {\n        use self::Errno::*;\n\n        match e {\n            libc::EPERM =\u003e EPERM,\n            libc::ENOENT =\u003e ENOENT,\n            libc::ESRCH =\u003e ESRCH,\n            libc::EINTR =\u003e EINTR,\n            libc::EIO =\u003e EIO,\n            libc::ENXIO =\u003e ENXIO,\n            libc::E2BIG =\u003e E2BIG,\n            libc::ENOEXEC =\u003e ENOEXEC,\n            libc::EBADF =\u003e EBADF,\n            libc::ECHILD =\u003e ECHILD,\n            libc::EDEADLK =\u003e EDEADLK,\n            libc::ENOMEM =\u003e ENOMEM,\n            libc::EACCES =\u003e EACCES,\n            libc::EFAULT =\u003e EFAULT,\n            libc::ENOTBLK =\u003e ENOTBLK,\n            libc::EBUSY =\u003e EBUSY,\n            libc::EEXIST =\u003e EEXIST,\n            libc::EXDEV =\u003e EXDEV,\n            libc::ENODEV =\u003e ENODEV,\n            libc::ENOTDIR =\u003e ENOTDIR,\n            libc::EISDIR =\u003e EISDIR,\n            libc::EINVAL =\u003e EINVAL,\n            libc::ENFILE =\u003e ENFILE,\n            libc::EMFILE =\u003e EMFILE,\n            libc::ENOTTY =\u003e ENOTTY,\n            libc::ETXTBSY =\u003e ETXTBSY,\n            libc::EFBIG =\u003e EFBIG,\n            libc::ENOSPC =\u003e ENOSPC,\n            libc::ESPIPE =\u003e ESPIPE,\n            libc::EROFS =\u003e EROFS,\n            libc::EMLINK =\u003e EMLINK,\n            libc::EPIPE =\u003e EPIPE,\n            libc::EDOM =\u003e EDOM,\n            libc::ERANGE =\u003e ERANGE,\n            libc::EAGAIN =\u003e EAGAIN,\n            libc::EINPROGRESS =\u003e EINPROGRESS,\n            libc::EALREADY =\u003e EALREADY,\n            libc::ENOTSOCK =\u003e ENOTSOCK,\n            libc::EDESTADDRREQ =\u003e EDESTADDRREQ,\n            libc::EMSGSIZE =\u003e EMSGSIZE,\n            libc::EPROTOTYPE =\u003e EPROTOTYPE,\n            libc::ENOPROTOOPT =\u003e ENOPROTOOPT,\n            libc::EPROTONOSUPPORT =\u003e EPROTONOSUPPORT,\n            libc::ESOCKTNOSUPPORT =\u003e ESOCKTNOSUPPORT,\n            libc::EOPNOTSUPP =\u003e EOPNOTSUPP,\n            libc::EPFNOSUPPORT =\u003e EPFNOSUPPORT,\n            libc::EAFNOSUPPORT =\u003e EAFNOSUPPORT,\n            libc::EADDRINUSE =\u003e EADDRINUSE,\n            libc::EADDRNOTAVAIL =\u003e EADDRNOTAVAIL,\n            libc::ENETDOWN =\u003e ENETDOWN,\n            libc::ENETUNREACH =\u003e ENETUNREACH,\n            libc::ENETRESET =\u003e ENETRESET,\n            libc::ECONNABORTED =\u003e ECONNABORTED,\n            libc::ECONNRESET =\u003e ECONNRESET,\n            libc::ENOBUFS =\u003e ENOBUFS,\n            libc::EISCONN =\u003e EISCONN,\n            libc::ENOTCONN =\u003e ENOTCONN,\n            libc::ESHUTDOWN =\u003e ESHUTDOWN,\n            libc::ETOOMANYREFS =\u003e ETOOMANYREFS,\n            libc::ETIMEDOUT =\u003e ETIMEDOUT,\n            libc::ECONNREFUSED =\u003e ECONNREFUSED,\n            libc::ELOOP =\u003e ELOOP,\n            libc::ENAMETOOLONG =\u003e ENAMETOOLONG,\n            libc::EHOSTDOWN =\u003e EHOSTDOWN,\n            libc::EHOSTUNREACH =\u003e EHOSTUNREACH,\n            libc::ENOTEMPTY =\u003e ENOTEMPTY,\n            libc::EPROCLIM =\u003e EPROCLIM,\n            libc::EUSERS =\u003e EUSERS,\n            libc::EDQUOT =\u003e EDQUOT,\n            libc::ESTALE =\u003e ESTALE,\n            libc::EREMOTE =\u003e EREMOTE,\n            libc::EBADRPC =\u003e EBADRPC,\n            libc::ERPCMISMATCH =\u003e ERPCMISMATCH,\n            libc::EPROGUNAVAIL =\u003e EPROGUNAVAIL,\n            libc::EPROGMISMATCH =\u003e EPROGMISMATCH,\n            libc::EPROCUNAVAIL =\u003e EPROCUNAVAIL,\n            libc::ENOLCK =\u003e ENOLCK,\n            libc::ENOSYS =\u003e ENOSYS,\n            libc::EFTYPE =\u003e EFTYPE,\n            libc::EAUTH =\u003e EAUTH,\n            libc::ENEEDAUTH =\u003e ENEEDAUTH,\n            libc::EIDRM =\u003e EIDRM,\n            libc::ENOMSG =\u003e ENOMSG,\n            libc::EOVERFLOW =\u003e EOVERFLOW,\n            libc::EILSEQ =\u003e EILSEQ,\n            libc::ENOTSUP =\u003e ENOTSUP,\n            libc::ECANCELED =\u003e ECANCELED,\n            libc::EBADMSG =\u003e EBADMSG,\n            libc::ENODATA =\u003e ENODATA,\n            libc::ENOSR =\u003e ENOSR,\n            libc::ENOSTR =\u003e ENOSTR,\n            libc::ETIME =\u003e ETIME,\n            libc::ENOATTR =\u003e ENOATTR,\n            libc::EMULTIHOP =\u003e EMULTIHOP,\n            libc::ENOLINK =\u003e ENOLINK,\n            libc::EPROTO =\u003e EPROTO,\n            _ =\u003e UnknownErrno,\n        }\n    }\n}\n\n#[cfg(target_os = \"redox\")]\nmod consts {\n    #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum Errno {\n        UnknownErrno = 0,\n        EPERM = libc::EPERM,\n        ENOENT = libc::ENOENT,\n        ESRCH = libc::ESRCH,\n        EINTR = libc::EINTR,\n        EIO = libc::EIO,\n        ENXIO = libc::ENXIO,\n        E2BIG = libc::E2BIG,\n        ENOEXEC = libc::ENOEXEC,\n        EBADF = libc::EBADF,\n        ECHILD = libc::ECHILD,\n        EDEADLK = libc::EDEADLK,\n        ENOMEM = libc::ENOMEM,\n        EACCES = libc::EACCES,\n        EFAULT = libc::EFAULT,\n        ENOTBLK = libc::ENOTBLK,\n        EBUSY = libc::EBUSY,\n        EEXIST = libc::EEXIST,\n        EXDEV = libc::EXDEV,\n        ENODEV = libc::ENODEV,\n        ENOTDIR = libc::ENOTDIR,\n        EISDIR = libc::EISDIR,\n        EINVAL = libc::EINVAL,\n        ENFILE = libc::ENFILE,\n        EMFILE = libc::EMFILE,\n        ENOTTY = libc::ENOTTY,\n        ETXTBSY = libc::ETXTBSY,\n        EFBIG = libc::EFBIG,\n        ENOSPC = libc::ENOSPC,\n        ESPIPE = libc::ESPIPE,\n        EROFS = libc::EROFS,\n        EMLINK = libc::EMLINK,\n        EPIPE = libc::EPIPE,\n        EDOM = libc::EDOM,\n        ERANGE = libc::ERANGE,\n        EAGAIN = libc::EAGAIN,\n        EINPROGRESS = libc::EINPROGRESS,\n        EALREADY = libc::EALREADY,\n        ENOTSOCK = libc::ENOTSOCK,\n        EDESTADDRREQ = libc::EDESTADDRREQ,\n        EMSGSIZE = libc::EMSGSIZE,\n        EPROTOTYPE = libc::EPROTOTYPE,\n        ENOPROTOOPT = libc::ENOPROTOOPT,\n        EPROTONOSUPPORT = libc::EPROTONOSUPPORT,\n        ESOCKTNOSUPPORT = libc::ESOCKTNOSUPPORT,\n        EOPNOTSUPP = libc::EOPNOTSUPP,\n        EPFNOSUPPORT = libc::EPFNOSUPPORT,\n        EAFNOSUPPORT = libc::EAFNOSUPPORT,\n        EADDRINUSE = libc::EADDRINUSE,\n        EADDRNOTAVAIL = libc::EADDRNOTAVAIL,\n        ENETDOWN = libc::ENETDOWN,\n        ENETUNREACH = libc::ENETUNREACH,\n        ENETRESET = libc::ENETRESET,\n        ECONNABORTED = libc::ECONNABORTED,\n        ECONNRESET = libc::ECONNRESET,\n        ENOBUFS = libc::ENOBUFS,\n        EISCONN = libc::EISCONN,\n        ENOTCONN = libc::ENOTCONN,\n        ESHUTDOWN = libc::ESHUTDOWN,\n        ETOOMANYREFS = libc::ETOOMANYREFS,\n        ETIMEDOUT = libc::ETIMEDOUT,\n        ECONNREFUSED = libc::ECONNREFUSED,\n        ELOOP = libc::ELOOP,\n        ENAMETOOLONG = libc::ENAMETOOLONG,\n        EHOSTDOWN = libc::EHOSTDOWN,\n        EHOSTUNREACH = libc::EHOSTUNREACH,\n        ENOTEMPTY = libc::ENOTEMPTY,\n        EUSERS = libc::EUSERS,\n        EDQUOT = libc::EDQUOT,\n        ESTALE = libc::ESTALE,\n        EREMOTE = libc::EREMOTE,\n        ENOLCK = libc::ENOLCK,\n        ENOSYS = libc::ENOSYS,\n        EIDRM = libc::EIDRM,\n        ENOMSG = libc::ENOMSG,\n        EOVERFLOW = libc::EOVERFLOW,\n        EILSEQ = libc::EILSEQ,\n        ECANCELED = libc::ECANCELED,\n        EBADMSG = libc::EBADMSG,\n        ENODATA = libc::ENODATA,\n        ENOSR = libc::ENOSR,\n        ENOSTR = libc::ENOSTR,\n        ETIME = libc::ETIME,\n        EMULTIHOP = libc::EMULTIHOP,\n        ENOLINK = libc::ENOLINK,\n        EPROTO = libc::EPROTO,\n    }\n\n    impl Errno {\n        pub const EWOULDBLOCK: Errno = Errno::EAGAIN;\n    }\n\n    #[deprecated(\n        since = \"0.28.0\",\n        note = \"please use `Errno::from_raw()` instead\"\n    )]\n    pub const fn from_i32(e: i32) -\u003e Errno {\n        use self::Errno::*;\n\n        match e {\n            libc::EPERM =\u003e EPERM,\n            libc::ENOENT =\u003e ENOENT,\n            libc::ESRCH =\u003e ESRCH,\n            libc::EINTR =\u003e EINTR,\n            libc::EIO =\u003e EIO,\n            libc::ENXIO =\u003e ENXIO,\n            libc::E2BIG =\u003e E2BIG,\n            libc::ENOEXEC =\u003e ENOEXEC,\n            libc::EBADF =\u003e EBADF,\n            libc::ECHILD =\u003e ECHILD,\n            libc::EDEADLK =\u003e EDEADLK,\n            libc::ENOMEM =\u003e ENOMEM,\n            libc::EACCES =\u003e EACCES,\n            libc::EFAULT =\u003e EFAULT,\n            libc::ENOTBLK =\u003e ENOTBLK,\n            libc::EBUSY =\u003e EBUSY,\n            libc::EEXIST =\u003e EEXIST,\n            libc::EXDEV =\u003e EXDEV,\n            libc::ENODEV =\u003e ENODEV,\n            libc::ENOTDIR =\u003e ENOTDIR,\n            libc::EISDIR =\u003e EISDIR,\n            libc::EINVAL =\u003e EINVAL,\n            libc::ENFILE =\u003e ENFILE,\n            libc::EMFILE =\u003e EMFILE,\n            libc::ENOTTY =\u003e ENOTTY,\n            libc::ETXTBSY =\u003e ETXTBSY,\n            libc::EFBIG =\u003e EFBIG,\n            libc::ENOSPC =\u003e ENOSPC,\n            libc::ESPIPE =\u003e ESPIPE,\n            libc::EROFS =\u003e EROFS,\n            libc::EMLINK =\u003e EMLINK,\n            libc::EPIPE =\u003e EPIPE,\n            libc::EDOM =\u003e EDOM,\n            libc::ERANGE =\u003e ERANGE,\n            libc::EAGAIN =\u003e EAGAIN,\n            libc::EINPROGRESS =\u003e EINPROGRESS,\n            libc::EALREADY =\u003e EALREADY,\n            libc::ENOTSOCK =\u003e ENOTSOCK,\n            libc::EDESTADDRREQ =\u003e EDESTADDRREQ,\n            libc::EMSGSIZE =\u003e EMSGSIZE,\n            libc::EPROTOTYPE =\u003e EPROTOTYPE,\n            libc::ENOPROTOOPT =\u003e ENOPROTOOPT,\n            libc::EPROTONOSUPPORT =\u003e EPROTONOSUPPORT,\n            libc::ESOCKTNOSUPPORT =\u003e ESOCKTNOSUPPORT,\n            libc::EOPNOTSUPP =\u003e EOPNOTSUPP,\n            libc::EPFNOSUPPORT =\u003e EPFNOSUPPORT,\n            libc::EAFNOSUPPORT =\u003e EAFNOSUPPORT,\n            libc::EADDRINUSE =\u003e EADDRINUSE,\n            libc::EADDRNOTAVAIL =\u003e EADDRNOTAVAIL,\n            libc::ENETDOWN =\u003e ENETDOWN,\n            libc::ENETUNREACH =\u003e ENETUNREACH,\n            libc::ENETRESET =\u003e ENETRESET,\n            libc::ECONNABORTED =\u003e ECONNABORTED,\n            libc::ECONNRESET =\u003e ECONNRESET,\n            libc::ENOBUFS =\u003e ENOBUFS,\n            libc::EISCONN =\u003e EISCONN,\n            libc::ENOTCONN =\u003e ENOTCONN,\n            libc::ESHUTDOWN =\u003e ESHUTDOWN,\n            libc::ETOOMANYREFS =\u003e ETOOMANYREFS,\n            libc::ETIMEDOUT =\u003e ETIMEDOUT,\n            libc::ECONNREFUSED =\u003e ECONNREFUSED,\n            libc::ELOOP =\u003e ELOOP,\n            libc::ENAMETOOLONG =\u003e ENAMETOOLONG,\n            libc::EHOSTDOWN =\u003e EHOSTDOWN,\n            libc::EHOSTUNREACH =\u003e EHOSTUNREACH,\n            libc::ENOTEMPTY =\u003e ENOTEMPTY,\n            libc::EUSERS =\u003e EUSERS,\n            libc::EDQUOT =\u003e EDQUOT,\n            libc::ESTALE =\u003e ESTALE,\n            libc::EREMOTE =\u003e EREMOTE,\n            libc::ENOLCK =\u003e ENOLCK,\n            libc::ENOSYS =\u003e ENOSYS,\n            libc::EIDRM =\u003e EIDRM,\n            libc::ENOMSG =\u003e ENOMSG,\n            libc::EOVERFLOW =\u003e EOVERFLOW,\n            libc::EILSEQ =\u003e EILSEQ,\n            libc::ECANCELED =\u003e ECANCELED,\n            libc::EBADMSG =\u003e EBADMSG,\n            libc::ENODATA =\u003e ENODATA,\n            libc::ENOSR =\u003e ENOSR,\n            libc::ENOSTR =\u003e ENOSTR,\n            libc::ETIME =\u003e ETIME,\n            libc::EMULTIHOP =\u003e EMULTIHOP,\n            libc::ENOLINK =\u003e ENOLINK,\n            libc::EPROTO =\u003e EPROTO,\n            _ =\u003e UnknownErrno,\n        }\n    }\n}\n\n#[cfg(solarish)]\nmod consts {\n    #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum Errno {\n        UnknownErrno = 0,\n        EPERM = libc::EPERM,\n        ENOENT = libc::ENOENT,\n        ESRCH = libc::ESRCH,\n        EINTR = libc::EINTR,\n        EIO = libc::EIO,\n        ENXIO = libc::ENXIO,\n        E2BIG = libc::E2BIG,\n        ENOEXEC = libc::ENOEXEC,\n        EBADF = libc::EBADF,\n        ECHILD = libc::ECHILD,\n        EAGAIN = libc::EAGAIN,\n        ENOMEM = libc::ENOMEM,\n        EACCES = libc::EACCES,\n        EFAULT = libc::EFAULT,\n        ENOTBLK = libc::ENOTBLK,\n        EBUSY = libc::EBUSY,\n        EEXIST = libc::EEXIST,\n        EXDEV = libc::EXDEV,\n        ENODEV = libc::ENODEV,\n        ENOTDIR = libc::ENOTDIR,\n        EISDIR = libc::EISDIR,\n        EINVAL = libc::EINVAL,\n        ENFILE = libc::ENFILE,\n        EMFILE = libc::EMFILE,\n        ENOTTY = libc::ENOTTY,\n        ETXTBSY = libc::ETXTBSY,\n        EFBIG = libc::EFBIG,\n        ENOSPC = libc::ENOSPC,\n        ESPIPE = libc::ESPIPE,\n        EROFS = libc::EROFS,\n        EMLINK = libc::EMLINK,\n        EPIPE = libc::EPIPE,\n        EDOM = libc::EDOM,\n        ERANGE = libc::ERANGE,\n        ENOMSG = libc::ENOMSG,\n        EIDRM = libc::EIDRM,\n        ECHRNG = libc::ECHRNG,\n        EL2NSYNC = libc::EL2NSYNC,\n        EL3HLT = libc::EL3HLT,\n        EL3RST = libc::EL3RST,\n        ELNRNG = libc::ELNRNG,\n        EUNATCH = libc::EUNATCH,\n        ENOCSI = libc::ENOCSI,\n        EL2HLT = libc::EL2HLT,\n        EDEADLK = libc::EDEADLK,\n        ENOLCK = libc::ENOLCK,\n        ECANCELED = libc::ECANCELED,\n        ENOTSUP = libc::ENOTSUP,\n        EDQUOT = libc::EDQUOT,\n        EBADE = libc::EBADE,\n        EBADR = libc::EBADR,\n        EXFULL = libc::EXFULL,\n        ENOANO = libc::ENOANO,\n        EBADRQC = libc::EBADRQC,\n        EBADSLT = libc::EBADSLT,\n        EDEADLOCK = libc::EDEADLOCK,\n        EBFONT = libc::EBFONT,\n        EOWNERDEAD = libc::EOWNERDEAD,\n        ENOTRECOVERABLE = libc::ENOTRECOVERABLE,\n        ENOSTR = libc::ENOSTR,\n        ENODATA = libc::ENODATA,\n        ETIME = libc::ETIME,\n        ENOSR = libc::ENOSR,\n        ENONET = libc::ENONET,\n        ENOPKG = libc::ENOPKG,\n        EREMOTE = libc::EREMOTE,\n        ENOLINK = libc::ENOLINK,\n        EADV = libc::EADV,\n        ESRMNT = libc::ESRMNT,\n        ECOMM = libc::ECOMM,\n        EPROTO = libc::EPROTO,\n        ELOCKUNMAPPED = libc::ELOCKUNMAPPED,\n        ENOTACTIVE = libc::ENOTACTIVE,\n        EMULTIHOP = libc::EMULTIHOP,\n        EBADMSG = libc::EBADMSG,\n        ENAMETOOLONG = libc::ENAMETOOLONG,\n        EOVERFLOW = libc::EOVERFLOW,\n        ENOTUNIQ = libc::ENOTUNIQ,\n        EBADFD = libc::EBADFD,\n        EREMCHG = libc::EREMCHG,\n        ELIBACC = libc::ELIBACC,\n        ELIBBAD = libc::ELIBBAD,\n        ELIBSCN = libc::ELIBSCN,\n        ELIBMAX = libc::ELIBMAX,\n        ELIBEXEC = libc::ELIBEXEC,\n        EILSEQ = libc::EILSEQ,\n        ENOSYS = libc::ENOSYS,\n        ELOOP = libc::ELOOP,\n        ERESTART = libc::ERESTART,\n        ESTRPIPE = libc::ESTRPIPE,\n        ENOTEMPTY = libc::ENOTEMPTY,\n        EUSERS = libc::EUSERS,\n        ENOTSOCK = libc::ENOTSOCK,\n        EDESTADDRREQ = libc::EDESTADDRREQ,\n        EMSGSIZE = libc::EMSGSIZE,\n        EPROTOTYPE = libc::EPROTOTYPE,\n        ENOPROTOOPT = libc::ENOPROTOOPT,\n        EPROTONOSUPPORT = libc::EPROTONOSUPPORT,\n        ESOCKTNOSUPPORT = libc::ESOCKTNOSUPPORT,\n        EOPNOTSUPP = libc::EOPNOTSUPP,\n        EPFNOSUPPORT = libc::EPFNOSUPPORT,\n        EAFNOSUPPORT = libc::EAFNOSUPPORT,\n        EADDRINUSE = libc::EADDRINUSE,\n        EADDRNOTAVAIL = libc::EADDRNOTAVAIL,\n        ENETDOWN = libc::ENETDOWN,\n        ENETUNREACH = libc::ENETUNREACH,\n        ENETRESET = libc::ENETRESET,\n        ECONNABORTED = libc::ECONNABORTED,\n        ECONNRESET = libc::ECONNRESET,\n        ENOBUFS = libc::ENOBUFS,\n        EISCONN = libc::EISCONN,\n        ENOTCONN = libc::ENOTCONN,\n        ESHUTDOWN = libc::ESHUTDOWN,\n        ETOOMANYREFS = libc::ETOOMANYREFS,\n        ETIMEDOUT = libc::ETIMEDOUT,\n        ECONNREFUSED = libc::ECONNREFUSED,\n        EHOSTDOWN = libc::EHOSTDOWN,\n        EHOSTUNREACH = libc::EHOSTUNREACH,\n        EALREADY = libc::EALREADY,\n        EINPROGRESS = libc::EINPROGRESS,\n        ESTALE = libc::ESTALE,\n    }\n\n    impl Errno {\n        pub const ELAST: Errno = Errno::ESTALE;\n        pub const EWOULDBLOCK: Errno = Errno::EAGAIN;\n    }\n\n    #[deprecated(\n        since = \"0.28.0\",\n        note = \"please use `Errno::from_raw()` instead\"\n    )]\n    pub const fn from_i32(e: i32) -\u003e Errno {\n        use self::Errno::*;\n\n        match e {\n            libc::EPERM =\u003e EPERM,\n            libc::ENOENT =\u003e ENOENT,\n            libc::ESRCH =\u003e ESRCH,\n            libc::EINTR =\u003e EINTR,\n            libc::EIO =\u003e EIO,\n            libc::ENXIO =\u003e ENXIO,\n            libc::E2BIG =\u003e E2BIG,\n            libc::ENOEXEC =\u003e ENOEXEC,\n            libc::EBADF =\u003e EBADF,\n            libc::ECHILD =\u003e ECHILD,\n            libc::EAGAIN =\u003e EAGAIN,\n            libc::ENOMEM =\u003e ENOMEM,\n            libc::EACCES =\u003e EACCES,\n            libc::EFAULT =\u003e EFAULT,\n            libc::ENOTBLK =\u003e ENOTBLK,\n            libc::EBUSY =\u003e EBUSY,\n            libc::EEXIST =\u003e EEXIST,\n            libc::EXDEV =\u003e EXDEV,\n            libc::ENODEV =\u003e ENODEV,\n            libc::ENOTDIR =\u003e ENOTDIR,\n            libc::EISDIR =\u003e EISDIR,\n            libc::EINVAL =\u003e EINVAL,\n            libc::ENFILE =\u003e ENFILE,\n            libc::EMFILE =\u003e EMFILE,\n            libc::ENOTTY =\u003e ENOTTY,\n            libc::ETXTBSY =\u003e ETXTBSY,\n            libc::EFBIG =\u003e EFBIG,\n            libc::ENOSPC =\u003e ENOSPC,\n            libc::ESPIPE =\u003e ESPIPE,\n            libc::EROFS =\u003e EROFS,\n            libc::EMLINK =\u003e EMLINK,\n            libc::EPIPE =\u003e EPIPE,\n            libc::EDOM =\u003e EDOM,\n            libc::ERANGE =\u003e ERANGE,\n            libc::ENOMSG =\u003e ENOMSG,\n            libc::EIDRM =\u003e EIDRM,\n            libc::ECHRNG =\u003e ECHRNG,\n            libc::EL2NSYNC =\u003e EL2NSYNC,\n            libc::EL3HLT =\u003e EL3HLT,\n            libc::EL3RST =\u003e EL3RST,\n            libc::ELNRNG =\u003e ELNRNG,\n            libc::EUNATCH =\u003e EUNATCH,\n            libc::ENOCSI =\u003e ENOCSI,\n            libc::EL2HLT =\u003e EL2HLT,\n            libc::EDEADLK =\u003e EDEADLK,\n            libc::ENOLCK =\u003e ENOLCK,\n            libc::ECANCELED =\u003e ECANCELED,\n            libc::ENOTSUP =\u003e ENOTSUP,\n            libc::EDQUOT =\u003e EDQUOT,\n            libc::EBADE =\u003e EBADE,\n            libc::EBADR =\u003e EBADR,\n            libc::EXFULL =\u003e EXFULL,\n            libc::ENOANO =\u003e ENOANO,\n            libc::EBADRQC =\u003e EBADRQC,\n            libc::EBADSLT =\u003e EBADSLT,\n            libc::EDEADLOCK =\u003e EDEADLOCK,\n            libc::EBFONT =\u003e EBFONT,\n            libc::EOWNERDEAD =\u003e EOWNERDEAD,\n            libc::ENOTRECOVERABLE =\u003e ENOTRECOVERABLE,\n            libc::ENOSTR =\u003e ENOSTR,\n            libc::ENODATA =\u003e ENODATA,\n            libc::ETIME =\u003e ETIME,\n            libc::ENOSR =\u003e ENOSR,\n            libc::ENONET =\u003e ENONET,\n            libc::ENOPKG =\u003e ENOPKG,\n            libc::EREMOTE =\u003e EREMOTE,\n            libc::ENOLINK =\u003e ENOLINK,\n            libc::EADV =\u003e EADV,\n            libc::ESRMNT =\u003e ESRMNT,\n            libc::ECOMM =\u003e ECOMM,\n            libc::EPROTO =\u003e EPROTO,\n            libc::ELOCKUNMAPPED =\u003e ELOCKUNMAPPED,\n            libc::ENOTACTIVE =\u003e ENOTACTIVE,\n            libc::EMULTIHOP =\u003e EMULTIHOP,\n            libc::EBADMSG =\u003e EBADMSG,\n            libc::ENAMETOOLONG =\u003e ENAMETOOLONG,\n            libc::EOVERFLOW =\u003e EOVERFLOW,\n            libc::ENOTUNIQ =\u003e ENOTUNIQ,\n            libc::EBADFD =\u003e EBADFD,\n            libc::EREMCHG =\u003e EREMCHG,\n            libc::ELIBACC =\u003e ELIBACC,\n            libc::ELIBBAD =\u003e ELIBBAD,\n            libc::ELIBSCN =\u003e ELIBSCN,\n            libc::ELIBMAX =\u003e ELIBMAX,\n            libc::ELIBEXEC =\u003e ELIBEXEC,\n            libc::EILSEQ =\u003e EILSEQ,\n            libc::ENOSYS =\u003e ENOSYS,\n            libc::ELOOP =\u003e ELOOP,\n            libc::ERESTART =\u003e ERESTART,\n            libc::ESTRPIPE =\u003e ESTRPIPE,\n            libc::ENOTEMPTY =\u003e ENOTEMPTY,\n            libc::EUSERS =\u003e EUSERS,\n            libc::ENOTSOCK =\u003e ENOTSOCK,\n            libc::EDESTADDRREQ =\u003e EDESTADDRREQ,\n            libc::EMSGSIZE =\u003e EMSGSIZE,\n            libc::EPROTOTYPE =\u003e EPROTOTYPE,\n            libc::ENOPROTOOPT =\u003e ENOPROTOOPT,\n            libc::EPROTONOSUPPORT =\u003e EPROTONOSUPPORT,\n            libc::ESOCKTNOSUPPORT =\u003e ESOCKTNOSUPPORT,\n            libc::EOPNOTSUPP =\u003e EOPNOTSUPP,\n            libc::EPFNOSUPPORT =\u003e EPFNOSUPPORT,\n            libc::EAFNOSUPPORT =\u003e EAFNOSUPPORT,\n            libc::EADDRINUSE =\u003e EADDRINUSE,\n            libc::EADDRNOTAVAIL =\u003e EADDRNOTAVAIL,\n            libc::ENETDOWN =\u003e ENETDOWN,\n            libc::ENETUNREACH =\u003e ENETUNREACH,\n            libc::ENETRESET =\u003e ENETRESET,\n            libc::ECONNABORTED =\u003e ECONNABORTED,\n            libc::ECONNRESET =\u003e ECONNRESET,\n            libc::ENOBUFS =\u003e ENOBUFS,\n            libc::EISCONN =\u003e EISCONN,\n            libc::ENOTCONN =\u003e ENOTCONN,\n            libc::ESHUTDOWN =\u003e ESHUTDOWN,\n            libc::ETOOMANYREFS =\u003e ETOOMANYREFS,\n            libc::ETIMEDOUT =\u003e ETIMEDOUT,\n            libc::ECONNREFUSED =\u003e ECONNREFUSED,\n            libc::EHOSTDOWN =\u003e EHOSTDOWN,\n            libc::EHOSTUNREACH =\u003e EHOSTUNREACH,\n            libc::EALREADY =\u003e EALREADY,\n            libc::EINPROGRESS =\u003e EINPROGRESS,\n            libc::ESTALE =\u003e ESTALE,\n            _ =\u003e UnknownErrno,\n        }\n    }\n}\n\n#[cfg(target_os = \"haiku\")]\nmod consts {\n    #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum Errno {\n        UnknownErrno = 0,\n        EPERM = libc::EPERM,\n        ENOENT = libc::ENOENT,\n        ESRCH = libc::ESRCH,\n        EINTR = libc::EINTR,\n        EIO = libc::EIO,\n        ENXIO = libc::ENXIO,\n        E2BIG = libc::E2BIG,\n        ENOEXEC = libc::ENOEXEC,\n        EBADF = libc::EBADF,\n        ECHILD = libc::ECHILD,\n        EDEADLK = libc::EDEADLK,\n        ENOMEM = libc::ENOMEM,\n        EACCES = libc::EACCES,\n        EFAULT = libc::EFAULT,\n        EBUSY = libc::EBUSY,\n        EEXIST = libc::EEXIST,\n        EXDEV = libc::EXDEV,\n        ENODEV = libc::ENODEV,\n        ENOTDIR = libc::ENOTDIR,\n        EISDIR = libc::EISDIR,\n        EINVAL = libc::EINVAL,\n        ENFILE = libc::ENFILE,\n        EMFILE = libc::EMFILE,\n        ENOTTY = libc::ENOTTY,\n        ETXTBSY = libc::ETXTBSY,\n        EFBIG = libc::EFBIG,\n        ENOSPC = libc::ENOSPC,\n        ESPIPE = libc::ESPIPE,\n        EROFS = libc::EROFS,\n        EMLINK = libc::EMLINK,\n        EPIPE = libc::EPIPE,\n        EDOM = libc::EDOM,\n        ERANGE = libc::ERANGE,\n        EAGAIN = libc::EAGAIN,\n        EINPROGRESS = libc::EINPROGRESS,\n        EALREADY = libc::EALREADY,\n        ENOTSOCK = libc::ENOTSOCK,\n        EDESTADDRREQ = libc::EDESTADDRREQ,\n        EMSGSIZE = libc::EMSGSIZE,\n        EPROTOTYPE = libc::EPROTOTYPE,\n        ENOPROTOOPT = libc::ENOPROTOOPT,\n        EPROTONOSUPPORT = libc::EPROTONOSUPPORT,\n        ENOTSUP = libc::ENOTSUP,\n        EADDRINUSE = libc::EADDRINUSE,\n        EADDRNOTAVAIL = libc::EADDRNOTAVAIL,\n        ENETDOWN = libc::ENETDOWN,\n        ENETUNREACH = libc::ENETUNREACH,\n        ENETRESET = libc::ENETRESET,\n        ECONNABORTED = libc::ECONNABORTED,\n        ECONNRESET = libc::ECONNRESET,\n        ENOBUFS = libc::ENOBUFS,\n        EISCONN = libc::EISCONN,\n        ENOTCONN = libc::ENOTCONN,\n        ESHUTDOWN = libc::ESHUTDOWN,\n        ETIMEDOUT = libc::ETIMEDOUT,\n        ECONNREFUSED = libc::ECONNREFUSED,\n        ELOOP = libc::ELOOP,\n        ENAMETOOLONG = libc::ENAMETOOLONG,\n        EHOSTDOWN = libc::EHOSTDOWN,\n        EHOSTUNREACH = libc::EHOSTUNREACH,\n        ENOTEMPTY = libc::ENOTEMPTY,\n        EDQUOT = libc::EDQUOT,\n        ESTALE = libc::ESTALE,\n        ENOLCK = libc::ENOLCK,\n        ENOSYS = libc::ENOSYS,\n        EIDRM = libc::EIDRM,\n        ENOMSG = libc::ENOMSG,\n        EOVERFLOW = libc::EOVERFLOW,\n        ECANCELED = libc::ECANCELED,\n        EILSEQ = libc::EILSEQ,\n        ENOATTR = libc::ENOATTR,\n        EBADMSG = libc::EBADMSG,\n        EMULTIHOP = libc::EMULTIHOP,\n        ENOLINK = libc::ENOLINK,\n        EPROTO = libc::EPROTO,\n    }\n\n    impl Errno {\n        pub const EWOULDBLOCK: Errno = Errno::EAGAIN;\n        pub const EDEADLOCK: Errno = Errno::EDEADLK;\n        pub const EOPNOTSUPP: Errno = Errno::ENOTSUP;\n    }\n\n    #[deprecated(\n        since = \"0.28.0\",\n        note = \"please use `Errno::from_raw()` instead\"\n    )]\n    pub const fn from_i32(e: i32) -\u003e Errno {\n        use self::Errno::*;\n\n        match e {\n            libc::EPERM =\u003e EPERM,\n            libc::ENOENT =\u003e ENOENT,\n            libc::ESRCH =\u003e ESRCH,\n            libc::EINTR =\u003e EINTR,\n            libc::EIO =\u003e EIO,\n            libc::ENXIO =\u003e ENXIO,\n            libc::E2BIG =\u003e E2BIG,\n            libc::ENOEXEC =\u003e ENOEXEC,\n            libc::EBADF =\u003e EBADF,\n            libc::ECHILD =\u003e ECHILD,\n            libc::EDEADLK =\u003e EDEADLK,\n            libc::ENOMEM =\u003e ENOMEM,\n            libc::EACCES =\u003e EACCES,\n            libc::EFAULT =\u003e EFAULT,\n            libc::EBUSY =\u003e EBUSY,\n            libc::EEXIST =\u003e EEXIST,\n            libc::EXDEV =\u003e EXDEV,\n            libc::ENODEV =\u003e ENODEV,\n            libc::ENOTDIR =\u003e ENOTDIR,\n            libc::EISDIR =\u003e EISDIR,\n            libc::EINVAL =\u003e EINVAL,\n            libc::ENFILE =\u003e ENFILE,\n            libc::EMFILE =\u003e EMFILE,\n            libc::ENOTTY =\u003e ENOTTY,\n            libc::ETXTBSY =\u003e ETXTBSY,\n            libc::EFBIG =\u003e EFBIG,\n            libc::ENOSPC =\u003e ENOSPC,\n            libc::ESPIPE =\u003e ESPIPE,\n            libc::EROFS =\u003e EROFS,\n            libc::EMLINK =\u003e EMLINK,\n            libc::EPIPE =\u003e EPIPE,\n            libc::EDOM =\u003e EDOM,\n            libc::ERANGE =\u003e ERANGE,\n            libc::EAGAIN =\u003e EAGAIN,\n            libc::EINPROGRESS =\u003e EINPROGRESS,\n            libc::EALREADY =\u003e EALREADY,\n            libc::ENOTSOCK =\u003e ENOTSOCK,\n            libc::EDESTADDRREQ =\u003e EDESTADDRREQ,\n            libc::EMSGSIZE =\u003e EMSGSIZE,\n            libc::EPROTOTYPE =\u003e EPROTOTYPE,\n            libc::ENOPROTOOPT =\u003e ENOPROTOOPT,\n            libc::EPROTONOSUPPORT =\u003e EPROTONOSUPPORT,\n            libc::ENOTSUP =\u003e ENOTSUP,\n            libc::EADDRINUSE =\u003e EADDRINUSE,\n            libc::EADDRNOTAVAIL =\u003e EADDRNOTAVAIL,\n            libc::ENETDOWN =\u003e ENETDOWN,\n            libc::ENETUNREACH =\u003e ENETUNREACH,\n            libc::ENETRESET =\u003e ENETRESET,\n            libc::ECONNABORTED =\u003e ECONNABORTED,\n            libc::ECONNRESET =\u003e ECONNRESET,\n            libc::ENOBUFS =\u003e ENOBUFS,\n            libc::EISCONN =\u003e EISCONN,\n            libc::ENOTCONN =\u003e ENOTCONN,\n            libc::ESHUTDOWN =\u003e ESHUTDOWN,\n            libc::ETIMEDOUT =\u003e ETIMEDOUT,\n            libc::ECONNREFUSED =\u003e ECONNREFUSED,\n            libc::ELOOP =\u003e ELOOP,\n            libc::ENAMETOOLONG =\u003e ENAMETOOLONG,\n            libc::EHOSTDOWN =\u003e EHOSTDOWN,\n            libc::EHOSTUNREACH =\u003e EHOSTUNREACH,\n            libc::ENOTEMPTY =\u003e ENOTEMPTY,\n            libc::EDQUOT =\u003e EDQUOT,\n            libc::ESTALE =\u003e ESTALE,\n            libc::ENOLCK =\u003e ENOLCK,\n            libc::ENOSYS =\u003e ENOSYS,\n            libc::EIDRM =\u003e EIDRM,\n            libc::ENOMSG =\u003e ENOMSG,\n            libc::EOVERFLOW =\u003e EOVERFLOW,\n            libc::ECANCELED =\u003e ECANCELED,\n            libc::EILSEQ =\u003e EILSEQ,\n            libc::ENOATTR =\u003e ENOATTR,\n            libc::EBADMSG =\u003e EBADMSG,\n            libc::EMULTIHOP =\u003e EMULTIHOP,\n            libc::ENOLINK =\u003e ENOLINK,\n            libc::EPROTO =\u003e EPROTO,\n            _ =\u003e UnknownErrno,\n        }\n    }\n}\n\n#[cfg(target_os = \"aix\")]\nmod consts {\n    #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum Errno {\n        UnknownErrno = 0,\n        EPERM = libc::EPERM,\n        ENOENT = libc::ENOENT,\n        ESRCH = libc::ESRCH,\n        EINTR = libc::EINTR,\n        EIO = libc::EIO,\n        ENXIO = libc::ENXIO,\n        E2BIG = libc::E2BIG,\n        ENOEXEC = libc::ENOEXEC,\n        EBADF = libc::EBADF,\n        ECHILD = libc::ECHILD,\n        EAGAIN = libc::EAGAIN,\n        ENOMEM = libc::ENOMEM,\n        EACCES = libc::EACCES,\n        EFAULT = libc::EFAULT,\n        ENOTBLK = libc::ENOTBLK,\n        EBUSY = libc::EBUSY,\n        EEXIST = libc::EEXIST,\n        EXDEV = libc::EXDEV,\n        ENODEV = libc::ENODEV,\n        ENOTDIR = libc::ENOTDIR,\n        EISDIR = libc::EISDIR,\n        EINVAL = libc::EINVAL,\n        ENFILE = libc::ENFILE,\n        EMFILE = libc::EMFILE,\n        ENOTTY = libc::ENOTTY,\n        ETXTBSY = libc::ETXTBSY,\n        EFBIG = libc::EFBIG,\n        ENOSPC = libc::ENOSPC,\n        ESPIPE = libc::ESPIPE,\n        EROFS = libc::EROFS,\n        EMLINK = libc::EMLINK,\n        EPIPE = libc::EPIPE,\n        EDOM = libc::EDOM,\n        ERANGE = libc::ERANGE,\n        EDEADLK = libc::EDEADLK,\n        ENAMETOOLONG = libc::ENAMETOOLONG,\n        ENOLCK = libc::ENOLCK,\n        ENOSYS = libc::ENOSYS,\n        ENOTEMPTY = libc::ENOTEMPTY,\n        ELOOP = libc::ELOOP,\n        ENOMSG = libc::ENOMSG,\n        EIDRM = libc::EIDRM,\n        EINPROGRESS = libc::EINPROGRESS,\n        EALREADY = libc::EALREADY,\n        ENOTSOCK = libc::ENOTSOCK,\n        EDESTADDRREQ = libc::EDESTADDRREQ,\n        EMSGSIZE = libc::EMSGSIZE,\n        EPROTOTYPE = libc::EPROTOTYPE,\n        ENOPROTOOPT = libc::ENOPROTOOPT,\n        EPROTONOSUPPORT = libc::EPROTONOSUPPORT,\n        ESOCKTNOSUPPORT = libc::ESOCKTNOSUPPORT,\n        EPFNOSUPPORT = libc::EPFNOSUPPORT,\n        EAFNOSUPPORT = libc::EAFNOSUPPORT,\n        EADDRINUSE = libc::EADDRINUSE,\n        EADDRNOTAVAIL = libc::EADDRNOTAVAIL,\n        ENETDOWN = libc::ENETDOWN,\n        ENETUNREACH = libc::ENETUNREACH,\n        ENETRESET = libc::ENETRESET,\n        ECONNABORTED = libc::ECONNABORTED,\n        ECONNRESET = libc::ECONNRESET,\n        ENOBUFS = libc::ENOBUFS,\n        EISCONN = libc::EISCONN,\n        ENOTCONN = libc::ENOTCONN,\n        ESHUTDOWN = libc::ESHUTDOWN,\n        ETOOMANYREFS = libc::ETOOMANYREFS,\n        ETIMEDOUT = libc::ETIMEDOUT,\n        ECONNREFUSED = libc::ECONNREFUSED,\n        EHOSTDOWN = libc::EHOSTDOWN,\n        EHOSTUNREACH = libc::EHOSTUNREACH,\n        ECHRNG = libc::ECHRNG,\n        EL2NSYNC = libc::EL2NSYNC,\n        EL3HLT = libc::EL3HLT,\n        EL3RST = libc::EL3RST,\n        ELNRNG = libc::ELNRNG,\n        EUNATCH = libc::EUNATCH,\n        ENOCSI = libc::ENOCSI,\n        EL2HLT = libc::EL2HLT,\n        ENOLINK = libc::ENOLINK,\n        EPROTO = libc::EPROTO,\n        EMULTIHOP = libc::EMULTIHOP,\n        EBADMSG = libc::EBADMSG,\n        EOVERFLOW = libc::EOVERFLOW,\n        EILSEQ = libc::EILSEQ,\n        ERESTART = libc::ERESTART,\n        EOWNERDEAD = libc::EOWNERDEAD,\n        ENOTRECOVERABLE = libc::ENOTRECOVERABLE,\n        ENOTSUP = libc::ENOTSUP,\n        EPROCLIM = libc::EPROCLIM,\n        EUSERS = libc::EUSERS,\n        EDQUOT = libc::EDQUOT,\n        ESTALE = libc::ESTALE,\n        EREMOTE = libc::EREMOTE,\n        ECANCELED = libc::ECANCELED,\n        ENODATA = libc::ENODATA,\n        ENOSR = libc::ENOSR,\n        ENOSTR = libc::ENOSTR,\n        ETIME = libc::ETIME,\n        EOPNOTSUPP = libc::EOPNOTSUPP,\n    }\n\n    #[deprecated(\n        since = \"0.28.0\",\n        note = \"please use `Errno::from_raw()` instead\"\n    )]\n    pub const fn from_i32(e: i32) -\u003e Errno {\n        use self::Errno::*;\n\n        match e {\n            libc::EPERM =\u003e EPERM,\n            libc::ENOENT =\u003e ENOENT,\n            libc::ESRCH =\u003e ESRCH,\n            libc::EINTR =\u003e EINTR,\n            libc::EIO =\u003e EIO,\n            libc::ENXIO =\u003e ENXIO,\n            libc::E2BIG =\u003e E2BIG,\n            libc::ENOEXEC =\u003e ENOEXEC,\n            libc::EBADF =\u003e EBADF,\n            libc::ECHILD =\u003e ECHILD,\n            libc::EAGAIN =\u003e EAGAIN,\n            libc::ENOMEM =\u003e ENOMEM,\n            libc::EACCES =\u003e EACCES,\n            libc::EFAULT =\u003e EFAULT,\n            libc::ENOTBLK =\u003e ENOTBLK,\n            libc::EBUSY =\u003e EBUSY,\n            libc::EEXIST =\u003e EEXIST,\n            libc::EXDEV =\u003e EXDEV,\n            libc::ENODEV =\u003e ENODEV,\n            libc::ENOTDIR =\u003e ENOTDIR,\n            libc::EISDIR =\u003e EISDIR,\n            libc::EINVAL =\u003e EINVAL,\n            libc::ENFILE =\u003e ENFILE,\n            libc::EMFILE =\u003e EMFILE,\n            libc::ENOTTY =\u003e ENOTTY,\n            libc::ETXTBSY =\u003e ETXTBSY,\n            libc::EFBIG =\u003e EFBIG,\n            libc::ENOSPC =\u003e ENOSPC,\n            libc::ESPIPE =\u003e ESPIPE,\n            libc::EROFS =\u003e EROFS,\n            libc::EMLINK =\u003e EMLINK,\n            libc::EPIPE =\u003e EPIPE,\n            libc::EDOM =\u003e EDOM,\n            libc::ERANGE =\u003e ERANGE,\n            libc::EDEADLK =\u003e EDEADLK,\n            libc::ENAMETOOLONG =\u003e ENAMETOOLONG,\n            libc::ENOLCK =\u003e ENOLCK,\n            libc::ENOSYS =\u003e ENOSYS,\n            libc::ENOTEMPTY =\u003e ENOTEMPTY,\n            libc::ELOOP =\u003e ELOOP,\n            libc::ENOMSG =\u003e ENOMSG,\n            libc::EIDRM =\u003e EIDRM,\n            libc::EINPROGRESS =\u003e EINPROGRESS,\n            libc::EALREADY =\u003e EALREADY,\n            libc::ENOTSOCK =\u003e ENOTSOCK,\n            libc::EDESTADDRREQ =\u003e EDESTADDRREQ,\n            libc::EMSGSIZE =\u003e EMSGSIZE,\n            libc::EPROTOTYPE =\u003e EPROTOTYPE,\n            libc::ENOPROTOOPT =\u003e ENOPROTOOPT,\n            libc::EPROTONOSUPPORT =\u003e EPROTONOSUPPORT,\n            libc::ESOCKTNOSUPPORT =\u003e ESOCKTNOSUPPORT,\n            libc::EPFNOSUPPORT =\u003e EPFNOSUPPORT,\n            libc::EAFNOSUPPORT =\u003e EAFNOSUPPORT,\n            libc::EADDRINUSE =\u003e EADDRINUSE,\n            libc::EADDRNOTAVAIL =\u003e EADDRNOTAVAIL,\n            libc::ENETDOWN =\u003e ENETDOWN,\n            libc::ENETUNREACH =\u003e ENETUNREACH,\n            libc::ENETRESET =\u003e ENETRESET,\n            libc::ECONNABORTED =\u003e ECONNABORTED,\n            libc::ECONNRESET =\u003e ECONNRESET,\n            libc::ENOBUFS =\u003e ENOBUFS,\n            libc::EISCONN =\u003e EISCONN,\n            libc::ENOTCONN =\u003e ENOTCONN,\n            libc::ESHUTDOWN =\u003e ESHUTDOWN,\n            libc::ETOOMANYREFS =\u003e ETOOMANYREFS,\n            libc::ETIMEDOUT =\u003e ETIMEDOUT,\n            libc::ECONNREFUSED =\u003e ECONNREFUSED,\n            libc::EHOSTDOWN =\u003e EHOSTDOWN,\n            libc::EHOSTUNREACH =\u003e EHOSTUNREACH,\n            libc::ECHRNG =\u003e ECHRNG,\n            libc::EL2NSYNC =\u003e EL2NSYNC,\n            libc::EL3HLT =\u003e EL3HLT,\n            libc::EL3RST =\u003e EL3RST,\n            libc::ELNRNG =\u003e ELNRNG,\n            libc::EUNATCH =\u003e EUNATCH,\n            libc::ENOCSI =\u003e ENOCSI,\n            libc::EL2HLT =\u003e EL2HLT,\n            libc::ENOLINK =\u003e ENOLINK,\n            libc::EPROTO =\u003e EPROTO,\n            libc::EMULTIHOP =\u003e EMULTIHOP,\n            libc::EBADMSG =\u003e EBADMSG,\n            libc::EOVERFLOW =\u003e EOVERFLOW,\n            libc::EILSEQ =\u003e EILSEQ,\n            libc::ERESTART =\u003e ERESTART,\n            libc::ENOTRECOVERABLE =\u003e ENOTRECOVERABLE,\n            libc::EOWNERDEAD =\u003e EOWNERDEAD,\n            libc::ENOTSUP =\u003e ENOTSUP,\n            libc::EPROCLIM =\u003e EPROCLIM,\n            libc::EUSERS =\u003e EUSERS,\n            libc::EDQUOT =\u003e EDQUOT,\n            libc::ESTALE =\u003e ESTALE,\n            libc::EREMOTE =\u003e EREMOTE,\n            libc::ECANCELED =\u003e ECANCELED,\n            libc::ENODATA =\u003e ENODATA,\n            libc::ENOSR =\u003e ENOSR,\n            libc::ENOSTR =\u003e ENOSTR,\n            libc::ETIME =\u003e ETIME,\n            libc::EOPNOTSUPP =\u003e EOPNOTSUPP,\n            _ =\u003e UnknownErrno,\n        }\n    }\n}\n\n#[cfg(target_os = \"hurd\")]\nmod consts {\n    #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum Errno {\n        UnknownErrno = 0,\n        EPERM = libc::EPERM,\n        ENOENT = libc::ENOENT,\n        ESRCH = libc::ESRCH,\n        EINTR = libc::EINTR,\n        EIO = libc::EIO,\n        ENXIO = libc::ENXIO,\n        E2BIG = libc::E2BIG,\n        ENOEXEC = libc::ENOEXEC,\n        EBADF = libc::EBADF,\n        ECHILD = libc::ECHILD,\n        EDEADLK = libc::EDEADLK,\n        ENOMEM = libc::ENOMEM,\n        EACCES = libc::EACCES,\n        EFAULT = libc::EFAULT,\n        ENOTBLK = libc::ENOTBLK,\n        EBUSY = libc::EBUSY,\n        EEXIST = libc::EEXIST,\n        EXDEV = libc::EXDEV,\n        ENODEV = libc::ENODEV,\n        ENOTDIR = libc::ENOTDIR,\n        EISDIR = libc::EISDIR,\n        EINVAL = libc::EINVAL,\n        EMFILE = libc::EMFILE,\n        ENFILE = libc::ENFILE,\n        ENOTTY = libc::ENOTTY,\n        ETXTBSY = libc::ETXTBSY,\n        EFBIG = libc::EFBIG,\n        ENOSPC = libc::ENOSPC,\n        ESPIPE = libc::ESPIPE,\n        EROFS = libc::EROFS,\n        EMLINK = libc::EMLINK,\n        EPIPE = libc::EPIPE,\n        EDOM = libc::EDOM,\n        ERANGE = libc::ERANGE,\n        EAGAIN = libc::EAGAIN,\n        EINPROGRESS = libc::EINPROGRESS,\n        EALREADY = libc::EALREADY,\n        ENOTSOCK = libc::ENOTSOCK,\n        EMSGSIZE = libc::EMSGSIZE,\n        EPROTOTYPE = libc::EPROTOTYPE,\n        ENOPROTOOPT = libc::ENOPROTOOPT,\n        EPROTONOSUPPORT = libc::EPROTONOSUPPORT,\n        ESOCKTNOSUPPORT = libc::ESOCKTNOSUPPORT,\n        EOPNOTSUPP = libc::EOPNOTSUPP,\n        EPFNOSUPPORT = libc::EPFNOSUPPORT,\n        EAFNOSUPPORT = libc::EAFNOSUPPORT,\n        EADDRINUSE = libc::EADDRINUSE,\n        EADDRNOTAVAIL = libc::EADDRNOTAVAIL,\n        ENETDOWN = libc::ENETDOWN,\n        ENETUNREACH = libc::ENETUNREACH,\n        ENETRESET = libc::ENETRESET,\n        ECONNABORTED = libc::ECONNABORTED,\n        ECONNRESET = libc::ECONNRESET,\n        ENOBUFS = libc::ENOBUFS,\n        EISCONN = libc::EISCONN,\n        ENOTCONN = libc::ENOTCONN,\n        EDESTADDRREQ = libc::EDESTADDRREQ,\n        ESHUTDOWN = libc::ESHUTDOWN,\n        ETOOMANYREFS = libc::ETOOMANYREFS,\n        ETIMEDOUT = libc::ETIMEDOUT,\n        ECONNREFUSED = libc::ECONNREFUSED,\n        ELOOP = libc::ELOOP,\n        ENAMETOOLONG = libc::ENAMETOOLONG,\n        EHOSTDOWN = libc::EHOSTDOWN,\n        EHOSTUNREACH = libc::EHOSTUNREACH,\n        ENOTEMPTY = libc::ENOTEMPTY,\n        EPROCLIM = libc::EPROCLIM,\n        EUSERS = libc::EUSERS,\n        EDQUOT = libc::EDQUOT,\n        ESTALE = libc::ESTALE,\n        EREMOTE = libc::EREMOTE,\n        EBADRPC = libc::EBADRPC,\n        ERPCMISMATCH = libc::ERPCMISMATCH,\n        EPROGUNAVAIL = libc::EPROGUNAVAIL,\n        EPROGMISMATCH = libc::EPROGMISMATCH,\n        EPROCUNAVAIL = libc::EPROCUNAVAIL,\n        ENOLCK = libc::ENOLCK,\n        EFTYPE = libc::EFTYPE,\n        EAUTH = libc::EAUTH,\n        ENEEDAUTH = libc::ENEEDAUTH,\n        ENOSYS = libc::ENOSYS,\n        ELIBEXEC = libc::ELIBEXEC,\n        ENOTSUP = libc::ENOTSUP,\n        EILSEQ = libc::EILSEQ,\n        EBACKGROUND = libc::EBACKGROUND,\n        EDIED = libc::EDIED,\n        EGREGIOUS = libc::EGREGIOUS,\n        EIEIO = libc::EIEIO,\n        EGRATUITOUS = libc::EGRATUITOUS,\n        EBADMSG = libc::EBADMSG,\n        EIDRM = libc::EIDRM,\n        EMULTIHOP = libc::EMULTIHOP,\n        ENODATA = libc::ENODATA,\n        ENOLINK = libc::ENOLINK,\n        ENOMSG = libc::ENOMSG,\n        ENOSR = libc::ENOSR,\n        ENOSTR = libc::ENOSTR,\n        EOVERFLOW = libc::EOVERFLOW,\n        EPROTO = libc::EPROTO,\n        ETIME = libc::ETIME,\n        ECANCELED = libc::ECANCELED,\n        EOWNERDEAD = libc::EOWNERDEAD,\n        ENOTRECOVERABLE = libc::ENOTRECOVERABLE,\n    }\n\n    impl Errno {\n        pub const EWOULDBLOCK: Errno = Errno::EAGAIN;\n    }\n\n    #[deprecated(\n        since = \"0.28.0\",\n        note = \"please use `Errno::from_raw()` instead\"\n    )]\n    pub const fn from_i32(e: i32) -\u003e Errno {\n        use self::Errno::*;\n\n        match e {\n            libc::EPERM =\u003e EPERM,\n            libc::ENOENT =\u003e ENOENT,\n            libc::ESRCH =\u003e ESRCH,\n            libc::EINTR =\u003e EINTR,\n            libc::EIO =\u003e EIO,\n            libc::ENXIO =\u003e ENXIO,\n            libc::E2BIG =\u003e E2BIG,\n            libc::ENOEXEC =\u003e ENOEXEC,\n            libc::EBADF =\u003e EBADF,\n            libc::ECHILD =\u003e ECHILD,\n            libc::EDEADLK =\u003e EDEADLK,\n            libc::ENOMEM =\u003e ENOMEM,\n            libc::EACCES =\u003e EACCES,\n            libc::EFAULT =\u003e EFAULT,\n            libc::ENOTBLK =\u003e ENOTBLK,\n            libc::EBUSY =\u003e EBUSY,\n            libc::EEXIST =\u003e EEXIST,\n            libc::EXDEV =\u003e EXDEV,\n            libc::ENODEV =\u003e ENODEV,\n            libc::ENOTDIR =\u003e ENOTDIR,\n            libc::EISDIR =\u003e EISDIR,\n            libc::EINVAL =\u003e EINVAL,\n            libc::EMFILE =\u003e EMFILE,\n            libc::ENFILE =\u003e ENFILE,\n            libc::ENOTTY =\u003e ENOTTY,\n            libc::ETXTBSY =\u003e ETXTBSY,\n            libc::EFBIG =\u003e EFBIG,\n            libc::ENOSPC =\u003e ENOSPC,\n            libc::ESPIPE =\u003e ESPIPE,\n            libc::EROFS =\u003e EROFS,\n            libc::EMLINK =\u003e EMLINK,\n            libc::EPIPE =\u003e EPIPE,\n            libc::EDOM =\u003e EDOM,\n            libc::ERANGE =\u003e ERANGE,\n            libc::EAGAIN =\u003e EAGAIN,\n            libc::EINPROGRESS =\u003e EINPROGRESS,\n            libc::EALREADY =\u003e EALREADY,\n            libc::ENOTSOCK =\u003e ENOTSOCK,\n            libc::EMSGSIZE =\u003e EMSGSIZE,\n            libc::EPROTOTYPE =\u003e EPROTOTYPE,\n            libc::ENOPROTOOPT =\u003e ENOPROTOOPT,\n            libc::EPROTONOSUPPORT =\u003e EPROTONOSUPPORT,\n            libc::ESOCKTNOSUPPORT =\u003e ESOCKTNOSUPPORT,\n            libc::EOPNOTSUPP =\u003e EOPNOTSUPP,\n            libc::EPFNOSUPPORT =\u003e EPFNOSUPPORT,\n            libc::EAFNOSUPPORT =\u003e EAFNOSUPPORT,\n            libc::EADDRINUSE =\u003e EADDRINUSE,\n            libc::EADDRNOTAVAIL =\u003e EADDRNOTAVAIL,\n            libc::ENETDOWN =\u003e ENETDOWN,\n            libc::ENETUNREACH =\u003e ENETUNREACH,\n            libc::ENETRESET =\u003e ENETRESET,\n            libc::ECONNABORTED =\u003e ECONNABORTED,\n            libc::ECONNRESET =\u003e ECONNRESET,\n            libc::ENOBUFS =\u003e ENOBUFS,\n            libc::EISCONN =\u003e EISCONN,\n            libc::ENOTCONN =\u003e ENOTCONN,\n            libc::EDESTADDRREQ =\u003e EDESTADDRREQ,\n            libc::ESHUTDOWN =\u003e ESHUTDOWN,\n            libc::ETOOMANYREFS =\u003e ETOOMANYREFS,\n            libc::ETIMEDOUT =\u003e ETIMEDOUT,\n            libc::ECONNREFUSED =\u003e ECONNREFUSED,\n            libc::ELOOP =\u003e ELOOP,\n            libc::ENAMETOOLONG =\u003e ENAMETOOLONG,\n            libc::EHOSTDOWN =\u003e EHOSTDOWN,\n            libc::EHOSTUNREACH =\u003e EHOSTUNREACH,\n            libc::ENOTEMPTY =\u003e ENOTEMPTY,\n            libc::EPROCLIM =\u003e EPROCLIM,\n            libc::EUSERS =\u003e EUSERS,\n            libc::EDQUOT =\u003e EDQUOT,\n            libc::ESTALE =\u003e ESTALE,\n            libc::EREMOTE =\u003e EREMOTE,\n            libc::EBADRPC =\u003e EBADRPC,\n            libc::ERPCMISMATCH =\u003e ERPCMISMATCH,\n            libc::EPROGUNAVAIL =\u003e EPROGUNAVAIL,\n            libc::EPROGMISMATCH =\u003e EPROGMISMATCH,\n            libc::EPROCUNAVAIL =\u003e EPROCUNAVAIL,\n            libc::ENOLCK =\u003e ENOLCK,\n            libc::EFTYPE =\u003e EFTYPE,\n            libc::EAUTH =\u003e EAUTH,\n            libc::ENEEDAUTH =\u003e ENEEDAUTH,\n            libc::ENOSYS =\u003e ENOSYS,\n            libc::ELIBEXEC =\u003e ELIBEXEC,\n            libc::ENOTSUP =\u003e ENOTSUP,\n            libc::EILSEQ =\u003e EILSEQ,\n            libc::EBACKGROUND =\u003e EBACKGROUND,\n            libc::EDIED =\u003e EDIED,\n            libc::EGREGIOUS =\u003e EGREGIOUS,\n            libc::EIEIO =\u003e EIEIO,\n            libc::EGRATUITOUS =\u003e EGRATUITOUS,\n            libc::EBADMSG =\u003e EBADMSG,\n            libc::EIDRM =\u003e EIDRM,\n            libc::EMULTIHOP =\u003e EMULTIHOP,\n            libc::ENODATA =\u003e ENODATA,\n            libc::ENOLINK =\u003e ENOLINK,\n            libc::ENOMSG =\u003e ENOMSG,\n            libc::ENOSR =\u003e ENOSR,\n            libc::ENOSTR =\u003e ENOSTR,\n            libc::EOVERFLOW =\u003e EOVERFLOW,\n            libc::EPROTO =\u003e EPROTO,\n            libc::ETIME =\u003e ETIME,\n            libc::ECANCELED =\u003e ECANCELED,\n            libc::EOWNERDEAD =\u003e EOWNERDEAD,\n            libc::ENOTRECOVERABLE =\u003e ENOTRECOVERABLE,\n            _ =\u003e UnknownErrno,\n        }\n    }\n}\n\n#[cfg(target_os = \"cygwin\")]\nmod consts {\n    #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum Errno {\n        UnknownErrno = 0,\n        EPERM = libc::EPERM,\n        ENOENT = libc::ENOENT,\n        ESRCH = libc::ESRCH,\n        EINTR = libc::EINTR,\n        EIO = libc::EIO,\n        ENXIO = libc::ENXIO,\n        E2BIG = libc::E2BIG,\n        ENOEXEC = libc::ENOEXEC,\n        EBADF = libc::EBADF,\n        ECHILD = libc::ECHILD,\n        EAGAIN = libc::EAGAIN,\n        ENOMEM = libc::ENOMEM,\n        EACCES = libc::EACCES,\n        EFAULT = libc::EFAULT,\n        ENOTBLK = libc::ENOTBLK,\n        EBUSY = libc::EBUSY,\n        EEXIST = libc::EEXIST,\n        EXDEV = libc::EXDEV,\n        ENODEV = libc::ENODEV,\n        ENOTDIR = libc::ENOTDIR,\n        EISDIR = libc::EISDIR,\n        EINVAL = libc::EINVAL,\n        ENFILE = libc::ENFILE,\n        EMFILE = libc::EMFILE,\n        ENOTTY = libc::ENOTTY,\n        ETXTBSY = libc::ETXTBSY,\n        EFBIG = libc::EFBIG,\n        ENOSPC = libc::ENOSPC,\n        ESPIPE = libc::ESPIPE,\n        EROFS = libc::EROFS,\n        EMLINK = libc::EMLINK,\n        EPIPE = libc::EPIPE,\n        EDOM = libc::EDOM,\n        ERANGE = libc::ERANGE,\n        ENOMSG = libc::ENOMSG,\n        EIDRM = libc::EIDRM,\n        ECHRNG = libc::ECHRNG,\n        EL2NSYNC = libc::EL2NSYNC,\n        EL3HLT = libc::EL3HLT,\n        EL3RST = libc::EL3RST,\n        ELNRNG = libc::ELNRNG,\n        EUNATCH = libc::EUNATCH,\n        ENOCSI = libc::ENOCSI,\n        EL2HLT = libc::EL2HLT,\n        EDEADLK = libc::EDEADLK,\n        ENOLCK = libc::ENOLCK,\n        EBADE = libc::EBADE,\n        EBADR = libc::EBADR,\n        EXFULL = libc::EXFULL,\n        ENOANO = libc::ENOANO,\n        EBADRQC = libc::EBADRQC,\n        EBADSLT = libc::EBADSLT,\n        EDEADLOCK = libc::EDEADLOCK,\n        EBFONT = libc::EBFONT,\n        ENOSTR = libc::ENOSTR,\n        ENODATA = libc::ENODATA,\n        ETIME = libc::ETIME,\n        ENOSR = libc::ENOSR,\n        ENONET = libc::ENONET,\n        ENOPKG = libc::ENOPKG,\n        EREMOTE = libc::EREMOTE,\n        ENOLINK = libc::ENOLINK,\n        EADV = libc::EADV,\n        ESRMNT = libc::ESRMNT,\n        ECOMM = libc::ECOMM,\n        EPROTO = libc::EPROTO,\n        EMULTIHOP = libc::EMULTIHOP,\n        EDOTDOT = libc::EDOTDOT,\n        EBADMSG = libc::EBADMSG,\n        EFTYPE = libc::EFTYPE,\n        ENOTUNIQ = libc::ENOTUNIQ,\n        EBADFD = libc::EBADFD,\n        EREMCHG = libc::EREMCHG,\n        ELIBACC = libc::ELIBACC,\n        ELIBBAD = libc::ELIBBAD,\n        ELIBSCN = libc::ELIBSCN,\n        ELIBMAX = libc::ELIBMAX,\n        ELIBEXEC = libc::ELIBEXEC,\n        ENOSYS = libc::ENOSYS,\n        ENOTEMPTY = libc::ENOTEMPTY,\n        ENAMETOOLONG = libc::ENAMETOOLONG,\n        ELOOP = libc::ELOOP,\n        EOPNOTSUPP = libc::EOPNOTSUPP,\n        EPFNOSUPPORT = libc::EPFNOSUPPORT,\n        ECONNRESET = libc::ECONNRESET,\n        ENOBUFS = libc::ENOBUFS,\n        EAFNOSUPPORT = libc::EAFNOSUPPORT,\n        EPROTOTYPE = libc::EPROTOTYPE,\n        ENOTSOCK = libc::ENOTSOCK,\n        ENOPROTOOPT = libc::ENOPROTOOPT,\n        ESHUTDOWN = libc::ESHUTDOWN,\n        ECONNREFUSED = libc::ECONNREFUSED,\n        EADDRINUSE = libc::EADDRINUSE,\n        ECONNABORTED = libc::ECONNABORTED,\n        ENETUNREACH = libc::ENETUNREACH,\n        ENETDOWN = libc::ENETDOWN,\n        ETIMEDOUT = libc::ETIMEDOUT,\n        EHOSTDOWN = libc::EHOSTDOWN,\n        EHOSTUNREACH = libc::EHOSTUNREACH,\n        EINPROGRESS = libc::EINPROGRESS,\n        EALREADY = libc::EALREADY,\n        EDESTADDRREQ = libc::EDESTADDRREQ,\n        EMSGSIZE = libc::EMSGSIZE,\n        EPROTONOSUPPORT = libc::EPROTONOSUPPORT,\n        ESOCKTNOSUPPORT = libc::ESOCKTNOSUPPORT,\n        EADDRNOTAVAIL = libc::EADDRNOTAVAIL,\n        ENETRESET = libc::ENETRESET,\n        EISCONN = libc::EISCONN,\n        ENOTCONN = libc::ENOTCONN,\n        ETOOMANYREFS = libc::ETOOMANYREFS,\n        EPROCLIM = libc::EPROCLIM,\n        EUSERS = libc::EUSERS,\n        EDQUOT = libc::EDQUOT,\n        ESTALE = libc::ESTALE,\n        ENOTSUP = libc::ENOTSUP,\n        ENOMEDIUM = libc::ENOMEDIUM,\n        EILSEQ = libc::EILSEQ,\n        EOVERFLOW = libc::EOVERFLOW,\n        ECANCELED = libc::ECANCELED,\n        ENOTRECOVERABLE = libc::ENOTRECOVERABLE,\n        EOWNERDEAD = libc::EOWNERDEAD,\n        ESTRPIPE = libc::ESTRPIPE,\n    }\n\n    impl Errno {\n        pub const EWOULDBLOCK: Errno = Errno::EAGAIN;\n        pub const EDEADLOCK: Errno = Errno::EDEADLK;\n        pub const EOPNOTSUPP: Errno = Errno::ENOTSUP;\n    }\n\n    pub(crate) const fn from_i32(e: i32) -\u003e Errno {\n        use self::Errno::*;\n\n        match e {\n            libc::EPERM =\u003e EPERM,\n            libc::ENOENT =\u003e ENOENT,\n            libc::ESRCH =\u003e ESRCH,\n            libc::EINTR =\u003e EINTR,\n            libc::EIO =\u003e EIO,\n            libc::ENXIO =\u003e ENXIO,\n            libc::E2BIG =\u003e E2BIG,\n            libc::ENOEXEC =\u003e ENOEXEC,\n            libc::EBADF =\u003e EBADF,\n            libc::ECHILD =\u003e ECHILD,\n            libc::EAGAIN =\u003e EAGAIN,\n            libc::ENOMEM =\u003e ENOMEM,\n            libc::EACCES =\u003e EACCES,\n            libc::EFAULT =\u003e EFAULT,\n            libc::ENOTBLK =\u003e ENOTBLK,\n            libc::EBUSY =\u003e EBUSY,\n            libc::EEXIST =\u003e EEXIST,\n            libc::EXDEV =\u003e EXDEV,\n            libc::ENODEV =\u003e ENODEV,\n            libc::ENOTDIR =\u003e ENOTDIR,\n            libc::EISDIR =\u003e EISDIR,\n            libc::EINVAL =\u003e EINVAL,\n            libc::ENFILE =\u003e ENFILE,\n            libc::EMFILE =\u003e EMFILE,\n            libc::ENOTTY =\u003e ENOTTY,\n            libc::ETXTBSY =\u003e ETXTBSY,\n            libc::EFBIG =\u003e EFBIG,\n            libc::ENOSPC =\u003e ENOSPC,\n            libc::ESPIPE =\u003e ESPIPE,\n            libc::EROFS =\u003e EROFS,\n            libc::EMLINK =\u003e EMLINK,\n            libc::EPIPE =\u003e EPIPE,\n            libc::EDOM =\u003e EDOM,\n            libc::ERANGE =\u003e ERANGE,\n            libc::ENOMSG =\u003e ENOMSG,\n            libc::EIDRM =\u003e EIDRM,\n            libc::ECHRNG =\u003e ECHRNG,\n            libc::EL2NSYNC =\u003e EL2NSYNC,\n            libc::EL3HLT =\u003e EL3HLT,\n            libc::EL3RST =\u003e EL3RST,\n            libc::ELNRNG =\u003e ELNRNG,\n            libc::EUNATCH =\u003e EUNATCH,\n            libc::ENOCSI =\u003e ENOCSI,\n            libc::EL2HLT =\u003e EL2HLT,\n            libc::EDEADLK =\u003e EDEADLK,\n            libc::ENOLCK =\u003e ENOLCK,\n            libc::EBADE =\u003e EBADE,\n            libc::EBADR =\u003e EBADR,\n            libc::EXFULL =\u003e EXFULL,\n            libc::ENOANO =\u003e ENOANO,\n            libc::EBADRQC =\u003e EBADRQC,\n            libc::EBADSLT =\u003e EBADSLT,\n            libc::EDEADLOCK =\u003e EDEADLOCK,\n            libc::EBFONT =\u003e EBFONT,\n            libc::ENOSTR =\u003e ENOSTR,\n            libc::ENODATA =\u003e ENODATA,\n            libc::ETIME =\u003e ETIME,\n            libc::ENOSR =\u003e ENOSR,\n            libc::ENONET =\u003e ENONET,\n            libc::ENOPKG =\u003e ENOPKG,\n            libc::EREMOTE =\u003e EREMOTE,\n            libc::ENOLINK =\u003e ENOLINK,\n            libc::EADV =\u003e EADV,\n            libc::ESRMNT =\u003e ESRMNT,\n            libc::ECOMM =\u003e ECOMM,\n            libc::EPROTO =\u003e EPROTO,\n            libc::EMULTIHOP =\u003e EMULTIHOP,\n            libc::EDOTDOT =\u003e EDOTDOT,\n            libc::EBADMSG =\u003e EBADMSG,\n            libc::EFTYPE =\u003e EFTYPE,\n            libc::ENOTUNIQ =\u003e ENOTUNIQ,\n            libc::EBADFD =\u003e EBADFD,\n            libc::EREMCHG =\u003e EREMCHG,\n            libc::ELIBACC =\u003e ELIBACC,\n            libc::ELIBBAD =\u003e ELIBBAD,\n            libc::ELIBSCN =\u003e ELIBSCN,\n            libc::ELIBMAX =\u003e ELIBMAX,\n            libc::ELIBEXEC =\u003e ELIBEXEC,\n            libc::ENOSYS =\u003e ENOSYS,\n            libc::ENOTEMPTY =\u003e ENOTEMPTY,\n            libc::ENAMETOOLONG =\u003e ENAMETOOLONG,\n            libc::ELOOP =\u003e ELOOP,\n            libc::EOPNOTSUPP =\u003e EOPNOTSUPP,\n            libc::EPFNOSUPPORT =\u003e EPFNOSUPPORT,\n            libc::ECONNRESET =\u003e ECONNRESET,\n            libc::ENOBUFS =\u003e ENOBUFS,\n            libc::EAFNOSUPPORT =\u003e EAFNOSUPPORT,\n            libc::EPROTOTYPE =\u003e EPROTOTYPE,\n            libc::ENOTSOCK =\u003e ENOTSOCK,\n            libc::ENOPROTOOPT =\u003e ENOPROTOOPT,\n            libc::ESHUTDOWN =\u003e ESHUTDOWN,\n            libc::ECONNREFUSED =\u003e ECONNREFUSED,\n            libc::EADDRINUSE =\u003e EADDRINUSE,\n            libc::ECONNABORTED =\u003e ECONNABORTED,\n            libc::ENETUNREACH =\u003e ENETUNREACH,\n            libc::ENETDOWN =\u003e ENETDOWN,\n            libc::ETIMEDOUT =\u003e ETIMEDOUT,\n            libc::EHOSTDOWN =\u003e EHOSTDOWN,\n            libc::EHOSTUNREACH =\u003e EHOSTUNREACH,\n            libc::EINPROGRESS =\u003e EINPROGRESS,\n            libc::EALREADY =\u003e EALREADY,\n            libc::EDESTADDRREQ =\u003e EDESTADDRREQ,\n            libc::EMSGSIZE =\u003e EMSGSIZE,\n            libc::EPROTONOSUPPORT =\u003e EPROTONOSUPPORT,\n            libc::ESOCKTNOSUPPORT =\u003e ESOCKTNOSUPPORT,\n            libc::EADDRNOTAVAIL =\u003e EADDRNOTAVAIL,\n            libc::ENETRESET =\u003e ENETRESET,\n            libc::EISCONN =\u003e EISCONN,\n            libc::ENOTCONN =\u003e ENOTCONN,\n            libc::ETOOMANYREFS =\u003e ETOOMANYREFS,\n            libc::EPROCLIM =\u003e EPROCLIM,\n            libc::EUSERS =\u003e EUSERS,\n            libc::EDQUOT =\u003e EDQUOT,\n            libc::ESTALE =\u003e ESTALE,\n            libc::ENOTSUP =\u003e ENOTSUP,\n            libc::ENOMEDIUM =\u003e ENOMEDIUM,\n            libc::EILSEQ =\u003e EILSEQ,\n            libc::EOVERFLOW =\u003e EOVERFLOW,\n            libc::ECANCELED =\u003e ECANCELED,\n            libc::ENOTRECOVERABLE =\u003e ENOTRECOVERABLE,\n            libc::EOWNERDEAD =\u003e EOWNERDEAD,\n            libc::ESTRPIPE =\u003e ESTRPIPE,\n            _ =\u003e UnknownErrno,\n        }\n    }\n}\n","traces":[{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","acooks","mcr","nix-0.30.1","src","fcntl.rs"],"content":"//! File control options\nuse crate::errno::Errno;\n#[cfg(all(target_os = \"freebsd\", target_arch = \"x86_64\"))]\nuse core::slice;\nuse libc::{c_int, c_uint, size_t, ssize_t};\n#[cfg(any(\n    target_os = \"netbsd\",\n    apple_targets,\n    target_os = \"dragonfly\",\n    all(target_os = \"freebsd\", target_arch = \"x86_64\"),\n))]\nuse std::ffi::CStr;\nuse std::ffi::OsString;\n#[cfg(not(any(target_os = \"redox\", target_os = \"solaris\")))]\nuse std::ops::{Deref, DerefMut};\nuse std::os::unix::ffi::OsStringExt;\n#[cfg(not(target_os = \"redox\"))]\nuse std::os::unix::io::OwnedFd;\nuse std::os::unix::io::RawFd;\n#[cfg(any(\n    target_os = \"netbsd\",\n    apple_targets,\n    target_os = \"dragonfly\",\n    all(target_os = \"freebsd\", target_arch = \"x86_64\"),\n))]\nuse std::path::PathBuf;\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\nuse std::ptr;\n\n#[cfg(feature = \"fs\")]\nuse crate::{sys::stat::Mode, NixPath, Result};\n\n#[cfg(any(\n    linux_android,\n    target_os = \"emscripten\",\n    target_os = \"fuchsia\",\n    target_os = \"wasi\",\n    target_env = \"uclibc\",\n    target_os = \"freebsd\"\n))]\n#[cfg(feature = \"fs\")]\npub use self::posix_fadvise::{posix_fadvise, PosixFadviseAdvice};\n\n/// A file descriptor referring to the working directory of the current process\n/// **that should be ONLY passed to the `dirfd` argument of those `xxat()` functions**.\n///\n/// # Examples\n///\n/// Use it in [`openat()`]:\n///\n/// ```no_run\n/// use nix::fcntl::AT_FDCWD;\n/// use nix::fcntl::openat;\n/// use nix::fcntl::OFlag;\n/// use nix::sys::stat::Mode;\n///\n/// let fd = openat(AT_FDCWD, \"foo\", OFlag::O_RDONLY | OFlag::O_CLOEXEC, Mode::empty()).unwrap();\n/// ```\n///\n/// # WARNING\n///\n/// Do NOT pass this symbol to non-`xxat()` functions, it won't work:\n///\n/// ```should_panic\n/// use nix::errno::Errno;\n/// use nix::fcntl::AT_FDCWD;\n/// use nix::sys::stat::fstat;\n///\n/// let never = fstat(AT_FDCWD).unwrap();\n/// ```\n//\n// SAFETY:\n// 1. `AT_FDCWD` is usable for the whole process life, so it is `'static`.\n// 2. It is not a valid file descriptor, but OS will handle it for us when passed\n//    to `xxat(2)` calls.\n#[cfg(not(target_os = \"redox\"))] // Redox does not have this\npub const AT_FDCWD: std::os::fd::BorrowedFd\u003c'static\u003e =\n    unsafe { std::os::fd::BorrowedFd::borrow_raw(libc::AT_FDCWD) };\n\n#[cfg(not(target_os = \"redox\"))]\n#[cfg(any(feature = \"fs\", feature = \"process\", feature = \"user\"))]\nlibc_bitflags! {\n    /// Flags that control how the various *at syscalls behave.\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"fs\", feature = \"process\"))))]\n    pub struct AtFlags: c_int {\n        #[allow(missing_docs)]\n        #[doc(hidden)]\n        // Should not be used by the public API, but only internally.\n        AT_REMOVEDIR;\n        /// Used with [`linkat`](crate::unistd::linkat`) to create a link to a symbolic link's\n        /// target, instead of to the symbolic link itself.\n        AT_SYMLINK_FOLLOW;\n        /// Used with functions like [`fstatat`](crate::sys::stat::fstatat`) to operate on a link\n        /// itself, instead of the symbolic link's target.\n        AT_SYMLINK_NOFOLLOW;\n        /// Don't automount the terminal (\"basename\") component of pathname if it is a directory\n        /// that is an automount point.\n        #[cfg(linux_android)]\n        AT_NO_AUTOMOUNT;\n        /// If the provided path is an empty string, operate on the provided directory file\n        /// descriptor instead.\n        #[cfg(any(linux_android, target_os = \"freebsd\", target_os = \"hurd\"))]\n        AT_EMPTY_PATH;\n        /// Used with [`faccessat`](crate::unistd::faccessat), the checks for accessibility are\n        /// performed using the effective user and group IDs instead of the real user and group ID\n        #[cfg(not(target_os = \"android\"))]\n        AT_EACCESS;\n    }\n}\n\n#[cfg(any(\n    feature = \"fs\",\n    feature = \"term\",\n    all(feature = \"fanotify\", target_os = \"linux\")\n))]\nlibc_bitflags!(\n    /// Configuration options for opened files.\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"fs\", feature = \"term\", all(feature = \"fanotify\", target_os = \"linux\")))))]\n    pub struct OFlag: c_int {\n        /// Mask for the access mode of the file.\n        O_ACCMODE;\n        /// Use alternate I/O semantics.\n        #[cfg(target_os = \"netbsd\")]\n        O_ALT_IO;\n        /// Open the file in append-only mode.\n        O_APPEND;\n        /// Generate a signal when input or output becomes possible.\n        #[cfg(not(any(\n            solarish,\n            target_os = \"aix\",\n            target_os = \"haiku\",\n            target_os = \"cygwin\"\n        )))]\n        O_ASYNC;\n        /// Closes the file descriptor once an `execve` call is made.\n        ///\n        /// Also sets the file offset to the beginning of the file.\n        O_CLOEXEC;\n        /// Create the file if it does not exist.\n        O_CREAT;\n        /// Try to minimize cache effects of the I/O for this file.\n        #[cfg(any(\n            freebsdlike,\n            linux_android,\n            target_os = \"illumos\",\n            target_os = \"netbsd\"\n        ))]\n        O_DIRECT;\n        /// If the specified path isn't a directory, fail.\n        O_DIRECTORY;\n        /// Implicitly follow each `write()` with an `fdatasync()`.\n        #[cfg(any(linux_android, apple_targets, target_os = \"freebsd\", netbsdlike))]\n        O_DSYNC;\n        /// Error out if a file was not created.\n        O_EXCL;\n        /// Open for execute only.\n        #[cfg(target_os = \"freebsd\")]\n        O_EXEC;\n        /// Open with an exclusive file lock.\n        #[cfg(any(bsd, target_os = \"redox\"))]\n        O_EXLOCK;\n        /// Same as `O_SYNC`.\n        #[cfg(any(bsd,\n                  all(target_os = \"linux\", not(target_env = \"musl\"), not(target_env = \"ohos\")),\n                  target_os = \"redox\"))]\n        O_FSYNC;\n        /// Allow files whose sizes can't be represented in an `off_t` to be opened.\n        #[cfg(linux_android)]\n        O_LARGEFILE;\n        /// Do not update the file last access time during `read(2)`s.\n        #[cfg(linux_android)]\n        O_NOATIME;\n        /// Don't attach the device as the process' controlling terminal.\n        #[cfg(not(target_os = \"redox\"))]\n        O_NOCTTY;\n        /// Same as `O_NONBLOCK`.\n        #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\", target_os = \"cygwin\")))]\n        O_NDELAY;\n        /// `open()` will fail if the given path is a symbolic link.\n        O_NOFOLLOW;\n        /// When possible, open the file in nonblocking mode.\n        O_NONBLOCK;\n        /// Don't deliver `SIGPIPE`.\n        #[cfg(target_os = \"netbsd\")]\n        O_NOSIGPIPE;\n        /// Obtain a file descriptor for low-level access.\n        ///\n        /// The file itself is not opened and other file operations will fail.\n        #[cfg(any(linux_android, target_os = \"redox\", target_os = \"freebsd\", target_os = \"fuchsia\"))]\n        O_PATH;\n        /// Only allow reading.\n        ///\n        /// This should not be combined with `O_WRONLY` or `O_RDWR`.\n        O_RDONLY;\n        /// Allow both reading and writing.\n        ///\n        /// This should not be combined with `O_WRONLY` or `O_RDONLY`.\n        O_RDWR;\n        /// Similar to `O_DSYNC` but applies to `read`s instead.\n        #[cfg(any(target_os = \"linux\", netbsdlike))]\n        O_RSYNC;\n        /// Open directory for search only. Skip search permission checks on\n        /// later `openat()` calls using the obtained file descriptor.\n        #[cfg(any(\n            apple_targets,\n            solarish,\n            target_os = \"netbsd\",\n            target_os = \"freebsd\",\n            target_os = \"fuchsia\",\n            target_os = \"emscripten\",\n            target_os = \"aix\",\n            target_os = \"wasi\"\n        ))]\n        O_SEARCH;\n        /// Open with a shared file lock.\n        #[cfg(any(bsd, target_os = \"redox\"))]\n        O_SHLOCK;\n        /// Implicitly follow each `write()` with an `fsync()`.\n        #[cfg(not(target_os = \"redox\"))]\n        O_SYNC;\n        /// Create an unnamed temporary file.\n        #[cfg(linux_android)]\n        O_TMPFILE;\n        /// Truncate an existing regular file to 0 length if it allows writing.\n        O_TRUNC;\n        /// Restore default TTY attributes.\n        #[cfg(target_os = \"freebsd\")]\n        O_TTY_INIT;\n        /// Only allow writing.\n        ///\n        /// This should not be combined with `O_RDONLY` or `O_RDWR`.\n        O_WRONLY;\n    }\n);\n\nfeature! {\n#![feature = \"fs\"]\n\n/// open or create a file for reading, writing or executing\n///\n/// # See Also\n/// [`open`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html)\n// The conversion is not identical on all operating systems.\n#[allow(clippy::useless_conversion)]\npub fn open\u003cP: ?Sized + NixPath\u003e(\n    path: \u0026P,\n    oflag: OFlag,\n    mode: Mode,\n) -\u003e Result\u003cstd::os::fd::OwnedFd\u003e {\n    use std::os::fd::FromRawFd;\n\n    let fd = path.with_nix_path(|cstr| unsafe {\n        libc::open(cstr.as_ptr(), oflag.bits(), mode.bits() as c_uint)\n    })?;\n    Errno::result(fd)?;\n\n    // SAFETY:\n    //\n    // `open(2)` should return a valid owned fd on success\n    Ok( unsafe { std::os::fd::OwnedFd::from_raw_fd(fd)  } )\n}\n\n/// open or create a file for reading, writing or executing\n///\n/// The `openat` function is equivalent to the [`open`] function except in the case where the path\n/// specifies a relative path.  In that case, the file to be opened is determined relative to the\n/// directory associated with the file descriptor `dirfd`.\n///\n/// # See Also\n/// [`openat`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/openat.html)\n// The conversion is not identical on all operating systems.\n#[allow(clippy::useless_conversion)]\n#[cfg(not(target_os = \"redox\"))]\npub fn openat\u003cP: ?Sized + NixPath, Fd: std::os::fd::AsFd\u003e(\n    dirfd: Fd,\n    path: \u0026P,\n    oflag: OFlag,\n    mode: Mode,\n) -\u003e Result\u003cOwnedFd\u003e {\n    use std::os::fd::AsRawFd;\n    use std::os::fd::FromRawFd;\n\n    let fd = path.with_nix_path(|cstr| unsafe {\n        libc::openat(dirfd.as_fd().as_raw_fd(), cstr.as_ptr(), oflag.bits(), mode.bits() as c_uint)\n    })?;\n    Errno::result(fd)?;\n\n    // SAFETY:\n    //\n    // `openat(2)` should return a valid owned fd on success\n    Ok( unsafe { OwnedFd::from_raw_fd(fd)  } )\n}\n\ncfg_if::cfg_if! {\n    if #[cfg(target_os = \"linux\")] {\n        libc_bitflags! {\n            /// Path resolution flags.\n            ///\n            /// See [path resolution(7)](https://man7.org/linux/man-pages/man7/path_resolution.7.html)\n            /// for details of the resolution process.\n            pub struct ResolveFlag: libc::c_ulonglong {\n                /// Do not permit the path resolution to succeed if any component of\n                /// the resolution is not a descendant of the directory indicated by\n                /// dirfd.  This causes absolute symbolic links (and absolute values of\n                /// pathname) to be rejected.\n                RESOLVE_BENEATH;\n\n                /// Treat the directory referred to by dirfd as the root directory\n                /// while resolving pathname.\n                RESOLVE_IN_ROOT;\n\n                /// Disallow all magic-link resolution during path resolution. Magic\n                /// links are symbolic link-like objects that are most notably found\n                /// in proc(5);  examples include `/proc/[pid]/exe` and `/proc/[pid]/fd/*`.\n                ///\n                /// See symlink(7) for more details.\n                RESOLVE_NO_MAGICLINKS;\n\n                /// Disallow resolution of symbolic links during path resolution. This\n                /// option implies RESOLVE_NO_MAGICLINKS.\n                RESOLVE_NO_SYMLINKS;\n\n                /// Disallow traversal of mount points during path resolution (including\n                /// all bind mounts).\n                RESOLVE_NO_XDEV;\n            }\n        }\n\n        /// Specifies how [`openat2()`] should open a pathname.\n        ///\n        /// # Reference\n        ///\n        /// * [Linux](https://man7.org/linux/man-pages/man2/open_how.2type.html)\n        #[repr(transparent)]\n        #[derive(Clone, Copy, Debug)]\n        pub struct OpenHow(libc::open_how);\n\n        impl OpenHow {\n            /// Create a new zero-filled `open_how`.\n            pub fn new() -\u003e Self {\n                // safety: according to the man page, open_how MUST be zero-initialized\n                // on init so that unknown fields are also zeroed.\n                Self(unsafe {\n                    std::mem::MaybeUninit::zeroed().assume_init()\n                })\n            }\n\n            /// Set the open flags used to open a file, completely overwriting any\n            /// existing flags.\n            pub fn flags(mut self, flags: OFlag) -\u003e Self {\n                let flags = flags.bits() as libc::c_ulonglong;\n                self.0.flags = flags;\n                self\n            }\n\n            /// Set the file mode new files will be created with, overwriting any\n            /// existing flags.\n            pub fn mode(mut self, mode: Mode) -\u003e Self {\n                let mode = mode.bits() as libc::c_ulonglong;\n                self.0.mode = mode;\n                self\n            }\n\n            /// Set resolve flags, completely overwriting any existing flags.\n            ///\n            /// See [ResolveFlag] for more detail.\n            pub fn resolve(mut self, resolve: ResolveFlag) -\u003e Self {\n                let resolve = resolve.bits();\n                self.0.resolve = resolve;\n                self\n            }\n        }\n\n        // safety: default isn't derivable because libc::open_how must be zeroed\n        impl Default for OpenHow {\n            fn default() -\u003e Self {\n                Self::new()\n            }\n        }\n\n        /// Open or create a file for reading, writing or executing.\n        ///\n        /// `openat2` is an extension of the [`openat`] function that allows the caller\n        /// to control how path resolution happens.\n        ///\n        /// # See also\n        ///\n        /// [openat2](https://man7.org/linux/man-pages/man2/openat2.2.html)\n        pub fn openat2\u003cP: ?Sized + NixPath, Fd: std::os::fd::AsFd\u003e(\n            dirfd: Fd,\n            path: \u0026P,\n            mut how: OpenHow,\n        ) -\u003e Result\u003cOwnedFd\u003e {\n            use std::os::fd::AsRawFd;\n            use std::os::fd::FromRawFd;\n\n            let fd = path.with_nix_path(|cstr| unsafe {\n                libc::syscall(\n                    libc::SYS_openat2,\n                    dirfd.as_fd().as_raw_fd(),\n                    cstr.as_ptr(),\n                    \u0026mut how as *mut OpenHow,\n                    std::mem::size_of::\u003clibc::open_how\u003e(),\n                )\n            })? as RawFd;\n            Errno::result(fd)?;\n\n            // SAFETY:\n            //\n            // `openat2(2)` should return a valid owned fd on success\n            Ok( unsafe { OwnedFd::from_raw_fd(fd)  } )\n        }\n    }\n}\n\n/// Change the name of a file.\n///\n/// The `renameat` function is equivalent to `rename` except in the case where either `old_path`\n/// or `new_path` specifies a relative path.  In such cases, the file to be renamed (or the its new\n/// name, respectively) is located relative to `old_dirfd` or `new_dirfd`, respectively\n///\n/// # See Also\n/// [`renameat`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html)\n#[cfg(not(target_os = \"redox\"))]\npub fn renameat\u003cP1: ?Sized + NixPath, P2: ?Sized + NixPath, Fd1: std::os::fd::AsFd, Fd2: std::os::fd::AsFd\u003e(\n    old_dirfd: Fd1,\n    old_path: \u0026P1,\n    new_dirfd: Fd2,\n    new_path: \u0026P2,\n) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = old_path.with_nix_path(|old_cstr| {\n        new_path.with_nix_path(|new_cstr| unsafe {\n            libc::renameat(\n                old_dirfd.as_fd().as_raw_fd(),\n                old_cstr.as_ptr(),\n                new_dirfd.as_fd().as_raw_fd(),\n                new_cstr.as_ptr(),\n            )\n        })\n    })??;\n    Errno::result(res).map(drop)\n}\n}\n\n#[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n#[cfg(feature = \"fs\")]\nlibc_bitflags! {\n    /// Flags for use with [`renameat2`].\n    #[cfg_attr(docsrs, doc(cfg(feature = \"fs\")))]\n    pub struct RenameFlags: u32 {\n        /// Atomically exchange `old_path` and `new_path`.\n        RENAME_EXCHANGE;\n        /// Don't overwrite `new_path` of the rename.  Return an error if `new_path` already\n        /// exists.\n        RENAME_NOREPLACE;\n        /// creates a \"whiteout\" object at the source of the rename at the same time as performing\n        /// the rename.\n        ///\n        /// This operation makes sense only for overlay/union filesystem implementations.\n        RENAME_WHITEOUT;\n    }\n}\n\nfeature! {\n#![feature = \"fs\"]\n/// Like [`renameat`], but with an additional `flags` argument.\n///\n/// A `renameat2` call with an empty flags argument is equivalent to `renameat`.\n///\n/// # See Also\n/// * [`rename`](https://man7.org/linux/man-pages/man2/rename.2.html)\n#[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\npub fn renameat2\u003cP1: ?Sized + NixPath, P2: ?Sized + NixPath, Fd1: std::os::fd::AsFd, Fd2: std::os::fd::AsFd\u003e(\n    old_dirfd: Fd1,\n    old_path: \u0026P1,\n    new_dirfd: Fd2,\n    new_path: \u0026P2,\n    flags: RenameFlags,\n) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = old_path.with_nix_path(|old_cstr| {\n        new_path.with_nix_path(|new_cstr| unsafe {\n            libc::renameat2(\n                old_dirfd.as_fd().as_raw_fd(),\n                old_cstr.as_ptr(),\n                new_dirfd.as_fd().as_raw_fd(),\n                new_cstr.as_ptr(),\n                flags.bits(),\n            )\n        })\n    })??;\n    Errno::result(res).map(drop)\n}\n\nfn wrap_readlink_result(mut v: Vec\u003cu8\u003e, len: ssize_t) -\u003e Result\u003cOsString\u003e {\n    unsafe { v.set_len(len as usize) }\n    v.shrink_to_fit();\n    Ok(OsString::from_vec(v.to_vec()))\n}\n\n/// Read the symlink specified by `path` and `dirfd` and put the contents in `v`.\n/// Return the number of bytes placed in `v`.\n///\n/// This function can call `readlink(2)` or `readlinkat(2)` depending on if `dirfd`\n/// is some, if it is, then `readlinkat(2)` is called, otherwise, call `readlink(2)`.\n///\n/// # Safety\n///\n/// This function is not I/O-safe considering it employs the `RawFd` type.\nunsafe fn readlink_maybe_at\u003cP: ?Sized + NixPath\u003e(\n    dirfd: Option\u003cRawFd\u003e,\n    path: \u0026P,\n    v: \u0026mut Vec\u003cu8\u003e,\n) -\u003e Result\u003clibc::ssize_t\u003e {\n    path.with_nix_path(|cstr| unsafe {\n        match dirfd {\n            #[cfg(target_os = \"redox\")]\n            Some(_) =\u003e unreachable!(\"redox does not have readlinkat(2)\"),\n            #[cfg(not(target_os = \"redox\"))]\n            Some(dirfd) =\u003e libc::readlinkat(\n                dirfd,\n                cstr.as_ptr(),\n                v.as_mut_ptr().cast(),\n                v.capacity() as size_t,\n            ),\n            None =\u003e libc::readlink(\n                cstr.as_ptr(),\n                v.as_mut_ptr().cast(),\n                v.capacity() as size_t,\n            ),\n        }\n    })\n}\n\n/// The actual implementation of [`readlink(2)`] or [`readlinkat(2)`].\n///\n/// This function can call `readlink(2)` or `readlinkat(2)` depending on if `dirfd`\n/// is some, if it is, then `readlinkat(2)` is called, otherwise, call `readlink(2)`.\n///\n/// # Safety\n///\n/// This function is marked unsafe because it uses `RawFd`.\nunsafe fn inner_readlink\u003cP: ?Sized + NixPath\u003e(\n    dirfd: Option\u003cRawFd\u003e,\n    path: \u0026P,\n) -\u003e Result\u003cOsString\u003e {\n    #[cfg(not(target_os = \"hurd\"))]\n    const PATH_MAX: usize = libc::PATH_MAX as usize;\n    #[cfg(target_os = \"hurd\")]\n    const PATH_MAX: usize = 1024; // Hurd does not define a hard limit, so try a guess first\n    let mut v = Vec::with_capacity(PATH_MAX);\n\n    {\n        // simple case: result is strictly less than `PATH_MAX`\n\n        // SAFETY:\n        //\n        // If this call of `readlink_maybe_at()` is safe or not depends on the\n        // usage of `unsafe fn inner_readlink()`.\n        let res = unsafe { readlink_maybe_at(dirfd, path, \u0026mut v)? };\n        let len = Errno::result(res)?;\n        debug_assert!(len \u003e= 0);\n        if (len as usize) \u003c v.capacity() {\n            return wrap_readlink_result(v, res);\n        }\n    }\n\n    // Uh oh, the result is too long...\n    // Let's try to ask lstat how many bytes to allocate.\n    let mut try_size = {\n        let reported_size = match dirfd {\n            #[cfg(target_os = \"redox\")]\n            Some(_) =\u003e unreachable!(\"redox does not have readlinkat(2)\"),\n            #[cfg(any(linux_android, target_os = \"freebsd\", target_os = \"hurd\"))]\n            Some(dirfd) =\u003e {\n                // SAFETY:\n                //\n                // If this call of `borrow_raw()` is safe or not depends on the\n                // usage of `unsafe fn inner_readlink()`.\n                let dirfd = unsafe {\n                    std::os::fd::BorrowedFd::borrow_raw(dirfd)\n                };\n                let flags = if path.is_empty() {\n                    AtFlags::AT_EMPTY_PATH\n                } else {\n                    AtFlags::empty()\n                };\n                super::sys::stat::fstatat(\n                    dirfd,\n                    path,\n                    flags | AtFlags::AT_SYMLINK_NOFOLLOW,\n                )\n            }\n            #[cfg(not(any(\n                linux_android,\n                target_os = \"redox\",\n                target_os = \"freebsd\",\n                target_os = \"hurd\"\n            )))]\n            Some(dirfd) =\u003e {\n                // SAFETY:\n                //\n                // If this call of `borrow_raw()` is safe or not depends on the\n                // usage of `unsafe fn inner_readlink()`.\n                let dirfd = unsafe {\n                    std::os::fd::BorrowedFd::borrow_raw(dirfd)\n                };\n                super::sys::stat::fstatat(dirfd, path, AtFlags::AT_SYMLINK_NOFOLLOW)\n            },\n            None =\u003e super::sys::stat::lstat(path),\n        }\n        .map(|x| x.st_size)\n        .unwrap_or(0);\n\n        if reported_size \u003e 0 {\n            // Note: even if `lstat`'s apparently valid answer turns out to be\n            // wrong, we will still read the full symlink no matter what.\n            reported_size as usize + 1\n        } else {\n            // If lstat doesn't cooperate, or reports an error, be a little less\n            // precise.\n            PATH_MAX.max(128) \u003c\u003c 1\n        }\n    };\n\n    loop {\n        {\n            v.reserve_exact(try_size);\n            // SAFETY:\n            //\n            // If this call of `readlink_maybe_at()` is safe or not depends on the\n            // usage of `unsafe fn inner_readlink()`.\n            let res = unsafe { readlink_maybe_at(dirfd, path, \u0026mut v)? };\n            let len = Errno::result(res)?;\n            debug_assert!(len \u003e= 0);\n            if (len as usize) \u003c v.capacity() {\n                return wrap_readlink_result(v, res);\n            }\n        }\n\n        // Ugh! Still not big enough!\n        match try_size.checked_shl(1) {\n            Some(next_size) =\u003e try_size = next_size,\n            // It's absurd that this would happen, but handle it sanely\n            // anyway.\n            None =\u003e break Err(Errno::ENAMETOOLONG),\n        }\n    }\n}\n\n/// Read value of a symbolic link\n///\n/// # See Also\n/// * [`readlink`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/readlink.html)\npub fn readlink\u003cP: ?Sized + NixPath\u003e(path: \u0026P) -\u003e Result\u003cOsString\u003e {\n    // argument `dirfd` should be `None` since we call it from `readlink()`\n    //\n    // Do NOT call it with `Some(AT_CWD)` as in that way, we are emulating\n    // `readlink(2)` with `readlinkat(2)`, which will make us lose `readlink(2)`\n    // on Redox.\n    //\n    // SAFETY:\n    //\n    // It is definitely safe because the argument involving `RawFd` is `None`\n    unsafe { inner_readlink(None, path) }\n}\n\n/// Read value of a symbolic link.\n///\n/// Equivalent to [`readlink` ] except for the case where `path` specifies a\n/// relative path, `path` will be interpreted relative to the path specified\n/// by `dirfd`. (Use [`AT_FDCWD`] to make it relative to the working directory).\n///\n/// # See Also\n/// * [`readlink`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/readlink.html)\n#[cfg(not(target_os = \"redox\"))]\npub fn readlinkat\u003cFd: std::os::fd::AsFd,P: ?Sized + NixPath\u003e(\n    dirfd: Fd,\n    path: \u0026P,\n) -\u003e Result\u003cOsString\u003e {\n    use std::os::fd::AsRawFd;\n\n    // argument `dirfd` should be `Some` since we call it from `readlinkat()`\n    //\n    // SAFETY:\n    //\n    // The passed `RawFd` should be valid since it is borrowed from `Fd: AsFd`.\n    unsafe { inner_readlink(Some(dirfd.as_fd().as_raw_fd()), path) }\n}\n}\n\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\n#[cfg(feature = \"fs\")]\nlibc_bitflags!(\n    /// Additional flags for file sealing, which allows for limiting operations on a file.\n    #[cfg_attr(docsrs, doc(cfg(feature = \"fs\")))]\n    pub struct SealFlag: c_int {\n        /// Prevents further calls to `fcntl()` with `F_ADD_SEALS`.\n        F_SEAL_SEAL;\n        /// The file cannot be reduced in size.\n        F_SEAL_SHRINK;\n        /// The size of the file cannot be increased.\n        F_SEAL_GROW;\n        /// The file contents cannot be modified.\n        F_SEAL_WRITE;\n        /// The file contents cannot be modified, except via shared writable mappings that were\n        /// created prior to the seal being set. Since Linux 5.1.\n        #[cfg(linux_android)]\n        F_SEAL_FUTURE_WRITE;\n    }\n);\n\n#[cfg(feature = \"fs\")]\nlibc_bitflags!(\n    /// Additional configuration flags for `fcntl`'s `F_SETFD`.\n    #[cfg_attr(docsrs, doc(cfg(feature = \"fs\")))]\n    pub struct FdFlag: c_int {\n        /// The file descriptor will automatically be closed during a successful `execve(2)`.\n        FD_CLOEXEC;\n    }\n);\n\nfeature! {\n#![feature = \"fs\"]\n\n/// Commands for use with [`fcntl`].\n#[cfg(not(target_os = \"redox\"))]\n#[derive(Debug, Eq, Hash, PartialEq)]\n#[non_exhaustive]\npub enum FcntlArg\u003c'a\u003e {\n    /// Duplicate the provided file descriptor\n    F_DUPFD(RawFd),\n    /// Duplicate the provided file descriptor and set the `FD_CLOEXEC` flag on it.\n    F_DUPFD_CLOEXEC(RawFd),\n    /// Get the close-on-exec flag associated with the file descriptor\n    F_GETFD,\n    /// Set the close-on-exec flag associated with the file descriptor\n    F_SETFD(FdFlag), // FD_FLAGS\n    /// Get descriptor status flags\n    F_GETFL,\n    /// Set descriptor status flags\n    F_SETFL(OFlag), // O_NONBLOCK\n    /// Set or clear a file segment lock\n    F_SETLK(\u0026'a libc::flock),\n    /// Like [`F_SETLK`](FcntlArg::F_SETLK) except that if a shared or exclusive lock is blocked by\n    /// other locks, the process waits until the request can be satisfied.\n    F_SETLKW(\u0026'a libc::flock),\n    /// Get the first lock that blocks the lock description\n    F_GETLK(\u0026'a mut libc::flock),\n    /// Acquire or release an open file description lock\n    #[cfg(linux_android)]\n    F_OFD_SETLK(\u0026'a libc::flock),\n    /// Like [`F_OFD_SETLK`](FcntlArg::F_OFD_SETLK) except that if a conflicting lock is held on\n    /// the file, then wait for that lock to be released.\n    #[cfg(linux_android)]\n    F_OFD_SETLKW(\u0026'a libc::flock),\n    /// Determine whether it would be possible to create the given lock.  If not, return details\n    /// about one existing lock that would prevent it.\n    #[cfg(linux_android)]\n    F_OFD_GETLK(\u0026'a mut libc::flock),\n    /// Add seals to the file\n    #[cfg(any(\n        linux_android,\n        target_os = \"freebsd\"\n    ))]\n    F_ADD_SEALS(SealFlag),\n    /// Get seals associated with the file\n    #[cfg(any(\n        linux_android,\n        target_os = \"freebsd\"\n    ))]\n    F_GET_SEALS,\n    /// Asks the drive to flush all buffered data to permanent storage.\n    #[cfg(apple_targets)]\n    F_FULLFSYNC,\n    /// fsync + issue barrier to drive\n    #[cfg(apple_targets)]\n    F_BARRIERFSYNC,\n    /// Return the capacity of a pipe\n    #[cfg(linux_android)]\n    F_GETPIPE_SZ,\n    /// Change the capacity of a pipe\n    #[cfg(linux_android)]\n    F_SETPIPE_SZ(c_int),\n    /// Look up the path of an open file descriptor, if possible.\n    #[cfg(any(\n        target_os = \"netbsd\",\n        target_os = \"dragonfly\",\n        apple_targets,\n    ))]\n    F_GETPATH(\u0026'a mut PathBuf),\n    /// Look up the path of an open file descriptor, if possible.\n    #[cfg(all(target_os = \"freebsd\", target_arch = \"x86_64\"))]\n    F_KINFO(\u0026'a mut PathBuf),\n    /// Return the full path without firmlinks of the fd.\n    #[cfg(apple_targets)]\n    F_GETPATH_NOFIRMLINK(\u0026'a mut PathBuf),\n    /// Issue an advisory read async with no copy to user\n    #[cfg(apple_targets)]\n    F_RDADVISE(libc::radvisory),\n    /// Turn read ahead off/on\n    #[cfg(apple_targets)]\n    F_RDAHEAD(bool),\n    /// Pre-allocate storage with different policies on fd.\n    /// Note that we want a mutable reference for the OUT\n    /// fstore_t field fst_bytesalloc.\n    #[cfg(apple_targets)]\n    F_PREALLOCATE(\u0026'a mut libc::fstore_t),\n    #[cfg(apple_targets)]\n    /// Get disk device information. In practice,\n    /// only the file offset data is set.\n    F_LOG2PHYS(\u0026'a mut libc::off_t),\n    #[cfg(apple_targets)]\n    /// Get disk device information. In practice,\n    /// only the file offset data is set.\n    /// The difference with F_LOG2PHYS is the struct passed\n    /// is used as both IN/OUT as both its l2p_devoffset and\n    /// l2p_contigbytes can be used for more specific queries.\n    F_LOG2PHYS_EXT(\u0026'a mut libc::log2phys),\n    /// Transfer any extra space in the file past the logical EOF\n    /// (as previously allocated via F_PREALLOCATE) to another file.\n    /// The other file is specified via a file descriptor as the lone extra argument.\n    /// Both descriptors must reference regular files in the same volume.\n    #[cfg(apple_targets)]\n    F_TRANSFEREXTENTS(RawFd),\n    /// Set or clear the read ahead (pre-fetch) amount for sequential access or\n    /// disable it with 0 or to system default for any value \u003c 0.\n    /// It manages how the kernel caches file data.\n    #[cfg(target_os = \"freebsd\")]\n    F_READAHEAD(c_int),\n    // TODO: Rest of flags\n}\n\n/// Commands for use with [`fcntl`].\n#[cfg(target_os = \"redox\")]\n#[derive(Debug, Clone, Copy, Eq, Hash, PartialEq)]\n#[non_exhaustive]\npub enum FcntlArg {\n    /// Duplicate the provided file descriptor\n    F_DUPFD(RawFd),\n    /// Duplicate the provided file descriptor and set the `FD_CLOEXEC` flag on it.\n    F_DUPFD_CLOEXEC(RawFd),\n    /// Get the close-on-exec flag associated with the file descriptor\n    F_GETFD,\n    /// Set the close-on-exec flag associated with the file descriptor\n    F_SETFD(FdFlag), // FD_FLAGS\n    /// Get descriptor status flags\n    F_GETFL,\n    /// Set descriptor status flags\n    F_SETFL(OFlag), // O_NONBLOCK\n}\npub use self::FcntlArg::*;\n\n/// Perform various operations on open file descriptors.\n///\n/// # See Also\n/// * [`fcntl`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fcntl.html)\n// TODO: Figure out how to handle value fcntl returns\npub fn fcntl\u003cFd: std::os::fd::AsFd\u003e(fd: Fd, arg: FcntlArg) -\u003e Result\u003cc_int\u003e {\n    use std::os::fd::AsRawFd;\n\n    let fd = fd.as_fd().as_raw_fd();\n    let res = unsafe {\n        match arg {\n            F_DUPFD(rawfd) =\u003e libc::fcntl(fd, libc::F_DUPFD, rawfd),\n            F_DUPFD_CLOEXEC(rawfd) =\u003e {\n                libc::fcntl(fd, libc::F_DUPFD_CLOEXEC, rawfd)\n            }\n            F_GETFD =\u003e libc::fcntl(fd, libc::F_GETFD),\n            F_SETFD(flag) =\u003e libc::fcntl(fd, libc::F_SETFD, flag.bits()),\n            F_GETFL =\u003e libc::fcntl(fd, libc::F_GETFL),\n            F_SETFL(flag) =\u003e libc::fcntl(fd, libc::F_SETFL, flag.bits()),\n            #[cfg(not(target_os = \"redox\"))]\n            F_SETLK(flock) =\u003e libc::fcntl(fd, libc::F_SETLK, flock),\n            #[cfg(not(target_os = \"redox\"))]\n            F_SETLKW(flock) =\u003e libc::fcntl(fd, libc::F_SETLKW, flock),\n            #[cfg(not(target_os = \"redox\"))]\n            F_GETLK(flock) =\u003e libc::fcntl(fd, libc::F_GETLK, flock),\n            #[cfg(linux_android)]\n            F_OFD_SETLK(flock) =\u003e libc::fcntl(fd, libc::F_OFD_SETLK, flock),\n            #[cfg(linux_android)]\n            F_OFD_SETLKW(flock) =\u003e libc::fcntl(fd, libc::F_OFD_SETLKW, flock),\n            #[cfg(linux_android)]\n            F_OFD_GETLK(flock) =\u003e libc::fcntl(fd, libc::F_OFD_GETLK, flock),\n            #[cfg(any(\n                linux_android,\n                target_os = \"freebsd\"\n            ))]\n            F_ADD_SEALS(flag) =\u003e {\n                libc::fcntl(fd, libc::F_ADD_SEALS, flag.bits())\n            }\n            #[cfg(any(\n                linux_android,\n                target_os = \"freebsd\"\n            ))]\n            F_GET_SEALS =\u003e libc::fcntl(fd, libc::F_GET_SEALS),\n            #[cfg(apple_targets)]\n            F_FULLFSYNC =\u003e libc::fcntl(fd, libc::F_FULLFSYNC),\n            #[cfg(apple_targets)]\n            F_BARRIERFSYNC =\u003e libc::fcntl(fd, libc::F_BARRIERFSYNC),\n            #[cfg(linux_android)]\n            F_GETPIPE_SZ =\u003e libc::fcntl(fd, libc::F_GETPIPE_SZ),\n            #[cfg(linux_android)]\n            F_SETPIPE_SZ(size) =\u003e libc::fcntl(fd, libc::F_SETPIPE_SZ, size),\n            #[cfg(any(\n                target_os = \"dragonfly\",\n                target_os = \"netbsd\",\n                apple_targets,\n            ))]\n            F_GETPATH(path) =\u003e {\n                let mut buffer = vec![0; libc::PATH_MAX as usize];\n                let res = libc::fcntl(fd, libc::F_GETPATH, buffer.as_mut_ptr());\n                let ok_res = Errno::result(res)?;\n                let optr = CStr::from_bytes_until_nul(\u0026buffer).unwrap();\n                *path = PathBuf::from(OsString::from(optr.to_str().unwrap()));\n                return Ok(ok_res)\n            },\n            #[cfg(all(target_os = \"freebsd\", target_arch = \"x86_64\"))]\n            F_KINFO(path) =\u003e {\n                let mut info: libc::kinfo_file = std::mem::zeroed();\n                info.kf_structsize = std::mem::size_of::\u003clibc::kinfo_file\u003e() as i32;\n                let res = libc::fcntl(fd, libc::F_KINFO, \u0026mut info);\n                let ok_res = Errno::result(res)?;\n                let p = info.kf_path;\n                let u8_slice = slice::from_raw_parts(p.as_ptr().cast(), p.len());\n                let optr = CStr::from_bytes_until_nul(u8_slice).unwrap();\n                *path = PathBuf::from(OsString::from(optr.to_str().unwrap()));\n                return Ok(ok_res)\n            },\n            #[cfg(apple_targets)]\n            F_GETPATH_NOFIRMLINK(path) =\u003e {\n                let mut buffer = vec![0; libc::PATH_MAX as usize];\n                let res = libc::fcntl(fd, libc::F_GETPATH_NOFIRMLINK, buffer.as_mut_ptr());\n                let ok_res = Errno::result(res)?;\n                let optr = CStr::from_bytes_until_nul(\u0026buffer).unwrap();\n                *path = PathBuf::from(OsString::from(optr.to_str().unwrap()));\n                return Ok(ok_res)\n            },\n            #[cfg(apple_targets)]\n            F_RDADVISE(rad) =\u003e {\n                libc::fcntl(fd, libc::F_RDADVISE, \u0026rad)\n            },\n            #[cfg(apple_targets)]\n            F_LOG2PHYS(offset) =\u003e {\n                let mut info: libc::log2phys = std::mem::zeroed();\n                let res = libc::fcntl(fd, libc::F_LOG2PHYS, \u0026mut info);\n                let ok_res = Errno::result(res)?;\n                *offset = info.l2p_devoffset;\n                return Ok(ok_res)\n            }\n            #[cfg(apple_targets)]\n            F_LOG2PHYS_EXT(info) =\u003e {\n                libc::fcntl(fd, libc::F_LOG2PHYS_EXT, info)\n            }\n            #[cfg(apple_targets)]\n            F_RDAHEAD(on) =\u003e {\n                let val = if on { 1 } else { 0 };\n                libc::fcntl(fd, libc::F_RDAHEAD, val)\n            },\n            #[cfg(apple_targets)]\n            F_PREALLOCATE(st) =\u003e {\n                libc::fcntl(fd, libc::F_PREALLOCATE, st)\n            },\n            #[cfg(apple_targets)]\n            F_TRANSFEREXTENTS(rawfd) =\u003e {\n                libc::fcntl(fd, libc::F_TRANSFEREXTENTS, rawfd)\n            },\n            #[cfg(target_os = \"freebsd\")]\n            F_READAHEAD(val) =\u003e {\n                libc::fcntl(fd, libc::F_READAHEAD, val)\n            },\n        }\n    };\n\n    Errno::result(res)\n}\n\n/// Operations for use with [`Flock::lock`].\n#[cfg(not(any(target_os = \"redox\", target_os = \"solaris\")))]\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\n#[non_exhaustive]\npub enum FlockArg {\n    /// shared file lock\n    LockShared,\n    /// exclusive file lock\n    LockExclusive,\n    /// Unlock file\n    Unlock,\n    /// Shared lock.  Do not block when locking.\n    LockSharedNonblock,\n    /// Exclusive lock.  Do not block when locking.\n    LockExclusiveNonblock,\n    #[allow(missing_docs)]\n    #[deprecated(since = \"0.28.0\", note = \"Use FlockArg::Unlock instead\")]\n    UnlockNonblock,\n}\n\n#[allow(missing_docs)]\n#[cfg(not(any(target_os = \"redox\", target_os = \"solaris\")))]\n#[deprecated(since = \"0.28.0\", note = \"`fcntl::Flock` should be used instead.\")]\npub fn flock(fd: RawFd, arg: FlockArg) -\u003e Result\u003c()\u003e {\n    use self::FlockArg::*;\n\n    let res = unsafe {\n        match arg {\n            LockShared =\u003e libc::flock(fd, libc::LOCK_SH),\n            LockExclusive =\u003e libc::flock(fd, libc::LOCK_EX),\n            Unlock =\u003e libc::flock(fd, libc::LOCK_UN),\n            LockSharedNonblock =\u003e {\n                libc::flock(fd, libc::LOCK_SH | libc::LOCK_NB)\n            }\n            LockExclusiveNonblock =\u003e {\n                libc::flock(fd, libc::LOCK_EX | libc::LOCK_NB)\n            }\n            #[allow(deprecated)]\n            UnlockNonblock =\u003e libc::flock(fd, libc::LOCK_UN | libc::LOCK_NB),\n        }\n    };\n\n    Errno::result(res).map(drop)\n}\n\n/// Represents valid types for flock.\n///\n/// # Safety\n/// Types implementing this must not be `Clone`.\n#[cfg(not(any(target_os = \"redox\", target_os = \"solaris\")))]\npub unsafe trait Flockable: std::os::fd::AsRawFd {}\n\n/// Represents an owned flock, which unlocks on drop.\n///\n/// See [flock(2)](https://linux.die.net/man/2/flock) for details on locking semantics.\n#[cfg(not(any(target_os = \"redox\", target_os = \"solaris\")))]\n#[derive(Debug)]\npub struct Flock\u003cT: Flockable\u003e(T);\n\n#[cfg(not(any(target_os = \"redox\", target_os = \"solaris\")))]\nimpl\u003cT: Flockable\u003e Drop for Flock\u003cT\u003e {\n    fn drop(\u0026mut self) {\n        let res = Errno::result(unsafe { libc::flock(self.0.as_raw_fd(), libc::LOCK_UN) });\n        if res.is_err() \u0026\u0026 !std::thread::panicking() {\n            panic!(\"Failed to remove flock: {}\", res.unwrap_err());\n        }\n    }\n}\n\n#[cfg(not(any(target_os = \"redox\", target_os = \"solaris\")))]\nimpl\u003cT: Flockable\u003e Deref for Flock\u003cT\u003e {\n    type Target = T;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n#[cfg(not(any(target_os = \"redox\", target_os = \"solaris\")))]\nimpl\u003cT: Flockable\u003e DerefMut for Flock\u003cT\u003e {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.0\n    }\n}\n\n#[cfg(not(any(target_os = \"redox\", target_os = \"solaris\")))]\nimpl\u003cT: Flockable\u003e Flock\u003cT\u003e {\n    /// Obtain a/an flock.\n    ///\n    /// # Example\n    /// ```\n    /// # use std::io::Write;\n    /// # use std::fs::File;\n    /// # use nix::fcntl::{Flock, FlockArg};\n    /// # fn do_stuff(file: File) {\n    ///   let mut file = match Flock::lock(file, FlockArg::LockExclusive) {\n    ///       Ok(l) =\u003e l,\n    ///       Err(_) =\u003e return,\n    ///   };\n    ///\n    ///   // Do stuff\n    ///   let data = \"Foo bar\";\n    ///   _ = file.write(data.as_bytes());\n    ///   _ = file.sync_data();\n    /// # }\n    pub fn lock(t: T, args: FlockArg) -\u003e std::result::Result\u003cSelf, (T, Errno)\u003e {\n        let flags = match args {\n            FlockArg::LockShared =\u003e libc::LOCK_SH,\n            FlockArg::LockExclusive =\u003e libc::LOCK_EX,\n            FlockArg::LockSharedNonblock =\u003e libc::LOCK_SH | libc::LOCK_NB,\n            FlockArg::LockExclusiveNonblock =\u003e libc::LOCK_EX | libc::LOCK_NB,\n            #[allow(deprecated)]\n            FlockArg::Unlock | FlockArg::UnlockNonblock =\u003e return Err((t, Errno::EINVAL)),\n        };\n        match Errno::result(unsafe { libc::flock(t.as_raw_fd(), flags) }) {\n            Ok(_) =\u003e Ok(Self(t)),\n            Err(errno) =\u003e Err((t, errno)),\n        }\n    }\n\n    /// Remove the lock and return the object wrapped within.\n    ///\n    /// # Example\n    /// ```\n    /// # use std::fs::File;\n    /// # use nix::fcntl::{Flock, FlockArg};\n    /// fn do_stuff(file: File) -\u003e nix::Result\u003c()\u003e {\n    ///     let mut lock = match Flock::lock(file, FlockArg::LockExclusive) {\n    ///         Ok(l) =\u003e l,\n    ///         Err((_,e)) =\u003e return Err(e),\n    ///     };\n    ///\n    ///     // Do critical section\n    ///\n    ///     // Unlock\n    ///     let file = match lock.unlock() {\n    ///         Ok(f) =\u003e f,\n    ///         Err((_, e)) =\u003e return Err(e),\n    ///     };\n    ///\n    ///     // Do anything else\n    ///\n    ///     Ok(())\n    /// }\n    pub fn unlock(self) -\u003e std::result::Result\u003cT, (Self, Errno)\u003e {\n        let inner = unsafe { match Errno::result(libc::flock(self.0.as_raw_fd(), libc::LOCK_UN)) {\n            Ok(_) =\u003e std::ptr::read(\u0026self.0),\n            Err(errno) =\u003e return Err((self, errno)),\n        }};\n\n        std::mem::forget(self);\n        Ok(inner)\n    }\n\n    /// Relock the file.  This can upgrade or downgrade the lock type.\n    ///\n    /// # Example\n    /// ```\n    /// # use std::fs::File;\n    /// # use nix::fcntl::{Flock, FlockArg};\n    /// # use tempfile::tempfile;\n    /// let f: std::fs::File = tempfile().unwrap();\n    /// let locked_file = Flock::lock(f, FlockArg::LockExclusive).unwrap();\n    /// // Do stuff, then downgrade the lock\n    /// locked_file.relock(FlockArg::LockShared).unwrap();\n    /// ```\n    pub fn relock(\u0026self, arg: FlockArg) -\u003e Result\u003c()\u003e {\n         let flags = match arg {\n            FlockArg::LockShared =\u003e libc::LOCK_SH,\n            FlockArg::LockExclusive =\u003e libc::LOCK_EX,\n            FlockArg::LockSharedNonblock =\u003e libc::LOCK_SH | libc::LOCK_NB,\n            FlockArg::LockExclusiveNonblock =\u003e libc::LOCK_EX | libc::LOCK_NB,\n            #[allow(deprecated)]\n            FlockArg::Unlock | FlockArg::UnlockNonblock =\u003e return Err(Errno::EINVAL),\n        };\n        Errno::result(unsafe { libc::flock(self.as_raw_fd(), flags) }).map(drop)\n    }\n}\n\n// Safety: `File` is not [std::clone::Clone].\n#[cfg(not(any(target_os = \"redox\", target_os = \"solaris\")))]\nunsafe impl Flockable for std::fs::File {}\n\n// Safety: `OwnedFd` is not [std::clone::Clone].\n#[cfg(not(any(target_os = \"redox\", target_os = \"solaris\")))]\nunsafe impl Flockable for OwnedFd {}\n}\n\n#[cfg(linux_android)]\n#[cfg(feature = \"zerocopy\")]\nlibc_bitflags! {\n    /// Additional flags to `splice` and friends.\n    #[cfg_attr(docsrs, doc(cfg(feature = \"zerocopy\")))]\n    pub struct SpliceFFlags: c_uint {\n        /// Request that pages be moved instead of copied.\n        ///\n        /// Not applicable to `vmsplice`.\n        SPLICE_F_MOVE;\n        /// Do not block on I/O.\n        SPLICE_F_NONBLOCK;\n        /// Hint that more data will be coming in a subsequent splice.\n        ///\n        /// Not applicable to `vmsplice`.\n        SPLICE_F_MORE;\n        /// Gift the user pages to the kernel.\n        ///\n        /// Not applicable to `splice`.\n        SPLICE_F_GIFT;\n    }\n}\n\nfeature! {\n#![feature = \"zerocopy\"]\n\n/// Copy a range of data from one file to another\n///\n/// The `copy_file_range` system call performs an in-kernel copy between\n/// file descriptors `fd_in` and `fd_out` without the additional cost of\n/// transferring data from the kernel to user space and back again. There may be\n/// additional optimizations for specific file systems.  It copies up to `len`\n/// bytes of data from file descriptor `fd_in` to file descriptor `fd_out`,\n/// overwriting any data that exists within the requested range of the target\n/// file.\n///\n/// If the `off_in` and/or `off_out` arguments are used, the values\n/// will be mutated to reflect the new position within the file after\n/// copying. If they are not used, the relevant file descriptors will be seeked\n/// to the new position.\n///\n/// On successful completion the number of bytes actually copied will be\n/// returned.\n// Note: FreeBSD defines the offset argument as \"off_t\".  Linux and Android\n// define it as \"loff_t\".  But on both OSes, on all supported platforms, those\n// are 64 bits.  So Nix uses i64 to make the docs simple and consistent.\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\npub fn copy_file_range\u003cFd1: std::os::fd::AsFd, Fd2: std::os::fd::AsFd\u003e(\n    fd_in: Fd1,\n    off_in: Option\u003c\u0026mut i64\u003e,\n    fd_out: Fd2,\n    off_out: Option\u003c\u0026mut i64\u003e,\n    len: usize,\n) -\u003e Result\u003cusize\u003e {\n    use std::os::fd::AsRawFd;\n\n    let off_in = off_in\n        .map(|offset| offset as *mut i64)\n        .unwrap_or(ptr::null_mut());\n    let off_out = off_out\n        .map(|offset| offset as *mut i64)\n        .unwrap_or(ptr::null_mut());\n\n    cfg_if::cfg_if! {\n        if #[cfg(target_os = \"freebsd\")] {\n            let ret = unsafe {\n                libc::copy_file_range(\n                    fd_in.as_fd().as_raw_fd(),\n                    off_in,\n                    fd_out.as_fd().as_raw_fd(),\n                    off_out,\n                    len,\n                    0,\n                )\n            };\n        } else {\n            // May Linux distros still don't include copy_file_range in their\n            // libc implementations, so we need to make a direct syscall.\n            let ret = unsafe {\n                libc::syscall(\n                    libc::SYS_copy_file_range,\n                    fd_in.as_fd().as_raw_fd(),\n                    off_in,\n                    fd_out.as_fd().as_raw_fd(),\n                    off_out,\n                    len,\n                    0,\n                )\n            };\n        }\n    }\n    Errno::result(ret).map(|r| r as usize)\n}\n\n/// Splice data to/from a pipe\n///\n/// # See Also\n/// *[`splice`](https://man7.org/linux/man-pages/man2/splice.2.html)\n#[cfg(linux_android)]\npub fn splice\u003cFd1: std::os::fd::AsFd, Fd2: std::os::fd::AsFd\u003e(\n    fd_in: Fd1,\n    off_in: Option\u003c\u0026mut libc::loff_t\u003e,\n    fd_out: Fd2,\n    off_out: Option\u003c\u0026mut libc::loff_t\u003e,\n    len: usize,\n    flags: SpliceFFlags,\n) -\u003e Result\u003cusize\u003e {\n    use std::os::fd::AsRawFd;\n\n    let off_in = off_in\n        .map(|offset| offset as *mut libc::loff_t)\n        .unwrap_or(ptr::null_mut());\n    let off_out = off_out\n        .map(|offset| offset as *mut libc::loff_t)\n        .unwrap_or(ptr::null_mut());\n\n    let ret = unsafe {\n        libc::splice(fd_in.as_fd().as_raw_fd(), off_in, fd_out.as_fd().as_raw_fd(), off_out, len, flags.bits())\n    };\n    Errno::result(ret).map(|r| r as usize)\n}\n\n/// Duplicate pipe content\n///\n/// # See Also\n/// *[`tee`](https://man7.org/linux/man-pages/man2/tee.2.html)\n#[cfg(linux_android)]\npub fn tee\u003cFd1: std::os::fd::AsFd, Fd2: std::os::fd::AsFd\u003e(\n    fd_in: Fd1,\n    fd_out: Fd2,\n    len: usize,\n    flags: SpliceFFlags,\n) -\u003e Result\u003cusize\u003e {\n    use std::os::fd::AsRawFd;\n\n    let ret = unsafe { libc::tee(fd_in.as_fd().as_raw_fd(), fd_out.as_fd().as_raw_fd(), len, flags.bits()) };\n    Errno::result(ret).map(|r| r as usize)\n}\n\n/// Splice user pages to/from a pipe\n///\n/// # See Also\n/// *[`vmsplice`](https://man7.org/linux/man-pages/man2/vmsplice.2.html)\n#[cfg(linux_android)]\npub fn vmsplice\u003cF: std::os::fd::AsFd\u003e(\n    fd: F,\n    iov: \u0026[std::io::IoSlice\u003c'_\u003e],\n    flags: SpliceFFlags,\n) -\u003e Result\u003cusize\u003e {\n    use std::os::fd::AsRawFd;\n\n    let ret = unsafe {\n        libc::vmsplice(\n            fd.as_fd().as_raw_fd(),\n            iov.as_ptr().cast(),\n            iov.len(),\n            flags.bits(),\n        )\n    };\n    Errno::result(ret).map(|r| r as usize)\n}\n}\n\n#[cfg(target_os = \"linux\")]\n#[cfg(feature = \"fs\")]\nlibc_bitflags!(\n    /// Mode argument flags for fallocate determining operation performed on a given range.\n    #[cfg_attr(docsrs, doc(cfg(feature = \"fs\")))]\n    pub struct FallocateFlags: c_int {\n        /// File size is not changed.\n        ///\n        /// offset + len can be greater than file size.\n        FALLOC_FL_KEEP_SIZE;\n        /// Deallocates space by creating a hole.\n        ///\n        /// Must be ORed with FALLOC_FL_KEEP_SIZE. Byte range starts at offset and continues for len bytes.\n        FALLOC_FL_PUNCH_HOLE;\n        /// Removes byte range from a file without leaving a hole.\n        ///\n        /// Byte range to collapse starts at offset and continues for len bytes.\n        FALLOC_FL_COLLAPSE_RANGE;\n        /// Zeroes space in specified byte range.\n        ///\n        /// Byte range starts at offset and continues for len bytes.\n        FALLOC_FL_ZERO_RANGE;\n        /// Increases file space by inserting a hole within the file size.\n        ///\n        /// Does not overwrite existing data. Hole starts at offset and continues for len bytes.\n        FALLOC_FL_INSERT_RANGE;\n        /// Shared file data extants are made private to the file.\n        ///\n        /// Guarantees that a subsequent write will not fail due to lack of space.\n        FALLOC_FL_UNSHARE_RANGE;\n    }\n);\n\nfeature! {\n#![feature = \"fs\"]\n\n/// Manipulates file space.\n///\n/// Allows the caller to directly manipulate the allocated disk space for the\n/// file referred to by fd.\n#[cfg(target_os = \"linux\")]\n#[cfg(feature = \"fs\")]\npub fn fallocate\u003cFd: std::os::fd::AsFd\u003e(\n    fd: Fd,\n    mode: FallocateFlags,\n    offset: libc::off_t,\n    len: libc::off_t,\n) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = unsafe { libc::fallocate(fd.as_fd().as_raw_fd(), mode.bits(), offset, len) };\n    Errno::result(res).map(drop)\n}\n\n/// Argument to [`fspacectl`] describing the range to zero.  The first member is\n/// the file offset, and the second is the length of the region.\n#[cfg(any(target_os = \"freebsd\"))]\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub struct SpacectlRange(pub libc::off_t, pub libc::off_t);\n\n#[cfg(any(target_os = \"freebsd\"))]\nimpl SpacectlRange {\n    /// Is the range empty?\n    ///\n    /// After a successful call to [`fspacectl`], A value of `true` for `SpacectlRange::is_empty`\n    /// indicates that the operation is complete.\n    #[inline]\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.1 == 0\n    }\n\n    /// Remaining length of the range\n    #[inline]\n    pub fn len(\u0026self) -\u003e libc::off_t {\n        self.1\n    }\n\n    /// Next file offset to operate on\n    #[inline]\n    pub fn offset(\u0026self) -\u003e libc::off_t {\n        self.0\n    }\n}\n\n/// Punch holes in a file.\n///\n/// `fspacectl` instructs the file system to deallocate a portion of a file.\n/// After a successful operation, this region of the file will return all zeroes\n/// if read.  If the file system supports deallocation, then it may free the\n/// underlying storage, too.\n///\n/// # Arguments\n///\n/// - `fd`      -   File to operate on\n/// - `range.0` -   File offset at which to begin deallocation\n/// - `range.1` -   Length of the region to deallocate\n///\n/// # Returns\n///\n/// The operation may deallocate less than the entire requested region.  On\n/// success, it returns the region that still remains to be deallocated.  The\n/// caller should loop until the returned region is empty.\n///\n/// # Example\n///\n#[cfg_attr(fbsd14, doc = \" ```\")]\n#[cfg_attr(not(fbsd14), doc = \" ```no_run\")]\n/// # use std::io::Write;\n/// # use std::os::unix::fs::FileExt;\n/// # use std::os::unix::io::AsRawFd;\n/// # use nix::fcntl::*;\n/// # use tempfile::tempfile;\n/// const INITIAL: \u0026[u8] = b\"0123456789abcdef\";\n/// let mut f = tempfile().unwrap();\n/// f.write_all(INITIAL).unwrap();\n/// let mut range = SpacectlRange(3, 6);\n/// while (!range.is_empty()) {\n///     range = fspacectl(\u0026f, range).unwrap();\n/// }\n/// let mut buf = vec![0; INITIAL.len()];\n/// f.read_exact_at(\u0026mut buf, 0).unwrap();\n/// assert_eq!(buf, b\"012\\0\\0\\0\\0\\0\\09abcdef\");\n/// ```\n#[cfg(target_os = \"freebsd\")]\n#[inline] // Delays codegen, preventing linker errors with dylibs and --no-allow-shlib-undefined\npub fn fspacectl\u003cFd: std::os::fd::AsFd\u003e(fd: Fd, range: SpacectlRange) -\u003e Result\u003cSpacectlRange\u003e {\n    use std::os::fd::AsRawFd;\n\n    let mut rqsr = libc::spacectl_range {\n        r_offset: range.0,\n        r_len: range.1,\n    };\n    let res = unsafe {\n        libc::fspacectl(\n            fd.as_fd().as_raw_fd(),\n            libc::SPACECTL_DEALLOC, // Only one command is supported ATM\n            \u0026rqsr,\n            0, // No flags are currently supported\n            \u0026mut rqsr,\n        )\n    };\n    Errno::result(res).map(|_| SpacectlRange(rqsr.r_offset, rqsr.r_len))\n}\n\n/// Like [`fspacectl`], but will never return incomplete.\n///\n/// # Arguments\n///\n/// - `fd`      -   File to operate on\n/// - `offset`  -   File offset at which to begin deallocation\n/// - `len`     -   Length of the region to deallocate\n///\n/// # Returns\n///\n/// Returns `()` on success.  On failure, the region may or may not be partially\n/// deallocated.\n///\n/// # Example\n///\n#[cfg_attr(fbsd14, doc = \" ```\")]\n#[cfg_attr(not(fbsd14), doc = \" ```no_run\")]\n/// # use std::io::Write;\n/// # use std::os::unix::fs::FileExt;\n/// # use std::os::unix::io::AsRawFd;\n/// # use nix::fcntl::*;\n/// # use tempfile::tempfile;\n/// const INITIAL: \u0026[u8] = b\"0123456789abcdef\";\n/// let mut f = tempfile().unwrap();\n/// f.write_all(INITIAL).unwrap();\n/// fspacectl_all(\u0026f, 3, 6).unwrap();\n/// let mut buf = vec![0; INITIAL.len()];\n/// f.read_exact_at(\u0026mut buf, 0).unwrap();\n/// assert_eq!(buf, b\"012\\0\\0\\0\\0\\0\\09abcdef\");\n/// ```\n#[cfg(target_os = \"freebsd\")]\n#[inline] // Delays codegen, preventing linker errors with dylibs and --no-allow-shlib-undefined\npub fn fspacectl_all\u003cFd: std::os::fd::AsFd\u003e(\n    fd: Fd,\n    offset: libc::off_t,\n    len: libc::off_t,\n) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let mut rqsr = libc::spacectl_range {\n        r_offset: offset,\n        r_len: len,\n    };\n    while rqsr.r_len \u003e 0 {\n        let res = unsafe {\n            libc::fspacectl(\n                fd.as_fd().as_raw_fd(),\n                libc::SPACECTL_DEALLOC, // Only one command is supported ATM\n                \u0026rqsr,\n                0, // No flags are currently supported\n                \u0026mut rqsr,\n            )\n        };\n        Errno::result(res)?;\n    }\n    Ok(())\n}\n\n#[cfg(any(\n    linux_android,\n    target_os = \"emscripten\",\n    target_os = \"fuchsia\",\n    target_os = \"wasi\",\n    target_env = \"uclibc\",\n    target_os = \"freebsd\"\n))]\nmod posix_fadvise {\n    use crate::errno::Errno;\n    use crate::Result;\n\n    #[cfg(feature = \"fs\")]\n    libc_enum! {\n        /// The specific advice provided to [`posix_fadvise`].\n        #[repr(i32)]\n        #[non_exhaustive]\n        #[cfg_attr(docsrs, doc(cfg(feature = \"fs\")))]\n        pub enum PosixFadviseAdvice {\n            /// Revert to the default data access behavior.\n            POSIX_FADV_NORMAL,\n            /// The file data will be accessed sequentially.\n            POSIX_FADV_SEQUENTIAL,\n            /// A hint that file data will be accessed randomly, and prefetching is likely not\n            /// advantageous.\n            POSIX_FADV_RANDOM,\n            /// The specified data will only be accessed once and then not reused.\n            POSIX_FADV_NOREUSE,\n            /// The specified data will be accessed in the near future.\n            POSIX_FADV_WILLNEED,\n            /// The specified data will not be accessed in the near future.\n            POSIX_FADV_DONTNEED,\n        }\n    }\n\n    feature! {\n    #![feature = \"fs\"]\n    /// Allows a process to describe to the system its data access behavior for an open file\n    /// descriptor.\n    ///\n    /// # See Also\n    /// * [`posix_fadvise`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_fadvise.html)\n    pub fn posix_fadvise\u003cFd: std::os::fd::AsFd\u003e(\n        fd: Fd,\n        offset: libc::off_t,\n        len: libc::off_t,\n        advice: PosixFadviseAdvice,\n    ) -\u003e Result\u003c()\u003e {\n        use std::os::fd::AsRawFd;\n\n        let res = unsafe { libc::posix_fadvise(fd.as_fd().as_raw_fd(), offset, len, advice as libc::c_int) };\n\n        if res == 0 {\n            Ok(())\n        } else {\n            Err(Errno::from_raw(res))\n        }\n    }\n    }\n}\n\n/// Pre-allocate storage for a range in a file\n///\n/// # See Also\n/// * [`posix_fallocate`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_fallocate.html)\n#[cfg(any(\n    linux_android,\n    freebsdlike,\n    target_os = \"emscripten\",\n    target_os = \"fuchsia\",\n    target_os = \"wasi\",\n))]\npub fn posix_fallocate\u003cFd: std::os::fd::AsFd\u003e(\n    fd: Fd,\n    offset: libc::off_t,\n    len: libc::off_t,\n) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = unsafe { libc::posix_fallocate(fd.as_fd().as_raw_fd(), offset, len) };\n    match Errno::result(res) {\n        Err(err) =\u003e Err(err),\n        Ok(0) =\u003e Ok(()),\n        Ok(errno) =\u003e Err(Errno::from_raw(errno)),\n    }\n}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","features.rs"],"content":"//! Feature tests for OS functionality\npub use self::os::*;\n\n#[cfg(any(linux_android, target_os = \"emscripten\"))]\nmod os {\n    use crate::sys::utsname::uname;\n    use crate::Result;\n    use std::os::unix::ffi::OsStrExt;\n    use std::sync::atomic::{AtomicUsize, Ordering};\n\n    // Features:\n    // * atomic cloexec on socket: 2.6.27\n    // * pipe2: 2.6.27\n    // * accept4: 2.6.28\n\n    static VERS_UNKNOWN: usize = 1;\n    static VERS_2_6_18: usize = 2;\n    static VERS_2_6_27: usize = 3;\n    static VERS_2_6_28: usize = 4;\n    static VERS_3: usize = 5;\n\n    #[inline]\n    fn digit(dst: \u0026mut usize, b: u8) {\n        *dst *= 10;\n        *dst += (b - b'0') as usize;\n    }\n\n    fn parse_kernel_version() -\u003e Result\u003cusize\u003e {\n        let u = uname()?;\n\n        let mut curr: usize = 0;\n        let mut major: usize = 0;\n        let mut minor: usize = 0;\n        let mut patch: usize = 0;\n\n        for \u0026b in u.release().as_bytes() {\n            if curr \u003e= 3 {\n                break;\n            }\n\n            match b {\n                b'.' | b'-' =\u003e {\n                    curr += 1;\n                }\n                b'0'..=b'9' =\u003e match curr {\n                    0 =\u003e digit(\u0026mut major, b),\n                    1 =\u003e digit(\u0026mut minor, b),\n                    _ =\u003e digit(\u0026mut patch, b),\n                },\n                _ =\u003e break,\n            }\n        }\n\n        Ok(if major \u003e= 3 {\n            VERS_3\n        } else if major \u003e= 2 {\n            if minor \u003e= 7 {\n                VERS_UNKNOWN\n            } else if minor \u003e= 6 {\n                if patch \u003e= 28 {\n                    VERS_2_6_28\n                } else if patch \u003e= 27 {\n                    VERS_2_6_27\n                } else {\n                    VERS_2_6_18\n                }\n            } else {\n                VERS_UNKNOWN\n            }\n        } else {\n            VERS_UNKNOWN\n        })\n    }\n\n    fn kernel_version() -\u003e Result\u003cusize\u003e {\n        static KERNEL_VERS: AtomicUsize = AtomicUsize::new(0);\n        let mut kernel_vers = KERNEL_VERS.load(Ordering::Relaxed);\n\n        if kernel_vers == 0 {\n            kernel_vers = parse_kernel_version()?;\n            KERNEL_VERS.store(kernel_vers, Ordering::Relaxed);\n        }\n\n        Ok(kernel_vers)\n    }\n\n    /// Check if the OS supports atomic close-on-exec for sockets\n    pub fn socket_atomic_cloexec() -\u003e bool {\n        kernel_version()\n            .map(|version| version \u003e= VERS_2_6_27)\n            .unwrap_or(false)\n    }\n\n    #[test]\n    fn test_parsing_kernel_version() {\n        assert!(kernel_version().unwrap() \u003e 0);\n    }\n}\n\n#[cfg(any(\n        freebsdlike,                // FreeBSD since 10.0 DragonFlyBSD since ???\n        netbsdlike,                 // NetBSD since 6.0 OpenBSD since 5.7\n        target_os = \"hurd\",         // Since glibc 2.28\n        target_os = \"illumos\",      // Since ???\n        target_os = \"redox\",        // Since 1-july-2020\n        target_os = \"cygwin\",\n))]\nmod os {\n    /// Check if the OS supports atomic close-on-exec for sockets\n    pub const fn socket_atomic_cloexec() -\u003e bool {\n        true\n    }\n}\n\n#[cfg(any(\n    target_os = \"aix\",\n    apple_targets,\n    target_os = \"fuchsia\",\n    target_os = \"haiku\",\n    target_os = \"solaris\"\n))]\nmod os {\n    /// Check if the OS supports atomic close-on-exec for sockets\n    pub const fn socket_atomic_cloexec() -\u003e bool {\n        false\n    }\n}\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","acooks","mcr","nix-0.30.1","src","ifaddrs.rs"],"content":"//! Query network interface addresses\n//!\n//! Uses the Linux and/or BSD specific function `getifaddrs` to query the list\n//! of interfaces and their associated addresses.\n\nuse cfg_if::cfg_if;\n#[cfg(apple_targets)]\nuse std::convert::TryFrom;\nuse std::ffi;\nuse std::iter::Iterator;\nuse std::mem;\nuse std::option::Option;\n\nuse crate::net::if_::*;\nuse crate::sys::socket::{SockaddrLike, SockaddrStorage};\nuse crate::{Errno, Result};\n\n/// Describes a single address for an interface as returned by `getifaddrs`.\n#[derive(Clone, Debug, Eq, Hash, PartialEq)]\npub struct InterfaceAddress {\n    /// Name of the network interface\n    pub interface_name: String,\n    /// Flags as from `SIOCGIFFLAGS` ioctl\n    pub flags: InterfaceFlags,\n    /// Network address of this interface\n    pub address: Option\u003cSockaddrStorage\u003e,\n    /// Netmask of this interface\n    pub netmask: Option\u003cSockaddrStorage\u003e,\n    /// Broadcast address of this interface, if applicable\n    pub broadcast: Option\u003cSockaddrStorage\u003e,\n    /// Point-to-point destination address\n    pub destination: Option\u003cSockaddrStorage\u003e,\n}\n\ncfg_if! {\n    if #[cfg(any(linux_android, target_os = \"emscripten\", target_os = \"fuchsia\"))] {\n        fn get_ifu_from_sockaddr(info: \u0026libc::ifaddrs) -\u003e *const libc::sockaddr {\n            info.ifa_ifu\n        }\n    } else {\n        fn get_ifu_from_sockaddr(info: \u0026libc::ifaddrs) -\u003e *const libc::sockaddr {\n            info.ifa_dstaddr\n        }\n    }\n}\n\n/// Workaround a bug in XNU where netmasks will always have the wrong size in\n/// the sa_len field due to the kernel ignoring trailing zeroes in the structure\n/// when setting the field. See https://github.com/nix-rust/nix/issues/1709#issuecomment-1199304470\n///\n/// To fix this, we stack-allocate a new sockaddr_storage, zero it out, and\n/// memcpy sa_len of the netmask to that new storage. Finally, we reset the\n/// ss_len field to sizeof(sockaddr_storage). This is supposedly valid as all\n/// members of the sockaddr_storage are \"ok\" with being zeroed out (there are\n/// no pointers).\n#[cfg(apple_targets)]\nunsafe fn workaround_xnu_bug(info: \u0026libc::ifaddrs) -\u003e Option\u003cSockaddrStorage\u003e {\n    let src_sock = info.ifa_netmask;\n    if src_sock.is_null() {\n        return None;\n    }\n\n    let mut dst_sock = mem::MaybeUninit::\u003clibc::sockaddr_storage\u003e::zeroed();\n\n    let dst_sock = unsafe {\n        // memcpy only sa_len bytes, assume the rest is zero\n        std::ptr::copy_nonoverlapping(\n            src_sock as *const u8,\n            dst_sock.as_mut_ptr().cast(),\n            (*src_sock).sa_len.into(),\n        );\n\n        // Initialize ss_len to sizeof(libc::sockaddr_storage).\n        (*dst_sock.as_mut_ptr()).ss_len =\n            u8::try_from(mem::size_of::\u003clibc::sockaddr_storage\u003e()).unwrap();\n        dst_sock.assume_init()\n    };\n\n    let dst_sock_ptr =\n        \u0026dst_sock as *const libc::sockaddr_storage as *const libc::sockaddr;\n\n    unsafe { SockaddrStorage::from_raw(dst_sock_ptr, None) }\n}\n\nimpl InterfaceAddress {\n    /// Create an `InterfaceAddress` from the libc struct.\n    fn from_libc_ifaddrs(info: \u0026libc::ifaddrs) -\u003e InterfaceAddress {\n        let ifname = unsafe { ffi::CStr::from_ptr(info.ifa_name) };\n        let address = unsafe { SockaddrStorage::from_raw(info.ifa_addr, None) };\n        #[cfg(apple_targets)]\n        let netmask = unsafe { workaround_xnu_bug(info) };\n        #[cfg(not(apple_targets))]\n        let netmask =\n            unsafe { SockaddrStorage::from_raw(info.ifa_netmask, None) };\n        let mut addr = InterfaceAddress {\n            interface_name: ifname.to_string_lossy().into_owned(),\n            flags: InterfaceFlags::from_bits_truncate(\n                info.ifa_flags as IflagsType,\n            ),\n            address,\n            netmask,\n            broadcast: None,\n            destination: None,\n        };\n\n        let ifu = get_ifu_from_sockaddr(info);\n        if addr.flags.contains(InterfaceFlags::IFF_POINTOPOINT) {\n            addr.destination = unsafe { SockaddrStorage::from_raw(ifu, None) };\n        } else if addr.flags.contains(InterfaceFlags::IFF_BROADCAST) {\n            addr.broadcast = unsafe { SockaddrStorage::from_raw(ifu, None) };\n        }\n\n        addr\n    }\n}\n\n/// Holds the results of `getifaddrs`.\n///\n/// Use the function `getifaddrs` to create this Iterator. Note that the\n/// actual list of interfaces can be iterated once and will be freed as\n/// soon as the Iterator goes out of scope.\n#[derive(Debug, Eq, Hash, PartialEq)]\npub struct InterfaceAddressIterator {\n    base: *mut libc::ifaddrs,\n    next: *mut libc::ifaddrs,\n}\n\nimpl Drop for InterfaceAddressIterator {\n    fn drop(\u0026mut self) {\n        unsafe { libc::freeifaddrs(self.base) };\n    }\n}\n\nimpl Iterator for InterfaceAddressIterator {\n    type Item = InterfaceAddress;\n    fn next(\u0026mut self) -\u003e Option\u003c\u003cSelf as Iterator\u003e::Item\u003e {\n        match unsafe { self.next.as_ref() } {\n            Some(ifaddr) =\u003e {\n                self.next = ifaddr.ifa_next;\n                Some(InterfaceAddress::from_libc_ifaddrs(ifaddr))\n            }\n            None =\u003e None,\n        }\n    }\n}\n\n/// Get interface addresses using libc's `getifaddrs`\n///\n/// Note that the underlying implementation differs between OSes. Only the\n/// most common address families are supported by the nix crate (due to\n/// lack of time and complexity of testing). The address family is encoded\n/// in the specific variant of `SockaddrStorage` returned for the fields\n/// `address`, `netmask`, `broadcast`, and `destination`. For any entry not\n/// supported, the returned list will contain a `None` entry.\n///\n/// # Example\n/// ```\n/// let addrs = nix::ifaddrs::getifaddrs().unwrap();\n/// for ifaddr in addrs {\n///   match ifaddr.address {\n///     Some(address) =\u003e {\n///       println!(\"interface {} address {}\",\n///                ifaddr.interface_name, address);\n///     },\n///     None =\u003e {\n///       println!(\"interface {} with unsupported address family\",\n///                ifaddr.interface_name);\n///     }\n///   }\n/// }\n/// ```\npub fn getifaddrs() -\u003e Result\u003cInterfaceAddressIterator\u003e {\n    let mut addrs = mem::MaybeUninit::\u003c*mut libc::ifaddrs\u003e::uninit();\n    unsafe {\n        Errno::result(libc::getifaddrs(addrs.as_mut_ptr())).map(|_| {\n            InterfaceAddressIterator {\n                base: addrs.assume_init(),\n                next: addrs.assume_init(),\n            }\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Only checks if `getifaddrs` can be invoked without panicking.\n    #[test]\n    fn test_getifaddrs() {\n        let _ = getifaddrs();\n    }\n\n    // Ensures getting the netmask works, and in particular that\n    // `workaround_xnu_bug` works properly.\n    #[test]\n    fn test_getifaddrs_netmask_correct() {\n        let addrs = getifaddrs().unwrap();\n        for iface in addrs {\n            let sock = if let Some(sock) = iface.netmask {\n                sock\n            } else {\n                continue;\n            };\n            if sock.family() == Some(crate::sys::socket::AddressFamily::Inet) {\n                let _ = sock.as_sockaddr_in().unwrap();\n                return;\n            } else if sock.family()\n                == Some(crate::sys::socket::AddressFamily::Inet6)\n            {\n                let _ = sock.as_sockaddr_in6().unwrap();\n                return;\n            }\n        }\n        panic!(\"No address?\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","kmod.rs"],"content":"//! Load and unload kernel modules.\n//!\n//! For more details see\n\nuse std::ffi::CStr;\nuse std::os::unix::io::{AsFd, AsRawFd};\n\nuse crate::errno::Errno;\nuse crate::Result;\n\n/// Loads a kernel module from a buffer.\n///\n/// It loads an ELF image into kernel space,\n/// performs any necessary symbol relocations,\n/// initializes module parameters to values provided by the caller,\n/// and then runs the module's init function.\n///\n/// This function requires `CAP_SYS_MODULE` privilege.\n///\n/// The `module_image` argument points to a buffer containing the binary image\n/// to be loaded. The buffer should contain a valid ELF image\n/// built for the running kernel.\n///\n/// The `param_values` argument is a string containing space-delimited specifications\n/// of the values for module parameters.\n/// Each of the parameter specifications has the form:\n///\n/// `name[=value[,value...]]`\n///\n/// # Example\n///\n/// ```no_run\n/// use std::fs::File;\n/// use std::io::Read;\n/// use std::ffi::CString;\n/// use nix::kmod::init_module;\n///\n/// let mut f = File::open(\"mykernel.ko\").unwrap();\n/// let mut contents: Vec\u003cu8\u003e = Vec::new();\n/// f.read_to_end(\u0026mut contents).unwrap();\n/// init_module(\u0026mut contents, \u0026CString::new(\"who=Rust when=Now,12\").unwrap()).unwrap();\n/// ```\n///\n/// See [`man init_module(2)`](https://man7.org/linux/man-pages/man2/init_module.2.html) for more information.\npub fn init_module(module_image: \u0026[u8], param_values: \u0026CStr) -\u003e Result\u003c()\u003e {\n    let res = unsafe {\n        libc::syscall(\n            libc::SYS_init_module,\n            module_image.as_ptr(),\n            module_image.len(),\n            param_values.as_ptr(),\n        )\n    };\n\n    Errno::result(res).map(drop)\n}\n\nlibc_bitflags!(\n    /// Flags used by the `finit_module` function.\n    pub struct ModuleInitFlags: libc::c_uint {\n        /// Ignore symbol version hashes.\n        MODULE_INIT_IGNORE_MODVERSIONS;\n        /// Ignore kernel version magic.\n        MODULE_INIT_IGNORE_VERMAGIC;\n    }\n);\n\n/// Loads a kernel module from a given file descriptor.\n///\n/// # Example\n///\n/// ```no_run\n/// use std::fs::File;\n/// use std::ffi::CString;\n/// use nix::kmod::{finit_module, ModuleInitFlags};\n///\n/// let f = File::open(\"mymod.ko\").unwrap();\n/// finit_module(\u0026f, \u0026CString::new(\"\").unwrap(), ModuleInitFlags::empty()).unwrap();\n/// ```\n///\n/// See [`man init_module(2)`](https://man7.org/linux/man-pages/man2/init_module.2.html) for more information.\npub fn finit_module\u003cFd: AsFd\u003e(\n    fd: Fd,\n    param_values: \u0026CStr,\n    flags: ModuleInitFlags,\n) -\u003e Result\u003c()\u003e {\n    let res = unsafe {\n        libc::syscall(\n            libc::SYS_finit_module,\n            fd.as_fd().as_raw_fd(),\n            param_values.as_ptr(),\n            flags.bits(),\n        )\n    };\n\n    Errno::result(res).map(drop)\n}\n\nlibc_bitflags!(\n    /// Flags used by `delete_module`.\n    ///\n    /// See [`man delete_module(2)`](https://man7.org/linux/man-pages/man2/delete_module.2.html)\n    /// for a detailed description how these flags work.\n    pub struct DeleteModuleFlags: libc::c_int {\n        /// `delete_module` will return immediately, with an error, if the module has a nonzero\n        /// reference count.\n        O_NONBLOCK;\n        /// `delete_module` will unload the module immediately, regardless of whether it has a\n        /// nonzero reference count.\n        O_TRUNC;\n    }\n);\n\n/// Unloads the kernel module with the given name.\n///\n/// # Example\n///\n/// ```no_run\n/// use std::ffi::CString;\n/// use nix::kmod::{delete_module, DeleteModuleFlags};\n///\n/// delete_module(\u0026CString::new(\"mymod\").unwrap(), DeleteModuleFlags::O_NONBLOCK).unwrap();\n/// ```\n///\n/// See [`man delete_module(2)`](https://man7.org/linux/man-pages/man2/delete_module.2.html) for more information.\npub fn delete_module(name: \u0026CStr, flags: DeleteModuleFlags) -\u003e Result\u003c()\u003e {\n    let res = unsafe {\n        libc::syscall(libc::SYS_delete_module, name.as_ptr(), flags.bits())\n    };\n\n    Errno::result(res).map(drop)\n}\n","traces":[{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","home","acooks","mcr","nix-0.30.1","src","lib.rs"],"content":"//! Rust friendly bindings to the various *nix system functions.\n//!\n//! Modules are structured according to the C header file that they would be\n//! defined in.\n//!\n//! # Features\n//!\n//! Nix uses the following Cargo features to enable optional functionality.\n//! They may be enabled in any combination.\n//! * `acct` - Process accounting\n//! * `aio` - POSIX AIO\n//! * `dir` - Stuff relating to directory iteration\n//! * `env` - Manipulate environment variables\n//! * `event` - Event-driven APIs, like `kqueue` and `epoll`\n//! * `fanotify` - Linux's `fanotify` filesystem events monitoring API\n//! * `feature` - Query characteristics of the OS at runtime\n//! * `fs` - File system functionality\n//! * `hostname` - Get and set the system's hostname\n//! * `inotify` - Linux's `inotify` file system notification API\n//! * `ioctl` - The `ioctl` syscall, and wrappers for many specific instances\n//! * `kmod` - Load and unload kernel modules\n//! * `mman` - Stuff relating to memory management\n//! * `mount` - Mount and unmount file systems\n//! * `mqueue` - POSIX message queues\n//! * `net` - Networking-related functionality\n//! * `personality` - Set the process execution domain\n//! * `poll` - APIs like `poll` and `select`\n//! * `process` - Stuff relating to running processes\n//! * `pthread` - POSIX threads\n//! * `ptrace` - Process tracing and debugging\n//! * `quota` - File system quotas\n//! * `reboot` - Reboot the system\n//! * `resource` - Process resource limits\n//! * `sched` - Manipulate process's scheduling\n//! * `socket` - Sockets, whether for networking or local use\n//! * `signal` - Send and receive signals to processes\n//! * `syslog` - System logging\n//! * `term` - Terminal control APIs\n//! * `time` - Query the operating system's clocks\n//! * `ucontext` - User thread context\n//! * `uio` - Vectored I/O\n//! * `user` - Stuff relating to users and groups\n//! * `zerocopy` - APIs like `sendfile` and `copy_file_range`\n#![crate_name = \"nix\"]\n#![cfg(unix)]\n#![allow(non_camel_case_types)]\n// A clear document is a good document no matter if it has a summary in its\n// first paragraph or not.\n#![allow(clippy::too_long_first_doc_paragraph)]\n#![recursion_limit = \"500\"]\n#![deny(unused)]\n#![deny(unexpected_cfgs)]\n#![allow(unused_macros)]\n#![cfg_attr(\n    not(all(\n        feature = \"acct\",\n        feature = \"aio\",\n        feature = \"dir\",\n        feature = \"env\",\n        feature = \"event\",\n        feature = \"fanotify\",\n        feature = \"feature\",\n        feature = \"fs\",\n        feature = \"hostname\",\n        feature = \"inotify\",\n        feature = \"ioctl\",\n        feature = \"kmod\",\n        feature = \"mman\",\n        feature = \"mount\",\n        feature = \"mqueue\",\n        feature = \"net\",\n        feature = \"personality\",\n        feature = \"poll\",\n        feature = \"process\",\n        feature = \"pthread\",\n        feature = \"ptrace\",\n        feature = \"quota\",\n        feature = \"reboot\",\n        feature = \"resource\",\n        feature = \"sched\",\n        feature = \"socket\",\n        feature = \"signal\",\n        feature = \"syslog\",\n        feature = \"term\",\n        feature = \"time\",\n        feature = \"ucontext\",\n        feature = \"uio\",\n        feature = \"user\",\n        feature = \"zerocopy\",\n    )),\n    allow(unused_imports)\n)]\n#![deny(unstable_features)]\n#![deny(missing_copy_implementations)]\n#![deny(missing_debug_implementations)]\n#![warn(missing_docs)]\n#![cfg_attr(docsrs, feature(doc_cfg))]\n#![deny(clippy::cast_ptr_alignment)]\n#![deny(unsafe_op_in_unsafe_fn)]\n// I found the change suggested by this rules could hurt code readability. I cannot\n// remeber every type's default value, in such cases, it forces me to open\n// the std doc to insepct the Default value, which is unnecessary with\n// `.unwrap_or(value)`.\n#![allow(clippy::unwrap_or_default)]\n\n// Re-exported external crates\npub use libc;\n\n// Private internal modules\n#[macro_use]\nmod macros;\n\n// Public crates\n#[cfg(not(target_os = \"redox\"))]\nfeature! {\n    #![feature = \"dir\"]\n    pub mod dir;\n}\nfeature! {\n    #![feature = \"env\"]\n    pub mod env;\n}\n#[allow(missing_docs)]\npub mod errno;\nfeature! {\n    #![feature = \"feature\"]\n\n    #[deny(missing_docs)]\n    pub mod features;\n}\npub mod fcntl;\nfeature! {\n    #![feature = \"net\"]\n\n    #[cfg(any(linux_android,\n              bsd,\n              solarish))]\n    #[deny(missing_docs)]\n    pub mod ifaddrs;\n    #[cfg(not(target_os = \"redox\"))]\n    #[deny(missing_docs)]\n    pub mod net;\n}\n#[cfg(linux_android)]\nfeature! {\n    #![feature = \"kmod\"]\n    pub mod kmod;\n}\nfeature! {\n    #![feature = \"mount\"]\n    pub mod mount;\n}\n#[cfg(any(\n    freebsdlike,\n    all(target_os = \"linux\", not(target_env = \"ohos\")),\n    target_os = \"netbsd\"\n))]\nfeature! {\n    #![feature = \"mqueue\"]\n    pub mod mqueue;\n}\nfeature! {\n    #![feature = \"poll\"]\n    pub mod poll;\n}\n#[cfg(not(any(target_os = \"redox\", target_os = \"fuchsia\")))]\nfeature! {\n    #![feature = \"term\"]\n    #[deny(missing_docs)]\n    pub mod pty;\n}\nfeature! {\n    #![feature = \"sched\"]\n    pub mod sched;\n}\npub mod sys;\nfeature! {\n    #![feature = \"time\"]\n    pub mod time;\n}\n// This can be implemented for other platforms as soon as libc\n// provides bindings for them.\n#[cfg(all(\n    target_os = \"linux\",\n    any(\n        target_arch = \"aarch64\",\n        target_arch = \"s390x\",\n        target_arch = \"x86\",\n        target_arch = \"x86_64\"\n    )\n))]\nfeature! {\n    #![feature = \"ucontext\"]\n    #[allow(missing_docs)]\n    pub mod ucontext;\n}\npub mod unistd;\n\n#[cfg(any(feature = \"poll\", feature = \"event\"))]\nmod poll_timeout;\n\n#[cfg(any(\n    target_os = \"freebsd\",\n    target_os = \"haiku\",\n    target_os = \"linux\",\n    target_os = \"netbsd\",\n    apple_targets\n))]\nfeature! {\n    #![feature = \"process\"]\n    pub mod spawn;\n}\n\nfeature! {\n    #![feature = \"syslog\"]\n    pub mod syslog;\n}\n\nuse std::ffi::{CStr, CString, OsStr};\nuse std::mem::MaybeUninit;\nuse std::os::unix::ffi::OsStrExt;\nuse std::path::{Path, PathBuf};\nuse std::{ptr, result, slice};\n\nuse errno::Errno;\n\n/// Nix Result Type\npub type Result\u003cT\u003e = result::Result\u003cT, Errno\u003e;\n\n/// Nix's main error type.\n///\n/// It's a wrapper around Errno.  As such, it's very interoperable with\n/// [`std::io::Error`], but it has the advantages of:\n/// * `Clone`\n/// * `Copy`\n/// * `Eq`\n/// * Small size\n/// * Represents all of the system's errnos, instead of just the most common\n///   ones.\npub type Error = Errno;\n\n/// Common trait used to represent file system paths by many Nix functions.\npub trait NixPath {\n    /// Is the path empty?\n    fn is_empty(\u0026self) -\u003e bool;\n\n    /// Length of the path in bytes\n    fn len(\u0026self) -\u003e usize;\n\n    /// Execute a function with this path as a `CStr`.\n    ///\n    /// Mostly used internally by Nix.\n    fn with_nix_path\u003cT, F\u003e(\u0026self, f: F) -\u003e Result\u003cT\u003e\n    where\n        F: FnOnce(\u0026CStr) -\u003e T;\n}\n\nimpl NixPath for str {\n    fn is_empty(\u0026self) -\u003e bool {\n        NixPath::is_empty(OsStr::new(self))\n    }\n\n    fn len(\u0026self) -\u003e usize {\n        NixPath::len(OsStr::new(self))\n    }\n\n    fn with_nix_path\u003cT, F\u003e(\u0026self, f: F) -\u003e Result\u003cT\u003e\n    where\n        F: FnOnce(\u0026CStr) -\u003e T,\n    {\n        OsStr::new(self).with_nix_path(f)\n    }\n}\n\nimpl NixPath for OsStr {\n    fn is_empty(\u0026self) -\u003e bool {\n        self.as_bytes().is_empty()\n    }\n\n    fn len(\u0026self) -\u003e usize {\n        self.as_bytes().len()\n    }\n\n    fn with_nix_path\u003cT, F\u003e(\u0026self, f: F) -\u003e Result\u003cT\u003e\n    where\n        F: FnOnce(\u0026CStr) -\u003e T,\n    {\n        self.as_bytes().with_nix_path(f)\n    }\n}\n\nimpl NixPath for CStr {\n    fn is_empty(\u0026self) -\u003e bool {\n        self.to_bytes().is_empty()\n    }\n\n    fn len(\u0026self) -\u003e usize {\n        self.to_bytes().len()\n    }\n\n    fn with_nix_path\u003cT, F\u003e(\u0026self, f: F) -\u003e Result\u003cT\u003e\n    where\n        F: FnOnce(\u0026CStr) -\u003e T,\n    {\n        Ok(f(self))\n    }\n}\n\nimpl NixPath for [u8] {\n    fn is_empty(\u0026self) -\u003e bool {\n        self.is_empty()\n    }\n\n    fn len(\u0026self) -\u003e usize {\n        self.len()\n    }\n\n    fn with_nix_path\u003cT, F\u003e(\u0026self, f: F) -\u003e Result\u003cT\u003e\n    where\n        F: FnOnce(\u0026CStr) -\u003e T,\n    {\n        // The real PATH_MAX is typically 4096, but it's statistically unlikely to have a path\n        // longer than ~300 bytes. See the PR description to get stats for your own machine.\n        // https://github.com/nix-rust/nix/pull/1656\n        //\n        // By being smaller than a memory page, we also avoid the compiler inserting a probe frame:\n        // https://docs.rs/compiler_builtins/latest/compiler_builtins/probestack/index.html\n        const MAX_STACK_ALLOCATION: usize = 1024;\n\n        if self.len() \u003e= MAX_STACK_ALLOCATION {\n            return with_nix_path_allocating(self, f);\n        }\n\n        let mut buf = MaybeUninit::\u003c[u8; MAX_STACK_ALLOCATION]\u003e::uninit();\n        let buf_ptr = buf.as_mut_ptr().cast();\n\n        unsafe {\n            ptr::copy_nonoverlapping(self.as_ptr(), buf_ptr, self.len());\n            buf_ptr.add(self.len()).write(0);\n        }\n\n        match CStr::from_bytes_with_nul(unsafe {\n            slice::from_raw_parts(buf_ptr, self.len() + 1)\n        }) {\n            Ok(s) =\u003e Ok(f(s)),\n            Err(_) =\u003e Err(Errno::EINVAL),\n        }\n    }\n}\n\n#[cold]\n#[inline(never)]\nfn with_nix_path_allocating\u003cT, F\u003e(from: \u0026[u8], f: F) -\u003e Result\u003cT\u003e\nwhere\n    F: FnOnce(\u0026CStr) -\u003e T,\n{\n    match CString::new(from) {\n        Ok(s) =\u003e Ok(f(\u0026s)),\n        Err(_) =\u003e Err(Errno::EINVAL),\n    }\n}\n\nimpl NixPath for Path {\n    fn is_empty(\u0026self) -\u003e bool {\n        NixPath::is_empty(self.as_os_str())\n    }\n\n    fn len(\u0026self) -\u003e usize {\n        NixPath::len(self.as_os_str())\n    }\n\n    fn with_nix_path\u003cT, F\u003e(\u0026self, f: F) -\u003e Result\u003cT\u003e\n    where\n        F: FnOnce(\u0026CStr) -\u003e T,\n    {\n        self.as_os_str().with_nix_path(f)\n    }\n}\n\nimpl NixPath for PathBuf {\n    fn is_empty(\u0026self) -\u003e bool {\n        NixPath::is_empty(self.as_os_str())\n    }\n\n    fn len(\u0026self) -\u003e usize {\n        NixPath::len(self.as_os_str())\n    }\n\n    fn with_nix_path\u003cT, F\u003e(\u0026self, f: F) -\u003e Result\u003cT\u003e\n    where\n        F: FnOnce(\u0026CStr) -\u003e T,\n    {\n        self.as_os_str().with_nix_path(f)\n    }\n}\n\n/// Like `NixPath::with_nix_path()`, but allow the `path` argument to be optional.\n///\n/// A NULL pointer will be provided if `path.is_none()`.\n#[cfg(any(\n    all(apple_targets, feature = \"mount\"),\n    all(linux_android, any(feature = \"mount\", feature = \"fanotify\"))\n))]\npub(crate) fn with_opt_nix_path\u003cP, T, F\u003e(path: Option\u003c\u0026P\u003e, f: F) -\u003e Result\u003cT\u003e\nwhere\n    P: ?Sized + NixPath,\n    F: FnOnce(*const libc::c_char) -\u003e T,\n{\n    match path {\n        Some(path) =\u003e path.with_nix_path(|p_str| f(p_str.as_ptr())),\n        None =\u003e Ok(f(ptr::null())),\n    }\n}\n","traces":[{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":21},{"path":["/","home","acooks","mcr","nix-0.30.1","src","macros.rs"],"content":"// Thanks to Tokio for this macro\nmacro_rules! feature {\n    (\n        #![$meta:meta]\n        $($item:item)*\n    ) =\u003e {\n        $(\n            #[cfg($meta)]\n            #[cfg_attr(docsrs, doc(cfg($meta)))]\n            $item\n        )*\n    }\n}\n\n/// The `libc_bitflags!` macro helps with a common use case of defining a public bitflags type\n/// with values from the libc crate. It is used the same way as the `bitflags!` macro, except\n/// that only the name of the flag value has to be given.\n///\n/// The `libc` crate must be in scope with the name `libc`.\n///\n/// # Example\n/// ```ignore\n/// libc_bitflags!{\n///     pub struct ProtFlags: libc::c_int {\n///         PROT_NONE;\n///         PROT_READ;\n///         /// PROT_WRITE enables write protect\n///         PROT_WRITE;\n///         PROT_EXEC;\n///         #[cfg(linux_android)]\n///         PROT_GROWSDOWN;\n///         #[cfg(linux_android)]\n///         PROT_GROWSUP;\n///     }\n/// }\n/// ```\n///\n/// Example with casting, due to a mistake in libc. In this example, the\n/// various flags have different types, so we cast the broken ones to the right\n/// type.\n///\n/// ```ignore\n/// libc_bitflags!{\n///     pub struct SaFlags: libc::c_ulong {\n///         SA_NOCLDSTOP as libc::c_ulong;\n///         SA_NOCLDWAIT;\n///         SA_NODEFER as libc::c_ulong;\n///         SA_ONSTACK;\n///         SA_RESETHAND as libc::c_ulong;\n///         SA_RESTART as libc::c_ulong;\n///         SA_SIGINFO;\n///     }\n/// }\n/// ```\nmacro_rules! libc_bitflags {\n    (\n        $(#[$outer:meta])*\n        pub struct $BitFlags:ident: $T:ty {\n            $(\n                $(#[$inner:ident $($args:tt)*])*\n                $Flag:ident $(as $cast:ty)*;\n            )+\n        }\n    ) =\u003e {\n        ::bitflags::bitflags! {\n            #[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n            #[repr(transparent)]\n            $(#[$outer])*\n            pub struct $BitFlags: $T {\n                $(\n                    $(#[$inner $($args)*])*\n                    const $Flag = libc::$Flag $(as $cast)*;\n                )+\n            }\n        }\n    };\n}\n\n/// The `libc_enum!` macro helps with a common use case of defining an enum exclusively using\n/// values from the `libc` crate. This macro supports both `pub` and private `enum`s.\n///\n/// The `libc` crate must be in scope with the name `libc`.\n///\n/// # Example\n/// ```ignore\n/// libc_enum!{\n///     pub enum ProtFlags {\n///         PROT_NONE,\n///         PROT_READ,\n///         PROT_WRITE,\n///         PROT_EXEC,\n///         #[cfg(linux_android)]\n///         PROT_GROWSDOWN,\n///         #[cfg(linux_android)]\n///         PROT_GROWSUP,\n///     }\n/// }\n/// ```\n// Some targets don't use all rules.\n#[allow(unused_macro_rules)]\nmacro_rules! libc_enum {\n    // Exit rule.\n    (@make_enum\n        name: $BitFlags:ident,\n        {\n            $v:vis\n            attrs: [$($attrs:tt)*],\n            entries: [$($entries:tt)*],\n        }\n    ) =\u003e {\n        $($attrs)*\n        #[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n        $v enum $BitFlags {\n            $($entries)*\n        }\n    };\n\n    // Exit rule including TryFrom\n    (@make_enum\n        name: $BitFlags:ident,\n        {\n            $v:vis\n            attrs: [$($attrs:tt)*],\n            entries: [$($entries:tt)*],\n            from_type: $repr:path,\n            try_froms: [$($try_froms:tt)*]\n        }\n    ) =\u003e {\n        $($attrs)*\n        #[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n        $v enum $BitFlags {\n            $($entries)*\n        }\n        impl ::std::convert::TryFrom\u003c$repr\u003e for $BitFlags {\n            type Error = $crate::Error;\n            #[allow(unused_doc_comments)]\n            #[allow(deprecated)]\n            #[allow(unused_attributes)]\n            fn try_from(x: $repr) -\u003e $crate::Result\u003cSelf\u003e {\n                match x {\n                    $($try_froms)*\n                    _ =\u003e Err($crate::Error::EINVAL)\n                }\n            }\n        }\n    };\n\n    // Done accumulating.\n    (@accumulate_entries\n        name: $BitFlags:ident,\n        {\n            $v:vis\n            attrs: $attrs:tt,\n        },\n        $entries:tt,\n        $try_froms:tt;\n    ) =\u003e {\n        libc_enum! {\n            @make_enum\n            name: $BitFlags,\n            {\n                $v\n                attrs: $attrs,\n                entries: $entries,\n            }\n        }\n    };\n\n    // Done accumulating and want TryFrom\n    (@accumulate_entries\n        name: $BitFlags:ident,\n        {\n            $v:vis\n            attrs: $attrs:tt,\n            from_type: $repr:path,\n        },\n        $entries:tt,\n        $try_froms:tt;\n    ) =\u003e {\n        libc_enum! {\n            @make_enum\n            name: $BitFlags,\n            {\n                $v\n                attrs: $attrs,\n                entries: $entries,\n                from_type: $repr,\n                try_froms: $try_froms\n            }\n        }\n    };\n\n    // Munch an attr.\n    (@accumulate_entries\n        name: $BitFlags:ident,\n        $prefix:tt,\n        [$($entries:tt)*],\n        [$($try_froms:tt)*];\n        #[$attr:meta] $($tail:tt)*\n    ) =\u003e {\n        libc_enum! {\n            @accumulate_entries\n            name: $BitFlags,\n            $prefix,\n            [\n                $($entries)*\n                #[$attr]\n            ],\n            [\n                $($try_froms)*\n                #[$attr]\n            ];\n            $($tail)*\n        }\n    };\n\n    // Munch last ident if not followed by a comma.\n    (@accumulate_entries\n        name: $BitFlags:ident,\n        $prefix:tt,\n        [$($entries:tt)*],\n        [$($try_froms:tt)*];\n        $entry:ident\n    ) =\u003e {\n        libc_enum! {\n            @accumulate_entries\n            name: $BitFlags,\n            $prefix,\n            [\n                $($entries)*\n                $entry = libc::$entry,\n            ],\n            [\n                $($try_froms)*\n                libc::$entry =\u003e Ok($BitFlags::$entry),\n            ];\n        }\n    };\n\n    // Munch an ident; covers terminating comma case.\n    (@accumulate_entries\n        name: $BitFlags:ident,\n        $prefix:tt,\n        [$($entries:tt)*],\n        [$($try_froms:tt)*];\n        $entry:ident,\n        $($tail:tt)*\n    ) =\u003e {\n        libc_enum! {\n            @accumulate_entries\n            name: $BitFlags,\n            $prefix,\n            [\n                $($entries)*\n                $entry = libc::$entry,\n            ],\n            [\n                $($try_froms)*\n                libc::$entry =\u003e Ok($BitFlags::$entry),\n            ];\n            $($tail)*\n        }\n    };\n\n    // Munch an ident and cast it to the given type; covers terminating comma.\n    (@accumulate_entries\n        name: $BitFlags:ident,\n        $prefix:tt,\n        [$($entries:tt)*],\n        [$($try_froms:tt)*];\n        $entry:ident as $ty:ty,\n        $($tail:tt)*\n    ) =\u003e {\n        libc_enum! {\n            @accumulate_entries\n            name: $BitFlags,\n            $prefix,\n            [\n                $($entries)*\n                $entry = libc::$entry as $ty,\n            ],\n            [\n                $($try_froms)*\n                libc::$entry as $ty =\u003e Ok($BitFlags::$entry),\n            ];\n            $($tail)*\n        }\n    };\n\n    // Entry rule.\n    (\n        $(#[$attr:meta])*\n        $v:vis enum $BitFlags:ident {\n            $($vals:tt)*\n        }\n    ) =\u003e {\n        libc_enum! {\n            @accumulate_entries\n            name: $BitFlags,\n            {\n                $v\n                attrs: [$(#[$attr])*],\n            },\n            [],\n            [];\n            $($vals)*\n        }\n    };\n\n    // Entry rule including TryFrom\n    (\n        $(#[$attr:meta])*\n        $v:vis enum $BitFlags:ident {\n            $($vals:tt)*\n        }\n        impl TryFrom\u003c$repr:path\u003e\n    ) =\u003e {\n        libc_enum! {\n            @accumulate_entries\n            name: $BitFlags,\n            {\n                $v\n                attrs: [$(#[$attr])*],\n                from_type: $repr,\n            },\n            [],\n            [];\n            $($vals)*\n        }\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","mount","apple.rs"],"content":"use crate::{Errno, NixPath, Result};\nuse libc::c_int;\n\nlibc_bitflags!(\n    /// Used with [`mount()`] and [`unmount()`].\n    pub struct MntFlags: c_int {\n        /// Do not interpret special files on the filesystem.\n        MNT_NODEV;\n        /// Enable data protection on the filesystem if the filesystem is configured for it.\n        MNT_CPROTECT;\n        /// file system is quarantined\n        MNT_QUARANTINE;\n        /// filesystem is stored locally\n        MNT_LOCAL;\n        /// quotas are enabled on filesystem\n        MNT_QUOTA;\n        /// identifies the root filesystem\n        MNT_ROOTFS;\n        /// file system is not appropriate path to user data\n        MNT_DONTBROWSE;\n        /// VFS will ignore ownership information on filesystem objects\n        MNT_IGNORE_OWNERSHIP;\n        /// filesystem was mounted by automounter\n        MNT_AUTOMOUNTED;\n        /// filesystem is journaled\n        MNT_JOURNALED;\n        /// Don't allow user extended attributes\n        MNT_NOUSERXATTR;\n        /// filesystem should defer writes\n        MNT_DEFWRITE;\n        /// don't block unmount if not responding\n        MNT_NOBLOCK;\n        /// file system is exported\n        MNT_EXPORTED;\n        /// file system written asynchronously\n        MNT_ASYNC;\n        /// Force a read-write mount even if the file system appears to be\n        /// unclean.\n        MNT_FORCE;\n        /// MAC support for objects.\n        MNT_MULTILABEL;\n        /// Do not update access times.\n        MNT_NOATIME;\n        /// Disallow program execution.\n        MNT_NOEXEC;\n        /// Do not honor setuid or setgid bits on files when executing them.\n        MNT_NOSUID;\n        /// Mount read-only.\n        MNT_RDONLY;\n        /// Causes the vfs subsystem to update its data structures pertaining to\n        /// the specified already mounted file system.\n        MNT_RELOAD;\n        /// Create a snapshot of the file system.\n        MNT_SNAPSHOT;\n        /// All I/O to the file system should be done synchronously.\n        MNT_SYNCHRONOUS;\n        /// Union with underlying fs.\n        MNT_UNION;\n        /// Indicates that the mount command is being applied to an already\n        /// mounted file system.\n        MNT_UPDATE;\n    }\n);\n\n/// Mount a file system.\n///\n/// # Arguments\n/// - `source`  -   Specifies the file system.  e.g. `/dev/sd0`.\n/// - `target` -    Specifies the destination.  e.g. `/mnt`.\n/// - `flags` -     Optional flags controlling the mount.\n/// - `data` -      Optional file system specific data.\n///\n/// # see also\n/// [`mount`](https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/mount.2.html)\npub fn mount\u003c\n    P1: ?Sized + NixPath,\n    P2: ?Sized + NixPath,\n    P3: ?Sized + NixPath,\n\u003e(\n    source: \u0026P1,\n    target: \u0026P2,\n    flags: MntFlags,\n    data: Option\u003c\u0026P3\u003e,\n) -\u003e Result\u003c()\u003e {\n    let res = source.with_nix_path(|s| {\n        target.with_nix_path(|t| {\n            crate::with_opt_nix_path(data, |d| unsafe {\n                libc::mount(\n                    s.as_ptr(),\n                    t.as_ptr(),\n                    flags.bits(),\n                    d.cast_mut().cast(),\n                )\n            })\n        })\n    })???;\n\n    Errno::result(res).map(drop)\n}\n\n/// Umount the file system mounted at `target`.\npub fn unmount\u003cP\u003e(target: \u0026P, flags: MntFlags) -\u003e Result\u003c()\u003e\nwhere\n    P: ?Sized + NixPath,\n{\n    let res = target.with_nix_path(|cstr| unsafe {\n        libc::unmount(cstr.as_ptr(), flags.bits())\n    })?;\n\n    Errno::result(res).map(drop)\n}\n","traces":[{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["/","home","acooks","mcr","nix-0.30.1","src","mount","bsd_without_apple.rs"],"content":"#[cfg(target_os = \"freebsd\")]\nuse crate::Error;\nuse crate::{Errno, NixPath, Result};\nuse libc::c_int;\n#[cfg(target_os = \"freebsd\")]\nuse libc::{c_char, c_uint, c_void};\n#[cfg(target_os = \"freebsd\")]\nuse std::{\n    borrow::Cow,\n    ffi::{CStr, CString},\n    fmt, io,\n    marker::PhantomData,\n};\n\nlibc_bitflags!(\n    /// Used with [`Nmount::nmount`].\n    pub struct MntFlags: c_int {\n        /// ACL support enabled.\n        #[cfg(any(target_os = \"netbsd\", target_os = \"freebsd\"))]\n        MNT_ACLS;\n        /// All I/O to the file system should be done asynchronously.\n        MNT_ASYNC;\n        /// dir should instead be a file system ID encoded as FSID:val0:val1.\n        #[cfg(target_os = \"freebsd\")]\n        MNT_BYFSID;\n        /// Force a read-write mount even if the file system appears to be\n        /// unclean.\n        MNT_FORCE;\n        /// GEOM journal support enabled.\n        #[cfg(target_os = \"freebsd\")]\n        MNT_GJOURNAL;\n        /// MAC support for objects.\n        #[cfg(target_os = \"freebsd\")]\n        MNT_MULTILABEL;\n        /// Disable read clustering.\n        #[cfg(freebsdlike)]\n        MNT_NOCLUSTERR;\n        /// Disable write clustering.\n        #[cfg(freebsdlike)]\n        MNT_NOCLUSTERW;\n        /// Enable NFS version 4 ACLs.\n        #[cfg(target_os = \"freebsd\")]\n        MNT_NFS4ACLS;\n        /// Do not update access times.\n        MNT_NOATIME;\n        /// Disallow program execution.\n        MNT_NOEXEC;\n        /// Do not honor setuid or setgid bits on files when executing them.\n        MNT_NOSUID;\n        /// Do not follow symlinks.\n        #[cfg(freebsdlike)]\n        MNT_NOSYMFOLLOW;\n        /// Mount read-only.\n        MNT_RDONLY;\n        /// Causes the vfs subsystem to update its data structures pertaining to\n        /// the specified already mounted file system.\n        MNT_RELOAD;\n        /// Create a snapshot of the file system.\n        ///\n        /// See [mksnap_ffs(8)](https://www.freebsd.org/cgi/man.cgi?query=mksnap_ffs)\n        #[cfg(target_os = \"freebsd\")]\n        MNT_SNAPSHOT;\n        /// Using soft updates.\n        #[cfg(any(freebsdlike, netbsdlike))]\n        MNT_SOFTDEP;\n        /// Directories with the SUID bit set chown new files to their own\n        /// owner.\n        #[cfg(freebsdlike)]\n        MNT_SUIDDIR;\n        /// All I/O to the file system should be done synchronously.\n        MNT_SYNCHRONOUS;\n        /// Union with underlying fs.\n        #[cfg(any(\n                target_os = \"freebsd\",\n                target_os = \"netbsd\"\n        ))]\n        MNT_UNION;\n        /// Indicates that the mount command is being applied to an already\n        /// mounted file system.\n        MNT_UPDATE;\n        /// Check vnode use counts.\n        #[cfg(target_os = \"freebsd\")]\n        MNT_NONBUSY;\n    }\n);\n\n/// The Error type of [`Nmount::nmount`].\n///\n/// It wraps an [`Errno`], but also may contain an additional message returned\n/// by `nmount(2)`.\n#[cfg(target_os = \"freebsd\")]\n#[derive(Debug)]\npub struct NmountError {\n    errno: Error,\n    errmsg: Option\u003cString\u003e,\n}\n\n#[cfg(target_os = \"freebsd\")]\nimpl NmountError {\n    /// Returns the additional error string sometimes generated by `nmount(2)`.\n    pub fn errmsg(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.errmsg.as_deref()\n    }\n\n    /// Returns the inner [`Error`]\n    pub const fn error(\u0026self) -\u003e Error {\n        self.errno\n    }\n\n    fn new(error: Error, errmsg: Option\u003c\u0026CStr\u003e) -\u003e Self {\n        Self {\n            errno: error,\n            errmsg: errmsg.map(CStr::to_string_lossy).map(Cow::into_owned),\n        }\n    }\n}\n\n#[cfg(target_os = \"freebsd\")]\nimpl std::error::Error for NmountError {}\n\n#[cfg(target_os = \"freebsd\")]\nimpl fmt::Display for NmountError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        if let Some(errmsg) = \u0026self.errmsg {\n            write!(f, \"{:?}: {}: {}\", self.errno, errmsg, self.errno.desc())\n        } else {\n            write!(f, \"{:?}: {}\", self.errno, self.errno.desc())\n        }\n    }\n}\n\n#[cfg(target_os = \"freebsd\")]\nimpl From\u003cNmountError\u003e for io::Error {\n    fn from(err: NmountError) -\u003e Self {\n        err.errno.into()\n    }\n}\n\n/// Result type of [`Nmount::nmount`].\n#[cfg(target_os = \"freebsd\")]\npub type NmountResult = std::result::Result\u003c(), NmountError\u003e;\n\n/// Mount a FreeBSD file system.\n///\n/// The `nmount(2)` system call works similarly to the `mount(8)` program; it\n/// takes its options as a series of name-value pairs.  Most of the values are\n/// strings, as are all of the names.  The `Nmount` structure builds up an\n/// argument list and then executes the syscall.\n///\n/// # Examples\n///\n/// To mount `target` onto `mountpoint` with `nullfs`:\n/// ```\n/// # use nix::unistd::Uid;\n/// # use ::sysctl::{CtlValue, Sysctl};\n/// # let ctl = ::sysctl::Ctl::new(\"vfs.usermount\").unwrap();\n/// # if !Uid::current().is_root() \u0026\u0026 CtlValue::Int(0) == ctl.value().unwrap() {\n/// #     return;\n/// # };\n/// use nix::mount::{MntFlags, Nmount, unmount};\n/// use std::ffi::CString;\n/// use tempfile::tempdir;\n///\n/// let mountpoint = tempdir().unwrap();\n/// let target = tempdir().unwrap();\n///\n/// let fstype = CString::new(\"fstype\").unwrap();\n/// let nullfs = CString::new(\"nullfs\").unwrap();\n/// Nmount::new()\n///     .str_opt(\u0026fstype, \u0026nullfs)\n///     .str_opt_owned(\"fspath\", mountpoint.path().to_str().unwrap())\n///     .str_opt_owned(\"target\", target.path().to_str().unwrap())\n///     .nmount(MntFlags::empty()).unwrap();\n///\n/// unmount(mountpoint.path(), MntFlags::empty()).unwrap();\n/// ```\n///\n/// # See Also\n/// * [`nmount(2)`](https://www.freebsd.org/cgi/man.cgi?query=nmount)\n/// * [`nullfs(5)`](https://www.freebsd.org/cgi/man.cgi?query=nullfs)\n#[cfg(target_os = \"freebsd\")]\n#[derive(Debug, Default)]\npub struct Nmount\u003c'a\u003e {\n    // n.b. notgull: In reality, this is a list that contains\n    //               both mutable and immutable pointers.\n    //               Be careful using this.\n    iov: Vec\u003clibc::iovec\u003e,\n    is_owned: Vec\u003cbool\u003e,\n    marker: PhantomData\u003c\u0026'a ()\u003e,\n}\n\n#[cfg(target_os = \"freebsd\")]\nimpl\u003c'a\u003e Nmount\u003c'a\u003e {\n    /// Helper function to push a slice onto the `iov` array.\n    fn push_slice(\u0026mut self, val: \u0026'a [u8], is_owned: bool) {\n        self.iov.push(libc::iovec {\n            iov_base: val.as_ptr().cast_mut().cast(),\n            iov_len: val.len(),\n        });\n        self.is_owned.push(is_owned);\n    }\n\n    /// Helper function to push a pointer and its length onto the `iov` array.\n    fn push_pointer_and_length(\n        \u0026mut self,\n        val: *const u8,\n        len: usize,\n        is_owned: bool,\n    ) {\n        self.iov.push(libc::iovec {\n            iov_base: val as *mut _,\n            iov_len: len,\n        });\n        self.is_owned.push(is_owned);\n    }\n\n    /// Helper function to push a `nix` path as owned.\n    fn push_nix_path\u003cP: ?Sized + NixPath\u003e(\u0026mut self, val: \u0026P) {\n        val.with_nix_path(|s| {\n            let len = s.to_bytes_with_nul().len();\n            let ptr = s.to_owned().into_raw() as *const u8;\n\n            self.push_pointer_and_length(ptr, len, true);\n        })\n        .unwrap();\n    }\n\n    /// Add an opaque mount option.\n    ///\n    /// Some file systems take binary-valued mount options.  They can be set\n    /// with this method.\n    ///\n    /// # Safety\n    ///\n    /// Unsafe because it will cause `Nmount::nmount` to dereference a raw\n    /// pointer.  The user is responsible for ensuring that `val` is valid and\n    /// its lifetime outlives `self`!  An easy way to do that is to give the\n    /// value a larger scope than `name`\n    ///\n    /// # Examples\n    /// ```\n    /// use libc::c_void;\n    /// use nix::mount::Nmount;\n    /// use std::ffi::CString;\n    /// use std::mem;\n    ///\n    /// // Note that flags outlives name\n    /// let mut flags: u32 = 0xdeadbeef;\n    /// let name = CString::new(\"flags\").unwrap();\n    /// let p = \u0026mut flags as *mut u32 as *mut c_void;\n    /// let len = mem::size_of_val(\u0026flags);\n    /// let mut nmount = Nmount::new();\n    /// unsafe { nmount.mut_ptr_opt(\u0026name, p, len) };\n    /// ```\n    pub unsafe fn mut_ptr_opt(\n        \u0026mut self,\n        name: \u0026'a CStr,\n        val: *mut c_void,\n        len: usize,\n    ) -\u003e \u0026mut Self {\n        self.push_slice(name.to_bytes_with_nul(), false);\n        self.push_pointer_and_length(val.cast(), len, false);\n        self\n    }\n\n    /// Add a mount option that does not take a value.\n    ///\n    /// # Examples\n    /// ```\n    /// use nix::mount::Nmount;\n    /// use std::ffi::CString;\n    ///\n    /// let read_only = CString::new(\"ro\").unwrap();\n    /// Nmount::new()\n    ///     .null_opt(\u0026read_only);\n    /// ```\n    pub fn null_opt(\u0026mut self, name: \u0026'a CStr) -\u003e \u0026mut Self {\n        self.push_slice(name.to_bytes_with_nul(), false);\n        self.push_slice(\u0026[], false);\n        self\n    }\n\n    /// Add a mount option that does not take a value, but whose name must be\n    /// owned.\n    ///\n    ///\n    /// This has higher runtime cost than [`Nmount::null_opt`], but is useful\n    /// when the name's lifetime doesn't outlive the `Nmount`, or it's a\n    /// different string type than `CStr`.\n    ///\n    /// # Examples\n    /// ```\n    /// use nix::mount::Nmount;\n    ///\n    /// let read_only = \"ro\";\n    /// let mut nmount: Nmount\u003c'static\u003e = Nmount::new();\n    /// nmount.null_opt_owned(read_only);\n    /// ```\n    pub fn null_opt_owned\u003cP: ?Sized + NixPath\u003e(\n        \u0026mut self,\n        name: \u0026P,\n    ) -\u003e \u0026mut Self {\n        self.push_nix_path(name);\n        self.push_slice(\u0026[], false);\n        self\n    }\n\n    /// Add a mount option as a [`CStr`].\n    ///\n    /// # Examples\n    /// ```\n    /// use nix::mount::Nmount;\n    /// use std::ffi::CString;\n    ///\n    /// let fstype = CString::new(\"fstype\").unwrap();\n    /// let nullfs = CString::new(\"nullfs\").unwrap();\n    /// Nmount::new()\n    ///     .str_opt(\u0026fstype, \u0026nullfs);\n    /// ```\n    pub fn str_opt(\u0026mut self, name: \u0026'a CStr, val: \u0026'a CStr) -\u003e \u0026mut Self {\n        self.push_slice(name.to_bytes_with_nul(), false);\n        self.push_slice(val.to_bytes_with_nul(), false);\n        self\n    }\n\n    /// Add a mount option as an owned string.\n    ///\n    /// This has higher runtime cost than [`Nmount::str_opt`], but is useful\n    /// when the value's lifetime doesn't outlive the `Nmount`, or it's a\n    /// different string type than `CStr`.\n    ///\n    /// # Examples\n    /// ```\n    /// use nix::mount::Nmount;\n    /// use std::path::Path;\n    ///\n    /// let mountpoint = Path::new(\"/mnt\");\n    /// Nmount::new()\n    ///     .str_opt_owned(\"fspath\", mountpoint.to_str().unwrap());\n    /// ```\n    pub fn str_opt_owned\u003cP1, P2\u003e(\u0026mut self, name: \u0026P1, val: \u0026P2) -\u003e \u0026mut Self\n    where\n        P1: ?Sized + NixPath,\n        P2: ?Sized + NixPath,\n    {\n        self.push_nix_path(name);\n        self.push_nix_path(val);\n        self\n    }\n\n    /// Create a new `Nmount` struct with no options\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Actually mount the file system.\n    pub fn nmount(\u0026mut self, flags: MntFlags) -\u003e NmountResult {\n        const ERRMSG_NAME: \u0026[u8] = b\"errmsg\\0\";\n        let mut errmsg = vec![0u8; 255];\n\n        // nmount can return extra error information via a \"errmsg\" return\n        // argument.\n        self.push_slice(ERRMSG_NAME, false);\n\n        // SAFETY: we are pushing a mutable iovec here, so we can't use\n        //         the above method\n        self.iov.push(libc::iovec {\n            iov_base: errmsg.as_mut_ptr().cast(),\n            iov_len: errmsg.len(),\n        });\n\n        let niov = self.iov.len() as c_uint;\n        let iovp = self.iov.as_mut_ptr();\n        let res = unsafe { libc::nmount(iovp, niov, flags.bits()) };\n        match Errno::result(res) {\n            Ok(_) =\u003e Ok(()),\n            Err(error) =\u003e {\n                let errmsg = if errmsg[0] == 0 {\n                    None\n                } else {\n                    CStr::from_bytes_until_nul(\u0026errmsg[..]).ok()\n                };\n                Err(NmountError::new(error, errmsg))\n            }\n        }\n    }\n}\n\n#[cfg(target_os = \"freebsd\")]\nimpl Drop for Nmount\u003c'_\u003e {\n    fn drop(\u0026mut self) {\n        for (iov, is_owned) in self.iov.iter().zip(self.is_owned.iter()) {\n            if *is_owned {\n                // Free the owned string.  Safe because we recorded ownership,\n                // and Nmount does not implement Clone.\n                unsafe {\n                    drop(CString::from_raw(iov.iov_base as *mut c_char));\n                }\n            }\n        }\n    }\n}\n\n/// Unmount the file system mounted at `mountpoint`.\n///\n/// Useful flags include\n/// * `MNT_FORCE` -     Unmount even if still in use.\n#[cfg_attr(\n    target_os = \"freebsd\",\n    doc = \"\n* `MNT_BYFSID` -    `mountpoint` is not a path, but a file system ID\n                    encoded as `FSID:val0:val1`, where `val0` and `val1`\n                    are the contents of the `fsid_t val[]` array in decimal.\n                    The file system that has the specified file system ID\n                    will be unmounted.  See\n                    [`statfs`](crate::sys::statfs::statfs) to determine the\n                    `fsid`.\n\"\n)]\npub fn unmount\u003cP\u003e(mountpoint: \u0026P, flags: MntFlags) -\u003e Result\u003c()\u003e\nwhere\n    P: ?Sized + NixPath,\n{\n    let res = mountpoint.with_nix_path(|cstr| unsafe {\n        libc::unmount(cstr.as_ptr(), flags.bits())\n    })?;\n\n    Errno::result(res).map(drop)\n}\n","traces":[{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":52},{"path":["/","home","acooks","mcr","nix-0.30.1","src","mount","linux.rs"],"content":"use crate::errno::Errno;\nuse crate::{NixPath, Result};\nuse libc::{self, c_int, c_ulong};\n\nlibc_bitflags!(\n    /// Used with [`mount`].\n    pub struct MsFlags: c_ulong {\n        /// Mount read-only\n        MS_RDONLY;\n        /// Ignore suid and sgid bits\n        MS_NOSUID;\n        /// Disallow access to device special files\n        MS_NODEV;\n        /// Disallow program execution\n        MS_NOEXEC;\n        /// Writes are synced at once\n        MS_SYNCHRONOUS;\n        /// Alter flags of a mounted FS\n        MS_REMOUNT;\n        /// Allow mandatory locks on a FS\n        MS_MANDLOCK;\n        /// Directory modifications are synchronous\n        MS_DIRSYNC;\n        /// Do not update access times\n        MS_NOATIME;\n        /// Do not update directory access times\n        MS_NODIRATIME;\n        /// Linux 2.4.0 - Bind directory at different place\n        MS_BIND;\n        /// Move an existing mount to a new location\n        MS_MOVE;\n        /// Used to create a recursive bind mount.\n        MS_REC;\n        /// Suppress the display of certain kernel warning messages.\n        MS_SILENT;\n        /// VFS does not apply the umask\n        MS_POSIXACL;\n        /// The resulting mount cannot subsequently be bind mounted.\n        MS_UNBINDABLE;\n        /// Make this mount point private.\n        MS_PRIVATE;\n        /// If this is a shared mount point that is a member of a peer group\n        /// that  contains  other  members, convert it to a slave mount.\n        MS_SLAVE;\n        /// Make  this mount point shared.\n        MS_SHARED;\n        /// When a file on this filesystem is accessed,  update  the  file's\n        /// last  access  time (atime) only if the current value of atime is\n        /// less than or equal to the file's last modification time  (mtime) or\n        /// last  status change time (ctime).\n        MS_RELATIME;\n        /// Mount request came from within the kernel\n        #[deprecated(since = \"0.27.0\", note = \"Should only be used in-kernel\")]\n        MS_KERNMOUNT;\n        /// Update inode I_version field\n        MS_I_VERSION;\n        /// Always  update  the  last access time (atime) when files on this\n        /// filesystem are accessed.\n        MS_STRICTATIME;\n        /// Reduce on-disk updates of inode timestamps (atime, mtime, ctime) by\n        /// maintaining these changes only in memory.\n        MS_LAZYTIME;\n        #[deprecated(since = \"0.27.0\", note = \"Should only be used in-kernel\")]\n        #[allow(missing_docs)]  // Not documented in Linux\n        MS_ACTIVE;\n        #[deprecated(since = \"0.27.0\", note = \"Should only be used in-kernel\")]\n        #[allow(missing_docs)]  // Not documented in Linux\n        MS_NOUSER;\n        #[allow(missing_docs)]  // Not documented in Linux; possibly kernel-only\n        MS_RMT_MASK;\n        #[allow(missing_docs)]  // Not documented in Linux; possibly kernel-only\n        MS_MGC_VAL;\n        #[allow(missing_docs)]  // Not documented in Linux; possibly kernel-only\n        MS_MGC_MSK;\n    }\n);\n\nlibc_bitflags!(\n    /// Used with [`umount2].\n    pub struct MntFlags: c_int {\n        /// Attempt to unmount even if still in use, aborting pending requests.\n        MNT_FORCE;\n        /// Lazy unmount.  Disconnect the file system immediately, but don't\n        /// actually unmount it until it ceases to be busy.\n        MNT_DETACH;\n        /// Mark the mount point as expired.\n        MNT_EXPIRE;\n        /// Don't dereference `target` if it is a symlink.\n        UMOUNT_NOFOLLOW;\n    }\n);\n\n/// Mount a file system.\n///\n/// # Arguments\n/// - `source`  -   Specifies the file system.  e.g. `/dev/sd0`.\n/// - `target` -    Specifies the destination.  e.g. `/mnt`.\n/// - `fstype` -    The file system type, e.g. `ext4`.\n/// - `flags` -     Optional flags controlling the mount.\n/// - `data` -      Optional file system specific data.\n///\n/// # See Also\n/// [`mount`](https://man7.org/linux/man-pages/man2/mount.2.html)\npub fn mount\u003c\n    P1: ?Sized + NixPath,\n    P2: ?Sized + NixPath,\n    P3: ?Sized + NixPath,\n    P4: ?Sized + NixPath,\n\u003e(\n    source: Option\u003c\u0026P1\u003e,\n    target: \u0026P2,\n    fstype: Option\u003c\u0026P3\u003e,\n    flags: MsFlags,\n    data: Option\u003c\u0026P4\u003e,\n) -\u003e Result\u003c()\u003e {\n    let res = crate::with_opt_nix_path(source, |s| {\n        target.with_nix_path(|t| {\n            crate::with_opt_nix_path(fstype, |ty| {\n                crate::with_opt_nix_path(data, |d| unsafe {\n                    libc::mount(\n                        s,\n                        t.as_ptr(),\n                        ty,\n                        flags.bits(),\n                        d as *const libc::c_void,\n                    )\n                })\n            })\n        })\n    })????;\n\n    Errno::result(res).map(drop)\n}\n\n/// Unmount the file system mounted at `target`.\npub fn umount\u003cP: ?Sized + NixPath\u003e(target: \u0026P) -\u003e Result\u003c()\u003e {\n    let res =\n        target.with_nix_path(|cstr| unsafe { libc::umount(cstr.as_ptr()) })?;\n\n    Errno::result(res).map(drop)\n}\n\n/// Unmount the file system mounted at `target`.\n///\n/// See also [`umount`](https://man7.org/linux/man-pages/man2/umount.2.html)\npub fn umount2\u003cP: ?Sized + NixPath\u003e(target: \u0026P, flags: MntFlags) -\u003e Result\u003c()\u003e {\n    let res = target.with_nix_path(|cstr| unsafe {\n        libc::umount2(cstr.as_ptr(), flags.bits())\n    })?;\n\n    Errno::result(res).map(drop)\n}\n","traces":[{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":19},{"path":["/","home","acooks","mcr","nix-0.30.1","src","mount","mod.rs"],"content":"//! Mount file systems\n#[cfg(linux_android)]\nmod linux;\n\n#[cfg(linux_android)]\npub use self::linux::*;\n\n#[cfg(bsd_without_apple)]\nmod bsd_without_apple;\n\n#[cfg(bsd_without_apple)]\npub use self::bsd_without_apple::*;\n\n#[cfg(apple_targets)]\nmod apple;\n\n#[cfg(apple_targets)]\npub use self::apple::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","mqueue.rs"],"content":"//! Posix Message Queue functions\n//!\n//! # Example\n//!\n// no_run because a kernel module may be required.\n//! ```no_run\n//! # use std::ffi::CString;\n//! # use nix::mqueue::*;\n//! use nix::sys::stat::Mode;\n//!\n//! const MSG_SIZE: mq_attr_member_t = 32;\n//! let mq_name= \"/a_nix_test_queue\";\n//!\n//! let oflag0 = MQ_OFlag::O_CREAT | MQ_OFlag::O_WRONLY;\n//! let mode = Mode::S_IWUSR | Mode::S_IRUSR | Mode::S_IRGRP | Mode::S_IROTH;\n//! let mqd0 = mq_open(mq_name, oflag0, mode, None).unwrap();\n//! let msg_to_send = b\"msg_1\";\n//! mq_send(\u0026mqd0, msg_to_send, 1).unwrap();\n//!\n//! let oflag1 = MQ_OFlag::O_CREAT | MQ_OFlag::O_RDONLY;\n//! let mqd1 = mq_open(mq_name, oflag1, mode, None).unwrap();\n//! let mut buf = [0u8; 32];\n//! let mut prio = 0u32;\n//! let len = mq_receive(\u0026mqd1, \u0026mut buf, \u0026mut prio).unwrap();\n//! assert_eq!(prio, 1);\n//! assert_eq!(msg_to_send, \u0026buf[0..len]);\n//!\n//! mq_close(mqd1).unwrap();\n//! mq_close(mqd0).unwrap();\n//! ```\n//! [Further reading and details on the C API](https://man7.org/linux/man-pages/man7/mq_overview.7.html)\n\nuse crate::errno::Errno;\nuse crate::NixPath;\nuse crate::Result;\n\nuse crate::sys::stat::Mode;\nuse libc::{self, mqd_t, size_t};\nuse std::mem;\n#[cfg(any(\n    target_os = \"linux\",\n    target_os = \"netbsd\",\n    target_os = \"dragonfly\"\n))]\nuse std::os::unix::io::{\n    AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, RawFd,\n};\n\nlibc_bitflags! {\n    /// Used with [`mq_open`].\n    pub struct MQ_OFlag: libc::c_int {\n        /// Open the message queue for receiving messages.\n        O_RDONLY;\n        /// Open the queue for sending messages.\n        O_WRONLY;\n        /// Open the queue for both receiving and sending messages\n        O_RDWR;\n        /// Create a message queue.\n        O_CREAT;\n        /// If set along with `O_CREAT`, `mq_open` will fail if the message\n        /// queue name exists.\n        O_EXCL;\n        /// `mq_send` and `mq_receive` should fail with `EAGAIN` rather than\n        /// wait for resources that are not currently available.\n        O_NONBLOCK;\n        /// Set the close-on-exec flag for the message queue descriptor.\n        O_CLOEXEC;\n    }\n}\n\n/// A message-queue attribute, optionally used with [`mq_setattr`] and\n/// [`mq_getattr`] and optionally [`mq_open`],\n#[repr(C)]\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct MqAttr {\n    mq_attr: libc::mq_attr,\n}\n\n/// Identifies an open POSIX Message Queue\n// A safer wrapper around libc::mqd_t, which is a pointer on some platforms\n// Deliberately is not Clone to prevent use-after-close scenarios\n#[repr(transparent)]\n#[derive(Debug)]\n#[allow(missing_copy_implementations)]\npub struct MqdT(mqd_t);\n\n// x32 compatibility\n// See https://sourceware.org/bugzilla/show_bug.cgi?id=21279\n/// Size of a message queue attribute member\n#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\npub type mq_attr_member_t = i64;\n/// Size of a message queue attribute member\n#[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\npub type mq_attr_member_t = libc::c_long;\n\nimpl MqAttr {\n    /// Create a new message queue attribute\n    ///\n    /// # Arguments\n    ///\n    /// - `mq_flags`:   Either `0` or `O_NONBLOCK`.\n    /// - `mq_maxmsg`:  Maximum number of messages on the queue.\n    /// - `mq_msgsize`: Maximum message size in bytes.\n    /// - `mq_curmsgs`: Number of messages currently in the queue.\n    pub fn new(\n        mq_flags: mq_attr_member_t,\n        mq_maxmsg: mq_attr_member_t,\n        mq_msgsize: mq_attr_member_t,\n        mq_curmsgs: mq_attr_member_t,\n    ) -\u003e MqAttr {\n        let mut attr = mem::MaybeUninit::\u003clibc::mq_attr\u003e::uninit();\n        unsafe {\n            let p = attr.as_mut_ptr();\n            (*p).mq_flags = mq_flags;\n            (*p).mq_maxmsg = mq_maxmsg;\n            (*p).mq_msgsize = mq_msgsize;\n            (*p).mq_curmsgs = mq_curmsgs;\n            MqAttr {\n                mq_attr: attr.assume_init(),\n            }\n        }\n    }\n\n    /// The current flags, either `0` or `O_NONBLOCK`.\n    pub const fn flags(\u0026self) -\u003e mq_attr_member_t {\n        self.mq_attr.mq_flags\n    }\n\n    /// The max number of messages that can be held by the queue\n    pub const fn maxmsg(\u0026self) -\u003e mq_attr_member_t {\n        self.mq_attr.mq_maxmsg\n    }\n\n    /// The maximum size of each message (in bytes)\n    pub const fn msgsize(\u0026self) -\u003e mq_attr_member_t {\n        self.mq_attr.mq_msgsize\n    }\n\n    /// The number of messages currently held in the queue\n    pub const fn curmsgs(\u0026self) -\u003e mq_attr_member_t {\n        self.mq_attr.mq_curmsgs\n    }\n}\n\n/// Open a message queue\n///\n/// See also [`mq_open(2)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_open.html)\n// The mode.bits() cast is only lossless on some OSes\n#[allow(clippy::cast_lossless)]\npub fn mq_open\u003cP\u003e(\n    name: \u0026P,\n    oflag: MQ_OFlag,\n    mode: Mode,\n    attr: Option\u003c\u0026MqAttr\u003e,\n) -\u003e Result\u003cMqdT\u003e\nwhere\n    P: ?Sized + NixPath,\n{\n    let res = name.with_nix_path(|cstr| match attr {\n        Some(mq_attr) =\u003e unsafe {\n            libc::mq_open(\n                cstr.as_ptr(),\n                oflag.bits(),\n                mode.bits() as libc::c_int,\n                \u0026mq_attr.mq_attr as *const libc::mq_attr,\n            )\n        },\n        None =\u003e unsafe { libc::mq_open(cstr.as_ptr(), oflag.bits()) },\n    })?;\n\n    Errno::result(res).map(MqdT)\n}\n\n/// Remove a message queue\n///\n/// See also [`mq_unlink(2)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_unlink.html)\npub fn mq_unlink\u003cP\u003e(name: \u0026P) -\u003e Result\u003c()\u003e\nwhere\n    P: ?Sized + NixPath,\n{\n    let res =\n        name.with_nix_path(|cstr| unsafe { libc::mq_unlink(cstr.as_ptr()) })?;\n    Errno::result(res).map(drop)\n}\n\n/// Close a message queue\n///\n/// See also [`mq_close(2)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_close.html)\npub fn mq_close(mqdes: MqdT) -\u003e Result\u003c()\u003e {\n    let res = unsafe { libc::mq_close(mqdes.0) };\n    Errno::result(res).map(drop)\n}\n\n/// Receive a message from a message queue\n///\n/// See also [`mq_receive(2)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_receive.html)\npub fn mq_receive(\n    mqdes: \u0026MqdT,\n    message: \u0026mut [u8],\n    msg_prio: \u0026mut u32,\n) -\u003e Result\u003cusize\u003e {\n    let len = message.len() as size_t;\n    let res = unsafe {\n        libc::mq_receive(\n            mqdes.0,\n            message.as_mut_ptr().cast(),\n            len,\n            msg_prio as *mut u32,\n        )\n    };\n    Errno::result(res).map(|r| r as usize)\n}\n\nfeature! {\n    #![feature = \"time\"]\n    use crate::sys::time::TimeSpec;\n    /// Receive a message from a message queue with a timeout\n    ///\n    /// See also ['mq_timedreceive(2)'](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_receive.html)\n    pub fn mq_timedreceive(\n        mqdes: \u0026MqdT,\n        message: \u0026mut [u8],\n        msg_prio: \u0026mut u32,\n        abstime: \u0026TimeSpec,\n    ) -\u003e Result\u003cusize\u003e {\n        let len = message.len() as size_t;\n        let res = unsafe {\n            libc::mq_timedreceive(\n                mqdes.0,\n                message.as_mut_ptr().cast(),\n                len,\n                msg_prio as *mut u32,\n                abstime.as_ref(),\n            )\n        };\n        Errno::result(res).map(|r| r as usize)\n    }\n}\n\n/// Send a message to a message queue\n///\n/// See also [`mq_send(2)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_send.html)\npub fn mq_send(mqdes: \u0026MqdT, message: \u0026[u8], msq_prio: u32) -\u003e Result\u003c()\u003e {\n    let res = unsafe {\n        libc::mq_send(mqdes.0, message.as_ptr().cast(), message.len(), msq_prio)\n    };\n    Errno::result(res).map(drop)\n}\n\n/// Get message queue attributes\n///\n/// See also [`mq_getattr(2)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_getattr.html)\npub fn mq_getattr(mqd: \u0026MqdT) -\u003e Result\u003cMqAttr\u003e {\n    let mut attr = mem::MaybeUninit::\u003clibc::mq_attr\u003e::uninit();\n    let res = unsafe { libc::mq_getattr(mqd.0, attr.as_mut_ptr()) };\n    Errno::result(res).map(|_| unsafe {\n        MqAttr {\n            mq_attr: attr.assume_init(),\n        }\n    })\n}\n\n/// Set the attributes of the message queue. Only `O_NONBLOCK` can be set,\n/// everything else will be ignored. Returns the old attributes.\n///\n/// It is recommend to use the `mq_set_nonblock()` and `mq_remove_nonblock()`\n/// convenience functions as they are easier to use.\n///\n/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_setattr.html)\npub fn mq_setattr(mqd: \u0026MqdT, newattr: \u0026MqAttr) -\u003e Result\u003cMqAttr\u003e {\n    let mut attr = mem::MaybeUninit::\u003clibc::mq_attr\u003e::uninit();\n    let res = unsafe {\n        libc::mq_setattr(\n            mqd.0,\n            \u0026newattr.mq_attr as *const libc::mq_attr,\n            attr.as_mut_ptr(),\n        )\n    };\n    Errno::result(res).map(|_| unsafe {\n        MqAttr {\n            mq_attr: attr.assume_init(),\n        }\n    })\n}\n\n/// Convenience function.\n/// Sets the `O_NONBLOCK` attribute for a given message queue descriptor\n/// Returns the old attributes\n#[allow(clippy::useless_conversion)] // Not useless on all OSes\npub fn mq_set_nonblock(mqd: \u0026MqdT) -\u003e Result\u003cMqAttr\u003e {\n    let oldattr = mq_getattr(mqd)?;\n    let newattr = MqAttr::new(\n        mq_attr_member_t::from(MQ_OFlag::O_NONBLOCK.bits()),\n        oldattr.mq_attr.mq_maxmsg,\n        oldattr.mq_attr.mq_msgsize,\n        oldattr.mq_attr.mq_curmsgs,\n    );\n    mq_setattr(mqd, \u0026newattr)\n}\n\n/// Convenience function.\n/// Removes `O_NONBLOCK` attribute for a given message queue descriptor\n/// Returns the old attributes\npub fn mq_remove_nonblock(mqd: \u0026MqdT) -\u003e Result\u003cMqAttr\u003e {\n    let oldattr = mq_getattr(mqd)?;\n    let newattr = MqAttr::new(\n        0,\n        oldattr.mq_attr.mq_maxmsg,\n        oldattr.mq_attr.mq_msgsize,\n        oldattr.mq_attr.mq_curmsgs,\n    );\n    mq_setattr(mqd, \u0026newattr)\n}\n\n#[cfg(any(target_os = \"linux\", target_os = \"netbsd\", target_os = \"dragonfly\"))]\nimpl AsFd for MqdT {\n    /// Borrow the underlying message queue descriptor.\n    fn as_fd(\u0026self) -\u003e BorrowedFd {\n        // SAFETY: [MqdT] will only contain a valid fd by construction.\n        unsafe { BorrowedFd::borrow_raw(self.0) }\n    }\n}\n\n#[cfg(any(target_os = \"linux\", target_os = \"netbsd\", target_os = \"dragonfly\"))]\nimpl AsRawFd for MqdT {\n    /// Return the underlying message queue descriptor.\n    ///\n    /// Returned descriptor is a \"shallow copy\" of the descriptor, so it refers\n    ///  to the same underlying kernel object as `self`.\n    fn as_raw_fd(\u0026self) -\u003e RawFd {\n        self.0\n    }\n}\n\n#[cfg(any(target_os = \"linux\", target_os = \"netbsd\", target_os = \"dragonfly\"))]\nimpl FromRawFd for MqdT {\n    /// Construct an [MqdT] from [RawFd].\n    ///\n    /// # Safety\n    /// The `fd` given must be a valid and open file descriptor for a message\n    ///  queue.\n    unsafe fn from_raw_fd(fd: RawFd) -\u003e MqdT {\n        MqdT(fd)\n    }\n}\n\n#[cfg(any(target_os = \"linux\", target_os = \"netbsd\", target_os = \"dragonfly\"))]\nimpl IntoRawFd for MqdT {\n    /// Consume this [MqdT] and return a [RawFd].\n    fn into_raw_fd(self) -\u003e RawFd {\n        self.0\n    }\n}\n","traces":[{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["/","home","acooks","mcr","nix-0.30.1","src","net","if_.rs"],"content":"//! Network interface name resolution.\n//!\n//! Uses Linux and/or POSIX functions to resolve interface names like \"eth0\"\n//! or \"socan1\" into device numbers.\n\nuse std::{ffi::{CStr, CString}, fmt};\nuse crate::{errno::Errno, Error, NixPath, Result};\nuse libc::{c_uint, IF_NAMESIZE};\n\n#[cfg(not(solarish))]\n/// type alias for InterfaceFlags\npub type IflagsType = libc::c_int;\n#[cfg(solarish)]\n/// type alias for InterfaceFlags\npub type IflagsType = libc::c_longlong;\n\n/// Resolve an interface into an interface number.\npub fn if_nametoindex\u003cP: ?Sized + NixPath\u003e(name: \u0026P) -\u003e Result\u003cc_uint\u003e {\n    let if_index = name\n        .with_nix_path(|name| unsafe { libc::if_nametoindex(name.as_ptr()) })?;\n\n    if if_index == 0 {\n        Err(Error::last())\n    } else {\n        Ok(if_index)\n    }\n}\n\n/// Resolve an interface number into an interface.\npub fn if_indextoname(index: c_uint) -\u003e Result\u003cCString\u003e {\n    // We need to allocate this anyway, so doing it directly is faster.\n    let mut buf = vec![0u8; IF_NAMESIZE];\n\n    let return_buf = unsafe {\n        libc::if_indextoname(index, buf.as_mut_ptr().cast())\n    };\n\n    Errno::result(return_buf.cast())?;\n    Ok(CStr::from_bytes_until_nul(buf.as_slice()).unwrap().to_owned())\n}\n\nlibc_bitflags!(\n    /// Standard interface flags, used by `getifaddrs`\n    pub struct InterfaceFlags: IflagsType {\n    \n        /// Interface is running. (see\n        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))\n        IFF_UP as IflagsType;\n        /// Valid broadcast address set. (see\n        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))\n        IFF_BROADCAST as IflagsType;\n        /// Internal debugging flag. (see\n        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))\n        #[cfg(not(any(target_os = \"haiku\", target_os = \"cygwin\")))]\n        IFF_DEBUG as IflagsType;\n        /// Interface is a loopback interface. (see\n        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))\n        IFF_LOOPBACK as IflagsType;\n        /// Interface is a point-to-point link. (see\n        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))\n        IFF_POINTOPOINT as IflagsType;\n        /// Avoid use of trailers. (see\n        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))\n        #[cfg(any(\n                  linux_android,\n                  solarish,\n                  apple_targets,\n                  target_os = \"fuchsia\",\n                  target_os = \"netbsd\",\n                  target_os = \"cygwin\"))]\n        IFF_NOTRAILERS as IflagsType;\n        /// Interface manages own routes.\n        #[cfg(any(target_os = \"dragonfly\"))]\n        IFF_SMART as IflagsType;\n        /// Resources allocated. (see\n        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))\n        #[cfg(any(\n                  linux_android,\n                  bsd,\n                  solarish,\n                  target_os = \"fuchsia\",\n                  target_os = \"cygwin\"))]\n        IFF_RUNNING as IflagsType;\n        /// No arp protocol, L2 destination address not set. (see\n        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))\n        IFF_NOARP as IflagsType;\n        /// Interface is in promiscuous mode. (see\n        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))\n        IFF_PROMISC as IflagsType;\n        /// Receive all multicast packets. (see\n        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))\n        #[cfg(not(target_os = \"cygwin\"))]\n        IFF_ALLMULTI as IflagsType;\n        /// Master of a load balancing bundle. (see\n        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))\n        #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n        IFF_MASTER;\n        /// transmission in progress, tx hardware queue is full\n        #[cfg(any(target_os = \"freebsd\", apple_targets, netbsdlike))]\n        IFF_OACTIVE;\n        /// Protocol code on board.\n        #[cfg(solarish)]\n        IFF_INTELLIGENT as IflagsType;\n        /// Slave of a load balancing bundle. (see\n        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))\n        #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n        IFF_SLAVE;\n        /// Can't hear own transmissions.\n        #[cfg(bsd)]\n        IFF_SIMPLEX;\n        /// Supports multicast. (see\n        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))\n        IFF_MULTICAST as IflagsType;\n        /// Per link layer defined bit.\n        #[cfg(bsd)]\n        IFF_LINK0;\n        /// Multicast using broadcast.\n        #[cfg(solarish)]\n        IFF_MULTI_BCAST as IflagsType;\n        /// Is able to select media type via ifmap. (see\n        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))\n        #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n        IFF_PORTSEL;\n        /// Per link layer defined bit.\n        #[cfg(bsd)]\n        IFF_LINK1;\n        /// Non-unique address.\n        #[cfg(solarish)]\n        IFF_UNNUMBERED as IflagsType;\n        /// Auto media selection active. (see\n        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))\n        #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n        IFF_AUTOMEDIA;\n        /// Per link layer defined bit.\n        #[cfg(bsd)]\n        IFF_LINK2;\n        /// Use alternate physical connection.\n        #[cfg(any(freebsdlike, apple_targets))]\n        IFF_ALTPHYS;\n        /// DHCP controls interface.\n        #[cfg(solarish)]\n        IFF_DHCPRUNNING as IflagsType;\n        /// The addresses are lost when the interface goes down. (see\n        /// [`netdevice(7)`](https://man7.org/linux/man-pages/man7/netdevice.7.html))\n        #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n        IFF_DYNAMIC;\n        /// Do not advertise.\n        #[cfg(solarish)]\n        IFF_PRIVATE as IflagsType;\n        /// Driver signals L1 up. Volatile.\n        #[cfg(any(target_os = \"fuchsia\", target_os = \"linux\", target_os = \"cygwin\"))]\n        IFF_LOWER_UP;\n        /// Interface is in polling mode.\n        #[cfg(any(target_os = \"dragonfly\"))]\n        IFF_POLLING_COMPAT;\n        /// Unconfigurable using ioctl(2).\n        #[cfg(any(target_os = \"freebsd\"))]\n        IFF_CANTCONFIG;\n        /// Do not transmit packets.\n        #[cfg(solarish)]\n        IFF_NOXMIT as IflagsType;\n        /// Driver signals dormant. Volatile.\n        #[cfg(any(target_os = \"fuchsia\", target_os = \"linux\", target_os = \"cygwin\"))]\n        IFF_DORMANT;\n        /// User-requested promisc mode.\n        #[cfg(freebsdlike)]\n        IFF_PPROMISC;\n        /// Just on-link subnet.\n        #[cfg(solarish)]\n        IFF_NOLOCAL as IflagsType;\n        /// Echo sent packets. Volatile.\n        #[cfg(any(target_os = \"fuchsia\", target_os = \"linux\"))]\n        IFF_ECHO;\n        /// User-requested monitor mode.\n        #[cfg(freebsdlike)]\n        IFF_MONITOR;\n        /// Address is deprecated.\n        #[cfg(solarish)]\n        IFF_DEPRECATED as IflagsType;\n        /// Static ARP.\n        #[cfg(freebsdlike)]\n        IFF_STATICARP;\n        /// Address from stateless addrconf.\n        #[cfg(solarish)]\n        IFF_ADDRCONF as IflagsType;\n        /// Interface is in polling mode.\n        #[cfg(any(target_os = \"dragonfly\"))]\n        IFF_NPOLLING;\n        /// Router on interface.\n        #[cfg(solarish)]\n        IFF_ROUTER as IflagsType;\n        /// Interface is in polling mode.\n        #[cfg(any(target_os = \"dragonfly\"))]\n        IFF_IDIRECT;\n        /// Interface is winding down\n        #[cfg(any(target_os = \"freebsd\"))]\n        IFF_DYING;\n        /// No NUD on interface.\n        #[cfg(solarish)]\n        IFF_NONUD as IflagsType;\n        /// Interface is being renamed\n        #[cfg(any(target_os = \"freebsd\"))]\n        IFF_RENAMING;\n        /// Anycast address.\n        #[cfg(solarish)]\n        IFF_ANYCAST as IflagsType;\n        /// Don't exchange routing info.\n        #[cfg(solarish)]\n        IFF_NORTEXCH as IflagsType;\n        /// Do not provide packet information\n        #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n        IFF_NO_PI as IflagsType;\n        /// TUN device (no Ethernet headers)\n        #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n        IFF_TUN as IflagsType;\n        /// TAP device\n        #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n        IFF_TAP as IflagsType;\n        /// IPv4 interface.\n        #[cfg(solarish)]\n        IFF_IPV4 as IflagsType;\n        /// IPv6 interface.\n        #[cfg(solarish)]\n        IFF_IPV6 as IflagsType;\n        /// in.mpathd test address\n        #[cfg(solarish)]\n        IFF_NOFAILOVER as IflagsType;\n        /// Interface has failed\n        #[cfg(solarish)]\n        IFF_FAILED as IflagsType;\n        /// Interface is a hot-spare\n        #[cfg(solarish)]\n        IFF_STANDBY as IflagsType;\n        /// Functioning but not used\n        #[cfg(solarish)]\n        IFF_INACTIVE as IflagsType;\n        /// Interface is offline\n        #[cfg(solarish)]\n        IFF_OFFLINE as IflagsType;\n        /// Has CoS marking supported\n        #[cfg(solarish)]\n        IFF_COS_ENABLED as IflagsType;\n        /// Prefer as source addr\n        #[cfg(solarish)]\n        IFF_PREFERRED as IflagsType;\n        /// RFC3041\n        #[cfg(solarish)]\n        IFF_TEMPORARY as IflagsType;\n        /// MTU set\n        #[cfg(solarish)]\n        IFF_FIXEDMTU as IflagsType;\n        /// Cannot send/receive packets\n        #[cfg(solarish)]\n        IFF_VIRTUAL as IflagsType;\n        /// Local address in use\n        #[cfg(solarish)]\n        IFF_DUPLICATE as IflagsType;\n        /// IPMP IP interface\n        #[cfg(solarish)]\n        IFF_IPMP as IflagsType;\n    }\n);\n\nimpl fmt::Display for InterfaceFlags {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        bitflags::parser::to_writer(self, f)\n    }\n}\n\n\n#[cfg(any(\n    bsd,\n    target_os = \"fuchsia\",\n    target_os = \"linux\",\n    solarish,\n))]\nmod if_nameindex {\n    use super::*;\n\n    use std::ffi::CStr;\n    use std::fmt;\n    use std::marker::PhantomData;\n    use std::ptr::NonNull;\n\n    /// A network interface. Has a name like \"eth0\" or \"wlp4s0\" or \"wlan0\", as well as an index\n    /// (1, 2, 3, etc) that identifies it in the OS's networking stack.\n    #[allow(missing_copy_implementations)]\n    #[repr(transparent)]\n    pub struct Interface(libc::if_nameindex);\n\n    impl Interface {\n        /// Obtain the index of this interface.\n        pub fn index(\u0026self) -\u003e c_uint {\n            self.0.if_index\n        }\n\n        /// Obtain the name of this interface.\n        pub fn name(\u0026self) -\u003e \u0026CStr {\n            unsafe { CStr::from_ptr(self.0.if_name) }\n        }\n    }\n\n    impl fmt::Debug for Interface {\n        fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            f.debug_struct(\"Interface\")\n                .field(\"index\", \u0026self.index())\n                .field(\"name\", \u0026self.name())\n                .finish()\n        }\n    }\n\n    /// A list of the network interfaces available on this system. Obtained from [`if_nameindex()`].\n    #[repr(transparent)]\n    pub struct Interfaces {\n        ptr: NonNull\u003clibc::if_nameindex\u003e,\n    }\n\n    impl Interfaces {\n        /// Iterate over the interfaces in this list.\n        #[inline]\n        pub fn iter(\u0026self) -\u003e InterfacesIter\u003c'_\u003e {\n            self.into_iter()\n        }\n\n        /// Convert this to a slice of interfaces. Note that the underlying interfaces list is\n        /// null-terminated, so calling this calculates the length. If random access isn't needed,\n        /// [`Interfaces::iter()`] should be used instead.\n        pub fn to_slice(\u0026self) -\u003e \u0026[Interface] {\n            let ifs = self.ptr.as_ptr().cast();\n            let len = self.iter().count();\n            unsafe { std::slice::from_raw_parts(ifs, len) }\n        }\n    }\n\n    impl Drop for Interfaces {\n        fn drop(\u0026mut self) {\n            unsafe { libc::if_freenameindex(self.ptr.as_ptr()) };\n        }\n    }\n\n    impl fmt::Debug for Interfaces {\n        fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            self.to_slice().fmt(f)\n        }\n    }\n\n    impl\u003c'a\u003e IntoIterator for \u0026'a Interfaces {\n        type IntoIter = InterfacesIter\u003c'a\u003e;\n        type Item = \u0026'a Interface;\n        #[inline]\n        fn into_iter(self) -\u003e Self::IntoIter {\n            InterfacesIter {\n                ptr: self.ptr.as_ptr(),\n                _marker: PhantomData,\n            }\n        }\n    }\n\n    /// An iterator over the interfaces in an [`Interfaces`].\n    #[derive(Debug)]\n    pub struct InterfacesIter\u003c'a\u003e {\n        ptr: *const libc::if_nameindex,\n        _marker: PhantomData\u003c\u0026'a Interfaces\u003e,\n    }\n\n    impl\u003c'a\u003e Iterator for InterfacesIter\u003c'a\u003e {\n        type Item = \u0026'a Interface;\n        #[inline]\n        fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n            unsafe {\n                if (*self.ptr).if_index == 0 {\n                    None\n                } else {\n                    let ret = \u0026*(self.ptr as *const Interface);\n                    self.ptr = self.ptr.add(1);\n                    Some(ret)\n                }\n            }\n        }\n    }\n\n    /// Retrieve a list of the network interfaces available on the local system.\n    ///\n    /// ```\n    /// let interfaces = nix::net::if_::if_nameindex().unwrap();\n    /// for iface in \u0026interfaces {\n    ///     println!(\"Interface #{} is called {}\", iface.index(), iface.name().to_string_lossy());\n    /// }\n    /// ```\n    pub fn if_nameindex() -\u003e Result\u003cInterfaces\u003e {\n        unsafe {\n            let ifs = libc::if_nameindex();\n            let ptr = NonNull::new(ifs).ok_or_else(Error::last)?;\n            Ok(Interfaces { ptr })\n        }\n    }\n}\n#[cfg(any(\n    bsd,\n    target_os = \"fuchsia\",\n    target_os = \"linux\",\n    solarish,\n))]\npub use if_nameindex::*;\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["/","home","acooks","mcr","nix-0.30.1","src","net","mod.rs"],"content":"//! Functionality involving network interfaces\n// To avoid clashing with the keyword \"if\", we use \"if_\" as the module name.\n// The original header is called \"net/if.h\".\npub mod if_;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","poll.rs"],"content":"//! Wait for events to trigger on specific file descriptors\nuse std::os::unix::io::{AsFd, AsRawFd, BorrowedFd};\n\nuse crate::errno::Errno;\npub use crate::poll_timeout::{PollTimeout, PollTimeoutTryFromError};\nuse crate::Result;\n\n/// This is a wrapper around `libc::pollfd`.\n///\n/// It's meant to be used as an argument to the [`poll`](fn.poll.html) and\n/// [`ppoll`](fn.ppoll.html) functions to specify the events of interest\n/// for a specific file descriptor.\n///\n/// After a call to `poll` or `ppoll`, the events that occurred can be retrieved by calling\n/// [`revents()`](#method.revents) on the `PollFd` object from the array passed to `poll`.\n#[repr(transparent)]\n#[derive(Clone, Debug, Eq, Hash, PartialEq)]\npub struct PollFd\u003c'fd\u003e {\n    pollfd: libc::pollfd,\n    _fd: std::marker::PhantomData\u003cBorrowedFd\u003c'fd\u003e\u003e,\n}\n\nimpl\u003c'fd\u003e PollFd\u003c'fd\u003e {\n    /// Creates a new `PollFd` specifying the events of interest\n    /// for a given file descriptor.\n    ///\n    /// # Examples\n    /// ```no_run\n    /// # use std::os::unix::io::{AsFd, AsRawFd, FromRawFd};\n    /// # use nix::{\n    /// #     poll::{PollTimeout, PollFd, PollFlags, poll},\n    /// #     unistd::{pipe, read}\n    /// # };\n    /// let (r, w) = pipe().unwrap();\n    /// let pfd = PollFd::new(r.as_fd(), PollFlags::POLLIN);\n    /// ```\n    /// These are placed in an array and passed to [`poll`] or [`ppoll`](fn.ppoll.html).\n    // Unlike I/O functions, constructors like this must take `BorrowedFd`\n    // instead of AsFd or \u0026AsFd.  Otherwise, an `OwnedFd` argument would be\n    // dropped at the end of the method, leaving the structure referencing a\n    // closed file descriptor.  For example:\n    //\n    // ```rust\n    // let (r, _) = pipe().unwrap();\n    // let pollfd = PollFd::new(r, flag);  // Drops the OwnedFd\n    // // Do something with `pollfd`, which uses the CLOSED fd.\n    // ```\n    pub fn new(fd: BorrowedFd\u003c'fd\u003e, events: PollFlags) -\u003e PollFd\u003c'fd\u003e {\n        PollFd {\n            pollfd: libc::pollfd {\n                fd: fd.as_raw_fd(),\n                events: events.bits(),\n                revents: PollFlags::empty().bits(),\n            },\n            _fd: std::marker::PhantomData,\n        }\n    }\n\n    /// Returns the events that occurred in the last call to `poll` or `ppoll`.  Will only return\n    /// `None` if the kernel provides status flags that Nix does not know about.\n    pub fn revents(\u0026self) -\u003e Option\u003cPollFlags\u003e {\n        PollFlags::from_bits(self.pollfd.revents)\n    }\n\n    /// Returns if any of the events of interest occured in the last call to `poll` or `ppoll`. Will\n    /// only return `None` if the kernel provides status flags that Nix does not know about.\n    ///\n    /// Equivalent to `x.revents()? != PollFlags::empty()`.\n    ///\n    /// This is marginally more efficient than [`PollFd::all`].\n    pub fn any(\u0026self) -\u003e Option\u003cbool\u003e {\n        Some(self.revents()? != PollFlags::empty())\n    }\n\n    /// Returns if all the events of interest occured in the last call to `poll` or `ppoll`. Will\n    /// only return `None` if the kernel provides status flags that Nix does not know about.\n    ///\n    /// Equivalent to `x.revents()? \u0026 x.events() == x.events()`.\n    ///\n    /// This is marginally less efficient than [`PollFd::any`].\n    pub fn all(\u0026self) -\u003e Option\u003cbool\u003e {\n        Some(self.revents()? \u0026 self.events() == self.events())\n    }\n\n    /// The events of interest for this `PollFd`.\n    pub fn events(\u0026self) -\u003e PollFlags {\n        PollFlags::from_bits(self.pollfd.events).unwrap()\n    }\n\n    /// Modify the events of interest for this `PollFd`.\n    pub fn set_events(\u0026mut self, events: PollFlags) {\n        self.pollfd.events = events.bits();\n    }\n}\n\nimpl AsFd for PollFd\u003c'_\u003e {\n    fn as_fd(\u0026self) -\u003e BorrowedFd\u003c'_\u003e {\n        // Safety:\n        //\n        // BorrowedFd::borrow_raw(RawFd) requires that the raw fd being passed\n        // must remain open for the duration of the returned BorrowedFd, this is\n        // guaranteed as the returned BorrowedFd has the lifetime parameter same\n        // as `self`:\n        // \"fn as_fd\u003c'self\u003e(\u0026'self self) -\u003e BorrowedFd\u003c'self\u003e\"\n        // which means that `self` (PollFd) is guaranteed to outlive the returned\n        // BorrowedFd. (Lifetime: PollFd \u003e BorrowedFd)\n        //\n        // And the lifetime parameter of PollFd::new(fd, ...) ensures that `fd`\n        // (an owned file descriptor) must outlive the returned PollFd:\n        // \"pub fn new\u003cFd: AsFd\u003e(fd: \u0026'fd Fd, events: PollFlags) -\u003e PollFd\u003c'fd\u003e\"\n        // (Lifetime: Owned fd \u003e PollFd)\n        //\n        // With two above relationships, we can conclude that the `Owned file\n        // descriptor` will outlive the returned BorrowedFd,\n        // (Lifetime: Owned fd \u003e BorrowedFd)\n        // i.e., the raw fd being passed will remain valid for the lifetime of\n        // the returned BorrowedFd.\n        unsafe { BorrowedFd::borrow_raw(self.pollfd.fd) }\n    }\n}\n\nlibc_bitflags! {\n    /// These flags define the different events that can be monitored by `poll` and `ppoll`\n    pub struct PollFlags: libc::c_short {\n        /// There is data to read.\n        POLLIN;\n        /// There is some exceptional condition on the file descriptor.\n        ///\n        /// Possibilities include:\n        ///\n        /// *  There is out-of-band data on a TCP socket (see\n        ///    [tcp(7)](https://man7.org/linux/man-pages/man7/tcp.7.html)).\n        /// *  A pseudoterminal master in packet mode has seen a state\n        ///    change on the slave (see\n        ///    [ioctl_tty(2)](https://man7.org/linux/man-pages/man2/ioctl_tty.2.html)).\n        /// *  A cgroup.events file has been modified (see\n        ///    [cgroups(7)](https://man7.org/linux/man-pages/man7/cgroups.7.html)).\n        POLLPRI;\n        /// Writing is now possible, though a write larger that the\n        /// available space in a socket or pipe will still block (unless\n        /// `O_NONBLOCK` is set).\n        POLLOUT;\n        /// Equivalent to [`POLLIN`](constant.POLLIN.html)\n        #[cfg(not(target_os = \"redox\"))]\n        POLLRDNORM;\n        #[cfg(not(target_os = \"redox\"))]\n        /// Equivalent to [`POLLOUT`](constant.POLLOUT.html)\n        POLLWRNORM;\n        /// Priority band data can be read (generally unused on Linux).\n        #[cfg(not(target_os = \"redox\"))]\n        POLLRDBAND;\n        /// Priority data may be written.\n        #[cfg(not(target_os = \"redox\"))]\n        POLLWRBAND;\n        /// Error condition (only returned in\n        /// [`PollFd::revents`](struct.PollFd.html#method.revents);\n        /// ignored in [`PollFd::new`](struct.PollFd.html#method.new)).\n        /// This bit is also set for a file descriptor referring to the\n        /// write end of a pipe when the read end has been closed.\n        POLLERR;\n        /// Hang up (only returned in [`PollFd::revents`](struct.PollFd.html#method.revents);\n        /// ignored in [`PollFd::new`](struct.PollFd.html#method.new)).\n        /// Note that when reading from a channel such as a pipe or a stream\n        /// socket, this event merely indicates that the peer closed its\n        /// end of the channel.  Subsequent reads from the channel will\n        /// return 0 (end of file) only after all outstanding data in the\n        /// channel has been consumed.\n        POLLHUP;\n        /// Invalid request: `fd` not open (only returned in\n        /// [`PollFd::revents`](struct.PollFd.html#method.revents);\n        /// ignored in [`PollFd::new`](struct.PollFd.html#method.new)).\n        POLLNVAL;\n    }\n}\n\n/// `poll` waits for one of a set of file descriptors to become ready to perform I/O.\n/// ([`poll(2)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/poll.html))\n///\n/// `fds` contains all [`PollFd`](struct.PollFd.html) to poll.\n/// The function will return as soon as any event occur for any of these `PollFd`s.\n///\n/// The `timeout` argument specifies the number of milliseconds that `poll()`\n/// should block waiting for a file descriptor to become ready.  The call\n/// will block until either:\n///\n/// *  a file descriptor becomes ready;\n/// *  the call is interrupted by a signal handler; or\n/// *  the timeout expires.\n///\n/// Note that the timeout interval will be rounded up to the system clock\n/// granularity, and kernel scheduling delays mean that the blocking\n/// interval may overrun by a small amount.  Specifying a [`PollTimeout::NONE`]\n/// in timeout means an infinite timeout.  Specifying a timeout of\n/// [`PollTimeout::ZERO`] causes `poll()` to return immediately, even if no file\n/// descriptors are ready.\n///\n/// The return value contains the number of `fds` which have selected events ([`PollFd::revents`]).\n///\n/// # Examples\n/// ```no_run\n/// # use std::os::unix::io::{AsFd, AsRawFd, FromRawFd};\n/// # use nix::{\n/// #     poll::{PollTimeout, PollFd, PollFlags, poll},\n/// #     unistd::{pipe, read}\n/// # };\n/// let (r0, w0) = pipe().unwrap();\n/// let (r1, w1) = pipe().unwrap();\n///\n/// let mut pollfds = [\n///     PollFd::new(r0.as_fd(), PollFlags::POLLIN),\n///     PollFd::new(r1.as_fd(), PollFlags::POLLIN),\n/// ];\n///\n/// let nready = poll(\u0026mut pollfds, PollTimeout::NONE).unwrap();\n/// assert!(nready \u003e= 1);  // Since there is no timeout\n///\n/// let mut buf = [0u8; 80];\n/// if pollfds[0].any().unwrap_or_default() {\n///     read(\u0026r0, \u0026mut buf[..]);\n/// } else if pollfds[1].any().unwrap_or_default() {\n///     read(\u0026r1, \u0026mut buf[..]);\n/// }\n/// ```\npub fn poll\u003cT: Into\u003cPollTimeout\u003e\u003e(\n    fds: \u0026mut [PollFd],\n    timeout: T,\n) -\u003e Result\u003clibc::c_int\u003e {\n    let res = unsafe {\n        libc::poll(\n            fds.as_mut_ptr().cast(),\n            fds.len() as libc::nfds_t,\n            i32::from(timeout.into()),\n        )\n    };\n\n    Errno::result(res)\n}\n\nfeature! {\n#![feature = \"signal\"]\n/// `ppoll()` allows an application to safely wait until either a file\n/// descriptor becomes ready or until a signal is caught.\n/// ([`poll(2)`](https://man7.org/linux/man-pages/man2/poll.2.html))\n///\n/// `ppoll` behaves like [`poll`], but let you specify what signals may interrupt it\n/// with the `sigmask` argument. If you want `ppoll` to block indefinitely,\n/// specify `None` as `timeout` (it is like `timeout = -1` for `poll`).\n/// If `sigmask` is `None`, then no signal mask manipulation is performed,\n/// so in that case `ppoll` differs from `poll` only in the precision of the\n/// timeout argument.\n///\n#[cfg(any(linux_android, freebsdlike))]\npub fn ppoll(\n    fds: \u0026mut [PollFd],\n    timeout: Option\u003ccrate::sys::time::TimeSpec\u003e,\n    sigmask: Option\u003ccrate::sys::signal::SigSet\u003e\n    ) -\u003e Result\u003clibc::c_int\u003e\n{\n    let timeout = timeout.as_ref().map_or(core::ptr::null(), |r| r.as_ref());\n    let sigmask = sigmask.as_ref().map_or(core::ptr::null(), |r| r.as_ref());\n    let res = unsafe {\n        libc::ppoll(fds.as_mut_ptr().cast(),\n                    fds.len() as libc::nfds_t,\n                    timeout,\n                    sigmask)\n    };\n    Errno::result(res)\n}\n}\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["/","home","acooks","mcr","nix-0.30.1","src","poll_timeout.rs"],"content":"use std::time::Duration;\n\n/// PollTimeout argument for polling.\n#[derive(Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd)]\npub struct PollTimeout(i32);\n\nimpl PollTimeout {\n    /// Blocks indefinitely.\n    ///\n    /// \u003e Specifying a negative value in timeout means an infinite timeout.\n    pub const NONE: Self = Self(-1);\n    /// Returns immediately.\n    ///\n    /// \u003e Specifying a timeout of zero causes poll() to return immediately, even if no file\n    /// \u003e descriptors are ready.\n    pub const ZERO: Self = Self(0);\n    /// Blocks for at most [`i32::MAX`] milliseconds.\n    pub const MAX: Self = Self(i32::MAX);\n    /// Returns if `self` equals [`PollTimeout::NONE`].\n    pub fn is_none(\u0026self) -\u003e bool {\n        // \u003e Specifying a negative value in timeout means an infinite timeout.\n        *self \u003c= Self::NONE\n    }\n    /// Returns if `self` does not equal [`PollTimeout::NONE`].\n    pub fn is_some(\u0026self) -\u003e bool {\n        !self.is_none()\n    }\n    /// Returns the timeout in milliseconds if there is some, otherwise returns `None`.\n    pub fn as_millis(\u0026self) -\u003e Option\u003cu32\u003e {\n        self.is_some().then_some(u32::try_from(self.0).unwrap())\n    }\n    /// Returns the timeout as a `Duration` if there is some, otherwise returns `None`.\n    pub fn duration(\u0026self) -\u003e Option\u003cDuration\u003e {\n        self.as_millis()\n            .map(|x| Duration::from_millis(u64::from(x)))\n    }\n}\n\n/// Error type for integer conversions into `PollTimeout`.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum PollTimeoutTryFromError {\n    /// Passing a value less than -1 is invalid on some systems, see\n    /// \u003chttps://man.freebsd.org/cgi/man.cgi?poll#end\u003e.\n    TooNegative,\n    /// Passing a value greater than `i32::MAX` is invalid.\n    TooPositive,\n}\n\nimpl std::fmt::Display for PollTimeoutTryFromError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::TooNegative =\u003e write!(f, \"Passed a negative timeout less than -1.\"),\n            Self::TooPositive =\u003e write!(f, \"Passed a positive timeout greater than `i32::MAX` milliseconds.\")\n        }\n    }\n}\n\nimpl std::error::Error for PollTimeoutTryFromError {}\n\nimpl\u003cT: Into\u003cPollTimeout\u003e\u003e From\u003cOption\u003cT\u003e\u003e for PollTimeout {\n    fn from(x: Option\u003cT\u003e) -\u003e Self {\n        x.map_or(Self::NONE, |x| x.into())\n    }\n}\nimpl TryFrom\u003cDuration\u003e for PollTimeout {\n    type Error = PollTimeoutTryFromError;\n    fn try_from(x: Duration) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        Ok(Self(\n            i32::try_from(x.as_millis())\n                .map_err(|_| PollTimeoutTryFromError::TooPositive)?,\n        ))\n    }\n}\nimpl TryFrom\u003cu128\u003e for PollTimeout {\n    type Error = PollTimeoutTryFromError;\n    fn try_from(x: u128) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        Ok(Self(\n            i32::try_from(x)\n                .map_err(|_| PollTimeoutTryFromError::TooPositive)?,\n        ))\n    }\n}\nimpl TryFrom\u003cu64\u003e for PollTimeout {\n    type Error = PollTimeoutTryFromError;\n    fn try_from(x: u64) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        Ok(Self(\n            i32::try_from(x)\n                .map_err(|_| PollTimeoutTryFromError::TooPositive)?,\n        ))\n    }\n}\nimpl TryFrom\u003cu32\u003e for PollTimeout {\n    type Error = PollTimeoutTryFromError;\n    fn try_from(x: u32) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        Ok(Self(\n            i32::try_from(x)\n                .map_err(|_| PollTimeoutTryFromError::TooPositive)?,\n        ))\n    }\n}\nimpl From\u003cu16\u003e for PollTimeout {\n    fn from(x: u16) -\u003e Self {\n        Self(i32::from(x))\n    }\n}\nimpl From\u003cu8\u003e for PollTimeout {\n    fn from(x: u8) -\u003e Self {\n        Self(i32::from(x))\n    }\n}\nimpl TryFrom\u003ci128\u003e for PollTimeout {\n    type Error = PollTimeoutTryFromError;\n    fn try_from(x: i128) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        match x {\n            ..=-2 =\u003e Err(PollTimeoutTryFromError::TooNegative),\n            -1.. =\u003e Ok(Self(\n                i32::try_from(x)\n                    .map_err(|_| PollTimeoutTryFromError::TooPositive)?,\n            )),\n        }\n    }\n}\nimpl TryFrom\u003ci64\u003e for PollTimeout {\n    type Error = PollTimeoutTryFromError;\n    fn try_from(x: i64) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        match x {\n            ..=-2 =\u003e Err(PollTimeoutTryFromError::TooNegative),\n            -1.. =\u003e Ok(Self(\n                i32::try_from(x)\n                    .map_err(|_| PollTimeoutTryFromError::TooPositive)?,\n            )),\n        }\n    }\n}\nimpl TryFrom\u003ci32\u003e for PollTimeout {\n    type Error = PollTimeoutTryFromError;\n    fn try_from(x: i32) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        match x {\n            ..=-2 =\u003e Err(PollTimeoutTryFromError::TooNegative),\n            -1.. =\u003e Ok(Self(x)),\n        }\n    }\n}\nimpl TryFrom\u003ci16\u003e for PollTimeout {\n    type Error = PollTimeoutTryFromError;\n    fn try_from(x: i16) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        match x {\n            ..=-2 =\u003e Err(PollTimeoutTryFromError::TooNegative),\n            -1.. =\u003e Ok(Self(i32::from(x))),\n        }\n    }\n}\nimpl TryFrom\u003ci8\u003e for PollTimeout {\n    type Error = PollTimeoutTryFromError;\n    fn try_from(x: i8) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        match x {\n            ..=-2 =\u003e Err(PollTimeoutTryFromError::TooNegative),\n            -1.. =\u003e Ok(Self(i32::from(x))),\n        }\n    }\n}\nimpl TryFrom\u003cPollTimeout\u003e for Duration {\n    type Error = ();\n    fn try_from(x: PollTimeout) -\u003e std::result::Result\u003cSelf, ()\u003e {\n        x.duration().ok_or(())\n    }\n}\nimpl TryFrom\u003cPollTimeout\u003e for u128 {\n    type Error = \u003cSelf as TryFrom\u003ci32\u003e\u003e::Error;\n    fn try_from(x: PollTimeout) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        Self::try_from(x.0)\n    }\n}\nimpl TryFrom\u003cPollTimeout\u003e for u64 {\n    type Error = \u003cSelf as TryFrom\u003ci32\u003e\u003e::Error;\n    fn try_from(x: PollTimeout) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        Self::try_from(x.0)\n    }\n}\nimpl TryFrom\u003cPollTimeout\u003e for u32 {\n    type Error = \u003cSelf as TryFrom\u003ci32\u003e\u003e::Error;\n    fn try_from(x: PollTimeout) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        Self::try_from(x.0)\n    }\n}\nimpl TryFrom\u003cPollTimeout\u003e for u16 {\n    type Error = \u003cSelf as TryFrom\u003ci32\u003e\u003e::Error;\n    fn try_from(x: PollTimeout) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        Self::try_from(x.0)\n    }\n}\nimpl TryFrom\u003cPollTimeout\u003e for u8 {\n    type Error = \u003cSelf as TryFrom\u003ci32\u003e\u003e::Error;\n    fn try_from(x: PollTimeout) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        Self::try_from(x.0)\n    }\n}\nimpl From\u003cPollTimeout\u003e for i128 {\n    fn from(x: PollTimeout) -\u003e Self {\n        Self::from(x.0)\n    }\n}\nimpl From\u003cPollTimeout\u003e for i64 {\n    fn from(x: PollTimeout) -\u003e Self {\n        Self::from(x.0)\n    }\n}\nimpl From\u003cPollTimeout\u003e for i32 {\n    fn from(x: PollTimeout) -\u003e Self {\n        x.0\n    }\n}\nimpl TryFrom\u003cPollTimeout\u003e for i16 {\n    type Error = \u003cSelf as TryFrom\u003ci32\u003e\u003e::Error;\n    fn try_from(x: PollTimeout) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        Self::try_from(x.0)\n    }\n}\nimpl TryFrom\u003cPollTimeout\u003e for i8 {\n    type Error = \u003cSelf as TryFrom\u003ci32\u003e\u003e::Error;\n    fn try_from(x: PollTimeout) -\u003e std::result::Result\u003cSelf, Self::Error\u003e {\n        Self::try_from(x.0)\n    }\n}\n","traces":[{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","acooks","mcr","nix-0.30.1","src","pty.rs"],"content":"//! Create master and slave virtual pseudo-terminals (PTYs)\n\npub use libc::pid_t as SessionId;\npub use libc::winsize as Winsize;\n\nuse std::ffi::CStr;\nuse std::io;\n#[cfg(not(target_os = \"aix\"))]\nuse std::mem;\nuse std::os::unix::prelude::*;\n\nuse crate::errno::Errno;\n#[cfg(not(target_os = \"aix\"))]\nuse crate::sys::termios::Termios;\n#[cfg(all(feature = \"process\", not(target_os = \"aix\")))]\nuse crate::unistd::Pid;\nuse crate::{fcntl, unistd, Result};\n\n/// Representation of a master/slave pty pair\n///\n/// This is returned by [`openpty`].\n#[derive(Debug)]\npub struct OpenptyResult {\n    /// The master port in a virtual pty pair\n    pub master: OwnedFd,\n    /// The slave port in a virtual pty pair\n    pub slave: OwnedFd,\n}\n\nfeature! {\n#![feature = \"process\"]\n/// A successful result of [`forkpty()`].\n#[derive(Debug)]\npub enum ForkptyResult {\n    /// This is the parent process of the underlying fork.\n    Parent {\n        /// The PID of the fork's child process\n        child: Pid,\n        /// A file descriptor referring to master side of the pseudoterminal of\n        /// the child process.\n        master: OwnedFd,\n    },\n    /// This is the child process of the underlying fork.\n    Child,\n}\n}\n\n/// Representation of the Master device in a master/slave pty pair\n///\n/// While this datatype is a thin wrapper around `OwnedFd`, it enforces that the available PTY\n/// functions are given the correct file descriptor.\n#[derive(Debug)]\npub struct PtyMaster(OwnedFd);\n\nimpl PtyMaster {\n    /// Constructs a `PytMaster` wrapping an existing `OwnedFd`.\n    ///\n    /// # Safety\n    ///\n    /// `OwnedFd` is a valid `PtyMaster`.\n    pub unsafe fn from_owned_fd(fd: OwnedFd) -\u003e Self {\n        Self(fd)\n    }\n}\n\nimpl AsRawFd for PtyMaster {\n    fn as_raw_fd(\u0026self) -\u003e RawFd {\n        self.0.as_raw_fd()\n    }\n}\n\nimpl AsFd for PtyMaster {\n    fn as_fd(\u0026self) -\u003e BorrowedFd\u003c'_\u003e {\n        self.0.as_fd()\n    }\n}\n\nimpl From\u003cPtyMaster\u003e for OwnedFd {\n    fn from(value: PtyMaster) -\u003e Self {\n        value.0\n    }\n}\n\nimpl IntoRawFd for PtyMaster {\n    fn into_raw_fd(self) -\u003e RawFd {\n        let fd = self.0;\n        fd.into_raw_fd()\n    }\n}\n\nimpl io::Read for PtyMaster {\n    fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e io::Result\u003cusize\u003e {\n        unistd::read(\u0026self.0, buf).map_err(io::Error::from)\n    }\n}\n\nimpl io::Write for PtyMaster {\n    fn write(\u0026mut self, buf: \u0026[u8]) -\u003e io::Result\u003cusize\u003e {\n        unistd::write(\u0026self.0, buf).map_err(io::Error::from)\n    }\n    fn flush(\u0026mut self) -\u003e io::Result\u003c()\u003e {\n        Ok(())\n    }\n}\n\nimpl io::Read for \u0026PtyMaster {\n    fn read(\u0026mut self, buf: \u0026mut [u8]) -\u003e io::Result\u003cusize\u003e {\n        unistd::read(\u0026self.0, buf).map_err(io::Error::from)\n    }\n}\n\nimpl io::Write for \u0026PtyMaster {\n    fn write(\u0026mut self, buf: \u0026[u8]) -\u003e io::Result\u003cusize\u003e {\n        unistd::write(\u0026self.0, buf).map_err(io::Error::from)\n    }\n    fn flush(\u0026mut self) -\u003e io::Result\u003c()\u003e {\n        Ok(())\n    }\n}\n\n/// Grant access to a slave pseudoterminal (see\n/// [`grantpt(3)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/grantpt.html))\n///\n/// `grantpt()` changes the mode and owner of the slave pseudoterminal device corresponding to the\n/// master pseudoterminal referred to by `fd`. This is a necessary step towards opening the slave.\n#[inline]\npub fn grantpt(fd: \u0026PtyMaster) -\u003e Result\u003c()\u003e {\n    if unsafe { libc::grantpt(fd.as_raw_fd()) } \u003c 0 {\n        return Err(Errno::last());\n    }\n\n    Ok(())\n}\n\n/// Open a pseudoterminal device (see\n/// [`posix_openpt(3)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_openpt.html))\n///\n/// `posix_openpt()` returns a file descriptor to an existing unused pseudoterminal master device.\n///\n/// # Examples\n///\n/// A common use case with this function is to open both a master and slave PTY pair. This can be\n/// done as follows:\n///\n/// ```\n/// use std::path::Path;\n/// use nix::fcntl::{OFlag, open};\n/// use nix::pty::{grantpt, posix_openpt, ptsname, unlockpt};\n/// use nix::sys::stat::Mode;\n///\n/// # #[allow(dead_code)]\n/// # fn run() -\u003e nix::Result\u003c()\u003e {\n/// // Open a new PTY master\n/// let master_fd = posix_openpt(OFlag::O_RDWR)?;\n///\n/// // Allow a slave to be generated for it\n/// grantpt(\u0026master_fd)?;\n/// unlockpt(\u0026master_fd)?;\n///\n/// // Get the name of the slave\n/// let slave_name = unsafe { ptsname(\u0026master_fd) }?;\n///\n/// // Try to open the slave\n/// let _slave_fd = open(Path::new(\u0026slave_name), OFlag::O_RDWR, Mode::empty())?;\n/// # Ok(())\n/// # }\n/// ```\n#[inline]\npub fn posix_openpt(flags: fcntl::OFlag) -\u003e Result\u003cPtyMaster\u003e {\n    let fd = unsafe { libc::posix_openpt(flags.bits()) };\n\n    if fd \u003c 0 {\n        return Err(Errno::last());\n    }\n\n    Ok(PtyMaster(unsafe { OwnedFd::from_raw_fd(fd) }))\n}\n\n/// Get the name of the slave pseudoterminal (see\n/// [`ptsname(3)`](https://man7.org/linux/man-pages/man3/ptsname.3.html))\n///\n/// `ptsname()` returns the name of the slave pseudoterminal device corresponding to the master\n/// referred to by `fd`.\n///\n/// This value is useful for opening the slave pty once the master has already been opened with\n/// `posix_openpt()`.\n///\n/// # Safety\n///\n/// `ptsname()` mutates global variables and is *not* threadsafe.\n/// Mutating global variables is always considered `unsafe` by Rust and this\n/// function is marked as `unsafe` to reflect that.\n///\n/// For a threadsafe and non-`unsafe` alternative on Linux, see `ptsname_r()`.\n#[inline]\npub unsafe fn ptsname(fd: \u0026PtyMaster) -\u003e Result\u003cString\u003e {\n    let name_ptr = unsafe { libc::ptsname(fd.as_raw_fd()) };\n    if name_ptr.is_null() {\n        return Err(Errno::last());\n    }\n\n    let name = unsafe { CStr::from_ptr(name_ptr) };\n    Ok(name.to_string_lossy().into_owned())\n}\n\n/// Get the name of the slave pseudoterminal (see\n/// [`ptsname(3)`](https://man7.org/linux/man-pages/man3/ptsname.3.html))\n///\n/// `ptsname_r()` returns the name of the slave pseudoterminal device corresponding to the master\n/// referred to by `fd`. This is the threadsafe version of `ptsname()`, but it is not part of the\n/// POSIX standard and is instead a Linux-specific extension.\n///\n/// This value is useful for opening the slave ptty once the master has already been opened with\n/// `posix_openpt()`.\n#[cfg(linux_android)]\n#[inline]\npub fn ptsname_r(fd: \u0026PtyMaster) -\u003e Result\u003cString\u003e {\n    let mut name_buf = Vec::\u003clibc::c_char\u003e::with_capacity(64);\n    let name_buf_ptr = name_buf.as_mut_ptr();\n    let cname = unsafe {\n        let cap = name_buf.capacity();\n        if libc::ptsname_r(fd.as_raw_fd(), name_buf_ptr, cap) != 0 {\n            return Err(crate::Error::last());\n        }\n        CStr::from_ptr(name_buf.as_ptr())\n    };\n\n    let name = cname.to_string_lossy().into_owned();\n    Ok(name)\n}\n\n/// Unlock a pseudoterminal master/slave pseudoterminal pair (see\n/// [`unlockpt(3)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/unlockpt.html))\n///\n/// `unlockpt()` unlocks the slave pseudoterminal device corresponding to the master pseudoterminal\n/// referred to by `fd`. This must be called before trying to open the slave side of a\n/// pseudoterminal.\n#[inline]\npub fn unlockpt(fd: \u0026PtyMaster) -\u003e Result\u003c()\u003e {\n    if unsafe { libc::unlockpt(fd.as_raw_fd()) } \u003c 0 {\n        return Err(Errno::last());\n    }\n\n    Ok(())\n}\n\n/// Create a new pseudoterminal, returning the slave and master file descriptors\n/// in `OpenptyResult`\n/// (see [`openpty`](https://man7.org/linux/man-pages/man3/openpty.3.html)).\n///\n/// If `winsize` is not `None`, the window size of the slave will be set to\n/// the values in `winsize`. If `termios` is not `None`, the pseudoterminal's\n/// terminal settings of the slave will be set to the values in `termios`.\n#[inline]\n#[cfg(not(target_os = \"aix\"))]\npub fn openpty\u003c\n    'a,\n    'b,\n    T: Into\u003cOption\u003c\u0026'a Winsize\u003e\u003e,\n    U: Into\u003cOption\u003c\u0026'b Termios\u003e\u003e,\n\u003e(\n    winsize: T,\n    termios: U,\n) -\u003e Result\u003cOpenptyResult\u003e {\n    use std::ptr;\n\n    let mut slave = mem::MaybeUninit::\u003clibc::c_int\u003e::uninit();\n    let mut master = mem::MaybeUninit::\u003clibc::c_int\u003e::uninit();\n    let ret = {\n        match (termios.into(), winsize.into()) {\n            (Some(termios), Some(winsize)) =\u003e {\n                let inner_termios = termios.get_libc_termios();\n                unsafe {\n                    libc::openpty(\n                        master.as_mut_ptr(),\n                        slave.as_mut_ptr(),\n                        ptr::null_mut(),\n                        \u0026*inner_termios as *const libc::termios as *mut _,\n                        winsize as *const Winsize as *mut _,\n                    )\n                }\n            }\n            (None, Some(winsize)) =\u003e unsafe {\n                libc::openpty(\n                    master.as_mut_ptr(),\n                    slave.as_mut_ptr(),\n                    ptr::null_mut(),\n                    ptr::null_mut(),\n                    winsize as *const Winsize as *mut _,\n                )\n            },\n            (Some(termios), None) =\u003e {\n                let inner_termios = termios.get_libc_termios();\n                unsafe {\n                    libc::openpty(\n                        master.as_mut_ptr(),\n                        slave.as_mut_ptr(),\n                        ptr::null_mut(),\n                        \u0026*inner_termios as *const libc::termios as *mut _,\n                        ptr::null_mut(),\n                    )\n                }\n            }\n            (None, None) =\u003e unsafe {\n                libc::openpty(\n                    master.as_mut_ptr(),\n                    slave.as_mut_ptr(),\n                    ptr::null_mut(),\n                    ptr::null_mut(),\n                    ptr::null_mut(),\n                )\n            },\n        }\n    };\n\n    Errno::result(ret)?;\n\n    unsafe {\n        Ok(OpenptyResult {\n            master: OwnedFd::from_raw_fd(master.assume_init()),\n            slave: OwnedFd::from_raw_fd(slave.assume_init()),\n        })\n    }\n}\n\nfeature! {\n#![feature = \"process\"]\n/// Create a new process operating in a pseudoterminal.\n///\n/// If `winsize` is not `None`, the window size of the slave will be set to\n/// the values in `winsize`. If `termios` is not `None`, the pseudoterminal's\n/// terminal settings of the slave will be set to the values in `termios`.\n///\n/// # Safety\n///\n/// In a multithreaded program, only [async-signal-safe] functions like `pause`\n/// and `_exit` may be called by the child (the parent isn't restricted) until\n/// a call of `execve(2)`. Note that memory allocation may **not** be\n/// async-signal-safe and thus must be prevented.\n///\n/// Those functions are only a small subset of your operating system's API, so\n/// special care must be taken to only invoke code you can control and audit.\n///\n/// [async-signal-safe]: https://man7.org/linux/man-pages/man7/signal-safety.7.html\n///\n/// # Reference\n///\n/// * [FreeBSD](https://man.freebsd.org/cgi/man.cgi?query=forkpty)\n/// * [Linux](https://man7.org/linux/man-pages/man3/forkpty.3.html)\n#[cfg(not(target_os = \"aix\"))]\npub unsafe fn forkpty\u003c'a, 'b, T: Into\u003cOption\u003c\u0026'a Winsize\u003e\u003e, U: Into\u003cOption\u003c\u0026'b Termios\u003e\u003e\u003e(\n    winsize: T,\n    termios: U,\n) -\u003e Result\u003cForkptyResult\u003e {\n    use std::ptr;\n\n    let mut master = mem::MaybeUninit::\u003clibc::c_int\u003e::uninit();\n\n    let term = match termios.into() {\n        Some(termios) =\u003e {\n            let inner_termios = termios.get_libc_termios();\n            \u0026*inner_termios as *const libc::termios as *mut _\n        },\n        None =\u003e ptr::null_mut(),\n    };\n\n    let win = winsize\n        .into()\n        .map(|ws| ws as *const Winsize as *mut _)\n        .unwrap_or(ptr::null_mut());\n\n    let res = unsafe { libc::forkpty(master.as_mut_ptr(), ptr::null_mut(), term, win) };\n\n    let success_ret = Errno::result(res)?;\n    let forkpty_result = match success_ret {\n        // In the child process\n        0 =\u003e ForkptyResult::Child,\n        // In the parent process\n        child_pid =\u003e {\n            // SAFETY:\n            // 1. The master buffer is guaranteed to be initialized in the parent process\n            // 2. OwnedFd::from_raw_fd won't panic as the fd is a valid file descriptor\n            let master = unsafe { OwnedFd::from_raw_fd( master.assume_init() ) };\n            ForkptyResult::Parent {\n                    master,\n                    child: Pid::from_raw(child_pid),\n            }\n        }\n    };\n\n    Ok(forkpty_result)\n}\n}\n","traces":[{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":60},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sched.rs"],"content":"//! Execution scheduling\n//!\n//! See Also\n//! [sched.h](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sched.h.html)\nuse crate::{Errno, Result};\n\n#[cfg(linux_android)]\npub use self::sched_linux_like::*;\n\n#[cfg(linux_android)]\nmod sched_linux_like {\n    use crate::errno::Errno;\n    use crate::unistd::Pid;\n    use crate::Result;\n    use libc::{self, c_int, c_void};\n    use std::mem;\n    use std::option::Option;\n    use std::os::unix::io::{AsFd, AsRawFd};\n\n    // For some functions taking with a parameter of type CloneFlags,\n    // only a subset of these flags have an effect.\n    libc_bitflags! {\n        /// Options for use with [`clone`]\n        pub struct CloneFlags: c_int {\n            /// The calling process and the child process run in the same\n            /// memory space.\n            CLONE_VM;\n            /// The caller and the child process share the same  filesystem\n            /// information.\n            CLONE_FS;\n            /// The calling process and the child process share the same file\n            /// descriptor table.\n            CLONE_FILES;\n            /// The calling process and the child process share the same table\n            /// of signal handlers.\n            CLONE_SIGHAND;\n            /// If the calling process is being traced, then trace the child\n            /// also.\n            CLONE_PTRACE;\n            /// The execution of the calling process is suspended until the\n            /// child releases its virtual memory resources via a call to\n            /// execve(2) or _exit(2) (as with vfork(2)).\n            CLONE_VFORK;\n            /// The parent of the new child  (as returned by getppid(2))\n            /// will be the same as that of the calling process.\n            CLONE_PARENT;\n            /// The child is placed in the same thread group as the calling\n            /// process.\n            CLONE_THREAD;\n            /// The cloned child is started in a new mount namespace.\n            CLONE_NEWNS;\n            /// The child and the calling process share a single list of System\n            /// V semaphore adjustment values\n            CLONE_SYSVSEM;\n            // Not supported by Nix due to lack of varargs support in Rust FFI\n            // CLONE_SETTLS;\n            // Not supported by Nix due to lack of varargs support in Rust FFI\n            // CLONE_PARENT_SETTID;\n            // Not supported by Nix due to lack of varargs support in Rust FFI\n            // CLONE_CHILD_CLEARTID;\n            /// Unused since Linux 2.6.2\n            #[deprecated(since = \"0.23.0\", note = \"Deprecated by Linux 2.6.2\")]\n            CLONE_DETACHED;\n            /// A tracing process cannot force `CLONE_PTRACE` on this child\n            /// process.\n            CLONE_UNTRACED;\n            // Not supported by Nix due to lack of varargs support in Rust FFI\n            // CLONE_CHILD_SETTID;\n            /// Create the process in a new cgroup namespace.\n            CLONE_NEWCGROUP;\n            /// Create the process in a new UTS namespace.\n            CLONE_NEWUTS;\n            /// Create the process in a new IPC namespace.\n            CLONE_NEWIPC;\n            /// Create the process in a new user namespace.\n            CLONE_NEWUSER;\n            /// Create the process in a new PID namespace.\n            CLONE_NEWPID;\n            /// Create the process in a new network namespace.\n            CLONE_NEWNET;\n            /// The new process shares an I/O context with the calling process.\n            CLONE_IO;\n        }\n    }\n\n    /// Type for the function executed by [`clone`].\n    pub type CloneCb\u003c'a\u003e = Box\u003cdyn FnMut() -\u003e isize + 'a\u003e;\n\n    /// `clone` create a child process\n    /// ([`clone(2)`](https://man7.org/linux/man-pages/man2/clone.2.html))\n    ///\n    /// `stack` is a reference to an array which will hold the stack of the new\n    /// process.  Unlike when calling `clone(2)` from C, the provided stack\n    /// address need not be the highest address of the region.  Nix will take\n    /// care of that requirement.  The user only needs to provide a reference to\n    /// a normally allocated buffer.\n    ///\n    /// # Safety\n    ///\n    /// Because `clone` creates a child process with its stack located in\n    /// `stack` without specifying the size of the stack, special care must be\n    /// taken to ensure that the child process does not overflow the provided\n    /// stack space.\n    ///\n    /// See [`fork`](crate::unistd::fork) for additional safety concerns related\n    /// to executing child processes.\n    pub unsafe fn clone(\n        mut cb: CloneCb,\n        stack: \u0026mut [u8],\n        flags: CloneFlags,\n        signal: Option\u003cc_int\u003e,\n    ) -\u003e Result\u003cPid\u003e {\n        extern \"C\" fn callback(data: *mut CloneCb) -\u003e c_int {\n            let cb: \u0026mut CloneCb = unsafe { \u0026mut *data };\n            (*cb)() as c_int\n        }\n\n        let combined = flags.bits() | signal.unwrap_or(0);\n        let res = unsafe {\n            let ptr = stack.as_mut_ptr().add(stack.len());\n            let ptr_aligned = ptr.sub(ptr as usize % 16);\n            libc::clone(\n                mem::transmute::\u003c\n                    extern \"C\" fn(*mut Box\u003cdyn FnMut() -\u003e isize\u003e) -\u003e i32,\n                    extern \"C\" fn(*mut libc::c_void) -\u003e i32,\n                \u003e(\n                    callback\n                        as extern \"C\" fn(*mut Box\u003cdyn FnMut() -\u003e isize\u003e) -\u003e i32,\n                ),\n                ptr_aligned as *mut c_void,\n                combined,\n                \u0026mut cb as *mut _ as *mut c_void,\n            )\n        };\n\n        Errno::result(res).map(Pid::from_raw)\n    }\n\n    /// disassociate parts of the process execution context\n    ///\n    /// See also [unshare(2)](https://man7.org/linux/man-pages/man2/unshare.2.html)\n    pub fn unshare(flags: CloneFlags) -\u003e Result\u003c()\u003e {\n        let res = unsafe { libc::unshare(flags.bits()) };\n\n        Errno::result(res).map(drop)\n    }\n\n    /// reassociate thread with a namespace\n    ///\n    /// See also [setns(2)](https://man7.org/linux/man-pages/man2/setns.2.html)\n    pub fn setns\u003cFd: AsFd\u003e(fd: Fd, nstype: CloneFlags) -\u003e Result\u003c()\u003e {\n        let res = unsafe { libc::setns(fd.as_fd().as_raw_fd(), nstype.bits()) };\n\n        Errno::result(res).map(drop)\n    }\n}\n\n#[cfg(any(linux_android, freebsdlike))]\npub use self::sched_affinity::*;\n\n#[cfg(any(linux_android, freebsdlike))]\nmod sched_affinity {\n    use crate::errno::Errno;\n    use crate::unistd::Pid;\n    use crate::Result;\n    use std::mem;\n\n    /// CpuSet represent a bit-mask of CPUs.\n    /// CpuSets are used by sched_setaffinity and\n    /// sched_getaffinity for example.\n    ///\n    /// This is a wrapper around `libc::cpu_set_t`.\n    #[repr(transparent)]\n    #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\n    pub struct CpuSet {\n        #[cfg(not(target_os = \"freebsd\"))]\n        cpu_set: libc::cpu_set_t,\n        #[cfg(target_os = \"freebsd\")]\n        cpu_set: libc::cpuset_t,\n    }\n\n    impl CpuSet {\n        /// Create a new and empty CpuSet.\n        pub fn new() -\u003e CpuSet {\n            CpuSet {\n                cpu_set: unsafe { mem::zeroed() },\n            }\n        }\n\n        /// Test to see if a CPU is in the CpuSet.\n        /// `field` is the CPU id to test\n        pub fn is_set(\u0026self, field: usize) -\u003e Result\u003cbool\u003e {\n            if field \u003e= CpuSet::count() {\n                Err(Errno::EINVAL)\n            } else {\n                Ok(unsafe { libc::CPU_ISSET(field, \u0026self.cpu_set) })\n            }\n        }\n\n        /// Add a CPU to CpuSet.\n        /// `field` is the CPU id to add\n        pub fn set(\u0026mut self, field: usize) -\u003e Result\u003c()\u003e {\n            if field \u003e= CpuSet::count() {\n                Err(Errno::EINVAL)\n            } else {\n                unsafe {\n                    libc::CPU_SET(field, \u0026mut self.cpu_set);\n                }\n                Ok(())\n            }\n        }\n\n        /// Remove a CPU from CpuSet.\n        /// `field` is the CPU id to remove\n        pub fn unset(\u0026mut self, field: usize) -\u003e Result\u003c()\u003e {\n            if field \u003e= CpuSet::count() {\n                Err(Errno::EINVAL)\n            } else {\n                unsafe {\n                    libc::CPU_CLR(field, \u0026mut self.cpu_set);\n                }\n                Ok(())\n            }\n        }\n\n        /// Return the maximum number of CPU in CpuSet\n        pub const fn count() -\u003e usize {\n            #[cfg(not(target_os = \"freebsd\"))]\n            let bytes = mem::size_of::\u003clibc::cpu_set_t\u003e();\n            #[cfg(target_os = \"freebsd\")]\n            let bytes = mem::size_of::\u003clibc::cpuset_t\u003e();\n\n            8 * bytes\n        }\n    }\n\n    impl Default for CpuSet {\n        fn default() -\u003e Self {\n            Self::new()\n        }\n    }\n\n    /// `sched_setaffinity` set a thread's CPU affinity mask\n    /// ([`sched_setaffinity(2)`](https://man7.org/linux/man-pages/man2/sched_setaffinity.2.html))\n    ///\n    /// `pid` is the thread ID to update.\n    /// If pid is zero, then the calling thread is updated.\n    ///\n    /// The `cpuset` argument specifies the set of CPUs on which the thread\n    /// will be eligible to run.\n    ///\n    /// # Example\n    ///\n    /// Binding the current thread to CPU 0 can be done as follows:\n    ///\n    /// ```rust,no_run\n    /// use nix::sched::{CpuSet, sched_setaffinity};\n    /// use nix::unistd::Pid;\n    ///\n    /// let mut cpu_set = CpuSet::new();\n    /// cpu_set.set(0).unwrap();\n    /// sched_setaffinity(Pid::from_raw(0), \u0026cpu_set).unwrap();\n    /// ```\n    pub fn sched_setaffinity(pid: Pid, cpuset: \u0026CpuSet) -\u003e Result\u003c()\u003e {\n        let res = unsafe {\n            libc::sched_setaffinity(\n                pid.into(),\n                mem::size_of::\u003cCpuSet\u003e() as libc::size_t,\n                \u0026cpuset.cpu_set,\n            )\n        };\n\n        Errno::result(res).map(drop)\n    }\n\n    /// `sched_getaffinity` get a thread's CPU affinity mask\n    /// ([`sched_getaffinity(2)`](https://man7.org/linux/man-pages/man2/sched_getaffinity.2.html))\n    ///\n    /// `pid` is the thread ID to check.\n    /// If pid is zero, then the calling thread is checked.\n    ///\n    /// Returned `cpuset` is the set of CPUs on which the thread\n    /// is eligible to run.\n    ///\n    /// # Example\n    ///\n    /// Checking if the current thread can run on CPU 0 can be done as follows:\n    ///\n    /// ```rust,no_run\n    /// use nix::sched::sched_getaffinity;\n    /// use nix::unistd::Pid;\n    ///\n    /// let cpu_set = sched_getaffinity(Pid::from_raw(0)).unwrap();\n    /// if cpu_set.is_set(0).unwrap() {\n    ///     println!(\"Current thread can run on CPU 0\");\n    /// }\n    /// ```\n    pub fn sched_getaffinity(pid: Pid) -\u003e Result\u003cCpuSet\u003e {\n        let mut cpuset = CpuSet::new();\n        let res = unsafe {\n            libc::sched_getaffinity(\n                pid.into(),\n                mem::size_of::\u003cCpuSet\u003e() as libc::size_t,\n                \u0026mut cpuset.cpu_set,\n            )\n        };\n\n        Errno::result(res).and(Ok(cpuset))\n    }\n\n    /// Determines the CPU on which the calling thread is running.\n    pub fn sched_getcpu() -\u003e Result\u003cusize\u003e {\n        let res = unsafe { libc::sched_getcpu() };\n\n        Errno::result(res).map(|int| int as usize)\n    }\n}\n\n/// Explicitly yield the processor to other threads.\n///\n/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/sched_yield.html)\npub fn sched_yield() -\u003e Result\u003c()\u003e {\n    let res = unsafe { libc::sched_yield() };\n\n    Errno::result(res).map(drop)\n}\n","traces":[{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","acooks","mcr","nix-0.30.1","src","spawn.rs"],"content":"//! Safe wrappers around posix_spawn* functions found in the libc \"spawn.h\" header.\n\nuse std::{ffi::CStr, mem, os::fd::RawFd};\n\n#[cfg(any(feature = \"fs\", feature = \"term\"))]\nuse crate::fcntl::OFlag;\n#[cfg(feature = \"signal\")]\nuse crate::sys::signal::SigSet;\n#[cfg(feature = \"fs\")]\nuse crate::sys::stat::Mode;\nuse crate::{errno::Errno, unistd::Pid, NixPath, Result};\n\n/// A spawn attributes object. See [posix_spawnattr_t](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawnattr_init.html).\n#[repr(transparent)]\n#[derive(Debug)]\npub struct PosixSpawnAttr {\n    attr: libc::posix_spawnattr_t,\n}\n\nimpl PosixSpawnAttr {\n    /// Initialize the spawn attributes object. See\n    /// [posix_spawnattr_init](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawnattr_init.html).\n    #[doc(alias(\"posix_spawnattr_init\"))]\n    pub fn init() -\u003e Result\u003cPosixSpawnAttr\u003e {\n        let mut attr = mem::MaybeUninit::uninit();\n        let res = unsafe { libc::posix_spawnattr_init(attr.as_mut_ptr()) };\n\n        Errno::result(res)?;\n\n        let attr = unsafe { attr.assume_init() };\n        Ok(PosixSpawnAttr { attr })\n    }\n\n    /// Reinitialize the spawn attributes object.\n    /// This is a wrapper around\n    /// [posix_spawnattr_destroy](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawnattr_destroy.html)\n    /// followed by\n    /// [posix_spawnattr_init](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawnattr_init.html).\n    #[doc(alias(\"posix_spawnattr_destroy\"))]\n    pub fn reinit(mut self) -\u003e Result\u003cPosixSpawnAttr\u003e {\n        let res = unsafe {\n            libc::posix_spawnattr_destroy(\n                \u0026mut self.attr as *mut libc::posix_spawnattr_t,\n            )\n        };\n        Errno::result(res)?;\n\n        let res = unsafe {\n            libc::posix_spawnattr_init(\n                \u0026mut self.attr as *mut libc::posix_spawnattr_t,\n            )\n        };\n        Errno::result(res)?;\n\n        Ok(self)\n    }\n\n    /// Set spawn flags. See\n    /// [posix_spawnattr_setflags](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawnattr_setflags.html).\n    #[doc(alias(\"posix_spawnattr_setflags\"))]\n    pub fn set_flags(\u0026mut self, flags: PosixSpawnFlags) -\u003e Result\u003c()\u003e {\n        let res = unsafe {\n            libc::posix_spawnattr_setflags(\n                \u0026mut self.attr as *mut libc::posix_spawnattr_t,\n                flags.bits() as libc::c_short,\n            )\n        };\n        Errno::result(res)?;\n\n        Ok(())\n    }\n\n    /// Get spawn flags. See\n    /// [posix_spawnattr_getflags](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawnattr_getflags.html).\n    #[doc(alias(\"posix_spawnattr_getflags\"))]\n    pub fn flags(\u0026self) -\u003e Result\u003cPosixSpawnFlags\u003e {\n        let mut flags: libc::c_short = 0;\n        let res = unsafe {\n            libc::posix_spawnattr_getflags(\n                \u0026self.attr as *const libc::posix_spawnattr_t,\n                \u0026mut flags,\n            )\n        };\n        Errno::result(res)?;\n\n        Ok(PosixSpawnFlags::from_bits_truncate(flags.into()))\n    }\n\n    /// Set spawn pgroup. See\n    /// [posix_spawnattr_setpgroup](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawnattr_setpgroup.html).\n    #[doc(alias(\"posix_spawnattr_setpgroup\"))]\n    pub fn set_pgroup(\u0026mut self, pgroup: Pid) -\u003e Result\u003c()\u003e {\n        let res = unsafe {\n            libc::posix_spawnattr_setpgroup(\n                \u0026mut self.attr as *mut libc::posix_spawnattr_t,\n                pgroup.as_raw(),\n            )\n        };\n        Errno::result(res)?;\n\n        Ok(())\n    }\n\n    /// Get spawn pgroup. See\n    /// [posix_spawnattr_getpgroup](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawnattr_getpgroup.html).\n    #[doc(alias(\"posix_spawnattr_getpgroup\"))]\n    pub fn pgroup(\u0026self) -\u003e Result\u003cPid\u003e {\n        let mut pid: libc::pid_t = 0;\n\n        let res = unsafe {\n            libc::posix_spawnattr_getpgroup(\n                \u0026self.attr as *const libc::posix_spawnattr_t,\n                \u0026mut pid,\n            )\n        };\n        Errno::result(res)?;\n\n        Ok(Pid::from_raw(pid))\n    }\n\n    feature! {\n    #![feature = \"signal\"]\n    /// Set spawn sigdefault. See\n    /// [posix_spawnattr_setsigdefault](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawnattr_setsigdefault.html).\n    #[doc(alias(\"posix_spawnattr_setsigdefault\"))]\n    pub fn set_sigdefault(\u0026mut self, sigdefault: \u0026SigSet) -\u003e Result\u003c()\u003e {\n        let res = unsafe {\n            libc::posix_spawnattr_setsigdefault(\n                \u0026mut self.attr as *mut libc::posix_spawnattr_t,\n                sigdefault.as_ref(),\n            )\n        };\n        Errno::result(res)?;\n\n        Ok(())\n    }\n\n    /// Get spawn sigdefault. See\n    /// [posix_spawnattr_getsigdefault](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawnattr_getsigdefault.html).\n    #[doc(alias(\"posix_spawnattr_getsigdefault\"))]\n    pub fn sigdefault(\u0026self) -\u003e Result\u003cSigSet\u003e {\n        let mut sigset = mem::MaybeUninit::uninit();\n\n        let res = unsafe {\n            libc::posix_spawnattr_getsigdefault(\n                \u0026self.attr as *const libc::posix_spawnattr_t,\n                sigset.as_mut_ptr(),\n            )\n        };\n        Errno::result(res)?;\n\n        let sigdefault =\n            unsafe { SigSet::from_sigset_t_unchecked(sigset.assume_init()) };\n        Ok(sigdefault)\n    }\n\n    /// Set spawn sigmask. See\n    /// [posix_spawnattr_setsigmask](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawnattr_setsigmask.html).\n    #[doc(alias(\"posix_spawnattr_setsigmask\"))]\n    pub fn set_sigmask(\u0026mut self, sigdefault: \u0026SigSet) -\u003e Result\u003c()\u003e {\n        let res = unsafe {\n            libc::posix_spawnattr_setsigmask(\n                \u0026mut self.attr as *mut libc::posix_spawnattr_t,\n                sigdefault.as_ref(),\n            )\n        };\n        Errno::result(res)?;\n\n        Ok(())\n    }\n\n    /// Get spawn sigmask. See\n    /// [posix_spawnattr_getsigmask](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawnattr_getsigmask.html).\n    #[doc(alias(\"posix_spawnattr_getsigmask\"))]\n    pub fn sigmask(\u0026self) -\u003e Result\u003cSigSet\u003e {\n        let mut sigset = mem::MaybeUninit::uninit();\n\n        let res = unsafe {\n            libc::posix_spawnattr_getsigmask(\n                \u0026self.attr as *const libc::posix_spawnattr_t,\n                sigset.as_mut_ptr(),\n            )\n        };\n        Errno::result(res)?;\n\n        let sigdefault =\n            unsafe { SigSet::from_sigset_t_unchecked(sigset.assume_init()) };\n        Ok(sigdefault)\n    }\n    }\n}\n\nimpl Drop for PosixSpawnAttr {\n    fn drop(\u0026mut self) {\n        unsafe {\n            libc::posix_spawnattr_destroy(\n                \u0026mut self.attr as *mut libc::posix_spawnattr_t,\n            );\n        }\n    }\n}\n\nlibc_bitflags!(\n    /// Process attributes to be changed in the new process image when invoking [`posix_spawn`]\n    /// or [`posix_spawnp`]. See\n    /// [posix_spawn](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawn.html).\n    pub struct PosixSpawnFlags: libc::c_int {\n        /// Reset effective user ID of the child process to parent's real user ID.\n        POSIX_SPAWN_RESETIDS;\n        /// Put the child in a process group specified by the spawn-pgroup attribute. See\n        /// [posix_spawnattr_setpgroup](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawnattr_setpgroup.html).\n        POSIX_SPAWN_SETPGROUP;\n        /// Force set signals to default signal handling in child process. See\n        /// [posix_spawnattr_setsigdefault](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawnattr_setsigdefault.html).\n        #[cfg(feature = \"signal\")]\n        POSIX_SPAWN_SETSIGDEF;\n        /// Set signal mask of child process. See\n        /// [posix_spawnattr_setsigmask](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawnattr_setsigmask.html).\n        #[cfg(feature = \"signal\")]\n        POSIX_SPAWN_SETSIGMASK;\n        // TODO: Add support for the following two flags whenever support for\n        // https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sched.h.html\n        // is added to nix.\n        // POSIX_SPAWN_SETSCHEDPARAM;\n        // POSIX_SPAWN_SETSCHEDULER;\n    }\n);\n\n/// A spawn file actions object. See [posix_spawn_file_actions_t](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawn_file_actions_addclose.html).\n#[repr(transparent)]\n#[derive(Debug)]\npub struct PosixSpawnFileActions {\n    fa: libc::posix_spawn_file_actions_t,\n}\n\nimpl PosixSpawnFileActions {\n    /// Initialize the spawn file actions object. See\n    /// [posix_spawn_file_actions_init](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawn_file_actions_init.html).\n    #[doc(alias(\"posix_spawn_file_actions_init\"))]\n    pub fn init() -\u003e Result\u003cPosixSpawnFileActions\u003e {\n        let mut actions = mem::MaybeUninit::uninit();\n        let res = unsafe {\n            libc::posix_spawn_file_actions_init(actions.as_mut_ptr())\n        };\n        Errno::result(res)?;\n        Ok(unsafe {\n            PosixSpawnFileActions {\n                fa: actions.assume_init(),\n            }\n        })\n    }\n\n    /// Reinitialize the spawn file actions object.\n    /// This is a wrapper around\n    /// [posix_spawn_file_actions_destroy](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawn_file_actions_destroy.html).\n    /// followed by\n    /// [posix_spawn_file_actions_init](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawn_file_actions_init.html).\n    #[doc(alias(\"posix_spawn_file_actions_destroy\"))]\n    pub fn reinit(mut self) -\u003e Result\u003cPosixSpawnFileActions\u003e {\n        let res = unsafe {\n            libc::posix_spawn_file_actions_destroy(\n                \u0026mut self.fa as *mut libc::posix_spawn_file_actions_t,\n            )\n        };\n        Errno::result(res)?;\n\n        let res = unsafe {\n            libc::posix_spawn_file_actions_init(\n                \u0026mut self.fa as *mut libc::posix_spawn_file_actions_t,\n            )\n        };\n        Errno::result(res)?;\n\n        Ok(self)\n    }\n\n    /// Add a [dup2](https://pubs.opengroup.org/onlinepubs/9699919799/functions/dup2.html) action. See\n    /// [posix_spawn_file_actions_adddup2](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawn_file_actions_adddup2.html).\n    #[doc(alias(\"posix_spawn_file_actions_adddup2\"))]\n    pub fn add_dup2(\u0026mut self, fd: RawFd, newfd: RawFd) -\u003e Result\u003c()\u003e {\n        let res = unsafe {\n            libc::posix_spawn_file_actions_adddup2(\n                \u0026mut self.fa as *mut libc::posix_spawn_file_actions_t,\n                fd,\n                newfd,\n            )\n        };\n        Errno::result(res)?;\n\n        Ok(())\n    }\n\n    feature! {\n    #![all(feature = \"fs\", feature = \"term\")]\n    /// Add an open action. See\n    /// [posix_spawn_file_actions_addopen](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawn_file_actions_addopen.html).\n    #[doc(alias(\"posix_spawn_file_actions_addopen\"))]\n    pub fn add_open\u003cP: ?Sized + NixPath\u003e(\n        \u0026mut self,\n        fd: RawFd,\n        path: \u0026P,\n        oflag: OFlag,\n        mode: Mode,\n    ) -\u003e Result\u003c()\u003e {\n        let res = path.with_nix_path(|cstr| unsafe {\n            libc::posix_spawn_file_actions_addopen(\n                \u0026mut self.fa as *mut libc::posix_spawn_file_actions_t,\n                fd,\n                cstr.as_ptr(),\n                oflag.bits(),\n                mode.bits(),\n            )\n        })?;\n        Errno::result(res)?;\n\n        Ok(())\n    }\n    }\n\n    /// Add a close action. See\n    /// [posix_spawn_file_actions_addclose](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawn_file_actions_addclose.html).\n    #[doc(alias(\"posix_spawn_file_actions_addclose\"))]\n    pub fn add_close(\u0026mut self, fd: RawFd) -\u003e Result\u003c()\u003e {\n        let res = unsafe {\n            libc::posix_spawn_file_actions_addclose(\n                \u0026mut self.fa as *mut libc::posix_spawn_file_actions_t,\n                fd,\n            )\n        };\n        Errno::result(res)?;\n\n        Ok(())\n    }\n}\n\nimpl Drop for PosixSpawnFileActions {\n    fn drop(\u0026mut self) {\n        unsafe {\n            libc::posix_spawn_file_actions_destroy(\n                \u0026mut self.fa as *mut libc::posix_spawn_file_actions_t,\n            );\n        }\n    }\n}\n\n// The POSIX standard requires those `args` and `envp` to be of type `*const *mut [c_char]`,\n// but implementations won't modify them, making the `mut` type redundant. Considering this,\n// Nix does not expose this mutability, but we have to change the interface when calling the\n// underlying libc interfaces , this helper function does the conversion job.\n//\n// SAFETY:\n// It is safe to add the mutability in types as implementations won't mutable them.\nunsafe fn to_exec_array\u003cS: AsRef\u003cCStr\u003e\u003e(args: \u0026[S]) -\u003e Vec\u003c*mut libc::c_char\u003e {\n    let mut v: Vec\u003c*mut libc::c_char\u003e = args\n        .iter()\n        .map(|s| s.as_ref().as_ptr().cast_mut())\n        .collect();\n    v.push(std::ptr::null_mut());\n    v\n}\n\n/// Create a new child process from the specified process image. See\n/// [posix_spawn](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawn.html).\npub fn posix_spawn\u003cP, SA, SE\u003e(\n    path: \u0026P,\n    file_actions: \u0026PosixSpawnFileActions,\n    attr: \u0026PosixSpawnAttr,\n    args: \u0026[SA],\n    envp: \u0026[SE],\n) -\u003e Result\u003cPid\u003e\nwhere\n    P: NixPath + ?Sized,\n    SA: AsRef\u003cCStr\u003e,\n    SE: AsRef\u003cCStr\u003e,\n{\n    let mut pid = 0;\n\n    let ret = unsafe {\n        let args_p = to_exec_array(args);\n        let env_p = to_exec_array(envp);\n\n        path.with_nix_path(|c_str| {\n            libc::posix_spawn(\n                \u0026mut pid as *mut libc::pid_t,\n                c_str.as_ptr(),\n                \u0026file_actions.fa as *const libc::posix_spawn_file_actions_t,\n                \u0026attr.attr as *const libc::posix_spawnattr_t,\n                args_p.as_ptr(),\n                env_p.as_ptr(),\n            )\n        })?\n    };\n\n    if ret != 0 {\n        return Err(Errno::from_raw(ret));\n    }\n\n    Ok(Pid::from_raw(pid))\n}\n\n/// Create a new child process from the specified process image. See\n/// [posix_spawnp](https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawnp.html).\npub fn posix_spawnp\u003cSA: AsRef\u003cCStr\u003e, SE: AsRef\u003cCStr\u003e\u003e(\n    path: \u0026CStr,\n    file_actions: \u0026PosixSpawnFileActions,\n    attr: \u0026PosixSpawnAttr,\n    args: \u0026[SA],\n    envp: \u0026[SE],\n) -\u003e Result\u003cPid\u003e {\n    let mut pid = 0;\n\n    let ret = unsafe {\n        let args_p = to_exec_array(args);\n        let env_p = to_exec_array(envp);\n\n        libc::posix_spawnp(\n            \u0026mut pid as *mut libc::pid_t,\n            path.as_ptr(),\n            \u0026file_actions.fa as *const libc::posix_spawn_file_actions_t,\n            \u0026attr.attr as *const libc::posix_spawnattr_t,\n            args_p.as_ptr(),\n            env_p.as_ptr(),\n        )\n    };\n\n    if ret != 0 {\n        return Err(Errno::from_raw(ret));\n    }\n\n    Ok(Pid::from_raw(pid))\n}\n","traces":[{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":31},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","aio.rs"],"content":"// vim: tw=80\n//! POSIX Asynchronous I/O\n//!\n//! The POSIX AIO interface is used for asynchronous I/O on files and disk-like\n//! devices.  It supports [`read`](struct.AioRead.html#method.new),\n//! [`write`](struct.AioWrite.html#method.new),\n//! [`fsync`](struct.AioFsync.html#method.new),\n//! [`readv`](struct.AioReadv.html#method.new), and\n//! [`writev`](struct.AioWritev.html#method.new), operations, subject to\n//! platform support.  Completion\n//! notifications can optionally be delivered via\n//! [signals](../signal/enum.SigevNotify.html#variant.SigevSignal), via the\n//! [`aio_suspend`](fn.aio_suspend.html) function, or via polling.  Some\n//! platforms support other completion\n//! notifications, such as\n//! [kevent](../signal/enum.SigevNotify.html#variant.SigevKevent).\n//!\n//! Multiple operations may be submitted in a batch with\n//! [`lio_listio`](fn.lio_listio.html), though the standard does not guarantee\n//! that they will be executed atomically.\n//!\n//! Outstanding operations may be cancelled with\n//! [`cancel`](trait.Aio.html#method.cancel) or\n//! [`aio_cancel_all`](fn.aio_cancel_all.html), though the operating system may\n//! not support this for all filesystems and devices.\n#[cfg(target_os = \"freebsd\")]\nuse std::io::{IoSlice, IoSliceMut};\nuse std::{\n    convert::TryFrom,\n    fmt::{self, Debug},\n    marker::{PhantomData, PhantomPinned},\n    mem,\n    os::unix::io::{AsFd, AsRawFd, BorrowedFd},\n    pin::Pin,\n    ptr, thread,\n};\n\nuse libc::off_t;\nuse pin_utils::unsafe_pinned;\n\nuse crate::{\n    errno::Errno,\n    sys::{signal::*, time::TimeSpec},\n    Result,\n};\n\nlibc_enum! {\n    /// Mode for `AioCb::fsync`.  Controls whether only data or both data and\n    /// metadata are synced.\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum AioFsyncMode {\n        /// do it like `fsync`\n        O_SYNC,\n        /// on supported operating systems only, do it like `fdatasync`\n        #[cfg(any(apple_targets,\n                  target_os = \"linux\",\n                  target_os = \"freebsd\",\n                  netbsdlike))]\n        O_DSYNC\n    }\n    impl TryFrom\u003ci32\u003e\n}\n\nlibc_enum! {\n    /// Mode for [`lio_listio`](fn.lio_listio.html)\n    #[repr(i32)]\n    pub enum LioMode {\n        /// Requests that [`lio_listio`](fn.lio_listio.html) block until all\n        /// requested operations have been completed\n        LIO_WAIT,\n        /// Requests that [`lio_listio`](fn.lio_listio.html) return immediately\n        LIO_NOWAIT,\n    }\n}\n\n/// Return values for [`AioCb::cancel`](struct.AioCb.html#method.cancel) and\n/// [`aio_cancel_all`](fn.aio_cancel_all.html)\n#[repr(i32)]\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub enum AioCancelStat {\n    /// All outstanding requests were canceled\n    AioCanceled = libc::AIO_CANCELED,\n    /// Some requests were not canceled.  Their status should be checked with\n    /// `AioCb::error`\n    AioNotCanceled = libc::AIO_NOTCANCELED,\n    /// All of the requests have already finished\n    AioAllDone = libc::AIO_ALLDONE,\n}\n\n/// Newtype that adds Send and Sync to libc::aiocb, which contains raw pointers\n#[repr(transparent)]\nstruct LibcAiocb(libc::aiocb);\n\nunsafe impl Send for LibcAiocb {}\nunsafe impl Sync for LibcAiocb {}\n\n/// Base class for all AIO operations.  Should only be used directly when\n/// checking for completion.\n// We could create some kind of AsPinnedMut trait, and implement it for all aio\n// ops, allowing the crate's users to get pinned references to `AioCb`.  That\n// could save some code for things like polling methods.  But IMHO it would\n// provide polymorphism at the wrong level.  Instead, the best place for\n// polymorphism is at the level of `Futures`.\n#[repr(C)]\nstruct AioCb\u003c'a\u003e {\n    aiocb: LibcAiocb,\n    /// Could this `AioCb` potentially have any in-kernel state?\n    // It would be really nice to perform the in-progress check entirely at\n    // compile time.  But I can't figure out how, because:\n    // * Future::poll takes a `Pin\u003c\u0026mut self\u003e` rather than `self`, and\n    // * Rust's lack of an equivalent of C++'s Guaranteed Copy Elision means\n    //   that there's no way to write an AioCb constructor that neither boxes\n    //   the object itself, nor moves it during return.\n    in_progress: bool,\n    _fd: PhantomData\u003cBorrowedFd\u003c'a\u003e\u003e,\n}\n\nimpl\u003c'a\u003e AioCb\u003c'a\u003e {\n    pin_utils::unsafe_unpinned!(aiocb: LibcAiocb);\n\n    fn aio_return(mut self: Pin\u003c\u0026mut Self\u003e) -\u003e Result\u003cusize\u003e {\n        self.in_progress = false;\n        unsafe {\n            let p: *mut libc::aiocb = \u0026mut self.aiocb.0;\n            Errno::result(libc::aio_return(p))\n        }\n        .map(|r| r as usize)\n    }\n\n    fn cancel(mut self: Pin\u003c\u0026mut Self\u003e) -\u003e Result\u003cAioCancelStat\u003e {\n        let r = unsafe {\n            libc::aio_cancel(self.aiocb.0.aio_fildes, \u0026mut self.aiocb.0)\n        };\n        match r {\n            libc::AIO_CANCELED =\u003e Ok(AioCancelStat::AioCanceled),\n            libc::AIO_NOTCANCELED =\u003e Ok(AioCancelStat::AioNotCanceled),\n            libc::AIO_ALLDONE =\u003e Ok(AioCancelStat::AioAllDone),\n            -1 =\u003e Err(Errno::last()),\n            _ =\u003e panic!(\"unknown aio_cancel return value\"),\n        }\n    }\n\n    fn common_init(\n        fd: BorrowedFd\u003c'a\u003e,\n        prio: i32,\n        sigev_notify: SigevNotify,\n    ) -\u003e Self {\n        // Use mem::zeroed instead of explicitly zeroing each field, because the\n        // number and name of reserved fields is OS-dependent.  On some OSes,\n        // some reserved fields are used the kernel for state, and must be\n        // explicitly zeroed when allocated.\n        let mut a = unsafe { mem::zeroed::\u003clibc::aiocb\u003e() };\n        a.aio_fildes = fd.as_raw_fd();\n        a.aio_reqprio = prio;\n        a.aio_sigevent = SigEvent::new(sigev_notify).sigevent();\n        AioCb {\n            aiocb: LibcAiocb(a),\n            in_progress: false,\n            _fd: PhantomData,\n        }\n    }\n\n    fn error(self: Pin\u003c\u0026mut Self\u003e) -\u003e Result\u003c()\u003e {\n        let r = unsafe { libc::aio_error(\u0026self.aiocb().0) };\n        match r {\n            0 =\u003e Ok(()),\n            num if num \u003e 0 =\u003e Err(Errno::from_raw(num)),\n            -1 =\u003e Err(Errno::last()),\n            num =\u003e panic!(\"unknown aio_error return value {num:?}\"),\n        }\n    }\n\n    fn in_progress(\u0026self) -\u003e bool {\n        self.in_progress\n    }\n\n    fn set_in_progress(mut self: Pin\u003c\u0026mut Self\u003e) {\n        self.as_mut().in_progress = true;\n    }\n\n    /// Update the notification settings for an existing AIO operation that has\n    /// not yet been submitted.\n    // Takes a normal reference rather than a pinned one because this method is\n    // normally called before the object needs to be pinned, that is, before\n    // it's been submitted to the kernel.\n    fn set_sigev_notify(\u0026mut self, sigev_notify: SigevNotify) {\n        assert!(\n            !self.in_progress,\n            \"Can't change notification settings for an in-progress operation\"\n        );\n        self.aiocb.0.aio_sigevent = SigEvent::new(sigev_notify).sigevent();\n    }\n}\n\nimpl Debug for AioCb\u003c'_\u003e {\n    fn fmt(\u0026self, fmt: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        fmt.debug_struct(\"AioCb\")\n            .field(\"aiocb\", \u0026self.aiocb.0)\n            .field(\"in_progress\", \u0026self.in_progress)\n            .finish()\n    }\n}\n\nimpl Drop for AioCb\u003c'_\u003e {\n    /// If the `AioCb` has no remaining state in the kernel, just drop it.\n    /// Otherwise, dropping constitutes a resource leak, which is an error\n    fn drop(\u0026mut self) {\n        assert!(\n            thread::panicking() || !self.in_progress,\n            \"Dropped an in-progress AioCb\"\n        );\n    }\n}\n\n/// Methods common to all AIO operations\npub trait Aio {\n    /// The return type of [`Aio::aio_return`].\n    type Output;\n\n    /// Retrieve return status of an asynchronous operation.\n    ///\n    /// Should only be called once for each operation, after [`Aio::error`]\n    /// indicates that it has completed.  The result is the same as for the\n    /// synchronous `read(2)`, `write(2)`, of `fsync(2)` functions.\n    ///\n    /// # References\n    ///\n    /// [aio_return](https://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_return.html)\n    fn aio_return(self: Pin\u003c\u0026mut Self\u003e) -\u003e Result\u003cSelf::Output\u003e;\n\n    /// Cancels an outstanding AIO request.\n    ///\n    /// The operating system is not required to implement cancellation for all\n    /// file and device types.  Even if it does, there is no guarantee that the\n    /// operation has not already completed.  So the caller must check the\n    /// result and handle operations that were not canceled or that have already\n    /// completed.\n    ///\n    /// # Examples\n    ///\n    /// Cancel an outstanding aio operation.  Note that we must still call\n    /// `aio_return` to free resources, even though we don't care about the\n    /// result.\n    ///\n    /// ```\n    /// # use nix::errno::Errno;\n    /// # use nix::Error;\n    /// # use nix::sys::aio::*;\n    /// # use nix::sys::signal::SigevNotify;\n    /// # use std::{thread, time};\n    /// # use std::io::Write;\n    /// # use std::os::unix::io::AsFd;\n    /// # use tempfile::tempfile;\n    /// let wbuf = b\"CDEF\";\n    /// let mut f = tempfile().unwrap();\n    /// let mut aiocb = Box::pin(AioWrite::new(f.as_fd(),\n    ///     2,   //offset\n    ///     \u0026wbuf[..],\n    ///     0,   //priority\n    ///     SigevNotify::SigevNone));\n    /// aiocb.as_mut().submit().unwrap();\n    /// let cs = aiocb.as_mut().cancel().unwrap();\n    /// if cs == AioCancelStat::AioNotCanceled {\n    ///     while (aiocb.as_mut().error() == Err(Errno::EINPROGRESS)) {\n    ///         thread::sleep(time::Duration::from_millis(10));\n    ///     }\n    /// }\n    /// // Must call `aio_return`, but ignore the result\n    /// let _ = aiocb.as_mut().aio_return();\n    /// ```\n    ///\n    /// # References\n    ///\n    /// [aio_cancel](https://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_cancel.html)\n    fn cancel(self: Pin\u003c\u0026mut Self\u003e) -\u003e Result\u003cAioCancelStat\u003e;\n\n    /// Retrieve error status of an asynchronous operation.\n    ///\n    /// If the request has not yet completed, returns `EINPROGRESS`.  Otherwise,\n    /// returns `Ok` or any other error.\n    ///\n    /// # Examples\n    ///\n    /// Issue an aio operation and use `error` to poll for completion.  Polling\n    /// is an alternative to `aio_suspend`, used by most of the other examples.\n    ///\n    /// ```\n    /// # use nix::errno::Errno;\n    /// # use nix::Error;\n    /// # use nix::sys::aio::*;\n    /// # use nix::sys::signal::SigevNotify;\n    /// # use std::{thread, time};\n    /// # use std::os::unix::io::AsFd;\n    /// # use tempfile::tempfile;\n    /// const WBUF: \u0026[u8] = b\"abcdef123456\";\n    /// let mut f = tempfile().unwrap();\n    /// let mut aiocb = Box::pin(AioWrite::new(f.as_fd(),\n    ///     2,   //offset\n    ///     WBUF,\n    ///     0,   //priority\n    ///     SigevNotify::SigevNone));\n    /// aiocb.as_mut().submit().unwrap();\n    /// while (aiocb.as_mut().error() == Err(Errno::EINPROGRESS)) {\n    ///     thread::sleep(time::Duration::from_millis(10));\n    /// }\n    /// assert_eq!(aiocb.as_mut().aio_return().unwrap(), WBUF.len());\n    /// ```\n    ///\n    /// # References\n    ///\n    /// [aio_error](https://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_error.html)\n    fn error(self: Pin\u003c\u0026mut Self\u003e) -\u003e Result\u003c()\u003e;\n\n    /// Returns the underlying file descriptor associated with the operation.\n    fn fd(\u0026self) -\u003e BorrowedFd;\n\n    /// Does this operation currently have any in-kernel state?\n    ///\n    /// Dropping an operation that does have in-kernel state constitutes a\n    /// resource leak.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use nix::errno::Errno;\n    /// # use nix::Error;\n    /// # use nix::sys::aio::*;\n    /// # use nix::sys::signal::SigevNotify::SigevNone;\n    /// # use std::{thread, time};\n    /// # use std::os::unix::io::AsFd;\n    /// # use tempfile::tempfile;\n    /// let f = tempfile().unwrap();\n    /// let mut aiof = Box::pin(AioFsync::new(f.as_fd(), AioFsyncMode::O_SYNC,\n    ///     0, SigevNone));\n    /// assert!(!aiof.as_mut().in_progress());\n    /// aiof.as_mut().submit().expect(\"aio_fsync failed early\");\n    /// assert!(aiof.as_mut().in_progress());\n    /// while (aiof.as_mut().error() == Err(Errno::EINPROGRESS)) {\n    ///     thread::sleep(time::Duration::from_millis(10));\n    /// }\n    /// aiof.as_mut().aio_return().expect(\"aio_fsync failed late\");\n    /// assert!(!aiof.as_mut().in_progress());\n    /// ```\n    fn in_progress(\u0026self) -\u003e bool;\n\n    /// Returns the priority of the `AioCb`\n    fn priority(\u0026self) -\u003e i32;\n\n    /// Update the notification settings for an existing AIO operation that has\n    /// not yet been submitted.\n    fn set_sigev_notify(\u0026mut self, sev: SigevNotify);\n\n    /// Returns the `SigEvent` that will be used for notification.\n    fn sigevent(\u0026self) -\u003e SigEvent;\n\n    /// Actually start the I/O operation.\n    ///\n    /// After calling this method and until [`Aio::aio_return`] returns `Ok`,\n    /// the structure may not be moved in memory.\n    fn submit(self: Pin\u003c\u0026mut Self\u003e) -\u003e Result\u003c()\u003e;\n}\n\nmacro_rules! aio_methods {\n    () =\u003e {\n        fn cancel(self: Pin\u003c\u0026mut Self\u003e) -\u003e Result\u003cAioCancelStat\u003e {\n            self.aiocb().cancel()\n        }\n\n        fn error(self: Pin\u003c\u0026mut Self\u003e) -\u003e Result\u003c()\u003e {\n            self.aiocb().error()\n        }\n\n        fn fd(\u0026self) -\u003e BorrowedFd\u003c'a\u003e {\n            // safe because self's lifetime is the same as the original file\n            // descriptor.\n            unsafe { BorrowedFd::borrow_raw(self.aiocb.aiocb.0.aio_fildes) }\n        }\n\n        fn in_progress(\u0026self) -\u003e bool {\n            self.aiocb.in_progress()\n        }\n\n        fn priority(\u0026self) -\u003e i32 {\n            self.aiocb.aiocb.0.aio_reqprio\n        }\n\n        fn set_sigev_notify(\u0026mut self, sev: SigevNotify) {\n            self.aiocb.set_sigev_notify(sev)\n        }\n\n        fn sigevent(\u0026self) -\u003e SigEvent {\n            SigEvent::from(\u0026self.aiocb.aiocb.0.aio_sigevent)\n        }\n    };\n    ($func:ident) =\u003e {\n        aio_methods!();\n\n        fn aio_return(self: Pin\u003c\u0026mut Self\u003e) -\u003e Result\u003c\u003cSelf as Aio\u003e::Output\u003e {\n            self.aiocb().aio_return()\n        }\n\n        fn submit(mut self: Pin\u003c\u0026mut Self\u003e) -\u003e Result\u003c()\u003e {\n            let p: *mut libc::aiocb = \u0026mut self.as_mut().aiocb().aiocb.0;\n            Errno::result({ unsafe { libc::$func(p) } }).map(|_| {\n                self.aiocb().set_in_progress();\n            })\n        }\n    };\n}\n\n/// An asynchronous version of `fsync(2)`.\n///\n/// # References\n///\n/// [aio_fsync](https://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_fsync.html)\n/// # Examples\n///\n/// ```\n/// # use nix::errno::Errno;\n/// # use nix::Error;\n/// # use nix::sys::aio::*;\n/// # use nix::sys::signal::SigevNotify::SigevNone;\n/// # use std::{thread, time};\n/// # use std::os::unix::io::AsFd;\n/// # use tempfile::tempfile;\n/// let f = tempfile().unwrap();\n/// let mut aiof = Box::pin(AioFsync::new(f.as_fd(), AioFsyncMode::O_SYNC,\n///     0, SigevNone));\n/// aiof.as_mut().submit().expect(\"aio_fsync failed early\");\n/// while (aiof.as_mut().error() == Err(Errno::EINPROGRESS)) {\n///     thread::sleep(time::Duration::from_millis(10));\n/// }\n/// aiof.as_mut().aio_return().expect(\"aio_fsync failed late\");\n/// ```\n#[derive(Debug)]\n#[repr(transparent)]\npub struct AioFsync\u003c'a\u003e {\n    aiocb: AioCb\u003c'a\u003e,\n    _pin: PhantomPinned,\n}\n\nimpl\u003c'a\u003e AioFsync\u003c'a\u003e {\n    unsafe_pinned!(aiocb: AioCb\u003c'a\u003e);\n\n    /// Returns the operation's fsync mode: data and metadata or data only?\n    pub fn mode(\u0026self) -\u003e AioFsyncMode {\n        AioFsyncMode::try_from(self.aiocb.aiocb.0.aio_lio_opcode).unwrap()\n    }\n\n    /// Create a new `AioFsync`.\n    ///\n    /// # Arguments\n    ///\n    /// * `fd`:           File descriptor to sync.\n    /// * `mode`:         Whether to sync file metadata too, or just data.\n    /// * `prio`:         If POSIX Prioritized IO is supported, then the\n    ///   operation will be prioritized at the process's priority level minus \n    ///   `prio`.\n    /// * `sigev_notify`: Determines how you will be notified of event completion.\n    pub fn new(\n        fd: BorrowedFd\u003c'a\u003e,\n        mode: AioFsyncMode,\n        prio: i32,\n        sigev_notify: SigevNotify,\n    ) -\u003e Self {\n        let mut aiocb = AioCb::common_init(fd, prio, sigev_notify);\n        // To save some memory, store mode in an unused field of the AioCb.\n        // True it isn't very much memory, but downstream creates will likely\n        // create an enum containing this and other AioCb variants and pack\n        // those enums into data structures like Vec, so it adds up.\n        aiocb.aiocb.0.aio_lio_opcode = mode as libc::c_int;\n        AioFsync {\n            aiocb,\n            _pin: PhantomPinned,\n        }\n    }\n}\n\nimpl\u003c'a\u003e Aio for AioFsync\u003c'a\u003e {\n    type Output = ();\n\n    aio_methods!();\n\n    fn aio_return(self: Pin\u003c\u0026mut Self\u003e) -\u003e Result\u003c()\u003e {\n        self.aiocb().aio_return().map(drop)\n    }\n\n    fn submit(mut self: Pin\u003c\u0026mut Self\u003e) -\u003e Result\u003c()\u003e {\n        let aiocb = \u0026mut self.as_mut().aiocb().aiocb.0;\n        let mode = mem::replace(\u0026mut aiocb.aio_lio_opcode, 0);\n        let p: *mut libc::aiocb = aiocb;\n        Errno::result(unsafe { libc::aio_fsync(mode, p) }).map(|_| {\n            self.aiocb().set_in_progress();\n        })\n    }\n}\n\n// AioFsync does not need AsMut, since it can't be used with lio_listio\n\nimpl AsRef\u003clibc::aiocb\u003e for AioFsync\u003c'_\u003e {\n    fn as_ref(\u0026self) -\u003e \u0026libc::aiocb {\n        \u0026self.aiocb.aiocb.0\n    }\n}\n\n/// Asynchronously reads from a file descriptor into a buffer\n///\n/// # References\n///\n/// [aio_read](https://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_read.html)\n///\n/// # Examples\n///\n///\n/// ```\n/// # use nix::errno::Errno;\n/// # use nix::Error;\n/// # use nix::sys::aio::*;\n/// # use nix::sys::signal::SigevNotify;\n/// # use std::{thread, time};\n/// # use std::io::Write;\n/// # use std::os::unix::io::AsFd;\n/// # use tempfile::tempfile;\n/// const INITIAL: \u0026[u8] = b\"abcdef123456\";\n/// const LEN: usize = 4;\n/// let mut rbuf = vec![0; LEN];\n/// let mut f = tempfile().unwrap();\n/// f.write_all(INITIAL).unwrap();\n/// {\n///     let mut aior = Box::pin(\n///         AioRead::new(\n///             f.as_fd(),\n///             2,   //offset\n///             \u0026mut rbuf,\n///             0,   //priority\n///             SigevNotify::SigevNone\n///         )\n///     );\n///     aior.as_mut().submit().unwrap();\n///     while (aior.as_mut().error() == Err(Errno::EINPROGRESS)) {\n///         thread::sleep(time::Duration::from_millis(10));\n///     }\n///     assert_eq!(aior.as_mut().aio_return().unwrap(), LEN);\n/// }\n/// assert_eq!(rbuf, b\"cdef\");\n/// ```\n#[derive(Debug)]\n#[repr(transparent)]\npub struct AioRead\u003c'a\u003e {\n    aiocb: AioCb\u003c'a\u003e,\n    _data: PhantomData\u003c\u0026'a [u8]\u003e,\n    _pin: PhantomPinned,\n}\n\nimpl\u003c'a\u003e AioRead\u003c'a\u003e {\n    unsafe_pinned!(aiocb: AioCb\u003c'a\u003e);\n\n    /// Returns the requested length of the aio operation in bytes\n    ///\n    /// This method returns the *requested* length of the operation.  To get the\n    /// number of bytes actually read or written by a completed operation, use\n    /// `aio_return` instead.\n    pub fn nbytes(\u0026self) -\u003e usize {\n        self.aiocb.aiocb.0.aio_nbytes\n    }\n\n    /// Create a new `AioRead`, placing the data in a mutable slice.\n    ///\n    /// # Arguments\n    ///\n    /// * `fd`:           File descriptor to read from\n    /// * `offs`:         File offset\n    /// * `buf`:          A memory buffer.  It must outlive the `AioRead`.\n    /// * `prio`:         If POSIX Prioritized IO is supported, then the operation\n    ///   will be prioritized at the process's priority level minus `prio`\n    /// * `sigev_notify`: Determines how you will be notified of event completion.\n    pub fn new(\n        fd: BorrowedFd\u003c'a\u003e,\n        offs: off_t,\n        buf: \u0026'a mut [u8],\n        prio: i32,\n        sigev_notify: SigevNotify,\n    ) -\u003e Self {\n        let mut aiocb = AioCb::common_init(fd, prio, sigev_notify);\n        aiocb.aiocb.0.aio_nbytes = buf.len();\n        aiocb.aiocb.0.aio_buf = buf.as_mut_ptr().cast();\n        aiocb.aiocb.0.aio_lio_opcode = libc::LIO_READ;\n        aiocb.aiocb.0.aio_offset = offs;\n        AioRead {\n            aiocb,\n            _data: PhantomData,\n            _pin: PhantomPinned,\n        }\n    }\n\n    /// Returns the file offset of the operation.\n    pub fn offset(\u0026self) -\u003e off_t {\n        self.aiocb.aiocb.0.aio_offset\n    }\n}\n\nimpl\u003c'a\u003e Aio for AioRead\u003c'a\u003e {\n    type Output = usize;\n\n    aio_methods!(aio_read);\n}\n\nimpl AsMut\u003clibc::aiocb\u003e for AioRead\u003c'_\u003e {\n    fn as_mut(\u0026mut self) -\u003e \u0026mut libc::aiocb {\n        \u0026mut self.aiocb.aiocb.0\n    }\n}\n\nimpl AsRef\u003clibc::aiocb\u003e for AioRead\u003c'_\u003e {\n    fn as_ref(\u0026self) -\u003e \u0026libc::aiocb {\n        \u0026self.aiocb.aiocb.0\n    }\n}\n\n/// Asynchronously reads from a file descriptor into a scatter/gather list of buffers.\n///\n/// # References\n///\n/// [aio_readv](https://www.freebsd.org/cgi/man.cgi?query=aio_readv)\n///\n/// # Examples\n///\n///\n#[cfg_attr(fbsd14, doc = \" ```\")]\n#[cfg_attr(not(fbsd14), doc = \" ```no_run\")]\n/// # use nix::errno::Errno;\n/// # use nix::Error;\n/// # use nix::sys::aio::*;\n/// # use nix::sys::signal::SigevNotify;\n/// # use std::{thread, time};\n/// # use std::io::{IoSliceMut, Write};\n/// # use std::os::unix::io::AsFd;\n/// # use tempfile::tempfile;\n/// const INITIAL: \u0026[u8] = b\"abcdef123456\";\n/// let mut rbuf0 = vec![0; 4];\n/// let mut rbuf1 = vec![0; 2];\n/// let expected_len = rbuf0.len() + rbuf1.len();\n/// let mut rbufs = [IoSliceMut::new(\u0026mut rbuf0), IoSliceMut::new(\u0026mut rbuf1)];\n/// let mut f = tempfile().unwrap();\n/// f.write_all(INITIAL).unwrap();\n/// {\n///     let mut aior = Box::pin(\n///         AioReadv::new(\n///             f.as_fd(),\n///             2,   //offset\n///             \u0026mut rbufs,\n///             0,   //priority\n///             SigevNotify::SigevNone\n///         )\n///     );\n///     aior.as_mut().submit().unwrap();\n///     while (aior.as_mut().error() == Err(Errno::EINPROGRESS)) {\n///         thread::sleep(time::Duration::from_millis(10));\n///     }\n///     assert_eq!(aior.as_mut().aio_return().unwrap(), expected_len);\n/// }\n/// assert_eq!(rbuf0, b\"cdef\");\n/// assert_eq!(rbuf1, b\"12\");\n/// ```\n#[cfg(target_os = \"freebsd\")]\n#[derive(Debug)]\n#[repr(transparent)]\npub struct AioReadv\u003c'a\u003e {\n    aiocb: AioCb\u003c'a\u003e,\n    _data: PhantomData\u003c\u0026'a [\u0026'a [u8]]\u003e,\n    _pin: PhantomPinned,\n}\n\n#[cfg(target_os = \"freebsd\")]\nimpl\u003c'a\u003e AioReadv\u003c'a\u003e {\n    unsafe_pinned!(aiocb: AioCb\u003c'a\u003e);\n\n    /// Returns the number of buffers the operation will read into.\n    pub fn iovlen(\u0026self) -\u003e usize {\n        self.aiocb.aiocb.0.aio_nbytes\n    }\n\n    /// Create a new `AioReadv`, placing the data in a list of mutable slices.\n    ///\n    /// # Arguments\n    ///\n    /// * `fd`:           File descriptor to read from\n    /// * `offs`:         File offset\n    /// * `bufs`:         A scatter/gather list of memory buffers.  They must\n    ///                   outlive the `AioReadv`.\n    /// * `prio`:         If POSIX Prioritized IO is supported, then the\n    ///                   operation will be prioritized at the process's\n    ///                   priority level minus `prio`\n    /// * `sigev_notify`: Determines how you will be notified of event\n    ///                   completion.\n    pub fn new(\n        fd: BorrowedFd\u003c'a\u003e,\n        offs: off_t,\n        bufs: \u0026mut [IoSliceMut\u003c'a\u003e],\n        prio: i32,\n        sigev_notify: SigevNotify,\n    ) -\u003e Self {\n        let mut aiocb = AioCb::common_init(fd, prio, sigev_notify);\n        // In vectored mode, aio_nbytes stores the length of the iovec array,\n        // not the byte count.\n        aiocb.aiocb.0.aio_nbytes = bufs.len();\n        aiocb.aiocb.0.aio_buf = bufs.as_mut_ptr().cast();\n        aiocb.aiocb.0.aio_lio_opcode = libc::LIO_READV;\n        aiocb.aiocb.0.aio_offset = offs;\n        AioReadv {\n            aiocb,\n            _data: PhantomData,\n            _pin: PhantomPinned,\n        }\n    }\n\n    /// Returns the file offset of the operation.\n    pub fn offset(\u0026self) -\u003e off_t {\n        self.aiocb.aiocb.0.aio_offset\n    }\n}\n\n#[cfg(target_os = \"freebsd\")]\nimpl\u003c'a\u003e Aio for AioReadv\u003c'a\u003e {\n    type Output = usize;\n\n    aio_methods!(aio_readv);\n}\n\n#[cfg(target_os = \"freebsd\")]\nimpl AsMut\u003clibc::aiocb\u003e for AioReadv\u003c'_\u003e {\n    fn as_mut(\u0026mut self) -\u003e \u0026mut libc::aiocb {\n        \u0026mut self.aiocb.aiocb.0\n    }\n}\n\n#[cfg(target_os = \"freebsd\")]\nimpl AsRef\u003clibc::aiocb\u003e for AioReadv\u003c'_\u003e {\n    fn as_ref(\u0026self) -\u003e \u0026libc::aiocb {\n        \u0026self.aiocb.aiocb.0\n    }\n}\n\n/// Asynchronously writes from a buffer to a file descriptor\n///\n/// # References\n///\n/// [aio_write](https://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_write.html)\n///\n/// # Examples\n///\n/// ```\n/// # use nix::errno::Errno;\n/// # use nix::Error;\n/// # use nix::sys::aio::*;\n/// # use nix::sys::signal::SigevNotify;\n/// # use std::{thread, time};\n/// # use std::os::unix::io::AsFd;\n/// # use tempfile::tempfile;\n/// const WBUF: \u0026[u8] = b\"abcdef123456\";\n/// let mut f = tempfile().unwrap();\n/// let mut aiow = Box::pin(\n///     AioWrite::new(\n///         f.as_fd(),\n///         2,   //offset\n///         WBUF,\n///         0,   //priority\n///         SigevNotify::SigevNone\n///     )\n/// );\n/// aiow.as_mut().submit().unwrap();\n/// while (aiow.as_mut().error() == Err(Errno::EINPROGRESS)) {\n///     thread::sleep(time::Duration::from_millis(10));\n/// }\n/// assert_eq!(aiow.as_mut().aio_return().unwrap(), WBUF.len());\n/// ```\n#[derive(Debug)]\n#[repr(transparent)]\npub struct AioWrite\u003c'a\u003e {\n    aiocb: AioCb\u003c'a\u003e,\n    _data: PhantomData\u003c\u0026'a [u8]\u003e,\n    _pin: PhantomPinned,\n}\n\nimpl\u003c'a\u003e AioWrite\u003c'a\u003e {\n    unsafe_pinned!(aiocb: AioCb\u003c'a\u003e);\n\n    /// Returns the requested length of the aio operation in bytes\n    ///\n    /// This method returns the *requested* length of the operation.  To get the\n    /// number of bytes actually read or written by a completed operation, use\n    /// `aio_return` instead.\n    pub fn nbytes(\u0026self) -\u003e usize {\n        self.aiocb.aiocb.0.aio_nbytes\n    }\n\n    /// Construct a new `AioWrite`.\n    ///\n    /// # Arguments\n    ///\n    /// * `fd`:           File descriptor to write to\n    /// * `offs`:         File offset\n    /// * `buf`:          A memory buffer.  It must outlive the `AioWrite`.\n    /// * `prio`:         If POSIX Prioritized IO is supported, then the operation\n    ///   will be prioritized at the process's priority level minus `prio`\n    /// * `sigev_notify`: Determines how you will be notified of event completion.\n    pub fn new(\n        fd: BorrowedFd\u003c'a\u003e,\n        offs: off_t,\n        buf: \u0026'a [u8],\n        prio: i32,\n        sigev_notify: SigevNotify,\n    ) -\u003e Self {\n        let mut aiocb = AioCb::common_init(fd, prio, sigev_notify);\n        aiocb.aiocb.0.aio_nbytes = buf.len();\n        // casting an immutable buffer to a mutable pointer looks unsafe,\n        // but technically its only unsafe to dereference it, not to create\n        // it.  Type Safety guarantees that we'll never pass aiocb to\n        // aio_read or aio_readv.\n        aiocb.aiocb.0.aio_buf = buf.as_ptr().cast_mut().cast();\n        aiocb.aiocb.0.aio_lio_opcode = libc::LIO_WRITE;\n        aiocb.aiocb.0.aio_offset = offs;\n        AioWrite {\n            aiocb,\n            _data: PhantomData,\n            _pin: PhantomPinned,\n        }\n    }\n\n    /// Returns the file offset of the operation.\n    pub fn offset(\u0026self) -\u003e off_t {\n        self.aiocb.aiocb.0.aio_offset\n    }\n}\n\nimpl\u003c'a\u003e Aio for AioWrite\u003c'a\u003e {\n    type Output = usize;\n\n    aio_methods!(aio_write);\n}\n\nimpl AsMut\u003clibc::aiocb\u003e for AioWrite\u003c'_\u003e {\n    fn as_mut(\u0026mut self) -\u003e \u0026mut libc::aiocb {\n        \u0026mut self.aiocb.aiocb.0\n    }\n}\n\nimpl AsRef\u003clibc::aiocb\u003e for AioWrite\u003c'_\u003e {\n    fn as_ref(\u0026self) -\u003e \u0026libc::aiocb {\n        \u0026self.aiocb.aiocb.0\n    }\n}\n\n/// Asynchronously writes from a scatter/gather list of buffers to a file descriptor.\n///\n/// # References\n///\n/// [aio_writev](https://www.freebsd.org/cgi/man.cgi?query=aio_writev)\n///\n/// # Examples\n///\n#[cfg_attr(fbsd14, doc = \" ```\")]\n#[cfg_attr(not(fbsd14), doc = \" ```no_run\")]\n/// # use nix::errno::Errno;\n/// # use nix::Error;\n/// # use nix::sys::aio::*;\n/// # use nix::sys::signal::SigevNotify;\n/// # use std::{thread, time};\n/// # use std::io::IoSlice;\n/// # use std::os::unix::io::AsFd;\n/// # use tempfile::tempfile;\n/// const wbuf0: \u0026[u8] = b\"abcdef\";\n/// const wbuf1: \u0026[u8] = b\"123456\";\n/// let len = wbuf0.len() + wbuf1.len();\n/// let wbufs = [IoSlice::new(wbuf0), IoSlice::new(wbuf1)];\n/// let mut f = tempfile().unwrap();\n/// let mut aiow = Box::pin(\n///     AioWritev::new(\n///         f.as_fd(),\n///         2,   //offset\n///         \u0026wbufs,\n///         0,   //priority\n///         SigevNotify::SigevNone\n///     )\n/// );\n/// aiow.as_mut().submit().unwrap();\n/// while (aiow.as_mut().error() == Err(Errno::EINPROGRESS)) {\n///     thread::sleep(time::Duration::from_millis(10));\n/// }\n/// assert_eq!(aiow.as_mut().aio_return().unwrap(), len);\n/// ```\n#[cfg(target_os = \"freebsd\")]\n#[derive(Debug)]\n#[repr(transparent)]\npub struct AioWritev\u003c'a\u003e {\n    aiocb: AioCb\u003c'a\u003e,\n    _data: PhantomData\u003c\u0026'a [\u0026'a [u8]]\u003e,\n    _pin: PhantomPinned,\n}\n\n#[cfg(target_os = \"freebsd\")]\nimpl\u003c'a\u003e AioWritev\u003c'a\u003e {\n    unsafe_pinned!(aiocb: AioCb\u003c'a\u003e);\n\n    /// Returns the number of buffers the operation will read into.\n    pub fn iovlen(\u0026self) -\u003e usize {\n        self.aiocb.aiocb.0.aio_nbytes\n    }\n\n    /// Construct a new `AioWritev`.\n    ///\n    /// # Arguments\n    ///\n    /// * `fd`:           File descriptor to write to\n    /// * `offs`:         File offset\n    /// * `bufs`:         A scatter/gather list of memory buffers.  They must\n    ///                   outlive the `AioWritev`.\n    /// * `prio`:         If POSIX Prioritized IO is supported, then the\n    ///                   operation will be prioritized at the process's\n    ///                   priority level minus `prio`\n    /// * `sigev_notify`: Determines how you will be notified of event\n    ///                   completion.\n    pub fn new(\n        fd: BorrowedFd\u003c'a\u003e,\n        offs: off_t,\n        bufs: \u0026[IoSlice\u003c'a\u003e],\n        prio: i32,\n        sigev_notify: SigevNotify,\n    ) -\u003e Self {\n        let mut aiocb = AioCb::common_init(fd, prio, sigev_notify);\n        // In vectored mode, aio_nbytes stores the length of the iovec array,\n        // not the byte count.\n        aiocb.aiocb.0.aio_nbytes = bufs.len();\n        // casting an immutable buffer to a mutable pointer looks unsafe,\n        // but technically its only unsafe to dereference it, not to create\n        // it.  Type Safety guarantees that we'll never pass aiocb to\n        // aio_read or aio_readv.\n        aiocb.aiocb.0.aio_buf = bufs.as_ptr().cast_mut().cast();\n        aiocb.aiocb.0.aio_lio_opcode = libc::LIO_WRITEV;\n        aiocb.aiocb.0.aio_offset = offs;\n        AioWritev {\n            aiocb,\n            _data: PhantomData,\n            _pin: PhantomPinned,\n        }\n    }\n\n    /// Returns the file offset of the operation.\n    pub fn offset(\u0026self) -\u003e off_t {\n        self.aiocb.aiocb.0.aio_offset\n    }\n}\n\n#[cfg(target_os = \"freebsd\")]\nimpl\u003c'a\u003e Aio for AioWritev\u003c'a\u003e {\n    type Output = usize;\n\n    aio_methods!(aio_writev);\n}\n\n#[cfg(target_os = \"freebsd\")]\nimpl AsMut\u003clibc::aiocb\u003e for AioWritev\u003c'_\u003e {\n    fn as_mut(\u0026mut self) -\u003e \u0026mut libc::aiocb {\n        \u0026mut self.aiocb.aiocb.0\n    }\n}\n\n#[cfg(target_os = \"freebsd\")]\nimpl AsRef\u003clibc::aiocb\u003e for AioWritev\u003c'_\u003e {\n    fn as_ref(\u0026self) -\u003e \u0026libc::aiocb {\n        \u0026self.aiocb.aiocb.0\n    }\n}\n\n/// Cancels outstanding AIO requests for a given file descriptor.\n///\n/// # Examples\n///\n/// Issue an aio operation, then cancel all outstanding operations on that file\n/// descriptor.\n///\n/// ```\n/// # use nix::errno::Errno;\n/// # use nix::Error;\n/// # use nix::sys::aio::*;\n/// # use nix::sys::signal::SigevNotify;\n/// # use std::{thread, time};\n/// # use std::io::Write;\n/// # use std::os::unix::io::AsFd;\n/// # use tempfile::tempfile;\n/// let wbuf = b\"CDEF\";\n/// let mut f = tempfile().unwrap();\n/// let mut aiocb = Box::pin(AioWrite::new(f.as_fd(),\n///     2,   //offset\n///     \u0026wbuf[..],\n///     0,   //priority\n///     SigevNotify::SigevNone));\n/// aiocb.as_mut().submit().unwrap();\n/// let cs = aio_cancel_all(f.as_fd()).unwrap();\n/// if cs == AioCancelStat::AioNotCanceled {\n///     while (aiocb.as_mut().error() == Err(Errno::EINPROGRESS)) {\n///         thread::sleep(time::Duration::from_millis(10));\n///     }\n/// }\n/// // Must call `aio_return`, but ignore the result\n/// let _ = aiocb.as_mut().aio_return();\n/// ```\n///\n/// # References\n///\n/// [`aio_cancel`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_cancel.html)\npub fn aio_cancel_all\u003cF: AsFd\u003e(fd: F) -\u003e Result\u003cAioCancelStat\u003e {\n    match unsafe { libc::aio_cancel(fd.as_fd().as_raw_fd(), ptr::null_mut()) } {\n        libc::AIO_CANCELED =\u003e Ok(AioCancelStat::AioCanceled),\n        libc::AIO_NOTCANCELED =\u003e Ok(AioCancelStat::AioNotCanceled),\n        libc::AIO_ALLDONE =\u003e Ok(AioCancelStat::AioAllDone),\n        -1 =\u003e Err(Errno::last()),\n        _ =\u003e panic!(\"unknown aio_cancel return value\"),\n    }\n}\n\n/// Suspends the calling process until at least one of the specified operations\n/// have completed, a signal is delivered, or the timeout has passed.\n///\n/// If `timeout` is `None`, `aio_suspend` will block indefinitely.\n///\n/// # Examples\n///\n/// Use `aio_suspend` to block until an aio operation completes.\n///\n/// ```\n/// # use nix::sys::aio::*;\n/// # use nix::sys::signal::SigevNotify;\n/// # use std::os::unix::io::AsFd;\n/// # use tempfile::tempfile;\n/// const WBUF: \u0026[u8] = b\"abcdef123456\";\n/// let mut f = tempfile().unwrap();\n/// let mut aiocb = Box::pin(AioWrite::new(f.as_fd(),\n///     2,   //offset\n///     WBUF,\n///     0,   //priority\n///     SigevNotify::SigevNone));\n/// aiocb.as_mut().submit().unwrap();\n/// aio_suspend(\u0026[\u0026*aiocb], None).expect(\"aio_suspend failed\");\n/// assert_eq!(aiocb.as_mut().aio_return().unwrap(), WBUF.len());\n/// ```\n/// # References\n///\n/// [`aio_suspend`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/aio_suspend.html)\npub fn aio_suspend(\n    list: \u0026[\u0026dyn AsRef\u003clibc::aiocb\u003e],\n    timeout: Option\u003cTimeSpec\u003e,\n) -\u003e Result\u003c()\u003e {\n    // Note that this allocation could be eliminated by making the argument\n    // generic, and accepting arguments like \u0026[AioWrite].  But that would\n    // prevent using aio_suspend to wait on a heterogeneous list of mixed\n    // operations.\n    let v = list\n        .iter()\n        .map(|x| x.as_ref() as *const libc::aiocb)\n        .collect::\u003cVec\u003c*const libc::aiocb\u003e\u003e();\n    let p = v.as_ptr();\n    let timep = match timeout {\n        None =\u003e ptr::null::\u003clibc::timespec\u003e(),\n        Some(x) =\u003e x.as_ref() as *const libc::timespec,\n    };\n    Errno::result(unsafe { libc::aio_suspend(p, list.len() as i32, timep) })\n        .map(drop)\n}\n\n/// Submits multiple asynchronous I/O requests with a single system call.\n///\n/// They are not guaranteed to complete atomically, and the order in which the\n/// requests are carried out is not specified. Reads, and writes may be freely\n/// mixed.\n///\n/// # Examples\n///\n/// Use `lio_listio` to submit an aio operation and wait for its completion. In\n/// this case, there is no need to use aio_suspend to wait or `error` to poll.\n/// This mode is useful for otherwise-synchronous programs that want to execute\n/// a handful of I/O operations in parallel.\n/// ```\n/// # use std::os::unix::io::AsFd;\n/// # use nix::sys::aio::*;\n/// # use nix::sys::signal::SigevNotify;\n/// # use tempfile::tempfile;\n/// const WBUF: \u0026[u8] = b\"abcdef123456\";\n/// let mut f = tempfile().unwrap();\n/// let mut aiow = Box::pin(AioWrite::new(\n///     f.as_fd(),\n///     2,      // offset\n///     WBUF,\n///     0,      // priority\n///     SigevNotify::SigevNone\n/// ));\n/// lio_listio(LioMode::LIO_WAIT, \u0026mut[aiow.as_mut()], SigevNotify::SigevNone)\n///     .unwrap();\n/// // At this point, we are guaranteed that aiow is complete.\n/// assert_eq!(aiow.as_mut().aio_return().unwrap(), WBUF.len());\n/// ```\n///\n/// Use `lio_listio` to submit multiple asynchronous operations with a single\n/// syscall, but receive notification individually.  This is an efficient\n/// technique for reducing overall context-switch overhead, especially when\n/// combined with kqueue.\n/// ```\n/// # use std::os::unix::io::AsFd;\n/// # use std::thread;\n/// # use std::time;\n/// # use nix::errno::Errno;\n/// # use nix::sys::aio::*;\n/// # use nix::sys::signal::SigevNotify;\n/// # use tempfile::tempfile;\n/// const WBUF: \u0026[u8] = b\"abcdef123456\";\n/// let mut f = tempfile().unwrap();\n/// let mut aiow = Box::pin(AioWrite::new(\n///     f.as_fd(),\n///     2,      // offset\n///     WBUF,\n///     0,      // priority\n///     SigevNotify::SigevNone\n/// ));\n/// lio_listio(LioMode::LIO_NOWAIT, \u0026mut[aiow.as_mut()], SigevNotify::SigevNone)\n///     .unwrap();\n/// // We must wait for the completion of each individual operation\n/// while (aiow.as_mut().error() == Err(Errno::EINPROGRESS)) {\n///     thread::sleep(time::Duration::from_millis(10));\n/// }\n/// assert_eq!(aiow.as_mut().aio_return().unwrap(), WBUF.len());\n/// ```\n///\n/// Use `lio_listio` to submit multiple operations, and receive notification\n/// only when all of them are complete.  This can be useful when there is some\n/// logical relationship between the operations.  But beware!  Errors or system\n/// resource limitations may cause `lio_listio` to return `EIO`, `EAGAIN`, or\n/// `EINTR`, in which case some but not all operations may have been submitted.\n/// In that case, you must check the status of each individual operation, and\n/// possibly resubmit some.\n/// ```\n/// # use libc::c_int;\n/// # use std::os::unix::io::AsFd;\n/// # use std::sync::atomic::{AtomicBool, Ordering};\n/// # use std::thread;\n/// # use std::time;\n/// # use nix::errno::Errno;\n/// # use nix::sys::aio::*;\n/// # use nix::sys::signal::*;\n/// # use tempfile::tempfile;\n/// pub static SIGNALED: AtomicBool = AtomicBool::new(false);\n///\n/// extern fn sigfunc(_: c_int) {\n///     SIGNALED.store(true, Ordering::Relaxed);\n/// }\n/// let sa = SigAction::new(SigHandler::Handler(sigfunc),\n///                         SaFlags::SA_RESETHAND,\n///                         SigSet::empty());\n/// SIGNALED.store(false, Ordering::Relaxed);\n/// unsafe { sigaction(Signal::SIGUSR2, \u0026sa) }.unwrap();\n///\n/// const WBUF: \u0026[u8] = b\"abcdef123456\";\n/// let mut f = tempfile().unwrap();\n/// let mut aiow = Box::pin(AioWrite::new(\n///     f.as_fd(),\n///     2,      // offset\n///     WBUF,\n///     0,      // priority\n///     SigevNotify::SigevNone\n/// ));\n/// let sev = SigevNotify::SigevSignal { signal: Signal::SIGUSR2, si_value: 0 };\n/// lio_listio(LioMode::LIO_NOWAIT, \u0026mut[aiow.as_mut()], sev).unwrap();\n/// while !SIGNALED.load(Ordering::Relaxed) {\n///     thread::sleep(time::Duration::from_millis(10));\n/// }\n/// // At this point, since `lio_listio` returned success and delivered its\n/// // notification, we know that all operations are complete.\n/// assert_eq!(aiow.as_mut().aio_return().unwrap(), WBUF.len());\n/// ```\n#[deprecated(\n    since = \"0.27.0\",\n    note = \"https://github.com/nix-rust/nix/issues/2017\"\n)]\npub fn lio_listio(\n    mode: LioMode,\n    list: \u0026mut [Pin\u003c\u0026mut dyn AsMut\u003clibc::aiocb\u003e\u003e],\n    sigev_notify: SigevNotify,\n) -\u003e Result\u003c()\u003e {\n    let p = list as *mut [Pin\u003c\u0026mut dyn AsMut\u003clibc::aiocb\u003e\u003e]\n        as *mut [*mut libc::aiocb] as *mut *mut libc::aiocb;\n    let sigev = SigEvent::new(sigev_notify);\n    let sigevp = \u0026mut sigev.sigevent() as *mut libc::sigevent;\n    Errno::result(unsafe {\n        libc::lio_listio(mode as i32, p, list.len() as i32, sigevp)\n    })\n    .map(drop)\n}\n","traces":[{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":585,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":794,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":815,"address":[],"length":0,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":0}},{"line":821,"address":[],"length":0,"stats":{"Line":0}},{"line":822,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":832,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":907,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":931,"address":[],"length":0,"stats":{"Line":0}},{"line":934,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":941,"address":[],"length":0,"stats":{"Line":0}},{"line":950,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":1013,"address":[],"length":0,"stats":{"Line":0}},{"line":1014,"address":[],"length":0,"stats":{"Line":0}},{"line":1015,"address":[],"length":0,"stats":{"Line":0}},{"line":1016,"address":[],"length":0,"stats":{"Line":0}},{"line":1017,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":0}},{"line":1019,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":89},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","epoll.rs"],"content":"use crate::errno::Errno;\npub use crate::poll_timeout::PollTimeout as EpollTimeout;\npub use crate::poll_timeout::PollTimeoutTryFromError as EpollTimeoutTryFromError;\nuse crate::Result;\nuse libc::{self, c_int};\nuse std::mem;\nuse std::os::unix::io::{AsFd, AsRawFd, FromRawFd, OwnedFd, RawFd};\n\nlibc_bitflags!(\n    pub struct EpollFlags: c_int {\n        EPOLLIN;\n        EPOLLPRI;\n        EPOLLOUT;\n        EPOLLRDNORM;\n        EPOLLRDBAND;\n        EPOLLWRNORM;\n        EPOLLWRBAND;\n        EPOLLMSG;\n        EPOLLERR;\n        EPOLLHUP;\n        EPOLLRDHUP;\n        EPOLLEXCLUSIVE;\n        #[cfg(not(target_arch = \"mips\"))]\n        EPOLLWAKEUP;\n        EPOLLONESHOT;\n        EPOLLET;\n    }\n);\n\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\n#[repr(i32)]\n#[non_exhaustive]\npub enum EpollOp {\n    EpollCtlAdd = libc::EPOLL_CTL_ADD,\n    EpollCtlDel = libc::EPOLL_CTL_DEL,\n    EpollCtlMod = libc::EPOLL_CTL_MOD,\n}\n\nlibc_bitflags! {\n    pub struct EpollCreateFlags: c_int {\n        EPOLL_CLOEXEC;\n    }\n}\n\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\n#[repr(transparent)]\npub struct EpollEvent {\n    event: libc::epoll_event,\n}\n\nimpl EpollEvent {\n    pub fn new(events: EpollFlags, data: u64) -\u003e Self {\n        EpollEvent {\n            event: libc::epoll_event {\n                events: events.bits() as u32,\n                u64: data,\n            },\n        }\n    }\n\n    pub fn empty() -\u003e Self {\n        unsafe { mem::zeroed::\u003cEpollEvent\u003e() }\n    }\n\n    pub fn events(\u0026self) -\u003e EpollFlags {\n        EpollFlags::from_bits(self.event.events as c_int).unwrap()\n    }\n\n    pub fn data(\u0026self) -\u003e u64 {\n        self.event.u64\n    }\n}\n\n/// A safe wrapper around [`epoll`](https://man7.org/linux/man-pages/man7/epoll.7.html).\n/// ```\n/// # use nix::sys::{epoll::{EpollTimeout, Epoll, EpollEvent, EpollFlags, EpollCreateFlags}, eventfd::{EventFd, EfdFlags}};\n/// # use nix::unistd::write;\n/// # use std::os::unix::io::{OwnedFd, FromRawFd, AsFd};\n/// # use std::time::{Instant, Duration};\n/// # fn main() -\u003e nix::Result\u003c()\u003e {\n/// const DATA: u64 = 17;\n/// const MILLIS: u8 = 100;\n///\n/// // Create epoll\n/// let epoll = Epoll::new(EpollCreateFlags::empty())?;\n///\n/// // Create eventfd \u0026 Add event\n/// let eventfd = EventFd::new()?;\n/// epoll.add(\u0026eventfd, EpollEvent::new(EpollFlags::EPOLLIN,DATA))?;\n///\n/// // Arm eventfd \u0026 Time wait\n/// eventfd.write(1)?;\n/// let now = Instant::now();\n///\n/// // Wait on event\n/// let mut events = [EpollEvent::empty()];\n/// epoll.wait(\u0026mut events, MILLIS)?;\n///\n/// // Assert data correct \u0026 timeout didn't occur\n/// assert_eq!(events[0].data(), DATA);\n/// assert!(now.elapsed().as_millis() \u003c MILLIS.into());\n/// # Ok(())\n/// # }\n/// ```\n#[derive(Debug)]\npub struct Epoll(pub OwnedFd);\nimpl Epoll {\n    /// Creates a new epoll instance and returns a file descriptor referring to that instance.\n    ///\n    /// [`epoll_create1`](https://man7.org/linux/man-pages/man2/epoll_create1.2.html).\n    pub fn new(flags: EpollCreateFlags) -\u003e Result\u003cSelf\u003e {\n        let res = unsafe { libc::epoll_create1(flags.bits()) };\n        let fd = Errno::result(res)?;\n        let owned_fd = unsafe { OwnedFd::from_raw_fd(fd) };\n        Ok(Self(owned_fd))\n    }\n    /// Add an entry to the interest list of the epoll file descriptor for\n    /// specified in events.\n    ///\n    /// [`epoll_ctl`](https://man7.org/linux/man-pages/man2/epoll_ctl.2.html) with `EPOLL_CTL_ADD`.\n    pub fn add\u003cFd: AsFd\u003e(\u0026self, fd: Fd, mut event: EpollEvent) -\u003e Result\u003c()\u003e {\n        self.epoll_ctl(EpollOp::EpollCtlAdd, fd, \u0026mut event)\n    }\n    /// Remove (deregister) the target file descriptor `fd` from the interest list.\n    ///\n    /// [`epoll_ctl`](https://man7.org/linux/man-pages/man2/epoll_ctl.2.html) with `EPOLL_CTL_DEL` .\n    pub fn delete\u003cFd: AsFd\u003e(\u0026self, fd: Fd) -\u003e Result\u003c()\u003e {\n        self.epoll_ctl(EpollOp::EpollCtlDel, fd, None)\n    }\n    /// Change the settings associated with `fd` in the interest list to the new settings specified\n    /// in `event`.\n    ///\n    /// [`epoll_ctl`](https://man7.org/linux/man-pages/man2/epoll_ctl.2.html) with `EPOLL_CTL_MOD`.\n    pub fn modify\u003cFd: AsFd\u003e(\n        \u0026self,\n        fd: Fd,\n        event: \u0026mut EpollEvent,\n    ) -\u003e Result\u003c()\u003e {\n        self.epoll_ctl(EpollOp::EpollCtlMod, fd, event)\n    }\n    /// Waits for I/O events, blocking the calling thread if no events are currently available.\n    /// (This can be thought of as fetching items from the ready list of the epoll instance.)\n    ///\n    /// [`epoll_wait`](https://man7.org/linux/man-pages/man2/epoll_wait.2.html)\n    pub fn wait\u003cT: Into\u003cEpollTimeout\u003e\u003e(\n        \u0026self,\n        events: \u0026mut [EpollEvent],\n        timeout: T,\n    ) -\u003e Result\u003cusize\u003e {\n        let res = unsafe {\n            libc::epoll_wait(\n                self.0.as_raw_fd(),\n                events.as_mut_ptr().cast(),\n                events.len() as c_int,\n                timeout.into().into(),\n            )\n        };\n\n        Errno::result(res).map(|r| r as usize)\n    }\n    /// This system call is used to add, modify, or remove entries in the interest list of the epoll\n    /// instance referred to by `self`. It requests that the operation `op` be performed for the\n    /// target file descriptor, `fd`.\n    ///\n    /// When possible prefer [`Epoll::add`], [`Epoll::delete`] and [`Epoll::modify`].\n    ///\n    /// [`epoll_ctl`](https://man7.org/linux/man-pages/man2/epoll_ctl.2.html)\n    fn epoll_ctl\u003c'a, Fd: AsFd, T\u003e(\n        \u0026self,\n        op: EpollOp,\n        fd: Fd,\n        event: T,\n    ) -\u003e Result\u003c()\u003e\n    where\n        T: Into\u003cOption\u003c\u0026'a mut EpollEvent\u003e\u003e,\n    {\n        let event: Option\u003c\u0026mut EpollEvent\u003e = event.into();\n        let ptr = event\n            .map(|x| \u0026mut x.event as *mut libc::epoll_event)\n            .unwrap_or(std::ptr::null_mut());\n        unsafe {\n            Errno::result(libc::epoll_ctl(\n                self.0.as_raw_fd(),\n                op as c_int,\n                fd.as_fd().as_raw_fd(),\n                ptr,\n            ))\n            .map(drop)\n        }\n    }\n}\n\n#[deprecated(since = \"0.27.0\", note = \"Use Epoll::new() instead\")]\n#[inline]\npub fn epoll_create() -\u003e Result\u003cRawFd\u003e {\n    let res = unsafe { libc::epoll_create(1024) };\n\n    Errno::result(res)\n}\n\n#[deprecated(since = \"0.27.0\", note = \"Use Epoll::new() instead\")]\n#[inline]\npub fn epoll_create1(flags: EpollCreateFlags) -\u003e Result\u003cRawFd\u003e {\n    let res = unsafe { libc::epoll_create1(flags.bits()) };\n\n    Errno::result(res)\n}\n\n#[deprecated(\n    since = \"0.27.0\",\n    note = \"Use corresponding Epoll methods instead\"\n)]\n#[inline]\npub fn epoll_ctl\u003c'a, T\u003e(\n    epfd: RawFd,\n    op: EpollOp,\n    fd: RawFd,\n    event: T,\n) -\u003e Result\u003c()\u003e\nwhere\n    T: Into\u003cOption\u003c\u0026'a mut EpollEvent\u003e\u003e,\n{\n    let mut event: Option\u003c\u0026mut EpollEvent\u003e = event.into();\n    if event.is_none() \u0026\u0026 op != EpollOp::EpollCtlDel {\n        Err(Errno::EINVAL)\n    } else {\n        let res = unsafe {\n            if let Some(ref mut event) = event {\n                libc::epoll_ctl(epfd, op as c_int, fd, \u0026mut event.event)\n            } else {\n                libc::epoll_ctl(epfd, op as c_int, fd, std::ptr::null_mut())\n            }\n        };\n        Errno::result(res).map(drop)\n    }\n}\n\n#[deprecated(since = \"0.27.0\", note = \"Use Epoll::wait() instead\")]\n#[inline]\npub fn epoll_wait(\n    epfd: RawFd,\n    events: \u0026mut [EpollEvent],\n    timeout_ms: isize,\n) -\u003e Result\u003cusize\u003e {\n    let res = unsafe {\n        libc::epoll_wait(\n            epfd,\n            events.as_mut_ptr().cast(),\n            events.len() as c_int,\n            timeout_ms as c_int,\n        )\n    };\n\n    Errno::result(res).map(|r| r as usize)\n}\n","traces":[{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":38},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","event.rs"],"content":"//! Kernel event notification mechanism\n//!\n//! # See Also\n//! [kqueue(2)](https://www.freebsd.org/cgi/man.cgi?query=kqueue)\n\nuse crate::{Errno, Result};\n#[cfg(not(target_os = \"netbsd\"))]\nuse libc::{c_int, c_long, intptr_t, time_t, timespec, uintptr_t};\n#[cfg(target_os = \"netbsd\")]\nuse libc::{c_long, intptr_t, size_t, time_t, timespec, uintptr_t};\nuse std::convert::TryInto;\nuse std::mem;\nuse std::os::fd::{AsFd, BorrowedFd};\nuse std::os::unix::io::{AsRawFd, FromRawFd, OwnedFd};\nuse std::ptr;\n\n/// A kernel event queue.  Used to notify a process of various asynchronous\n/// events.\n#[repr(C)]\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct KEvent {\n    kevent: libc::kevent,\n}\n\n/// A kernel event queue.\n///\n/// Used by the kernel to notify the process of various types of asynchronous\n/// events.\n#[repr(transparent)]\n#[derive(Debug)]\npub struct Kqueue(OwnedFd);\n\nimpl AsFd for Kqueue {\n    fn as_fd(\u0026self) -\u003e BorrowedFd\u003c'_\u003e {\n        self.0.as_fd()\n    }\n}\n\nimpl From\u003cKqueue\u003e for OwnedFd {\n    fn from(value: Kqueue) -\u003e Self {\n        value.0\n    }\n}\n\nimpl Kqueue {\n    /// Create a new kernel event queue.\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        let res = unsafe { libc::kqueue() };\n\n        Errno::result(res).map(|fd| unsafe { Self(OwnedFd::from_raw_fd(fd)) })\n    }\n\n    /// Register new events with the kqueue, and return any pending events to\n    /// the user.\n    ///\n    /// This method will block until either the timeout expires, or a registered\n    /// event triggers a notification.\n    ///\n    /// # Arguments\n    /// - `changelist` - Any new kevents to register for notifications.\n    /// - `eventlist` - Storage space for the kernel to return notifications.\n    /// - `timeout` - An optional timeout.\n    ///\n    /// # Returns\n    /// Returns the number of events placed in the `eventlist`.  If an error\n    /// occurs while processing an element of the `changelist` and there is\n    /// enough room in the `eventlist`, then the event will be placed in the\n    /// `eventlist` with `EV_ERROR` set in `flags` and the system error in\n    /// `data`.\n    pub fn kevent(\n        \u0026self,\n        changelist: \u0026[KEvent],\n        eventlist: \u0026mut [KEvent],\n        timeout_opt: Option\u003ctimespec\u003e,\n    ) -\u003e Result\u003cusize\u003e {\n        let res = unsafe {\n            libc::kevent(\n                self.0.as_raw_fd(),\n                changelist.as_ptr().cast(),\n                changelist.len() as type_of_nchanges,\n                eventlist.as_mut_ptr().cast(),\n                eventlist.len() as type_of_nchanges,\n                if let Some(ref timeout) = timeout_opt {\n                    timeout as *const timespec\n                } else {\n                    ptr::null()\n                },\n            )\n        };\n        Errno::result(res).map(|r| r as usize)\n    }\n}\n\n#[cfg(any(freebsdlike, apple_targets, target_os = \"openbsd\"))]\ntype type_of_udata = *mut libc::c_void;\n#[cfg(target_os = \"netbsd\")]\ntype type_of_udata = intptr_t;\n\n#[cfg(target_os = \"netbsd\")]\ntype type_of_event_filter = u32;\n#[cfg(not(target_os = \"netbsd\"))]\ntype type_of_event_filter = i16;\nlibc_enum! {\n    #[cfg_attr(target_os = \"netbsd\", repr(u32))]\n    #[cfg_attr(not(target_os = \"netbsd\"), repr(i16))]\n    #[non_exhaustive]\n    /// Kqueue filter types.  These are all the different types of event that a\n    /// kqueue can notify for.\n    pub enum EventFilter {\n        /// Notifies on the completion of a POSIX AIO operation.\n        EVFILT_AIO,\n        #[cfg(target_os = \"freebsd\")]\n        /// Returns whenever there is no remaining data in the write buffer\n        EVFILT_EMPTY,\n        #[cfg(target_os = \"dragonfly\")]\n        /// Takes a descriptor as the identifier, and returns whenever one of\n        /// the specified exceptional conditions has occurred on the descriptor.\n        EVFILT_EXCEPT,\n        #[cfg(any(freebsdlike, apple_targets))]\n        /// Establishes a file system monitor.\n        EVFILT_FS,\n        #[cfg(target_os = \"freebsd\")]\n        /// Notify for completion of a list of POSIX AIO operations.\n        /// # See Also\n        /// [lio_listio(2)](https://www.freebsd.org/cgi/man.cgi?query=lio_listio)\n        EVFILT_LIO,\n        #[cfg(apple_targets)]\n        /// Mach portsets\n        EVFILT_MACHPORT,\n        /// Notifies when a process performs one or more of the requested\n        /// events.\n        EVFILT_PROC,\n        /// Returns events associated with the process referenced by a given\n        /// process descriptor, created by `pdfork()`. The events to monitor are:\n        ///\n        /// - NOTE_EXIT: the process has exited. The exit status will be stored in data.\n        #[cfg(target_os = \"freebsd\")]\n        EVFILT_PROCDESC,\n        /// Takes a file descriptor as the identifier, and notifies whenever\n        /// there is data available to read.\n        EVFILT_READ,\n        #[cfg(target_os = \"freebsd\")]\n        #[doc(hidden)]\n        #[deprecated(since = \"0.27.0\", note = \"Never fully implemented by the OS\")]\n        EVFILT_SENDFILE,\n        /// Takes a signal number to monitor as the identifier and notifies when\n        /// the given signal is delivered to the process.\n        EVFILT_SIGNAL,\n        /// Establishes a timer and notifies when the timer expires.\n        EVFILT_TIMER,\n        #[cfg(any(freebsdlike, apple_targets))]\n        /// Notifies only when explicitly requested by the user.\n        EVFILT_USER,\n        #[cfg(apple_targets)]\n        /// Virtual memory events\n        EVFILT_VM,\n        /// Notifies when a requested event happens on a specified file.\n        EVFILT_VNODE,\n        /// Takes a file descriptor as the identifier, and notifies whenever\n        /// it is possible to write to the file without blocking.\n        EVFILT_WRITE,\n    }\n    impl TryFrom\u003ctype_of_event_filter\u003e\n}\n\n#[cfg(any(freebsdlike, apple_targets, target_os = \"openbsd\"))]\n#[doc(hidden)]\npub type type_of_event_flag = u16;\n#[cfg(target_os = \"netbsd\")]\n#[doc(hidden)]\npub type type_of_event_flag = u32;\nlibc_bitflags! {\n    /// Event flags.  See the man page for details.\n    // There's no useful documentation we can write for the individual flags\n    // that wouldn't simply be repeating the man page.\n    pub struct EvFlags: type_of_event_flag {\n        #[allow(missing_docs)]\n        EV_ADD;\n        #[allow(missing_docs)]\n        EV_CLEAR;\n        #[allow(missing_docs)]\n        EV_DELETE;\n        #[allow(missing_docs)]\n        EV_DISABLE;\n        #[cfg(bsd)]\n        #[allow(missing_docs)]\n        EV_DISPATCH;\n        #[cfg(target_os = \"freebsd\")]\n        #[allow(missing_docs)]\n        EV_DROP;\n        #[allow(missing_docs)]\n        EV_ENABLE;\n        #[allow(missing_docs)]\n        EV_EOF;\n        #[allow(missing_docs)]\n        EV_ERROR;\n        #[cfg(apple_targets)]\n        #[allow(missing_docs)]\n        EV_FLAG0;\n        #[allow(missing_docs)]\n        EV_FLAG1;\n        #[cfg(target_os = \"dragonfly\")]\n        #[allow(missing_docs)]\n        EV_NODATA;\n        #[allow(missing_docs)]\n        EV_ONESHOT;\n        #[cfg(apple_targets)]\n        #[allow(missing_docs)]\n        EV_OOBAND;\n        #[cfg(apple_targets)]\n        #[allow(missing_docs)]\n        EV_POLL;\n        #[cfg(bsd)]\n        #[allow(missing_docs)]\n        EV_RECEIPT;\n    }\n}\n\n#[deprecated(since = \"0.30.0\", note = \"Use `EvFlags instead`\")]\n/// The deprecated EventFlag type alias\npub type EventFlag = EvFlags;\n\nlibc_bitflags!(\n    /// Filter-specific flags.  See the man page for details.\n    // There's no useful documentation we can write for the individual flags\n    // that wouldn't simply be repeating the man page.\n    #[allow(missing_docs)]\n    pub struct FilterFlag: u32 {\n        #[cfg(apple_targets)]\n        #[allow(missing_docs)]\n        NOTE_ABSOLUTE;\n        #[allow(missing_docs)]\n        NOTE_ATTRIB;\n        #[allow(missing_docs)]\n        NOTE_CHILD;\n        #[allow(missing_docs)]\n        NOTE_DELETE;\n        #[cfg(target_os = \"openbsd\")]\n        #[allow(missing_docs)]\n        NOTE_EOF;\n        #[allow(missing_docs)]\n        NOTE_EXEC;\n        #[allow(missing_docs)]\n        NOTE_EXIT;\n        #[cfg(apple_targets)]\n        #[allow(missing_docs)]\n        NOTE_EXITSTATUS;\n        #[allow(missing_docs)]\n        NOTE_EXTEND;\n        #[cfg(any(apple_targets, freebsdlike))]\n        #[allow(missing_docs)]\n        NOTE_FFAND;\n        #[cfg(any(apple_targets, freebsdlike))]\n        #[allow(missing_docs)]\n        NOTE_FFCOPY;\n        #[cfg(any(apple_targets, freebsdlike))]\n        #[allow(missing_docs)]\n        NOTE_FFCTRLMASK;\n        #[cfg(any(apple_targets, freebsdlike))]\n        #[allow(missing_docs)]\n        NOTE_FFLAGSMASK;\n        #[cfg(any(apple_targets, freebsdlike))]\n        #[allow(missing_docs)]\n        NOTE_FFNOP;\n        #[cfg(any(apple_targets, freebsdlike))]\n        #[allow(missing_docs)]\n        NOTE_FFOR;\n        #[allow(missing_docs)]\n        NOTE_FORK;\n        #[allow(missing_docs)]\n        NOTE_LINK;\n        #[allow(missing_docs)]\n        NOTE_LOWAT;\n        #[cfg(target_os = \"freebsd\")]\n        #[allow(missing_docs)]\n        NOTE_MSECONDS;\n        #[cfg(apple_targets)]\n        #[allow(missing_docs)]\n        NOTE_NONE;\n        #[cfg(any(\n            apple_targets,\n            target_os = \"freebsd\"))]\n        #[allow(missing_docs)]\n        NOTE_NSECONDS;\n        #[cfg(target_os = \"dragonfly\")]\n        #[allow(missing_docs)]\n        NOTE_OOB;\n        #[allow(missing_docs)]\n        NOTE_PCTRLMASK;\n        #[allow(missing_docs)]\n        NOTE_PDATAMASK;\n        #[allow(missing_docs)]\n        NOTE_RENAME;\n        #[allow(missing_docs)]\n        NOTE_REVOKE;\n        #[cfg(any(\n            apple_targets,\n            target_os = \"freebsd\"))]\n        #[allow(missing_docs)]\n        NOTE_SECONDS;\n        #[cfg(apple_targets)]\n        #[allow(missing_docs)]\n        NOTE_SIGNAL;\n        #[allow(missing_docs)]\n        NOTE_TRACK;\n        #[allow(missing_docs)]\n        NOTE_TRACKERR;\n        #[cfg(any(apple_targets, freebsdlike))]\n        #[allow(missing_docs)]\n        NOTE_TRIGGER;\n        #[cfg(target_os = \"openbsd\")]\n        #[allow(missing_docs)]\n        NOTE_TRUNCATE;\n        #[cfg(any(\n            apple_targets,\n            target_os = \"freebsd\"))]\n        #[allow(missing_docs)]\n        NOTE_USECONDS;\n        #[cfg(apple_targets)]\n        #[allow(missing_docs)]\n        NOTE_VM_ERROR;\n        #[cfg(apple_targets)]\n        #[allow(missing_docs)]\n        NOTE_VM_PRESSURE;\n        #[cfg(apple_targets)]\n        #[allow(missing_docs)]\n        NOTE_VM_PRESSURE_SUDDEN_TERMINATE;\n        #[cfg(apple_targets)]\n        #[allow(missing_docs)]\n        NOTE_VM_PRESSURE_TERMINATE;\n        #[allow(missing_docs)]\n        NOTE_WRITE;\n    }\n);\n\n#[allow(missing_docs)]\n#[deprecated(since = \"0.27.0\", note = \"Use KEvent::new instead\")]\npub fn kqueue() -\u003e Result\u003cKqueue\u003e {\n    Kqueue::new()\n}\n\n// KEvent can't derive Send because on some operating systems, udata is defined\n// as a void*.  However, KEvent's public API always treats udata as an intptr_t,\n// which is safe to Send.\nunsafe impl Send for KEvent {}\n\nimpl KEvent {\n    #[allow(clippy::needless_update)] // Not needless on all platforms.\n    /// Construct a new `KEvent` suitable for submission to the kernel via the\n    /// `changelist` argument of [`Kqueue::kevent`].\n    pub fn new(\n        ident: uintptr_t,\n        filter: EventFilter,\n        flags: EvFlags,\n        fflags: FilterFlag,\n        data: intptr_t,\n        udata: intptr_t,\n    ) -\u003e KEvent {\n        KEvent {\n            kevent: libc::kevent {\n                ident,\n                filter: filter as type_of_event_filter,\n                flags: flags.bits(),\n                fflags: fflags.bits(),\n                // data can be either i64 or intptr_t, depending on platform\n                data: data as _,\n                udata: udata as type_of_udata,\n                ..unsafe { mem::zeroed() }\n            },\n        }\n    }\n\n    /// Value used to identify this event.  The exact interpretation is\n    /// determined by the attached filter, but often is a raw file descriptor.\n    pub fn ident(\u0026self) -\u003e uintptr_t {\n        self.kevent.ident\n    }\n\n    /// Identifies the kernel filter used to process this event.\n    ///\n    /// Will only return an error if the kernel reports an event via a filter\n    /// that is unknown to Nix.\n    pub fn filter(\u0026self) -\u003e Result\u003cEventFilter\u003e {\n        self.kevent.filter.try_into()\n    }\n\n    /// Flags control what the kernel will do when this event is added with\n    /// [`Kqueue::kevent`].\n    pub fn flags(\u0026self) -\u003e EvFlags {\n        EvFlags::from_bits(self.kevent.flags).unwrap()\n    }\n\n    /// Filter-specific flags.\n    pub fn fflags(\u0026self) -\u003e FilterFlag {\n        FilterFlag::from_bits(self.kevent.fflags).unwrap()\n    }\n\n    /// Filter-specific data value.\n    pub fn data(\u0026self) -\u003e intptr_t {\n        self.kevent.data as intptr_t\n    }\n\n    /// Opaque user-defined value passed through the kernel unchanged.\n    pub fn udata(\u0026self) -\u003e intptr_t {\n        self.kevent.udata as intptr_t\n    }\n}\n\n#[allow(missing_docs)]\n#[deprecated(since = \"0.27.0\", note = \"Use Kqueue::kevent instead\")]\npub fn kevent(\n    kq: \u0026Kqueue,\n    changelist: \u0026[KEvent],\n    eventlist: \u0026mut [KEvent],\n    timeout_ms: usize,\n) -\u003e Result\u003cusize\u003e {\n    // Convert ms to timespec\n    let timeout = timespec {\n        tv_sec: (timeout_ms / 1000) as time_t,\n        tv_nsec: ((timeout_ms % 1000) * 1_000_000) as c_long,\n    };\n\n    kq.kevent(changelist, eventlist, Some(timeout))\n}\n\n#[cfg(any(apple_targets, freebsdlike, target_os = \"openbsd\"))]\ntype type_of_nchanges = c_int;\n#[cfg(target_os = \"netbsd\")]\ntype type_of_nchanges = size_t;\n\n#[allow(missing_docs)]\n#[deprecated(since = \"0.27.0\", note = \"Use Kqueue::kevent instead\")]\npub fn kevent_ts(\n    kq: \u0026Kqueue,\n    changelist: \u0026[KEvent],\n    eventlist: \u0026mut [KEvent],\n    timeout_opt: Option\u003ctimespec\u003e,\n) -\u003e Result\u003cusize\u003e {\n    kq.kevent(changelist, eventlist, timeout_opt)\n}\n\n/// Modify an existing [`KEvent`].\n// Probably should deprecate.  Would anybody ever use it over `KEvent::new`?\n#[deprecated(since = \"0.27.0\", note = \"Use Kqueue::kevent instead\")]\n#[inline]\npub fn ev_set(\n    ev: \u0026mut KEvent,\n    ident: usize,\n    filter: EventFilter,\n    flags: EvFlags,\n    fflags: FilterFlag,\n    udata: intptr_t,\n) {\n    ev.kevent.ident = ident as uintptr_t;\n    ev.kevent.filter = filter as type_of_event_filter;\n    ev.kevent.flags = flags.bits();\n    ev.kevent.fflags = fflags.bits();\n    ev.kevent.data = 0;\n    ev.kevent.udata = udata as type_of_udata;\n}\n","traces":[{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","eventfd.rs"],"content":"use crate::errno::Errno;\nuse crate::{unistd, Result};\nuse std::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, OwnedFd, RawFd};\n\nlibc_bitflags! {\n    /// Eventfd flags.\n    pub struct EfdFlags: libc::c_int {\n        /// Set the close-on-exec (`FD_CLOEXEC`) flag on the new event file descriptor.\n        EFD_CLOEXEC; // Since Linux 2.6.27/FreeBSD 13.0\n        /// Set the `O_NONBLOCK` file status flag on the new event file description.\n        EFD_NONBLOCK; // Since Linux 2.6.27/FreeBSD 13.0\n        /// Provide semaphore-like semantics for reads from the new event file\n        /// descriptor.\n        EFD_SEMAPHORE; // Since Linux 2.6.30/FreeBSD 13.0\n    }\n}\n\n#[deprecated(\n    since = \"0.28.0\",\n    note = \"Use EventFd::from_value_and_flags() instead\"\n)]\n#[allow(missing_docs)]\npub fn eventfd(initval: libc::c_uint, flags: EfdFlags) -\u003e Result\u003cOwnedFd\u003e {\n    let res = unsafe { libc::eventfd(initval, flags.bits()) };\n\n    Errno::result(res).map(|r| unsafe { OwnedFd::from_raw_fd(r) })\n}\n\n/// An eventfd file descriptor.\n#[derive(Debug)]\n#[repr(transparent)]\npub struct EventFd(OwnedFd);\n\nimpl EventFd {\n    /// [`EventFd::from_value_and_flags`] with `init_val = 0` and `flags = EfdFlags::empty()`.\n    pub fn new() -\u003e Result\u003cSelf\u003e {\n        Self::from_value_and_flags(0, EfdFlags::empty())\n    }\n\n    /// Constructs [`EventFd`] with the given `init_val` and `flags`.\n    ///\n    /// Wrapper around [`libc::eventfd`].\n    pub fn from_value_and_flags(\n        init_val: u32,\n        flags: EfdFlags,\n    ) -\u003e Result\u003cSelf\u003e {\n        let res = unsafe { libc::eventfd(init_val, flags.bits()) };\n        Errno::result(res).map(|r| Self(unsafe { OwnedFd::from_raw_fd(r) }))\n    }\n\n    /// [`EventFd::from_value_and_flags`] with `init_val = 0` and given `flags`.\n    pub fn from_flags(flags: EfdFlags) -\u003e Result\u003cSelf\u003e {\n        Self::from_value_and_flags(0, flags)\n    }\n\n    /// [`EventFd::from_value_and_flags`] with given `init_val` and `flags = EfdFlags::empty()`.\n    pub fn from_value(init_val: u32) -\u003e Result\u003cSelf\u003e {\n        Self::from_value_and_flags(init_val, EfdFlags::empty())\n    }\n\n    /// Constructs an `EventFd` wrapping an existing `OwnedFd`.\n    ///\n    /// # Safety\n    ///\n    /// `OwnedFd` is a valid eventfd.\n    pub unsafe fn from_owned_fd(fd: OwnedFd) -\u003e Self {\n        Self(fd)\n    }\n\n    /// Enqueues `value` triggers, i.e., adds the integer value supplied in `value`\n    /// to the counter.\n    ///\n    /// The next `value` calls to `poll`, `select` or `epoll` will return immediately.\n    ///\n    /// [`EventFd::write`] with `value`.\n    pub fn write(\u0026self, value: u64) -\u003e Result\u003cusize\u003e {\n        unistd::write(\u0026self.0, \u0026value.to_ne_bytes())\n    }\n\n    /// Reads the value from the file descriptor.\n    ///\n    /// * If [`EFD_SEMAPHORE`](EfdFlags::EFD_SEMAPHORE) was not specified and\n    ///   the eventfd counter has a nonzero value, then this function returns\n    ///   an `u64` containing that value, and the counter's value is reset to\n    ///   zero.\n    ///\n    /// * If [`EFD_SEMAPHORE`](EfdFlags::EFD_SEMAPHORE) was specified and the\n    ///   eventfd counter has a nonzero value, then this function returns an\n    ///   `u64` containing the value 1, and the counter's value is decremented\n    ///   by 1.\n    ///\n    /// * If the eventfd counter is zero at the time of this call, then the\n    ///   call either blocks until the counter becomes nonzero (at which time,\n    ///   this function proceeds as described above) or fails with the error\n    ///   `EAGAIN` if the file descriptor has been made nonblocking with\n    ///   [`EFD_NONBLOCK`](EfdFlags::EFD_NONBLOCK).\n    pub fn read(\u0026self) -\u003e Result\u003cu64\u003e {\n        let mut arr = [0; std::mem::size_of::\u003cu64\u003e()];\n        unistd::read(\u0026self.0, \u0026mut arr)?;\n        Ok(u64::from_ne_bytes(arr))\n    }\n}\nimpl AsFd for EventFd {\n    fn as_fd(\u0026self) -\u003e BorrowedFd {\n        self.0.as_fd()\n    }\n}\nimpl AsRawFd for EventFd {\n    fn as_raw_fd(\u0026self) -\u003e RawFd {\n        self.0.as_raw_fd()\n    }\n}\n\nimpl From\u003cEventFd\u003e for OwnedFd {\n    fn from(value: EventFd) -\u003e Self {\n        value.0\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","fanotify.rs"],"content":"//! Monitoring API for filesystem events.\n//!\n//! Fanotify is a Linux-only API to monitor filesystems events.\n//!\n//! Additional capabilities compared to the `inotify` API include the ability to\n//! monitor all of the objects in a mounted filesystem, the ability to make\n//! access permission decisions, and the possibility to read or modify files\n//! before access by other applications.\n//!\n//! For more documentation, please read\n//! [fanotify(7)](https://man7.org/linux/man-pages/man7/fanotify.7.html).\n\nuse crate::errno::Errno;\nuse crate::fcntl::OFlag;\nuse crate::unistd::{close, read, write};\nuse crate::{NixPath, Result};\nuse std::marker::PhantomData;\nuse std::mem::{size_of, MaybeUninit};\nuse std::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, OwnedFd, RawFd};\nuse std::ptr;\n\nlibc_bitflags! {\n    /// Mask for defining which events shall be listened with [`Fanotify::mark()`]\n    /// and for querying notifications.\n    pub struct MaskFlags: u64 {\n        /// File was accessed.\n        FAN_ACCESS;\n        /// File was modified.\n        FAN_MODIFY;\n        /// Metadata has changed. Since Linux 5.1.\n        FAN_ATTRIB;\n        /// Writtable file was closed.\n        FAN_CLOSE_WRITE;\n        /// Unwrittable file was closed.\n        FAN_CLOSE_NOWRITE;\n        /// File was opened.\n        FAN_OPEN;\n        /// File was moved from X. Since Linux 5.1.\n        FAN_MOVED_FROM;\n        /// File was moved to Y. Since Linux 5.1.\n        FAN_MOVED_TO;\n        /// Subfile was created. Since Linux 5.1.\n        FAN_CREATE;\n        /// Subfile was deleted. Since Linux 5.1.\n        FAN_DELETE;\n        /// Self was deleted. Since Linux 5.1.\n        FAN_DELETE_SELF;\n        /// Self was moved. Since Linux 5.1.\n        FAN_MOVE_SELF;\n        /// File was opened for execution. Since Linux 5.0.\n        FAN_OPEN_EXEC;\n\n        /// Event queue overflowed.\n        FAN_Q_OVERFLOW;\n        /// Filesystem error. Since Linux 5.16.\n        FAN_FS_ERROR;\n\n        /// Permission to open file was requested.\n        FAN_OPEN_PERM;\n        /// Permission to access file was requested.\n        FAN_ACCESS_PERM;\n        /// Permission to open file for execution was requested. Since Linux\n        /// 5.0.\n        FAN_OPEN_EXEC_PERM;\n\n        /// Interested in child events.\n        FAN_EVENT_ON_CHILD;\n\n        /// File was renamed. Since Linux 5.17.\n        FAN_RENAME;\n\n        /// Event occurred against dir.\n        FAN_ONDIR;\n\n        /// Combination of `FAN_CLOSE_WRITE` and `FAN_CLOSE_NOWRITE`.\n        FAN_CLOSE;\n        /// Combination of `FAN_MOVED_FROM` and `FAN_MOVED_TO`.\n        FAN_MOVE;\n    }\n}\n\nlibc_bitflags! {\n    /// Configuration options for [`Fanotify::init()`].\n    pub struct InitFlags: libc::c_uint {\n        /// Close-on-exec flag set on the file descriptor.\n        FAN_CLOEXEC;\n        /// Nonblocking flag set on the file descriptor.\n        FAN_NONBLOCK;\n\n        /// Receipt of events notifications.\n        FAN_CLASS_NOTIF;\n        /// Receipt of events for permission decisions, after they contain final\n        /// data.\n        FAN_CLASS_CONTENT;\n        /// Receipt of events for permission decisions, before they contain\n        /// final data.\n        FAN_CLASS_PRE_CONTENT;\n\n        /// Remove the limit on the number of events in the event queue.\n        ///\n        /// Prior to Linux kernel 5.13, this limit was hardcoded to 16384. After\n        /// 5.13, one can change it via file `/proc/sys/fs/fanotify/max_queued_events`.\n        ///\n        /// See `fanotify(7)` for details about this limit. Use of this flag\n        /// requires the `CAP_SYS_ADMIN` capability.\n        FAN_UNLIMITED_QUEUE;\n        /// Remove the limit on the number of fanotify marks per user.\n        ///\n        /// Prior to Linux kernel 5.13, this limit was hardcoded to 8192 (per\n        /// group, not per user). After 5.13, one can change it via file\n        /// `/proc/sys/fs/fanotify/max_user_marks`.\n        ///\n        /// See `fanotify(7)` for details about this limit. Use of this flag\n        /// requires the `CAP_SYS_ADMIN` capability.\n        FAN_UNLIMITED_MARKS;\n\n        /// Make `FanotifyEvent::pid` return pidfd. Since Linux 5.15.\n        FAN_REPORT_PIDFD;\n        /// Make `FanotifyEvent::pid` return thread id. Since Linux 4.20.\n        FAN_REPORT_TID;\n    }\n}\n\nlibc_bitflags! {\n    /// File status flags for fanotify events file descriptors.\n    pub struct EventFFlags: libc::c_uint {\n        /// Read only access.\n        O_RDONLY as libc::c_uint;\n        /// Write only access.\n        O_WRONLY as libc::c_uint;\n        /// Read and write access.\n        O_RDWR as libc::c_uint;\n        /// Support for files exceeded 2 GB.\n        O_LARGEFILE as libc::c_uint;\n        /// Close-on-exec flag for the file descriptor. Since Linux 3.18.\n        O_CLOEXEC as libc::c_uint;\n        /// Append mode for the file descriptor.\n        O_APPEND as libc::c_uint;\n        /// Synchronized I/O data integrity completion.\n        O_DSYNC as libc::c_uint;\n        /// No file last access time update.\n        O_NOATIME as libc::c_uint;\n        /// Nonblocking mode for the file descriptor.\n        O_NONBLOCK as libc::c_uint;\n        /// Synchronized I/O file integrity completion.\n        O_SYNC as libc::c_uint;\n    }\n}\n\nimpl TryFrom\u003cOFlag\u003e for EventFFlags {\n    type Error = Errno;\n\n    fn try_from(o_flag: OFlag) -\u003e Result\u003cSelf\u003e {\n        EventFFlags::from_bits(o_flag.bits() as u32).ok_or(Errno::EINVAL)\n    }\n}\n\nimpl From\u003cEventFFlags\u003e for OFlag {\n    fn from(event_f_flags: EventFFlags) -\u003e Self {\n        OFlag::from_bits_retain(event_f_flags.bits() as i32)\n    }\n}\n\nlibc_bitflags! {\n    /// Configuration options for [`Fanotify::mark()`].\n    pub struct MarkFlags: libc::c_uint {\n        /// Add the events to the marks.\n        FAN_MARK_ADD;\n        /// Remove the events to the marks.\n        FAN_MARK_REMOVE;\n        /// Don't follow symlinks, mark them.\n        FAN_MARK_DONT_FOLLOW;\n        /// Raise an error if filesystem to be marked is not a directory.\n        FAN_MARK_ONLYDIR;\n        /// Events added to or removed from the marks.\n        FAN_MARK_IGNORED_MASK;\n        /// Ignore mask shall survive modify events.\n        FAN_MARK_IGNORED_SURV_MODIFY;\n        /// Remove all marks.\n        FAN_MARK_FLUSH;\n        /// Do not pin inode object in the inode cache. Since Linux 5.19.\n        FAN_MARK_EVICTABLE;\n        /// Events added to or removed from the marks. Since Linux 6.0.\n        FAN_MARK_IGNORE;\n\n        /// Default flag.\n        FAN_MARK_INODE;\n        /// Mark the mount specified by pathname.\n        FAN_MARK_MOUNT;\n        /// Mark the filesystem specified by pathname. Since Linux 4.20.\n        FAN_MARK_FILESYSTEM;\n\n        /// Combination of `FAN_MARK_IGNORE` and `FAN_MARK_IGNORED_SURV_MODIFY`.\n        FAN_MARK_IGNORE_SURV;\n    }\n}\n\n/// Compile version number of fanotify API.\npub const FANOTIFY_METADATA_VERSION: u8 = libc::FANOTIFY_METADATA_VERSION;\n\n/// Abstract over [`libc::fanotify_event_metadata`], which represents an event\n/// received via [`Fanotify::read_events`].\n// Is not Clone due to fd field, to avoid use-after-close scenarios.\n#[derive(Debug, Eq, Hash, PartialEq)]\n#[repr(transparent)]\n#[allow(missing_copy_implementations)]\npub struct FanotifyEvent(libc::fanotify_event_metadata);\n\nimpl FanotifyEvent {\n    /// Version number for the structure. It must be compared to\n    /// `FANOTIFY_METADATA_VERSION` to verify compile version and runtime\n    /// version does match. It can be done with the\n    /// `FanotifyEvent::check_version` method.\n    pub fn version(\u0026self) -\u003e u8 {\n        self.0.vers\n    }\n\n    /// Checks that compile fanotify API version is equal to the version of the\n    /// event.\n    pub fn check_version(\u0026self) -\u003e bool {\n        self.version() == FANOTIFY_METADATA_VERSION\n    }\n\n    /// Mask flags of the events.\n    pub fn mask(\u0026self) -\u003e MaskFlags {\n        MaskFlags::from_bits_truncate(self.0.mask)\n    }\n\n    /// The file descriptor of the event. If the value is `None` when reading\n    /// from the fanotify group, this event is to notify that a group queue\n    /// overflow occured.\n    pub fn fd(\u0026self) -\u003e Option\u003cBorrowedFd\u003e {\n        if self.0.fd == libc::FAN_NOFD {\n            None\n        } else {\n            // SAFETY: self.0.fd will be opened for the lifetime of `Self`,\n            // which is longer than the lifetime of the returned BorrowedFd, so\n            // it is safe.\n            Some(unsafe { BorrowedFd::borrow_raw(self.0.fd) })\n        }\n    }\n\n    /// PID of the process that caused the event. TID in case flag\n    /// `FAN_REPORT_TID` was set at group initialization.\n    pub fn pid(\u0026self) -\u003e i32 {\n        self.0.pid\n    }\n}\n\nimpl Drop for FanotifyEvent {\n    fn drop(\u0026mut self) {\n        if self.0.fd == libc::FAN_NOFD {\n            return;\n        }\n        let e = close(self.0.fd);\n        if !std::thread::panicking() \u0026\u0026 e == Err(Errno::EBADF) {\n            panic!(\"Closing an invalid file descriptor!\");\n        };\n    }\n}\n\n/// Abstraction over the structure to be sent to allow or deny a given event.\n#[derive(Debug)]\n#[repr(transparent)]\npub struct FanotifyResponse\u003c'a\u003e {\n    inner: libc::fanotify_response,\n    _borrowed_fd: PhantomData\u003cBorrowedFd\u003c'a\u003e\u003e,\n}\n\nimpl\u003c'a\u003e FanotifyResponse\u003c'a\u003e {\n    /// Create a new response.\n    pub fn new(fd: BorrowedFd\u003c'a\u003e, response: Response) -\u003e Self {\n        Self {\n            inner: libc::fanotify_response {\n                fd: fd.as_raw_fd(),\n                response: response.bits(),\n            },\n            _borrowed_fd: PhantomData,\n        }\n    }\n}\n\nlibc_bitflags! {\n    /// Response to be wrapped in [`FanotifyResponse`] and sent to the [`Fanotify`]\n    /// group to allow or deny an event.\n    pub struct Response: u32 {\n        /// Allow the event.\n        FAN_ALLOW;\n        /// Deny the event.\n        FAN_DENY;\n    }\n}\n\n/// A fanotify group. This is also a file descriptor that can feed to other\n/// interfaces consuming file descriptors.\n#[derive(Debug)]\npub struct Fanotify {\n    fd: OwnedFd,\n}\n\nimpl Fanotify {\n    /// Initialize a new fanotify group.\n    ///\n    /// Returns a Result containing a Fanotify instance.\n    ///\n    /// For more information, see [fanotify_init(2)](https://man7.org/linux/man-pages/man7/fanotify_init.2.html).\n    pub fn init(\n        flags: InitFlags,\n        event_f_flags: EventFFlags,\n    ) -\u003e Result\u003cFanotify\u003e {\n        let res = Errno::result(unsafe {\n            libc::fanotify_init(flags.bits(), event_f_flags.bits())\n        });\n        res.map(|fd| Fanotify {\n            fd: unsafe { OwnedFd::from_raw_fd(fd) },\n        })\n    }\n\n    /// Add, remove, or modify an fanotify mark on a filesystem object.\n    ///\n    /// Returns a Result containing either `()` on success or errno otherwise.\n    ///\n    /// For more information, see [fanotify_mark(2)](https://man7.org/linux/man-pages/man7/fanotify_mark.2.html).\n    pub fn mark\u003cFd: std::os::fd::AsFd, P: ?Sized + NixPath\u003e(\n        \u0026self,\n        flags: MarkFlags,\n        mask: MaskFlags,\n        dirfd: Fd,\n        path: Option\u003c\u0026P\u003e,\n    ) -\u003e Result\u003c()\u003e {\n        let res = crate::with_opt_nix_path(path, |p| unsafe {\n            libc::fanotify_mark(\n                self.fd.as_raw_fd(),\n                flags.bits(),\n                mask.bits(),\n                dirfd.as_fd().as_raw_fd(),\n                p,\n            )\n        })?;\n\n        Errno::result(res).map(|_| ())\n    }\n\n    /// Read incoming events from the fanotify group.\n    ///\n    /// Returns a Result containing either a `Vec` of events on success or errno\n    /// otherwise.\n    ///\n    /// # Errors\n    ///\n    /// Possible errors can be those that are explicitly listed in\n    /// [fanotify(2)](https://man7.org/linux/man-pages/man7/fanotify.2.html) in\n    /// addition to the possible errors caused by `read` call.\n    /// In particular, `EAGAIN` is returned when no event is available on a\n    /// group that has been initialized with the flag `InitFlags::FAN_NONBLOCK`,\n    /// thus making this method nonblocking.\n    pub fn read_events(\u0026self) -\u003e Result\u003cVec\u003cFanotifyEvent\u003e\u003e {\n        let metadata_size = size_of::\u003clibc::fanotify_event_metadata\u003e();\n        const BUFSIZ: usize = 4096;\n        let mut buffer = [0u8; BUFSIZ];\n        let mut events = Vec::new();\n        let mut offset = 0;\n\n        let nread = read(\u0026self.fd, \u0026mut buffer)?;\n\n        while (nread - offset) \u003e= metadata_size {\n            let metadata = unsafe {\n                let mut metadata =\n                    MaybeUninit::\u003clibc::fanotify_event_metadata\u003e::uninit();\n                ptr::copy_nonoverlapping(\n                    buffer.as_ptr().add(offset),\n                    metadata.as_mut_ptr().cast(),\n                    (BUFSIZ - offset).min(metadata_size),\n                );\n                metadata.assume_init()\n            };\n\n            events.push(FanotifyEvent(metadata));\n            offset += metadata.event_len as usize;\n        }\n\n        Ok(events)\n    }\n\n    /// Write an event response on the fanotify group.\n    ///\n    /// Returns a Result containing either `()` on success or errno otherwise.\n    ///\n    /// # Errors\n    ///\n    /// Possible errors can be those that are explicitly listed in\n    /// [fanotify(2)](https://man7.org/linux/man-pages/man7/fanotify.2.html) in\n    /// addition to the possible errors caused by `write` call.\n    /// In particular, `EAGAIN` or `EWOULDBLOCK` is returned when no event is\n    /// available on a group that has been initialized with the flag\n    /// `InitFlags::FAN_NONBLOCK`, thus making this method nonblocking.\n    pub fn write_response(\u0026self, response: FanotifyResponse) -\u003e Result\u003c()\u003e {\n        write(self.fd.as_fd(), unsafe {\n            std::slice::from_raw_parts(\n                (\u0026response.inner as *const libc::fanotify_response).cast(),\n                size_of::\u003clibc::fanotify_response\u003e(),\n            )\n        })?;\n        Ok(())\n    }\n}\n\nimpl FromRawFd for Fanotify {\n    unsafe fn from_raw_fd(fd: RawFd) -\u003e Self {\n        Fanotify {\n            fd: unsafe { OwnedFd::from_raw_fd(fd) },\n        }\n    }\n}\n\nimpl AsFd for Fanotify {\n    fn as_fd(\u0026'_ self) -\u003e BorrowedFd\u003c'_\u003e {\n        self.fd.as_fd()\n    }\n}\n\nimpl AsRawFd for Fanotify {\n    fn as_raw_fd(\u0026self) -\u003e RawFd\n    {\n        self.fd.as_raw_fd()\n    }\n}\n\nimpl From\u003cFanotify\u003e for OwnedFd {\n    fn from(value: Fanotify) -\u003e Self {\n        value.fd\n    }\n}\n\nimpl Fanotify {\n    /// Constructs a `Fanotify` wrapping an existing `OwnedFd`.\n    ///\n    /// # Safety\n    ///\n    /// `OwnedFd` is a valid `Fanotify`.\n    pub unsafe fn from_owned_fd(fd: OwnedFd) -\u003e Self {\n        Self {\n            fd\n        }\n    }\n}","traces":[{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","inotify.rs"],"content":"//! Monitoring API for filesystem events.\n//!\n//! Inotify is a Linux-only API to monitor filesystems events.\n//!\n//! For more documentation, please read [inotify(7)](https://man7.org/linux/man-pages/man7/inotify.7.html).\n//!\n//! # Examples\n//!\n//! Monitor all events happening in directory \"test\":\n//! ```no_run\n//! # use nix::sys::inotify::{AddWatchFlags,InitFlags,Inotify};\n//! #\n//! // We create a new inotify instance.\n//! let instance = Inotify::init(InitFlags::empty()).unwrap();\n//!\n//! // We add a new watch on directory \"test\" for all events.\n//! let wd = instance.add_watch(\"test\", AddWatchFlags::IN_ALL_EVENTS).unwrap();\n//!\n//! loop {\n//!     // We read from our inotify instance for events.\n//!     let events = instance.read_events().unwrap();\n//!     println!(\"Events: {:?}\", events);\n//! }\n//! ```\n\nuse crate::errno::Errno;\nuse crate::unistd::read;\nuse crate::NixPath;\nuse crate::Result;\nuse cfg_if::cfg_if;\nuse libc::{c_char, c_int};\nuse std::ffi::{CStr, OsStr, OsString};\nuse std::mem::{size_of, MaybeUninit};\nuse std::os::unix::ffi::OsStrExt;\nuse std::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, OwnedFd, RawFd};\nuse std::ptr;\n\nlibc_bitflags! {\n    /// Configuration options for [`inotify_add_watch`](fn.inotify_add_watch.html).\n    pub struct AddWatchFlags: u32 {\n        /// File was accessed.\n        IN_ACCESS;\n        /// File was modified.\n        IN_MODIFY;\n        /// Metadata changed.\n        IN_ATTRIB;\n        /// Writable file was closed.\n        IN_CLOSE_WRITE;\n        /// Nonwritable file was closed.\n        IN_CLOSE_NOWRITE;\n        /// File was opened.\n        IN_OPEN;\n        /// File was moved from X.\n        IN_MOVED_FROM;\n        /// File was moved to Y.\n        IN_MOVED_TO;\n        /// Subfile was created.\n        IN_CREATE;\n        /// Subfile was deleted.\n        IN_DELETE;\n        /// Self was deleted.\n        IN_DELETE_SELF;\n        /// Self was moved.\n        IN_MOVE_SELF;\n\n        /// Backing filesystem was unmounted.\n        IN_UNMOUNT;\n        /// Event queue overflowed.\n        IN_Q_OVERFLOW;\n        /// File was ignored.\n        IN_IGNORED;\n\n        /// Combination of `IN_CLOSE_WRITE` and `IN_CLOSE_NOWRITE`.\n        IN_CLOSE;\n        /// Combination of `IN_MOVED_FROM` and `IN_MOVED_TO`.\n        IN_MOVE;\n\n        /// Only watch the path if it is a directory.\n        IN_ONLYDIR;\n        /// Don't follow symlinks.\n        IN_DONT_FOLLOW;\n\n        /// Event occurred against directory.\n        IN_ISDIR;\n        /// Only send event once.\n        IN_ONESHOT;\n        /// All of the events.\n        IN_ALL_EVENTS;\n    }\n}\n\nlibc_bitflags! {\n    /// Configuration options for [`inotify_init1`](fn.inotify_init1.html).\n    pub struct InitFlags: c_int {\n        /// Set the `FD_CLOEXEC` flag on the file descriptor.\n        IN_CLOEXEC;\n        /// Set the `O_NONBLOCK` flag on the open file description referred to by the new file descriptor.\n        IN_NONBLOCK;\n    }\n}\n\n/// An inotify instance. This is also a file descriptor, you can feed it to\n/// other interfaces consuming file descriptors, epoll for example.\n#[derive(Debug)]\npub struct Inotify {\n    fd: OwnedFd,\n}\n\n/// This object is returned when you create a new watch on an inotify instance.\n/// It is then returned as part of an event once triggered. It allows you to\n/// know which watch triggered which event.\n#[derive(Debug, Clone, Copy, Hash, Eq, PartialEq, Ord, PartialOrd)]\npub struct WatchDescriptor {\n    wd: i32,\n}\n\n/// A single inotify event.\n///\n/// For more documentation see, [inotify(7)](https://man7.org/linux/man-pages/man7/inotify.7.html).\n#[derive(Debug)]\npub struct InotifyEvent {\n    /// Watch descriptor. This field corresponds to the watch descriptor you\n    /// were issued when calling add_watch. It allows you to know which watch\n    /// this event comes from.\n    pub wd: WatchDescriptor,\n    /// Event mask. This field is a bitfield describing the exact event that\n    /// occured.\n    pub mask: AddWatchFlags,\n    /// This cookie is a number that allows you to connect related events. For\n    /// now only IN_MOVED_FROM and IN_MOVED_TO can be connected.\n    pub cookie: u32,\n    /// Filename. This field exists only if the event was triggered for a file\n    /// inside the watched directory.\n    pub name: Option\u003cOsString\u003e,\n}\n\nimpl Inotify {\n    /// Initialize a new inotify instance.\n    ///\n    /// Returns a Result containing an inotify instance.\n    ///\n    /// For more information see, [inotify_init(2)](https://man7.org/linux/man-pages/man2/inotify_init.2.html).\n    pub fn init(flags: InitFlags) -\u003e Result\u003cInotify\u003e {\n        let res = Errno::result(unsafe { libc::inotify_init1(flags.bits()) });\n\n        res.map(|fd| Inotify {\n            fd: unsafe { OwnedFd::from_raw_fd(fd) },\n        })\n    }\n\n    /// Adds a new watch on the target file or directory.\n    ///\n    /// Returns a watch descriptor. This is not a File Descriptor!\n    ///\n    /// For more information see, [inotify_add_watch(2)](https://man7.org/linux/man-pages/man2/inotify_add_watch.2.html).\n    pub fn add_watch\u003cP: ?Sized + NixPath\u003e(\n        \u0026self,\n        path: \u0026P,\n        mask: AddWatchFlags,\n    ) -\u003e Result\u003cWatchDescriptor\u003e {\n        let res = path.with_nix_path(|cstr| unsafe {\n            libc::inotify_add_watch(\n                self.fd.as_raw_fd(),\n                cstr.as_ptr(),\n                mask.bits(),\n            )\n        })?;\n\n        Errno::result(res).map(|wd| WatchDescriptor { wd })\n    }\n\n    /// Removes an existing watch using the watch descriptor returned by\n    /// inotify_add_watch.\n    ///\n    /// Returns an EINVAL error if the watch descriptor is invalid.\n    ///\n    /// For more information see, [inotify_rm_watch(2)](https://man7.org/linux/man-pages/man2/inotify_rm_watch.2.html).\n    pub fn rm_watch(\u0026self, wd: WatchDescriptor) -\u003e Result\u003c()\u003e {\n        cfg_if! {\n            if #[cfg(target_os = \"linux\")] {\n                let arg = wd.wd;\n            } else if #[cfg(target_os = \"android\")] {\n                let arg = wd.wd as u32;\n            }\n        }\n        let res = unsafe { libc::inotify_rm_watch(self.fd.as_raw_fd(), arg) };\n\n        Errno::result(res).map(drop)\n    }\n\n    /// Reads a collection of events from the inotify file descriptor. This call\n    /// can either be blocking or non blocking depending on whether IN_NONBLOCK\n    /// was set at initialization.\n    ///\n    /// Returns as many events as available. If the call was non blocking and no\n    /// events could be read then the EAGAIN error is returned.\n    pub fn read_events(\u0026self) -\u003e Result\u003cVec\u003cInotifyEvent\u003e\u003e {\n        let header_size = size_of::\u003clibc::inotify_event\u003e();\n        const BUFSIZ: usize = 4096;\n        let mut buffer = [0u8; BUFSIZ];\n        let mut events = Vec::new();\n        let mut offset = 0;\n\n        let nread = read(\u0026self.fd, \u0026mut buffer)?;\n\n        while (nread - offset) \u003e= header_size {\n            let event = unsafe {\n                let mut event = MaybeUninit::\u003clibc::inotify_event\u003e::uninit();\n                ptr::copy_nonoverlapping(\n                    buffer.as_ptr().add(offset),\n                    event.as_mut_ptr().cast(),\n                    (BUFSIZ - offset).min(header_size),\n                );\n                event.assume_init()\n            };\n\n            let name = match event.len {\n                0 =\u003e None,\n                _ =\u003e {\n                    let ptr = unsafe {\n                        buffer.as_ptr().add(offset + header_size)\n                            as *const c_char\n                    };\n                    let cstr = unsafe { CStr::from_ptr(ptr) };\n\n                    Some(OsStr::from_bytes(cstr.to_bytes()).to_owned())\n                }\n            };\n\n            events.push(InotifyEvent {\n                wd: WatchDescriptor { wd: event.wd },\n                mask: AddWatchFlags::from_bits_truncate(event.mask),\n                cookie: event.cookie,\n                name,\n            });\n\n            offset += header_size + event.len as usize;\n        }\n\n        Ok(events)\n    }\n\n    /// Constructs an `Inotify` wrapping an existing `OwnedFd`.\n    ///\n    /// # Safety\n    ///\n    /// `OwnedFd` is a valid `Inotify`.\n    pub unsafe fn from_owned_fd(fd: OwnedFd) -\u003e Self {\n        Self {\n            fd\n        }\n    }\n}\n\nimpl FromRawFd for Inotify {\n    unsafe fn from_raw_fd(fd: RawFd) -\u003e Self {\n        Inotify {\n            fd: unsafe { OwnedFd::from_raw_fd(fd) },\n        }\n    }\n}\n\nimpl AsFd for Inotify {\n    fn as_fd(\u0026'_ self) -\u003e BorrowedFd\u003c'_\u003e {\n        self.fd.as_fd()\n    }\n}\n\nimpl From\u003cInotify\u003e for OwnedFd {\n    fn from(value: Inotify) -\u003e Self {\n        value.fd\n    }\n}","traces":[{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","ioctl","bsd.rs"],"content":"/// The datatype used for the ioctl number\n#[doc(hidden)]\n#[cfg(not(solarish))]\npub type ioctl_num_type = ::libc::c_ulong;\n\n#[doc(hidden)]\n#[cfg(solarish)]\npub type ioctl_num_type = ::libc::c_int;\n\n/// The datatype used for the 3rd argument\n#[doc(hidden)]\npub type ioctl_param_type = ::libc::c_int;\n\nmod consts {\n    use crate::sys::ioctl::ioctl_num_type;\n    #[doc(hidden)]\n    pub const VOID: ioctl_num_type = 0x2000_0000;\n    #[doc(hidden)]\n    pub const OUT: ioctl_num_type = 0x4000_0000;\n    #[doc(hidden)]\n    #[allow(overflowing_literals)]\n    pub const IN: ioctl_num_type = 0x8000_0000;\n    #[doc(hidden)]\n    pub const INOUT: ioctl_num_type = IN | OUT;\n    #[doc(hidden)]\n    pub const IOCPARM_MASK: ioctl_num_type = 0x1fff;\n}\n\npub use self::consts::*;\n\n#[macro_export]\n#[doc(hidden)]\nmacro_rules! ioc {\n    ($inout:expr, $group:expr, $num:expr, $len:expr) =\u003e {\n        $inout\n            | (($len as $crate::sys::ioctl::ioctl_num_type\n                \u0026 $crate::sys::ioctl::IOCPARM_MASK)\n                \u003c\u003c 16)\n            | (($group as $crate::sys::ioctl::ioctl_num_type) \u003c\u003c 8)\n            | ($num as $crate::sys::ioctl::ioctl_num_type)\n    };\n}\n\n/// Generate an ioctl request code for a command that passes no data.\n///\n/// This is equivalent to the `_IO()` macro exposed by the C ioctl API.\n///\n/// You should only use this macro directly if the `ioctl` you're working\n/// with is \"bad\" and you cannot use `ioctl_none!()` directly.\n///\n/// # Example\n///\n/// ```\n/// # #[macro_use] extern crate nix;\n/// const KVMIO: u8 = 0xAE;\n/// ioctl_write_int_bad!(kvm_create_vm, request_code_none!(KVMIO, 0x03));\n/// # fn main() {}\n/// ```\n#[macro_export(local_inner_macros)]\nmacro_rules! request_code_none {\n    ($g:expr, $n:expr) =\u003e {\n        ioc!($crate::sys::ioctl::VOID, $g, $n, 0)\n    };\n}\n\n/// Generate an ioctl request code for a command that passes an integer\n///\n/// This is equivalent to the `_IOWINT()` macro exposed by the C ioctl API.\n///\n/// You should only use this macro directly if the `ioctl` you're working\n/// with is \"bad\" and you cannot use `ioctl_write_int!()` directly.\n#[macro_export(local_inner_macros)]\nmacro_rules! request_code_write_int {\n    ($g:expr, $n:expr) =\u003e {\n        ioc!(\n            $crate::sys::ioctl::VOID,\n            $g,\n            $n,\n            ::std::mem::size_of::\u003c$crate::libc::c_int\u003e()\n        )\n    };\n}\n\n/// Generate an ioctl request code for a command that reads.\n///\n/// This is equivalent to the `_IOR()` macro exposed by the C ioctl API.\n///\n/// You should only use this macro directly if the `ioctl` you're working\n/// with is \"bad\" and you cannot use `ioctl_read!()` directly.\n///\n/// The read/write direction is relative to userland, so this\n/// command would be userland is reading and the kernel is\n/// writing.\n#[macro_export(local_inner_macros)]\nmacro_rules! request_code_read {\n    ($g:expr, $n:expr, $len:expr) =\u003e {\n        ioc!($crate::sys::ioctl::OUT, $g, $n, $len)\n    };\n}\n\n/// Generate an ioctl request code for a command that writes.\n///\n/// This is equivalent to the `_IOW()` macro exposed by the C ioctl API.\n///\n/// You should only use this macro directly if the `ioctl` you're working\n/// with is \"bad\" and you cannot use `ioctl_write!()` directly.\n///\n/// The read/write direction is relative to userland, so this\n/// command would be userland is writing and the kernel is\n/// reading.\n#[macro_export(local_inner_macros)]\nmacro_rules! request_code_write {\n    ($g:expr, $n:expr, $len:expr) =\u003e {\n        ioc!($crate::sys::ioctl::IN, $g, $n, $len)\n    };\n}\n\n/// Generate an ioctl request code for a command that reads and writes.\n///\n/// This is equivalent to the `_IOWR()` macro exposed by the C ioctl API.\n///\n/// You should only use this macro directly if the `ioctl` you're working\n/// with is \"bad\" and you cannot use `ioctl_readwrite!()` directly.\n#[macro_export(local_inner_macros)]\nmacro_rules! request_code_readwrite {\n    ($g:expr, $n:expr, $len:expr) =\u003e {\n        ioc!($crate::sys::ioctl::INOUT, $g, $n, $len)\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","ioctl","linux.rs"],"content":"use cfg_if::cfg_if;\n\n/// The datatype used for the ioctl number\n#[cfg(any(\n    target_os = \"android\",\n    target_os = \"fuchsia\",\n    target_env = \"musl\",\n    target_env = \"ohos\"\n))]\n#[doc(hidden)]\npub type ioctl_num_type = ::libc::c_int;\n#[cfg(not(any(\n    target_os = \"android\",\n    target_os = \"fuchsia\",\n    target_env = \"musl\",\n    target_env = \"ohos\"\n)))]\n#[doc(hidden)]\npub type ioctl_num_type = ::libc::c_ulong;\n/// The datatype used for the 3rd argument\n#[doc(hidden)]\npub type ioctl_param_type = ::libc::c_ulong;\n\n#[doc(hidden)]\npub const NRBITS: ioctl_num_type = 8;\n#[doc(hidden)]\npub const TYPEBITS: ioctl_num_type = 8;\n\ncfg_if! {\n    if #[cfg(any(\n        target_arch = \"mips\",\n        target_arch = \"mips32r6\",\n        target_arch = \"mips64\",\n        target_arch = \"mips64r6\",\n        target_arch = \"powerpc\",\n        target_arch = \"powerpc64\",\n        target_arch = \"sparc64\"\n    ))] {\n        mod consts {\n            #[doc(hidden)]\n            pub const NONE: u8 = 1;\n            #[doc(hidden)]\n            pub const READ: u8 = 2;\n            #[doc(hidden)]\n            pub const WRITE: u8 = 4;\n            #[doc(hidden)]\n            pub const SIZEBITS: u8 = 13;\n            #[doc(hidden)]\n            pub const DIRBITS: u8 = 3;\n        }\n    } else {\n        // \"Generic\" ioctl protocol\n        mod consts {\n            #[doc(hidden)]\n            pub const NONE: u8 = 0;\n            #[doc(hidden)]\n            pub const READ: u8 = 2;\n            #[doc(hidden)]\n            pub const WRITE: u8 = 1;\n            #[doc(hidden)]\n            pub const SIZEBITS: u8 = 14;\n            #[doc(hidden)]\n            pub const DIRBITS: u8 = 2;\n        }\n    }\n}\n\npub use self::consts::*;\n\n#[doc(hidden)]\npub const NRSHIFT: ioctl_num_type = 0;\n#[doc(hidden)]\npub const TYPESHIFT: ioctl_num_type = NRSHIFT + NRBITS as ioctl_num_type;\n#[doc(hidden)]\npub const SIZESHIFT: ioctl_num_type = TYPESHIFT + TYPEBITS as ioctl_num_type;\n#[doc(hidden)]\npub const DIRSHIFT: ioctl_num_type = SIZESHIFT + SIZEBITS as ioctl_num_type;\n\n#[doc(hidden)]\npub const NRMASK: ioctl_num_type = (1 \u003c\u003c NRBITS) - 1;\n#[doc(hidden)]\npub const TYPEMASK: ioctl_num_type = (1 \u003c\u003c TYPEBITS) - 1;\n#[doc(hidden)]\npub const SIZEMASK: ioctl_num_type = (1 \u003c\u003c SIZEBITS) - 1;\n#[doc(hidden)]\npub const DIRMASK: ioctl_num_type = (1 \u003c\u003c DIRBITS) - 1;\n\n/// Encode an ioctl command.\n#[macro_export]\n#[doc(hidden)]\nmacro_rules! ioc {\n    ($dir:expr, $ty:expr, $nr:expr, $sz:expr) =\u003e {\n        (($dir as $crate::sys::ioctl::ioctl_num_type\n            \u0026 $crate::sys::ioctl::DIRMASK)\n            \u003c\u003c $crate::sys::ioctl::DIRSHIFT)\n            | (($ty as $crate::sys::ioctl::ioctl_num_type\n                \u0026 $crate::sys::ioctl::TYPEMASK)\n                \u003c\u003c $crate::sys::ioctl::TYPESHIFT)\n            | (($nr as $crate::sys::ioctl::ioctl_num_type\n                \u0026 $crate::sys::ioctl::NRMASK)\n                \u003c\u003c $crate::sys::ioctl::NRSHIFT)\n            | (($sz as $crate::sys::ioctl::ioctl_num_type\n                \u0026 $crate::sys::ioctl::SIZEMASK)\n                \u003c\u003c $crate::sys::ioctl::SIZESHIFT)\n    };\n}\n\n/// Generate an ioctl request code for a command that passes no data.\n///\n/// This is equivalent to the `_IO()` macro exposed by the C ioctl API.\n///\n/// You should only use this macro directly if the `ioctl` you're working\n/// with is \"bad\" and you cannot use `ioctl_none!()` directly.\n///\n/// # Example\n///\n/// ```\n/// # #[macro_use] extern crate nix;\n/// const KVMIO: u8 = 0xAE;\n/// ioctl_write_int_bad!(kvm_create_vm, request_code_none!(KVMIO, 0x03));\n/// # fn main() {}\n/// ```\n#[macro_export(local_inner_macros)]\nmacro_rules! request_code_none {\n    ($ty:expr, $nr:expr) =\u003e {\n        ioc!($crate::sys::ioctl::NONE, $ty, $nr, 0)\n    };\n}\n\n/// Generate an ioctl request code for a command that reads.\n///\n/// This is equivalent to the `_IOR()` macro exposed by the C ioctl API.\n///\n/// You should only use this macro directly if the `ioctl` you're working\n/// with is \"bad\" and you cannot use `ioctl_read!()` directly.\n///\n/// The read/write direction is relative to userland, so this\n/// command would be userland is reading and the kernel is\n/// writing.\n#[macro_export(local_inner_macros)]\nmacro_rules! request_code_read {\n    ($ty:expr, $nr:expr, $sz:expr) =\u003e {\n        ioc!($crate::sys::ioctl::READ, $ty, $nr, $sz)\n    };\n}\n\n/// Generate an ioctl request code for a command that writes.\n///\n/// This is equivalent to the `_IOW()` macro exposed by the C ioctl API.\n///\n/// You should only use this macro directly if the `ioctl` you're working\n/// with is \"bad\" and you cannot use `ioctl_write!()` directly.\n///\n/// The read/write direction is relative to userland, so this\n/// command would be userland is writing and the kernel is\n/// reading.\n#[macro_export(local_inner_macros)]\nmacro_rules! request_code_write {\n    ($ty:expr, $nr:expr, $sz:expr) =\u003e {\n        ioc!($crate::sys::ioctl::WRITE, $ty, $nr, $sz)\n    };\n}\n\n/// Generate an ioctl request code for a command that reads and writes.\n///\n/// This is equivalent to the `_IOWR()` macro exposed by the C ioctl API.\n///\n/// You should only use this macro directly if the `ioctl` you're working\n/// with is \"bad\" and you cannot use `ioctl_readwrite!()` directly.\n#[macro_export(local_inner_macros)]\nmacro_rules! request_code_readwrite {\n    ($ty:expr, $nr:expr, $sz:expr) =\u003e {\n        ioc!(\n            $crate::sys::ioctl::READ | $crate::sys::ioctl::WRITE,\n            $ty,\n            $nr,\n            $sz\n        )\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","ioctl","mod.rs"],"content":"//! Provide helpers for making ioctl system calls.\n//!\n//! This library is pretty low-level and messy. `ioctl` is not fun.\n//!\n//! What is an `ioctl`?\n//! ===================\n//!\n//! The `ioctl` syscall is the grab-bag syscall on POSIX systems. Don't want to add a new\n//! syscall? Make it an `ioctl`! `ioctl` refers to both the syscall, and the commands that can be\n//! sent with it. `ioctl` stands for \"IO control\", and the commands are always sent to a file\n//! descriptor.\n//!\n//! It is common to see `ioctl`s used for the following purposes:\n//!\n//!   * Provide read/write access to out-of-band data related to a device such as configuration\n//!     (for instance, setting serial port options)\n//!   * Provide a mechanism for performing full-duplex data transfers (for instance, xfer on SPI\n//!     devices).\n//!   * Provide access to control functions on a device (for example, on Linux you can send\n//!     commands like pause, resume, and eject to the CDROM device.\n//!   * Do whatever else the device driver creator thought made most sense.\n//!\n//! `ioctl`s are synchronous system calls and are similar to read and write calls in that regard.\n//! They operate on file descriptors and have an identifier that specifies what the ioctl is.\n//! Additionally they may read or write data and therefore need to pass along a data pointer.\n//! Besides the semantics of the ioctls being confusing, the generation of this identifer can also\n//! be difficult.\n//!\n//! Historically `ioctl` numbers were arbitrary hard-coded values. In Linux (before 2.6) and some\n//! unices this has changed to a more-ordered system where the ioctl numbers are partitioned into\n//! subcomponents (For linux this is documented in\n//! [`Documentation/ioctl/ioctl-number.rst`](https://elixir.bootlin.com/linux/latest/source/Documentation/userspace-api/ioctl/ioctl-number.rst)):\n//!\n//!   * Number: The actual ioctl ID\n//!   * Type: A grouping of ioctls for a common purpose or driver\n//!   * Size: The size in bytes of the data that will be transferred\n//!   * Direction: Whether there is any data and if it's read, write, or both\n//!\n//! Newer drivers should not generate complete integer identifiers for their `ioctl`s instead\n//! preferring to use the 4 components above to generate the final ioctl identifier. Because of\n//! how old `ioctl`s are, however, there are many hard-coded `ioctl` identifiers. These are\n//! commonly referred to as \"bad\" in `ioctl` documentation.\n//!\n//! Defining `ioctl`s\n//! =================\n//!\n//! This library provides several `ioctl_*!` macros for binding `ioctl`s. These generate public\n//! unsafe functions that can then be used for calling the ioctl. This macro has a few different\n//! ways it can be used depending on the specific ioctl you're working with.\n//!\n//! A simple `ioctl` is `SPI_IOC_RD_MODE`. This ioctl works with the SPI interface on Linux. This\n//! specific `ioctl` reads the mode of the SPI device as a `u8`. It's declared in\n//! `/include/uapi/linux/spi/spidev.h` as `_IOR(SPI_IOC_MAGIC, 1, __u8)`. Since it uses the `_IOR`\n//! macro, we know it's a `read` ioctl and can use the `ioctl_read!` macro as follows:\n//!\n//! ```\n//! # #[macro_use] extern crate nix;\n//! const SPI_IOC_MAGIC: u8 = b'k'; // Defined in linux/spi/spidev.h\n//! const SPI_IOC_TYPE_MODE: u8 = 1;\n//! ioctl_read!(spi_read_mode, SPI_IOC_MAGIC, SPI_IOC_TYPE_MODE, u8);\n//! # fn main() {}\n//! ```\n//!\n//! This generates the function:\n//!\n//! ```\n//! # #[macro_use] extern crate nix;\n//! # use std::mem;\n//! # use nix::{libc, Result};\n//! # use nix::errno::Errno;\n//! # use nix::libc::c_int as c_int;\n//! # const SPI_IOC_MAGIC: u8 = b'k'; // Defined in linux/spi/spidev.h\n//! # const SPI_IOC_TYPE_MODE: u8 = 1;\n//! pub unsafe fn spi_read_mode(fd: c_int, data: *mut u8) -\u003e Result\u003cc_int\u003e {\n//!     let res = unsafe { libc::ioctl(fd, request_code_read!(SPI_IOC_MAGIC, SPI_IOC_TYPE_MODE, mem::size_of::\u003cu8\u003e()), data) };\n//!     Errno::result(res)\n//! }\n//! # fn main() {}\n//! ```\n//!\n//! The return value for the wrapper functions generated by the `ioctl_*!` macros are `nix::Error`s.\n//! These are generated by assuming the return value of the ioctl is `-1` on error and everything\n//! else is a valid return value. If this is not the case, `Result::map` can be used to map some\n//! of the range of \"good\" values (-Inf..-2, 0..Inf) into a smaller range in a helper function.\n//!\n//! Writing `ioctl`s generally use pointers as their data source and these should use the\n//! `ioctl_write_ptr!`. But in some cases an `int` is passed directly. For these `ioctl`s use the\n//! `ioctl_write_int!` macro. This variant does not take a type as the last argument:\n//!\n//! ```\n//! # #[macro_use] extern crate nix;\n//! const HCI_IOC_MAGIC: u8 = b'k';\n//! const HCI_IOC_HCIDEVUP: u8 = 1;\n//! ioctl_write_int!(hci_dev_up, HCI_IOC_MAGIC, HCI_IOC_HCIDEVUP);\n//! # fn main() {}\n//! ```\n//!\n//! Some `ioctl`s don't transfer any data, and those should use `ioctl_none!`. This macro\n//! doesn't take a type and so it is declared similar to the `write_int` variant shown above.\n//!\n//! The mode for a given `ioctl` should be clear from the documentation if it has good\n//! documentation. Otherwise it will be clear based on the macro used to generate the `ioctl`\n//! number where `_IO`, `_IOR`, `_IOW`, and `_IOWR` map to \"none\", \"read\", \"write_*\", and \"readwrite\"\n//! respectively. To determine the specific `write_` variant to use you'll need to find\n//! what the argument type is supposed to be. If it's an `int`, then `write_int` should be used,\n//! otherwise it should be a pointer and `write_ptr` should be used. On Linux the\n//! [`ioctl_list` man page](https://man7.org/linux/man-pages/man2/ioctl_list.2.html) describes a\n//! large number of `ioctl`s and describes their argument data type.\n//!\n//! Using \"bad\" `ioctl`s\n//! --------------------\n//!\n//! As mentioned earlier, there are many old `ioctl`s that do not use the newer method of\n//! generating `ioctl` numbers and instead use hardcoded values. These can be used with the\n//! `ioctl_*_bad!` macros. This naming comes from the Linux kernel which refers to these\n//! `ioctl`s as \"bad\". These are a different variant as they bypass calling the macro that generates\n//! the ioctl number and instead use the defined value directly.\n//!\n//! For example the `TCGETS` `ioctl` reads a `termios` data structure for a given file descriptor.\n//! It's defined as `0x5401` in `ioctls.h` on Linux and can be implemented as:\n//!\n//! ```\n//! # #[macro_use] extern crate nix;\n//! # #[cfg(linux_android)]\n//! # use nix::libc::TCGETS as TCGETS;\n//! # #[cfg(linux_android)]\n//! # use nix::libc::termios as termios;\n//! # #[cfg(linux_android)]\n//! ioctl_read_bad!(tcgets, TCGETS, termios);\n//! # fn main() {}\n//! ```\n//!\n//! The generated function has the same form as that generated by `ioctl_read!`:\n//!\n//! ```text\n//! pub unsafe fn tcgets(fd: c_int, data: *mut termios) -\u003e Result\u003cc_int\u003e;\n//! ```\n//!\n//! Working with Arrays\n//! -------------------\n//!\n//! Some `ioctl`s work with entire arrays of elements. These are supported by the `ioctl_*_buf`\n//! family of macros: `ioctl_read_buf`, `ioctl_write_buf`, and `ioctl_readwrite_buf`. Note that\n//! there are no \"bad\" versions for working with buffers. The generated functions include a `len`\n//! argument to specify the number of elements (where the type of each element is specified in the\n//! macro).\n//!\n//! Again looking to the SPI `ioctl`s on Linux for an example, there is a `SPI_IOC_MESSAGE` `ioctl`\n//! that queues up multiple SPI messages by writing an entire array of `spi_ioc_transfer` structs.\n//! `linux/spi/spidev.h` defines a macro to calculate the `ioctl` number like:\n//!\n//! ```C\n//! #define SPI_IOC_MAGIC 'k'\n//! #define SPI_MSGSIZE(N) ...\n//! #define SPI_IOC_MESSAGE(N) _IOW(SPI_IOC_MAGIC, 0, char[SPI_MSGSIZE(N)])\n//! ```\n//!\n//! The `SPI_MSGSIZE(N)` calculation is already handled by the `ioctl_*!` macros, so all that's\n//! needed to define this `ioctl` is:\n//!\n//! ```\n//! # #[macro_use] extern crate nix;\n//! const SPI_IOC_MAGIC: u8 = b'k'; // Defined in linux/spi/spidev.h\n//! const SPI_IOC_TYPE_MESSAGE: u8 = 0;\n//! # pub struct spi_ioc_transfer(u64);\n//! ioctl_write_buf!(spi_transfer, SPI_IOC_MAGIC, SPI_IOC_TYPE_MESSAGE, spi_ioc_transfer);\n//! # fn main() {}\n//! ```\n//!\n//! This generates a function like:\n//!\n//! ```\n//! # #[macro_use] extern crate nix;\n//! # use std::mem;\n//! # use nix::{libc, Result};\n//! # use nix::errno::Errno;\n//! # use nix::libc::c_int as c_int;\n//! # const SPI_IOC_MAGIC: u8 = b'k';\n//! # const SPI_IOC_TYPE_MESSAGE: u8 = 0;\n//! # pub struct spi_ioc_transfer(u64);\n//! pub unsafe fn spi_message(fd: c_int, data: \u0026mut [spi_ioc_transfer]) -\u003e Result\u003cc_int\u003e {\n//!     let res = unsafe {\n//!         libc::ioctl(\n//!             fd,\n//!             request_code_write!(SPI_IOC_MAGIC, SPI_IOC_TYPE_MESSAGE, data.len() * mem::size_of::\u003cspi_ioc_transfer\u003e()),\n//!             data\n//!         )\n//!     };\n//!     Errno::result(res)\n//! }\n//! # fn main() {}\n//! ```\n//!\n//! Finding `ioctl` Documentation\n//! -----------------------------\n//!\n//! For Linux, look at your system's headers. For example, `/usr/include/linux/input.h` has a lot\n//! of lines defining macros which use `_IO`, `_IOR`, `_IOW`, `_IOC`, and `_IOWR`. Some `ioctl`s are\n//! documented directly in the headers defining their constants, but others have more extensive\n//! documentation in man pages (like termios' `ioctl`s which are in `tty_ioctl(4)`).\n//!\n//! Documenting the Generated Functions\n//! ===================================\n//!\n//! In many cases, users will wish for the functions generated by the `ioctl`\n//! macro to be public and documented. For this reason, the generated functions\n//! are public by default. If you wish to hide the ioctl, you will need to put\n//! them in a private module.\n//!\n//! For documentation, it is possible to use doc comments inside the `ioctl_*!` macros. Here is an\n//! example :\n//!\n//! ```\n//! # #[macro_use] extern crate nix;\n//! # use nix::libc::c_int;\n//! ioctl_read! {\n//!     /// Make the given terminal the controlling terminal of the calling process. The calling\n//!     /// process must be a session leader and not have a controlling terminal already. If the\n//!     /// terminal is already the controlling terminal of a different session group then the\n//!     /// ioctl will fail with **EPERM**, unless the caller is root (more precisely: has the\n//!     /// **CAP_SYS_ADMIN** capability) and arg equals 1, in which case the terminal is stolen\n//!     /// and all processes that had it as controlling terminal lose it.\n//!     tiocsctty, b't', 19, c_int\n//! }\n//!\n//! # fn main() {}\n//! ```\nuse cfg_if::cfg_if;\n\n#[cfg(any(linux_android, target_os = \"fuchsia\", target_os = \"redox\"))]\n#[macro_use]\nmod linux;\n\n#[cfg(any(linux_android, target_os = \"fuchsia\", target_os = \"redox\"))]\npub use self::linux::*;\n\n#[cfg(any(bsd, solarish, target_os = \"haiku\",))]\n#[macro_use]\nmod bsd;\n\n#[cfg(any(bsd, solarish, target_os = \"haiku\",))]\npub use self::bsd::*;\n\n/// Convert raw ioctl return value to a Nix result\n#[macro_export]\n#[doc(hidden)]\nmacro_rules! convert_ioctl_res {\n    ($w:expr) =\u003e {{\n        $crate::errno::Errno::result($w)\n    }};\n}\n\n/// Generates a wrapper function for an ioctl that passes no data to the kernel.\n///\n/// The arguments to this macro are:\n///\n/// * The function name\n/// * The ioctl identifier\n/// * The ioctl sequence number\n///\n/// The generated function has the following signature:\n///\n/// ```rust,ignore\n/// pub unsafe fn FUNCTION_NAME(fd: libc::c_int) -\u003e Result\u003clibc::c_int\u003e\n/// ```\n///\n/// For a more in-depth explanation of ioctls, see [`::sys::ioctl`](sys/ioctl/index.html).\n///\n/// # Example\n///\n/// The `videodev2` driver on Linux defines the `log_status` `ioctl` as:\n///\n/// ```C\n/// #define VIDIOC_LOG_STATUS         _IO('V', 70)\n/// ```\n///\n/// This can be implemented in Rust like:\n///\n/// ```no_run\n/// # #[macro_use] extern crate nix;\n/// ioctl_none!(log_status, b'V', 70);\n/// fn main() {}\n/// ```\n#[macro_export(local_inner_macros)]\nmacro_rules! ioctl_none {\n    ($(#[$attr:meta])* $name:ident, $ioty:expr, $nr:expr) =\u003e (\n        $(#[$attr])*\n        pub unsafe fn $name(fd: $crate::libc::c_int)\n                            -\u003e $crate::Result\u003c$crate::libc::c_int\u003e {\n            unsafe {\n                convert_ioctl_res!($crate::libc::ioctl(fd, request_code_none!($ioty, $nr) as $crate::sys::ioctl::ioctl_num_type))\n            }\n        }\n    )\n}\n\n/// Generates a wrapper function for a \"bad\" ioctl that passes no data to the kernel.\n///\n/// The arguments to this macro are:\n///\n/// * The function name\n/// * The ioctl request code\n///\n/// The generated function has the following signature:\n///\n/// ```rust,ignore\n/// pub unsafe fn FUNCTION_NAME(fd: libc::c_int) -\u003e Result\u003clibc::c_int\u003e\n/// ```\n///\n/// For a more in-depth explanation of ioctls, see [`::sys::ioctl`](sys/ioctl/index.html).\n///\n/// # Example\n///\n/// ```no_run\n/// # #[macro_use] extern crate nix;\n/// # use libc::TIOCNXCL;\n/// # use std::fs::File;\n/// # use std::os::unix::io::AsRawFd;\n/// ioctl_none_bad!(tiocnxcl, TIOCNXCL);\n/// fn main() {\n///     let file = File::open(\"/dev/ttyUSB0\").unwrap();\n///     unsafe { tiocnxcl(file.as_raw_fd()) }.unwrap();\n/// }\n/// ```\n// TODO: add an example using request_code_*!()\n#[macro_export(local_inner_macros)]\nmacro_rules! ioctl_none_bad {\n    ($(#[$attr:meta])* $name:ident, $nr:expr) =\u003e (\n        $(#[$attr])*\n        pub unsafe fn $name(fd: $crate::libc::c_int)\n                            -\u003e $crate::Result\u003c$crate::libc::c_int\u003e {\n            unsafe {\n                convert_ioctl_res!($crate::libc::ioctl(fd, $nr as $crate::sys::ioctl::ioctl_num_type))\n            }\n        }\n    )\n}\n\n/// Generates a wrapper function for an ioctl that reads data from the kernel.\n///\n/// The arguments to this macro are:\n///\n/// * The function name\n/// * The ioctl identifier\n/// * The ioctl sequence number\n/// * The data type passed by this ioctl\n///\n/// The generated function has the following signature:\n///\n/// ```rust,ignore\n/// pub unsafe fn FUNCTION_NAME(fd: libc::c_int, data: *mut DATA_TYPE) -\u003e Result\u003clibc::c_int\u003e\n/// ```\n///\n/// For a more in-depth explanation of ioctls, see [`::sys::ioctl`](sys/ioctl/index.html).\n///\n/// # Example\n///\n/// ```\n/// # #[macro_use] extern crate nix;\n/// const SPI_IOC_MAGIC: u8 = b'k'; // Defined in linux/spi/spidev.h\n/// const SPI_IOC_TYPE_MODE: u8 = 1;\n/// ioctl_read!(spi_read_mode, SPI_IOC_MAGIC, SPI_IOC_TYPE_MODE, u8);\n/// # fn main() {}\n/// ```\n#[macro_export(local_inner_macros)]\nmacro_rules! ioctl_read {\n    ($(#[$attr:meta])* $name:ident, $ioty:expr, $nr:expr, $ty:ty) =\u003e (\n        $(#[$attr])*\n        pub unsafe fn $name(fd: $crate::libc::c_int,\n                            data: *mut $ty)\n                            -\u003e $crate::Result\u003c$crate::libc::c_int\u003e {\n            unsafe {\n                convert_ioctl_res!($crate::libc::ioctl(fd, request_code_read!($ioty, $nr, ::std::mem::size_of::\u003c$ty\u003e()) as $crate::sys::ioctl::ioctl_num_type, data))\n            }\n        }\n    )\n}\n\n/// Generates a wrapper function for a \"bad\" ioctl that reads data from the kernel.\n///\n/// The arguments to this macro are:\n///\n/// * The function name\n/// * The ioctl request code\n/// * The data type passed by this ioctl\n///\n/// The generated function has the following signature:\n///\n/// ```rust,ignore\n/// pub unsafe fn FUNCTION_NAME(fd: libc::c_int, data: *mut DATA_TYPE) -\u003e Result\u003clibc::c_int\u003e\n/// ```\n///\n/// For a more in-depth explanation of ioctls, see [`::sys::ioctl`](sys/ioctl/index.html).\n///\n/// # Example\n///\n/// ```\n/// # #[macro_use] extern crate nix;\n/// # #[cfg(linux_android)]\n/// ioctl_read_bad!(tcgets, libc::TCGETS, libc::termios);\n/// # fn main() {}\n/// ```\n#[macro_export(local_inner_macros)]\nmacro_rules! ioctl_read_bad {\n    ($(#[$attr:meta])* $name:ident, $nr:expr, $ty:ty) =\u003e (\n        $(#[$attr])*\n        pub unsafe fn $name(fd: $crate::libc::c_int,\n                            data: *mut $ty)\n                            -\u003e $crate::Result\u003c$crate::libc::c_int\u003e {\n            unsafe {\n                convert_ioctl_res!($crate::libc::ioctl(fd, $nr as $crate::sys::ioctl::ioctl_num_type, data))\n            }\n        }\n    )\n}\n\n/// Generates a wrapper function for an ioctl that writes data through a pointer to the kernel.\n///\n/// The arguments to this macro are:\n///\n/// * The function name\n/// * The ioctl identifier\n/// * The ioctl sequence number\n/// * The data type passed by this ioctl\n///\n/// The generated function has the following signature:\n///\n/// ```rust,ignore\n/// pub unsafe fn FUNCTION_NAME(fd: libc::c_int, data: *const DATA_TYPE) -\u003e Result\u003clibc::c_int\u003e\n/// ```\n///\n/// For a more in-depth explanation of ioctls, see [`::sys::ioctl`](sys/ioctl/index.html).\n///\n/// # Example\n///\n/// ```\n/// # #[macro_use] extern crate nix;\n/// # pub struct v4l2_audio {}\n/// ioctl_write_ptr!(s_audio, b'V', 34, v4l2_audio);\n/// # fn main() {}\n/// ```\n#[macro_export(local_inner_macros)]\nmacro_rules! ioctl_write_ptr {\n    ($(#[$attr:meta])* $name:ident, $ioty:expr, $nr:expr, $ty:ty) =\u003e (\n        $(#[$attr])*\n        pub unsafe fn $name(fd: $crate::libc::c_int,\n                            data: *const $ty)\n                            -\u003e $crate::Result\u003c$crate::libc::c_int\u003e {\n            unsafe {\n                convert_ioctl_res!($crate::libc::ioctl(fd, request_code_write!($ioty, $nr, ::std::mem::size_of::\u003c$ty\u003e()) as $crate::sys::ioctl::ioctl_num_type, data))\n            }\n        }\n    )\n}\n\n/// Generates a wrapper function for a \"bad\" ioctl that writes data through a pointer to the kernel.\n///\n/// The arguments to this macro are:\n///\n/// * The function name\n/// * The ioctl request code\n/// * The data type passed by this ioctl\n///\n/// The generated function has the following signature:\n///\n/// ```rust,ignore\n/// pub unsafe fn FUNCTION_NAME(fd: libc::c_int, data: *const DATA_TYPE) -\u003e Result\u003clibc::c_int\u003e\n/// ```\n///\n/// For a more in-depth explanation of ioctls, see [`::sys::ioctl`](sys/ioctl/index.html).\n///\n/// # Example\n///\n/// ```\n/// # #[macro_use] extern crate nix;\n/// # #[cfg(linux_android)]\n/// ioctl_write_ptr_bad!(tcsets, libc::TCSETS, libc::termios);\n/// # fn main() {}\n/// ```\n#[macro_export(local_inner_macros)]\nmacro_rules! ioctl_write_ptr_bad {\n    ($(#[$attr:meta])* $name:ident, $nr:expr, $ty:ty) =\u003e (\n        $(#[$attr])*\n        pub unsafe fn $name(fd: $crate::libc::c_int,\n                            data: *const $ty)\n                            -\u003e $crate::Result\u003c$crate::libc::c_int\u003e {\n            unsafe {\n                convert_ioctl_res!($crate::libc::ioctl(fd, $nr as $crate::sys::ioctl::ioctl_num_type, data))\n            }\n        }\n    )\n}\n\ncfg_if! {\n    if #[cfg(freebsdlike)] {\n        /// Generates a wrapper function for a ioctl that writes an integer to the kernel.\n        ///\n        /// The arguments to this macro are:\n        ///\n        /// * The function name\n        /// * The ioctl identifier\n        /// * The ioctl sequence number\n        ///\n        /// The generated function has the following signature:\n        ///\n        /// ```rust,ignore\n        /// pub unsafe fn FUNCTION_NAME(fd: libc::c_int, data: nix::sys::ioctl::ioctl_param_type) -\u003e Result\u003clibc::c_int\u003e\n        /// ```\n        ///\n        /// `nix::sys::ioctl::ioctl_param_type` depends on the OS:\n        /// *   BSD - `libc::c_int`\n        /// *   Linux - `libc::c_ulong`\n        ///\n        /// For a more in-depth explanation of ioctls, see [`::sys::ioctl`](sys/ioctl/index.html).\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// # #[macro_use] extern crate nix;\n        /// ioctl_write_int!(vt_activate, b'v', 4);\n        /// # fn main() {}\n        /// ```\n        #[macro_export(local_inner_macros)]\n        macro_rules! ioctl_write_int {\n            ($(#[$attr:meta])* $name:ident, $ioty:expr, $nr:expr) =\u003e (\n                $(#[$attr])*\n                pub unsafe fn $name(fd: $crate::libc::c_int,\n                                    data: $crate::sys::ioctl::ioctl_param_type)\n                                    -\u003e $crate::Result\u003c$crate::libc::c_int\u003e {\n                    unsafe {\n                        convert_ioctl_res!($crate::libc::ioctl(fd, request_code_write_int!($ioty, $nr) as $crate::sys::ioctl::ioctl_num_type, data))\n                    }\n                }\n            )\n        }\n    } else {\n        /// Generates a wrapper function for a ioctl that writes an integer to the kernel.\n        ///\n        /// The arguments to this macro are:\n        ///\n        /// * The function name\n        /// * The ioctl identifier\n        /// * The ioctl sequence number\n        ///\n        /// The generated function has the following signature:\n        ///\n        /// ```rust,ignore\n        /// pub unsafe fn FUNCTION_NAME(fd: libc::c_int, data: nix::sys::ioctl::ioctl_param_type) -\u003e Result\u003clibc::c_int\u003e\n        /// ```\n        ///\n        /// `nix::sys::ioctl::ioctl_param_type` depends on the OS:\n        /// *   BSD - `libc::c_int`\n        /// *   Linux - `libc::c_ulong`\n        ///\n        /// For a more in-depth explanation of ioctls, see [`::sys::ioctl`](sys/ioctl/index.html).\n        ///\n        /// # Example\n        ///\n        /// ```\n        /// # #[macro_use] extern crate nix;\n        /// const HCI_IOC_MAGIC: u8 = b'k';\n        /// const HCI_IOC_HCIDEVUP: u8 = 1;\n        /// ioctl_write_int!(hci_dev_up, HCI_IOC_MAGIC, HCI_IOC_HCIDEVUP);\n        /// # fn main() {}\n        /// ```\n        #[macro_export(local_inner_macros)]\n        macro_rules! ioctl_write_int {\n            ($(#[$attr:meta])* $name:ident, $ioty:expr, $nr:expr) =\u003e (\n                $(#[$attr])*\n                pub unsafe fn $name(fd: $crate::libc::c_int,\n                                    data: $crate::sys::ioctl::ioctl_param_type)\n                                    -\u003e $crate::Result\u003c$crate::libc::c_int\u003e {\n                    unsafe {\n                        convert_ioctl_res!($crate::libc::ioctl(fd, request_code_write!($ioty, $nr, ::std::mem::size_of::\u003c$crate::libc::c_int\u003e()) as $crate::sys::ioctl::ioctl_num_type, data))\n                    }\n                }\n            )\n        }\n    }\n}\n\n/// Generates a wrapper function for a \"bad\" ioctl that writes an integer to the kernel.\n///\n/// The arguments to this macro are:\n///\n/// * The function name\n/// * The ioctl request code\n///\n/// The generated function has the following signature:\n///\n/// ```rust,ignore\n/// pub unsafe fn FUNCTION_NAME(fd: libc::c_int, data: libc::c_int) -\u003e Result\u003clibc::c_int\u003e\n/// ```\n///\n/// For a more in-depth explanation of ioctls, see [`::sys::ioctl`](sys/ioctl/index.html).\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate nix;\n/// # #[cfg(linux_android)]\n/// ioctl_write_int_bad!(tcsbrk, libc::TCSBRK);\n/// # fn main() {}\n/// ```\n///\n/// ```rust\n/// # #[macro_use] extern crate nix;\n/// const KVMIO: u8 = 0xAE;\n/// ioctl_write_int_bad!(kvm_create_vm, request_code_none!(KVMIO, 0x03));\n/// # fn main() {}\n/// ```\n#[macro_export(local_inner_macros)]\nmacro_rules! ioctl_write_int_bad {\n    ($(#[$attr:meta])* $name:ident, $nr:expr) =\u003e (\n        $(#[$attr])*\n        pub unsafe fn $name(fd: $crate::libc::c_int,\n                            data: $crate::libc::c_int)\n                            -\u003e $crate::Result\u003c$crate::libc::c_int\u003e {\n            unsafe {\n                convert_ioctl_res!($crate::libc::ioctl(fd, $nr as $crate::sys::ioctl::ioctl_num_type, data))\n            }\n        }\n    )\n}\n\n/// Generates a wrapper function for an ioctl that reads and writes data to the kernel.\n///\n/// The arguments to this macro are:\n///\n/// * The function name\n/// * The ioctl identifier\n/// * The ioctl sequence number\n/// * The data type passed by this ioctl\n///\n/// The generated function has the following signature:\n///\n/// ```rust,ignore\n/// pub unsafe fn FUNCTION_NAME(fd: libc::c_int, data: *mut DATA_TYPE) -\u003e Result\u003clibc::c_int\u003e\n/// ```\n///\n/// For a more in-depth explanation of ioctls, see [`::sys::ioctl`](sys/ioctl/index.html).\n///\n/// # Example\n///\n/// ```\n/// # #[macro_use] extern crate nix;\n/// # pub struct v4l2_audio {}\n/// ioctl_readwrite!(enum_audio, b'V', 65, v4l2_audio);\n/// # fn main() {}\n/// ```\n#[macro_export(local_inner_macros)]\nmacro_rules! ioctl_readwrite {\n    ($(#[$attr:meta])* $name:ident, $ioty:expr, $nr:expr, $ty:ty) =\u003e (\n        $(#[$attr])*\n        pub unsafe fn $name(fd: $crate::libc::c_int,\n                            data: *mut $ty)\n                            -\u003e $crate::Result\u003c$crate::libc::c_int\u003e {\n            let ioty = $ioty;\n            let nr = $nr;\n            unsafe {\n                convert_ioctl_res!($crate::libc::ioctl(fd, request_code_readwrite!(ioty, nr, ::std::mem::size_of::\u003c$ty\u003e()) as $crate::sys::ioctl::ioctl_num_type, data))\n            }\n        }\n    )\n}\n\n/// Generates a wrapper function for a \"bad\" ioctl that reads and writes data to the kernel.\n///\n/// The arguments to this macro are:\n///\n/// * The function name\n/// * The ioctl request code\n/// * The data type passed by this ioctl\n///\n/// The generated function has the following signature:\n///\n/// ```rust,ignore\n/// pub unsafe fn FUNCTION_NAME(fd: libc::c_int, data: *mut DATA_TYPE) -\u003e Result\u003clibc::c_int\u003e\n/// ```\n///\n/// For a more in-depth explanation of ioctls, see [`::sys::ioctl`](sys/ioctl/index.html).\n// TODO: Find an example for ioctl_readwrite_bad\n#[macro_export(local_inner_macros)]\nmacro_rules! ioctl_readwrite_bad {\n    ($(#[$attr:meta])* $name:ident, $nr:expr, $ty:ty) =\u003e (\n        $(#[$attr])*\n        pub unsafe fn $name(fd: $crate::libc::c_int,\n                            data: *mut $ty)\n                            -\u003e $crate::Result\u003c$crate::libc::c_int\u003e {\n            unsafe {\n                convert_ioctl_res!($crate::libc::ioctl(fd, $nr as $crate::sys::ioctl::ioctl_num_type, data))\n            }\n        }\n    )\n}\n\n/// Generates a wrapper function for an ioctl that reads an array of elements from the kernel.\n///\n/// The arguments to this macro are:\n///\n/// * The function name\n/// * The ioctl identifier\n/// * The ioctl sequence number\n/// * The data type passed by this ioctl\n///\n/// The generated function has the following signature:\n///\n/// ```rust,ignore\n/// pub unsafe fn FUNCTION_NAME(fd: libc::c_int, data: \u0026mut [DATA_TYPE]) -\u003e Result\u003clibc::c_int\u003e\n/// ```\n///\n/// For a more in-depth explanation of ioctls, see [`::sys::ioctl`](sys/ioctl/index.html).\n// TODO: Find an example for ioctl_read_buf\n#[macro_export(local_inner_macros)]\nmacro_rules! ioctl_read_buf {\n    ($(#[$attr:meta])* $name:ident, $ioty:expr, $nr:expr, $ty:ty) =\u003e (\n        $(#[$attr])*\n        pub unsafe fn $name(fd: $crate::libc::c_int,\n                            data: \u0026mut [$ty])\n                            -\u003e $crate::Result\u003c$crate::libc::c_int\u003e {\n            unsafe {\n                convert_ioctl_res!($crate::libc::ioctl(fd, request_code_read!($ioty, $nr, ::std::mem::size_of_val(data)) as $crate::sys::ioctl::ioctl_num_type, data.as_mut_ptr()))\n            }\n        }\n    )\n}\n\n/// Generates a wrapper function for an ioctl that writes an array of elements to the kernel.\n///\n/// The arguments to this macro are:\n///\n/// * The function name\n/// * The ioctl identifier\n/// * The ioctl sequence number\n/// * The data type passed by this ioctl\n///\n/// The generated function has the following signature:\n///\n/// ```rust,ignore\n/// pub unsafe fn FUNCTION_NAME(fd: libc::c_int, data: \u0026[DATA_TYPE]) -\u003e Result\u003clibc::c_int\u003e\n/// ```\n///\n/// For a more in-depth explanation of ioctls, see [`::sys::ioctl`](sys/ioctl/index.html).\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate nix;\n/// const SPI_IOC_MAGIC: u8 = b'k'; // Defined in linux/spi/spidev.h\n/// const SPI_IOC_TYPE_MESSAGE: u8 = 0;\n/// # pub struct spi_ioc_transfer(u64);\n/// ioctl_write_buf!(spi_transfer, SPI_IOC_MAGIC, SPI_IOC_TYPE_MESSAGE, spi_ioc_transfer);\n/// # fn main() {}\n/// ```\n#[macro_export(local_inner_macros)]\nmacro_rules! ioctl_write_buf {\n    ($(#[$attr:meta])* $name:ident, $ioty:expr, $nr:expr, $ty:ty) =\u003e (\n        $(#[$attr])*\n        pub unsafe fn $name(fd: $crate::libc::c_int,\n                            data: \u0026[$ty])\n                            -\u003e $crate::Result\u003c$crate::libc::c_int\u003e {\n            unsafe {\n                convert_ioctl_res!($crate::libc::ioctl(fd, request_code_write!($ioty, $nr, ::std::mem::size_of_val(data)) as $crate::sys::ioctl::ioctl_num_type, data.as_ptr()))\n            }\n        }\n    )\n}\n\n/// Generates a wrapper function for an ioctl that reads and writes an array of elements to the kernel.\n///\n/// The arguments to this macro are:\n///\n/// * The function name\n/// * The ioctl identifier\n/// * The ioctl sequence number\n/// * The data type passed by this ioctl\n///\n/// The generated function has the following signature:\n///\n/// ```rust,ignore\n/// pub unsafe fn FUNCTION_NAME(fd: libc::c_int, data: \u0026mut [DATA_TYPE]) -\u003e Result\u003clibc::c_int\u003e\n/// ```\n///\n/// For a more in-depth explanation of ioctls, see [`::sys::ioctl`](sys/ioctl/index.html).\n// TODO: Find an example for readwrite_buf\n#[macro_export(local_inner_macros)]\nmacro_rules! ioctl_readwrite_buf {\n    ($(#[$attr:meta])* $name:ident, $ioty:expr, $nr:expr, $ty:ty) =\u003e (\n        $(#[$attr])*\n        pub unsafe fn $name(fd: $crate::libc::c_int,\n                            data: \u0026mut [$ty])\n                            -\u003e $crate::Result\u003c$crate::libc::c_int\u003e {\n            unsafe {\n                convert_ioctl_res!($crate::libc::ioctl(fd, request_code_readwrite!($ioty, $nr, ::std::mem::size_of_val(data)) as $crate::sys::ioctl::ioctl_num_type, data.as_mut_ptr()))\n            }\n        }\n    )\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","memfd.rs"],"content":"//! Interfaces for managing memory-backed files.\n\nuse cfg_if::cfg_if;\nuse std::os::unix::io::{FromRawFd, OwnedFd, RawFd};\n\nuse crate::errno::Errno;\nuse crate::{NixPath, Result};\n\nlibc_bitflags!(\n    /// Options that change the behavior of [`memfd_create`].\n    pub struct MFdFlags: libc::c_uint {\n        /// Set the close-on-exec ([`FD_CLOEXEC`]) flag on the new file descriptor.\n        ///\n        /// By default, the new file descriptor is set to remain open across an [`execve`]\n        /// (the `FD_CLOEXEC` flag is initially disabled). This flag can be used to change\n        /// this default. The file offset is set to the beginning of the file (see [`lseek`]).\n        ///\n        /// See also the description of the `O_CLOEXEC` flag in [`open(2)`].\n        ///\n        /// [`execve`]: crate::unistd::execve\n        /// [`lseek`]: crate::unistd::lseek\n        /// [`FD_CLOEXEC`]: crate::fcntl::FdFlag::FD_CLOEXEC\n        /// [`open(2)`]: https://man7.org/linux/man-pages/man2/open.2.html\n        MFD_CLOEXEC;\n        /// Allow sealing operations on this file.\n        ///\n        /// See also the file sealing notes given in [`memfd_create(2)`].\n        ///\n        /// [`memfd_create(2)`]: https://man7.org/linux/man-pages/man2/memfd_create.2.html\n        MFD_ALLOW_SEALING;\n        /// Anonymous file will be created using huge pages. It should be safe now to\n        /// combine with [`MFD_ALLOW_SEALING`] too.\n        /// However, despite its presence, on FreeBSD it is unimplemented for now (ENOSYS).\n        ///\n        /// See also the hugetlb filesystem in [`memfd_create(2)`].\n        ///\n        /// [`memfd_create(2)`]: https://man7.org/linux/man-pages/man2/memfd_create.2.html\n        #[cfg(linux_android)]\n        MFD_HUGETLB;\n        /// Shift to get the huge page size.\n        #[cfg(target_env = \"ohos\")]\n        MFD_HUGE_SHIFT;\n        /// Mask to get the huge page size.\n        #[cfg(target_env = \"ohos\")]\n        MFD_HUGE_MASK;\n        /// hugetlb size of 64KB.\n        #[cfg(target_env = \"ohos\")]\n        MFD_HUGE_64KB;\n        /// hugetlb size of 512KB.\n        #[cfg(target_env = \"ohos\")]\n        MFD_HUGE_512KB;\n        /// Following are to be used with [`MFD_HUGETLB`], indicating the desired hugetlb size.\n        ///\n        /// See also the hugetlb filesystem in [`memfd_create(2)`].\n        ///\n        /// [`memfd_create(2)`]: https://man7.org/linux/man-pages/man2/memfd_create.2.html\n        #[cfg(linux_android)]\n        MFD_HUGE_1MB;\n        /// hugetlb size of 2MB.\n        #[cfg(linux_android)]\n        MFD_HUGE_2MB;\n        /// hugetlb size of 8MB.\n        #[cfg(linux_android)]\n        MFD_HUGE_8MB;\n        /// hugetlb size of 16MB.\n        #[cfg(linux_android)]\n        MFD_HUGE_16MB;\n        /// hugetlb size of 32MB.\n        #[cfg(linux_android)]\n        MFD_HUGE_32MB;\n        /// hugetlb size of 256MB.\n        #[cfg(linux_android)]\n        MFD_HUGE_256MB;\n        /// hugetlb size of 512MB.\n        #[cfg(linux_android)]\n        MFD_HUGE_512MB;\n        /// hugetlb size of 1GB.\n        #[cfg(linux_android)]\n        MFD_HUGE_1GB;\n        /// hugetlb size of 2GB.\n        #[cfg(linux_android)]\n        MFD_HUGE_2GB;\n        /// hugetlb size of 16GB.\n        #[cfg(linux_android)]\n        MFD_HUGE_16GB;\n    }\n);\n\n#[deprecated(since = \"0.30.0\", note = \"Use `MFdFlags instead`\")]\n/// The deprecated MemFdCreateFlag type alias\npub type MemFdCreateFlag = MFdFlags;\n\n/// Creates an anonymous file that lives in memory, and return a file-descriptor to it.\n///\n/// The file behaves like a regular file, and so can be modified, truncated, memory-mapped, and so on.\n/// However, unlike a regular file, it lives in RAM and has a volatile backing storage.\n///\n/// For more information, see [`memfd_create(2)`].\n///\n/// [`memfd_create(2)`]: https://man7.org/linux/man-pages/man2/memfd_create.2.html\n#[inline] // Delays codegen, preventing linker errors with dylibs and --no-allow-shlib-undefined\npub fn memfd_create\u003cP: NixPath + ?Sized\u003e(\n    name: \u0026P,\n    flags: MFdFlags,\n) -\u003e Result\u003cOwnedFd\u003e {\n    let res = name.with_nix_path(|cstr| {\n        unsafe {\n            cfg_if! {\n            if #[cfg(all(\n                // Android does not have a memfd_create symbol\n                not(target_os = \"android\"),\n                any(\n                    target_os = \"freebsd\",\n                    // If the OS is Linux, gnu/musl/ohos expose a memfd_create symbol but not uclibc\n                    target_env = \"gnu\",\n                    target_env = \"musl\",\n                    target_env = \"ohos\"\n                )))]\n            {\n                libc::memfd_create(cstr.as_ptr(), flags.bits())\n            } else {\n                libc::syscall(libc::SYS_memfd_create, cstr.as_ptr(), flags.bits())\n            }\n        }\n        }\n    })?;\n\n    Errno::result(res).map(|r| unsafe { OwnedFd::from_raw_fd(r as RawFd) })\n}\n","traces":[{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","mman.rs"],"content":"//! Memory management declarations.\n\nuse crate::errno::Errno;\n#[cfg(not(target_os = \"android\"))]\nuse crate::NixPath;\nuse crate::Result;\n#[cfg(not(target_os = \"android\"))]\n#[cfg(feature = \"fs\")]\nuse crate::{fcntl::OFlag, sys::stat::Mode};\nuse libc::{self, c_int, c_void, off_t, size_t};\nuse std::ptr::NonNull;\nuse std::{\n    num::NonZeroUsize,\n    os::unix::io::{AsFd, AsRawFd},\n};\n\nlibc_bitflags! {\n    /// Desired memory protection of a memory mapping.\n    pub struct ProtFlags: c_int {\n        /// Pages cannot be accessed.\n        PROT_NONE;\n        /// Pages can be read.\n        PROT_READ;\n        /// Pages can be written.\n        PROT_WRITE;\n        /// Pages can be executed\n        PROT_EXEC;\n        /// Apply protection up to the end of a mapping that grows upwards.\n        #[cfg(linux_android)]\n        PROT_GROWSDOWN;\n        /// Apply protection down to the beginning of a mapping that grows downwards.\n        #[cfg(linux_android)]\n        PROT_GROWSUP;\n    }\n}\n\nlibc_bitflags! {\n    /// Additional parameters for [`mmap`].\n    pub struct MapFlags: c_int {\n        /// Compatibility flag. Ignored.\n        #[cfg(not(any(target_os = \"solaris\", target_os = \"redox\")))]\n        MAP_FILE;\n        /// Share this mapping. Mutually exclusive with `MAP_PRIVATE`.\n        MAP_SHARED;\n        /// Force mmap to check and fail on unknown flags. This also enables `MAP_SYNC`.\n        #[cfg(target_os = \"linux\")]\n        MAP_SHARED_VALIDATE;\n        /// Create a private copy-on-write mapping. Mutually exclusive with `MAP_SHARED`.\n        MAP_PRIVATE;\n        /// Place the mapping at exactly the address specified in `addr`.\n        MAP_FIXED;\n        /// Place the mapping at exactly the address specified in `addr`, but never clobber an existing range.\n        #[cfg(target_os = \"linux\")]\n        MAP_FIXED_NOREPLACE;\n        /// To be used with `MAP_FIXED`, to forbid the system\n        /// to select a different address than the one specified.\n        #[cfg(target_os = \"freebsd\")]\n        MAP_EXCL;\n        /// Synonym for `MAP_ANONYMOUS`.\n        MAP_ANON;\n        /// The mapping is not backed by any file.\n        MAP_ANONYMOUS;\n        /// Put the mapping into the first 2GB of the process address space.\n        #[cfg(any(all(linux_android,\n                      any(target_arch = \"x86\", target_arch = \"x86_64\")),\n                  all(target_os = \"linux\", target_env = \"musl\", any(target_arch = \"x86\", target_arch = \"x86_64\")),\n                  all(target_os = \"linux\", target_env = \"ohos\", target_arch = \"x86_64\"),\n                  all(target_os = \"freebsd\", target_pointer_width = \"64\")))]\n        MAP_32BIT;\n        /// Used for stacks; indicates to the kernel that the mapping should extend downward in memory.\n        #[cfg(linux_android)]\n        MAP_GROWSDOWN;\n        /// Compatibility flag. Ignored.\n        #[cfg(linux_android)]\n        MAP_DENYWRITE;\n        /// Compatibility flag. Ignored.\n        #[cfg(linux_android)]\n        MAP_EXECUTABLE;\n        /// Mark the mmaped region to be locked in the same way as `mlock(2)`.\n        #[cfg(linux_android)]\n        MAP_LOCKED;\n        /// Do not reserve swap space for this mapping.\n        ///\n        /// This was removed in FreeBSD 11 and is unused in DragonFlyBSD.\n        #[cfg(not(any(freebsdlike, target_os = \"aix\", target_os = \"hurd\", target_os = \"redox\")))]\n        MAP_NORESERVE;\n        /// Populate page tables for a mapping.\n        #[cfg(linux_android)]\n        MAP_POPULATE;\n        /// Only meaningful when used with `MAP_POPULATE`. Don't perform read-ahead.\n        #[cfg(linux_android)]\n        MAP_NONBLOCK;\n        /// Allocate the mapping using \"huge pages.\"\n        #[cfg(linux_android)]\n        MAP_HUGETLB;\n        /// Make use of 64KB huge page (must be supported by the system)\n        #[cfg(target_os = \"linux\")]\n        MAP_HUGE_64KB;\n        /// Make use of 512KB huge page (must be supported by the system)\n        #[cfg(target_os = \"linux\")]\n        MAP_HUGE_512KB;\n        /// Make use of 1MB huge page (must be supported by the system)\n        #[cfg(target_os = \"linux\")]\n        MAP_HUGE_1MB;\n        /// Make use of 2MB huge page (must be supported by the system)\n        #[cfg(target_os = \"linux\")]\n        MAP_HUGE_2MB;\n        /// Make use of 8MB huge page (must be supported by the system)\n        #[cfg(target_os = \"linux\")]\n        MAP_HUGE_8MB;\n        /// Make use of 16MB huge page (must be supported by the system)\n        #[cfg(target_os = \"linux\")]\n        MAP_HUGE_16MB;\n        /// Make use of 32MB huge page (must be supported by the system)\n        #[cfg(target_os = \"linux\")]\n        MAP_HUGE_32MB;\n        /// Make use of 256MB huge page (must be supported by the system)\n        #[cfg(target_os = \"linux\")]\n        MAP_HUGE_256MB;\n        /// Make use of 512MB huge page (must be supported by the system)\n        #[cfg(target_os = \"linux\")]\n        MAP_HUGE_512MB;\n        /// Make use of 1GB huge page (must be supported by the system)\n        #[cfg(target_os = \"linux\")]\n        MAP_HUGE_1GB;\n        /// Make use of 2GB huge page (must be supported by the system)\n        #[cfg(target_os = \"linux\")]\n        MAP_HUGE_2GB;\n        /// Make use of 16GB huge page (must be supported by the system)\n        #[cfg(target_os = \"linux\")]\n        MAP_HUGE_16GB;\n\n        /// Lock the mapped region into memory as with `mlock(2)`.\n        #[cfg(target_os = \"netbsd\")]\n        MAP_WIRED;\n        /// Causes dirtied data in the specified range to be flushed to disk only when necessary.\n        #[cfg(freebsdlike)]\n        MAP_NOSYNC;\n        /// Rename private pages to a file.\n        ///\n        /// This was removed in FreeBSD 11 and is unused in DragonFlyBSD.\n        #[cfg(netbsdlike)]\n        MAP_RENAME;\n        /// Region may contain semaphores.\n        #[cfg(any(freebsdlike, netbsdlike))]\n        MAP_HASSEMAPHORE;\n        /// Region grows down, like a stack.\n        #[cfg(any(linux_android, freebsdlike, netbsdlike))]\n        MAP_STACK;\n        /// Do not write through the page caches, write directly to the file. Used for Direct Access (DAX) enabled file systems.\n        // Available on Linux glibc and musl, MIPS* target excluded.\n        #[cfg(all(target_os = \"linux\", not(any(target_arch = \"mips\", target_arch = \"mips64\", target_arch = \"mips32r6\", target_arch = \"mips64r6\")), not(target_env = \"uclibc\")))]\n        MAP_SYNC;\n        /// Pages in this mapping are not retained in the kernel's memory cache.\n        #[cfg(apple_targets)]\n        MAP_NOCACHE;\n        /// Allows the W/X bit on the page, it's necessary on aarch64 architecture.\n        #[cfg(apple_targets)]\n        MAP_JIT;\n        /// Allows to use large pages, underlying alignment based on size.\n        #[cfg(target_os = \"freebsd\")]\n        MAP_ALIGNED_SUPER;\n        /// Pages will be discarded in the core dumps.\n        #[cfg(target_os = \"openbsd\")]\n        MAP_CONCEAL;\n        /// Attempt to place the mapping at exactly the address specified in `addr`.\n        /// it's a default behavior on OpenBSD.\n        #[cfg(netbsdlike)]\n        MAP_TRYFIXED;\n    }\n}\n\nimpl MapFlags {\n    /// Create `MAP_HUGETLB` with provided size of huge page.\n    ///\n    /// Under the hood it computes `MAP_HUGETLB | (huge_page_size_log2 \u003c\u003c libc::MAP_HUGE_SHIFT`).\n    /// `huge_page_size_log2` denotes logarithm of huge page size to use and should be\n    /// between 16 and 63 (inclusively).\n    ///\n    /// ```\n    /// # use nix::sys::mman::MapFlags;\n    /// let f = MapFlags::map_hugetlb_with_size_log2(30).unwrap();\n    /// assert_eq!(f, MapFlags::MAP_HUGETLB | MapFlags::MAP_HUGE_1GB);\n    /// ```\n    #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n    pub fn map_hugetlb_with_size_log2(\n        huge_page_size_log2: u32,\n    ) -\u003e Option\u003cSelf\u003e {\n        if (16..=63).contains(\u0026huge_page_size_log2) {\n            let flag = libc::MAP_HUGETLB\n                | (huge_page_size_log2 \u003c\u003c libc::MAP_HUGE_SHIFT) as i32;\n            Some(Self(flag.into()))\n        } else {\n            None\n        }\n    }\n}\n\n#[cfg(any(target_os = \"linux\", target_os = \"netbsd\"))]\nlibc_bitflags! {\n    /// Options for [`mremap`].\n    pub struct MRemapFlags: c_int {\n        /// Permit the kernel to relocate the mapping to a new virtual address, if necessary.\n        #[cfg(target_os = \"linux\")]\n        MREMAP_MAYMOVE;\n        /// Place the mapping at exactly the address specified in `new_address`.\n        #[cfg(target_os = \"linux\")]\n        MREMAP_FIXED;\n        /// Works in conjunction with `MREMAP_MAYMOVE` but does not unmap `old_address`.\n        /// Note that, in this case, `old_size` and `new_size` must be the same.\n        #[cfg(target_os = \"linux\")]\n        MREMAP_DONTUNMAP;\n        /// Place the mapping at exactly the address specified in `new_address`.\n        #[cfg(target_os = \"netbsd\")]\n        MAP_FIXED;\n        /// Allows to duplicate the mapping to be able to apply different flags on the copy.\n        #[cfg(target_os = \"netbsd\")]\n        MAP_REMAPDUP;\n    }\n}\n\nlibc_enum! {\n    /// Usage information for a range of memory to allow for performance optimizations by the kernel.\n    ///\n    /// Used by [`madvise`].\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum MmapAdvise {\n        /// No further special treatment. This is the default.\n        MADV_NORMAL,\n        /// Expect random page references.\n        MADV_RANDOM,\n        /// Expect sequential page references.\n        MADV_SEQUENTIAL,\n        /// Expect access in the near future.\n        MADV_WILLNEED,\n        /// Do not expect access in the near future.\n        MADV_DONTNEED,\n        /// Free up a given range of pages and its associated backing store.\n        #[cfg(linux_android)]\n        MADV_REMOVE,\n        /// Do not make pages in this range available to the child after a `fork(2)`.\n        #[cfg(linux_android)]\n        MADV_DONTFORK,\n        /// Undo the effect of `MADV_DONTFORK`.\n        #[cfg(linux_android)]\n        MADV_DOFORK,\n        /// Poison the given pages.\n        ///\n        /// Subsequent references to those pages are treated like hardware memory corruption.\n        #[cfg(linux_android)]\n        MADV_HWPOISON,\n        /// Enable Kernel Samepage Merging (KSM) for the given pages.\n        #[cfg(linux_android)]\n        MADV_MERGEABLE,\n        /// Undo the effect of `MADV_MERGEABLE`\n        #[cfg(linux_android)]\n        MADV_UNMERGEABLE,\n        /// Preserve the memory of each page but offline the original page.\n        #[cfg(any(target_os = \"android\",\n            all(target_os = \"linux\", any(\n                target_arch = \"aarch64\",\n                target_arch = \"arm\",\n                target_arch = \"powerpc\",\n                target_arch = \"powerpc64\",\n                target_arch = \"s390x\",\n                target_arch = \"x86\",\n                target_arch = \"x86_64\",\n                target_arch = \"sparc64\"))))]\n        MADV_SOFT_OFFLINE,\n        /// Enable Transparent Huge Pages (THP) for pages in the given range.\n        #[cfg(linux_android)]\n        MADV_HUGEPAGE,\n        /// Undo the effect of `MADV_HUGEPAGE`.\n        #[cfg(linux_android)]\n        MADV_NOHUGEPAGE,\n        /// Exclude the given range from a core dump.\n        #[cfg(linux_android)]\n        MADV_DONTDUMP,\n        /// Undo the effect of an earlier `MADV_DONTDUMP`.\n        #[cfg(linux_android)]\n        MADV_DODUMP,\n        /// Specify that the application no longer needs the pages in the given range.\n        #[cfg(not(any(target_os = \"aix\", target_os = \"hurd\", target_os = \"cygwin\", target_os = \"redox\")))]\n        MADV_FREE,\n        /// Request that the system not flush the current range to disk unless it needs to.\n        #[cfg(freebsdlike)]\n        MADV_NOSYNC,\n        /// Undoes the effects of `MADV_NOSYNC` for any future pages dirtied within the given range.\n        #[cfg(freebsdlike)]\n        MADV_AUTOSYNC,\n        /// Region is not included in a core file.\n        #[cfg(freebsdlike)]\n        MADV_NOCORE,\n        /// Include region in a core file\n        #[cfg(freebsdlike)]\n        MADV_CORE,\n        /// This process should not be killed when swap space is exhausted.\n        #[cfg(any(target_os = \"freebsd\"))]\n        MADV_PROTECT,\n        /// Invalidate the hardware page table for the given region.\n        #[cfg(target_os = \"dragonfly\")]\n        MADV_INVAL,\n        /// Set the offset of the page directory page to `value` for the virtual page table.\n        #[cfg(target_os = \"dragonfly\")]\n        MADV_SETMAP,\n        /// Indicates that the application will not need the data in the given range.\n        #[cfg(apple_targets)]\n        MADV_ZERO_WIRED_PAGES,\n        /// Pages can be reused (by anyone).\n        #[cfg(apple_targets)]\n        MADV_FREE_REUSABLE,\n        /// Caller wants to reuse those pages.\n        #[cfg(apple_targets)]\n        MADV_FREE_REUSE,\n        // Darwin doesn't document this flag's behavior.\n        #[cfg(apple_targets)]\n        #[allow(missing_docs)]\n        MADV_CAN_REUSE,\n        /// Reclaim the address range when applicable.\n        #[cfg(linux_android)]\n        MADV_PAGEOUT,\n        /// Deactivate the address range when applicable.\n        #[cfg(linux_android)]\n        MADV_COLD,\n        /// After fork, the adress range is zero filled.\n        #[cfg(linux_android)]\n        MADV_WIPEONFORK,\n        /// Undo `MADV_WIPEONFORK` when it applied.\n        #[cfg(linux_android)]\n        MADV_KEEPONFORK,\n        /// Pre-load the address range for reading to reduce page-fault latency.\n        #[cfg(linux_android)]\n        MADV_POPULATE_READ,\n        /// Pre-fault the address range for writing to reduce page-fault\n        /// latency on subsequent writes.\n        #[cfg(linux_android)]\n        MADV_POPULATE_WRITE,\n    }\n}\n\nlibc_bitflags! {\n    /// Configuration flags for [`msync`].\n    pub struct MsFlags: c_int {\n        /// Schedule an update but return immediately.\n        MS_ASYNC;\n        /// Invalidate all cached data.\n        MS_INVALIDATE;\n        /// Invalidate pages, but leave them mapped.\n        #[cfg(apple_targets)]\n        MS_KILLPAGES;\n        /// Deactivate pages, but leave them mapped.\n        #[cfg(apple_targets)]\n        MS_DEACTIVATE;\n        /// Perform an update and wait for it to complete.\n        MS_SYNC;\n    }\n}\n\n#[cfg(not(any(target_os = \"haiku\", target_os = \"cygwin\", target_os = \"redox\")))]\nlibc_bitflags! {\n    /// Flags for [`mlockall`].\n    pub struct MlockAllFlags: c_int {\n        /// Lock pages that are currently mapped into the address space of the process.\n        MCL_CURRENT;\n        /// Lock pages which will become mapped into the address space of the process in the future.\n        MCL_FUTURE;\n    }\n}\n\n/// Locks all memory pages that contain part of the address range with `length`\n/// bytes starting at `addr`.\n///\n/// Locked pages never move to the swap area.\n///\n/// # Safety\n///\n/// `addr` must meet all the requirements described in the [`mlock(2)`] man page.\n///\n/// [`mlock(2)`]: https://man7.org/linux/man-pages/man2/mlock.2.html\npub unsafe fn mlock(addr: NonNull\u003cc_void\u003e, length: size_t) -\u003e Result\u003c()\u003e {\n    unsafe { Errno::result(libc::mlock(addr.as_ptr(), length)).map(drop) }\n}\n\n/// Unlocks all memory pages that contain part of the address range with\n/// `length` bytes starting at `addr`.\n///\n/// # Safety\n///\n/// `addr` must meet all the requirements described in the [`munlock(2)`] man\n/// page.\n///\n/// [`munlock(2)`]: https://man7.org/linux/man-pages/man2/munlock.2.html\npub unsafe fn munlock(addr: NonNull\u003cc_void\u003e, length: size_t) -\u003e Result\u003c()\u003e {\n    unsafe { Errno::result(libc::munlock(addr.as_ptr(), length)).map(drop) }\n}\n\n/// Locks all memory pages mapped into this process' address space.\n///\n/// Locked pages never move to the swap area. For more information, see [`mlockall(2)`].\n///\n/// [`mlockall(2)`]: https://man7.org/linux/man-pages/man2/mlockall.2.html\n#[cfg(not(any(target_os = \"haiku\", target_os = \"cygwin\", target_os = \"redox\")))]\npub fn mlockall(flags: MlockAllFlags) -\u003e Result\u003c()\u003e {\n    unsafe { Errno::result(libc::mlockall(flags.bits())) }.map(drop)\n}\n\n/// Unlocks all memory pages mapped into this process' address space.\n///\n/// For more information, see [`munlockall(2)`].\n///\n/// [`munlockall(2)`]: https://man7.org/linux/man-pages/man2/munlockall.2.html\n#[cfg(not(any(target_os = \"haiku\", target_os = \"cygwin\", target_os = \"redox\")))]\npub fn munlockall() -\u003e Result\u003c()\u003e {\n    unsafe { Errno::result(libc::munlockall()) }.map(drop)\n}\n\n/// Allocate memory, or map files or devices into memory\n///\n/// For anonymous mappings (`MAP_ANON`/`MAP_ANONYMOUS`), see [mmap_anonymous].\n///\n/// # Safety\n///\n/// See the [`mmap(2)`] man page for detailed requirements.\n///\n/// [`mmap(2)`]: https://man7.org/linux/man-pages/man2/mmap.2.html\npub unsafe fn mmap\u003cF: AsFd\u003e(\n    addr: Option\u003cNonZeroUsize\u003e,\n    length: NonZeroUsize,\n    prot: ProtFlags,\n    flags: MapFlags,\n    f: F,\n    offset: off_t,\n) -\u003e Result\u003cNonNull\u003cc_void\u003e\u003e {\n    let ptr = addr.map_or(std::ptr::null_mut(), |a| a.get() as *mut c_void);\n\n    let fd = f.as_fd().as_raw_fd();\n    let ret = unsafe {\n        libc::mmap(ptr, length.into(), prot.bits(), flags.bits(), fd, offset)\n    };\n\n    if std::ptr::eq(ret, libc::MAP_FAILED) {\n        Err(Errno::last())\n    } else {\n        // SAFETY: `libc::mmap` returns a valid non-null pointer or `libc::MAP_FAILED`, thus `ret`\n        // will be non-null here.\n        Ok(unsafe { NonNull::new_unchecked(ret) })\n    }\n}\n\n/// Create an anonymous memory mapping.\n///\n/// This function is a wrapper around [`mmap`]:\n/// `mmap(ptr, len, prot, MAP_ANONYMOUS | flags, -1, 0)`.\n///\n/// # Safety\n///\n/// See the [`mmap(2)`] man page for detailed requirements.\n///\n/// [`mmap(2)`]: https://man7.org/linux/man-pages/man2/mmap.2.html\npub unsafe fn mmap_anonymous(\n    addr: Option\u003cNonZeroUsize\u003e,\n    length: NonZeroUsize,\n    prot: ProtFlags,\n    flags: MapFlags,\n) -\u003e Result\u003cNonNull\u003cc_void\u003e\u003e {\n    let ptr = addr.map_or(std::ptr::null_mut(), |a| a.get() as *mut c_void);\n\n    let flags = MapFlags::MAP_ANONYMOUS | flags;\n    let ret = unsafe {\n        libc::mmap(ptr, length.into(), prot.bits(), flags.bits(), -1, 0)\n    };\n\n    if std::ptr::eq(ret, libc::MAP_FAILED) {\n        Err(Errno::last())\n    } else {\n        // SAFETY: `libc::mmap` returns a valid non-null pointer or `libc::MAP_FAILED`, thus `ret`\n        // will be non-null here.\n        Ok(unsafe { NonNull::new_unchecked(ret) })\n    }\n}\n\n/// Expands (or shrinks) an existing memory mapping, potentially moving it at\n/// the same time.\n///\n/// # Safety\n///\n/// See the `mremap(2)` [man page](https://man7.org/linux/man-pages/man2/mremap.2.html) for\n/// detailed requirements.\n#[cfg(any(target_os = \"linux\", target_os = \"netbsd\"))]\npub unsafe fn mremap(\n    addr: NonNull\u003cc_void\u003e,\n    old_size: size_t,\n    new_size: size_t,\n    flags: MRemapFlags,\n    new_address: Option\u003cNonNull\u003cc_void\u003e\u003e,\n) -\u003e Result\u003cNonNull\u003cc_void\u003e\u003e {\n    #[cfg(target_os = \"linux\")]\n    let ret = unsafe {\n        libc::mremap(\n            addr.as_ptr(),\n            old_size,\n            new_size,\n            flags.bits(),\n            new_address\n                .map(NonNull::as_ptr)\n                .unwrap_or(std::ptr::null_mut()),\n        )\n    };\n    #[cfg(target_os = \"netbsd\")]\n    let ret = unsafe {\n        libc::mremap(\n            addr.as_ptr(),\n            old_size,\n            new_address\n                .map(NonNull::as_ptr)\n                .unwrap_or(std::ptr::null_mut()),\n            new_size,\n            flags.bits(),\n        )\n    };\n\n    if std::ptr::eq(ret, libc::MAP_FAILED) {\n        Err(Errno::last())\n    } else {\n        // SAFETY: `libc::mremap` returns a valid non-null pointer or `libc::MAP_FAILED`, thus `ret`\n        // will be non-null here.\n        Ok(unsafe { NonNull::new_unchecked(ret) })\n    }\n}\n\n/// remove a mapping\n///\n/// # Safety\n///\n/// `addr` must meet all the requirements described in the [`munmap(2)`] man\n/// page.\n///\n/// [`munmap(2)`]: https://man7.org/linux/man-pages/man2/munmap.2.html\npub unsafe fn munmap(addr: NonNull\u003cc_void\u003e, len: size_t) -\u003e Result\u003c()\u003e {\n    unsafe { Errno::result(libc::munmap(addr.as_ptr(), len)).map(drop) }\n}\n\n/// give advice about use of memory\n///\n/// # Safety\n///\n/// See the [`madvise(2)`] man page.  Take special care when using\n/// [`MmapAdvise::MADV_FREE`].\n///\n/// [`madvise(2)`]: https://man7.org/linux/man-pages/man2/madvise.2.html\n#[allow(rustdoc::broken_intra_doc_links)] // For Hurd as `MADV_FREE` is not available on it\npub unsafe fn madvise(\n    addr: NonNull\u003cc_void\u003e,\n    length: size_t,\n    advise: MmapAdvise,\n) -\u003e Result\u003c()\u003e {\n    unsafe {\n        Errno::result(libc::madvise(addr.as_ptr(), length, advise as i32))\n            .map(drop)\n    }\n}\n\n/// Set protection of memory mapping.\n///\n/// See [`mprotect(3)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mprotect.html) for\n/// details.\n///\n/// # Safety\n///\n/// Calls to `mprotect` are inherently unsafe, as changes to memory protections can lead to\n/// SIGSEGVs.\n///\n/// ```\n/// # use nix::libc::size_t;\n/// # use nix::sys::mman::{mmap_anonymous, mprotect, MapFlags, ProtFlags};\n/// # use std::ptr;\n/// # use std::os::unix::io::BorrowedFd;\n/// const ONE_K: size_t = 1024;\n/// let one_k_non_zero = std::num::NonZeroUsize::new(ONE_K).unwrap();\n/// let mut slice: \u0026mut [u8] = unsafe {\n///     let mem = mmap_anonymous(None, one_k_non_zero, ProtFlags::PROT_NONE, MapFlags::MAP_PRIVATE)\n///         .unwrap();\n///     mprotect(mem, ONE_K, ProtFlags::PROT_READ | ProtFlags::PROT_WRITE).unwrap();\n///     std::slice::from_raw_parts_mut(mem.as_ptr().cast(), ONE_K)\n/// };\n/// assert_eq!(slice[0], 0x00);\n/// slice[0] = 0xFF;\n/// assert_eq!(slice[0], 0xFF);\n/// ```\npub unsafe fn mprotect(\n    addr: NonNull\u003cc_void\u003e,\n    length: size_t,\n    prot: ProtFlags,\n) -\u003e Result\u003c()\u003e {\n    unsafe {\n        Errno::result(libc::mprotect(addr.as_ptr(), length, prot.bits()))\n            .map(drop)\n    }\n}\n\n/// synchronize a mapped region\n///\n/// # Safety\n///\n/// `addr` must meet all the requirements described in the [`msync(2)`] man\n/// page.\n///\n/// [`msync(2)`]: https://man7.org/linux/man-pages/man2/msync.2.html\npub unsafe fn msync(\n    addr: NonNull\u003cc_void\u003e,\n    length: size_t,\n    flags: MsFlags,\n) -\u003e Result\u003c()\u003e {\n    unsafe {\n        Errno::result(libc::msync(addr.as_ptr(), length, flags.bits()))\n            .map(drop)\n    }\n}\n\n#[cfg(not(target_os = \"android\"))]\nfeature! {\n#![feature = \"fs\"]\n/// Creates and opens a new, or opens an existing, POSIX shared memory object.\n///\n/// For more information, see [`shm_open(3)`].\n///\n/// [`shm_open(3)`]: https://man7.org/linux/man-pages/man3/shm_open.3.html\npub fn shm_open\u003cP\u003e(\n    name: \u0026P,\n    flag: OFlag,\n    mode: Mode\n    ) -\u003e Result\u003cstd::os::unix::io::OwnedFd\u003e\n    where P: ?Sized + NixPath\n{\n    use std::os::unix::io::{FromRawFd, OwnedFd};\n\n    let ret = name.with_nix_path(|cstr| {\n        #[cfg(apple_targets)]\n        unsafe {\n            libc::shm_open(cstr.as_ptr(), flag.bits(), mode.bits() as libc::c_uint)\n        }\n        #[cfg(not(apple_targets))]\n        unsafe {\n            libc::shm_open(cstr.as_ptr(), flag.bits(), mode.bits() as libc::mode_t)\n        }\n    })?;\n\n    match ret {\n        -1 =\u003e Err(Errno::last()),\n        fd =\u003e Ok(unsafe{ OwnedFd::from_raw_fd(fd) })\n    }\n}\n}\n\n/// Performs the converse of [`shm_open`], removing an object previously created.\n///\n/// For more information, see [`shm_unlink(3)`].\n///\n/// [`shm_unlink(3)`]: https://man7.org/linux/man-pages/man3/shm_unlink.3.html\n#[cfg(not(target_os = \"android\"))]\npub fn shm_unlink\u003cP: ?Sized + NixPath\u003e(name: \u0026P) -\u003e Result\u003c()\u003e {\n    let ret =\n        name.with_nix_path(|cstr| unsafe { libc::shm_unlink(cstr.as_ptr()) })?;\n\n    Errno::result(ret).map(drop)\n}\n","traces":[{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","mod.rs"],"content":"//! Mostly platform-specific functionality\n#[cfg(any(\n    freebsdlike,\n    all(\n        target_os = \"linux\",\n        not(any(target_env = \"uclibc\", target_env = \"ohos\"))\n    ),\n    apple_targets,\n    target_os = \"netbsd\"\n))]\nfeature! {\n    #![feature = \"aio\"]\n    pub mod aio;\n}\n\nfeature! {\n    #![feature = \"event\"]\n\n    #[cfg(linux_android)]\n    #[allow(missing_docs)]\n    pub mod epoll;\n\n    #[cfg(bsd)]\n    pub mod event;\n\n    /// Event file descriptor.\n    #[cfg(any(linux_android, target_os = \"freebsd\"))]\n    pub mod eventfd;\n}\n\n#[cfg(target_os = \"linux\")]\nfeature! {\n    #![feature = \"fanotify\"]\n    pub mod fanotify;\n}\n\n#[cfg(any(\n    bsd,\n    linux_android,\n    solarish,\n    target_os = \"fuchsia\",\n    target_os = \"redox\",\n))]\n#[cfg(feature = \"ioctl\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"ioctl\")))]\n#[macro_use]\npub mod ioctl;\n\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\nfeature! {\n    #![feature = \"fs\"]\n    pub mod memfd;\n}\n\nfeature! {\n    #![feature = \"mman\"]\n    pub mod mman;\n}\n\n#[cfg(target_os = \"linux\")]\nfeature! {\n    #![feature = \"personality\"]\n    pub mod personality;\n}\n\n#[cfg(target_os = \"linux\")]\nfeature! {\n    #![feature = \"process\"]\n    pub mod prctl;\n}\n\nfeature! {\n    #![feature = \"pthread\"]\n    pub mod pthread;\n}\n\n#[cfg(any(linux_android, bsd))]\nfeature! {\n    #![feature = \"ptrace\"]\n    #[allow(missing_docs)]\n    pub mod ptrace;\n}\n\n#[cfg(target_os = \"linux\")]\nfeature! {\n    #![feature = \"quota\"]\n    pub mod quota;\n}\n\n#[cfg(any(target_os = \"linux\", netbsdlike))]\nfeature! {\n    #![feature = \"reboot\"]\n    pub mod reboot;\n}\n\n#[cfg(not(any(\n    target_os = \"redox\",\n    target_os = \"fuchsia\",\n    solarish,\n    target_os = \"haiku\"\n)))]\nfeature! {\n    #![feature = \"resource\"]\n    pub mod resource;\n}\n\nfeature! {\n    #![feature = \"poll\"]\n    pub mod select;\n}\n\n#[cfg(any(linux_android, freebsdlike, apple_targets, solarish))]\nfeature! {\n    #![feature = \"zerocopy\"]\n    pub mod sendfile;\n}\n\npub mod signal;\n\n#[cfg(linux_android)]\nfeature! {\n    #![feature = \"signal\"]\n    #[allow(missing_docs)]\n    pub mod signalfd;\n}\n\nfeature! {\n    #![feature = \"socket\"]\n    #[allow(missing_docs)]\n    pub mod socket;\n}\n\nfeature! {\n    #![feature = \"fs\"]\n    #[allow(missing_docs)]\n    pub mod stat;\n}\n\n#[cfg(any(\n    linux_android,\n    freebsdlike,\n    apple_targets,\n    target_os = \"openbsd\",\n    target_os = \"cygwin\"\n))]\nfeature! {\n    #![feature = \"fs\"]\n    pub mod statfs;\n}\n\nfeature! {\n    #![feature = \"fs\"]\n    pub mod statvfs;\n}\n\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub mod sysinfo;\n\nfeature! {\n    #![feature = \"term\"]\n    #[allow(missing_docs)]\n    pub mod termios;\n}\n\n#[allow(missing_docs)]\npub mod time;\n\nfeature! {\n    #![feature = \"uio\"]\n    pub mod uio;\n}\n\nfeature! {\n    #![feature = \"feature\"]\n    pub mod utsname;\n}\n\nfeature! {\n    #![feature = \"process\"]\n    pub mod wait;\n}\n\n#[cfg(linux_android)]\nfeature! {\n    #![feature = \"inotify\"]\n    pub mod inotify;\n}\n\n#[cfg(linux_android)]\nfeature! {\n    #![feature = \"time\"]\n    pub mod timerfd;\n}\n\n#[cfg(all(\n    any(\n        target_os = \"freebsd\",\n        solarish,\n        target_os = \"linux\",\n        target_os = \"netbsd\"\n    ),\n    feature = \"time\",\n    feature = \"signal\"\n))]\nfeature! {\n    #![feature = \"time\"]\n    pub mod timer;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","personality.rs"],"content":"//! Process execution domains\nuse crate::errno::Errno;\nuse crate::Result;\n\nuse libc::{self, c_int, c_ulong};\n\nlibc_bitflags! {\n    /// Flags used and returned by [`get()`](fn.get.html) and\n    /// [`set()`](fn.set.html).\n    pub struct Persona: c_int {\n        /// Provide the legacy virtual address space layout.\n        ADDR_COMPAT_LAYOUT;\n        /// Disable address-space-layout randomization.\n        ADDR_NO_RANDOMIZE;\n        /// Limit the address space to 32 bits.\n        ADDR_LIMIT_32BIT;\n        /// Use `0xc0000000` as the offset at which to search a virtual memory\n        /// chunk on [`mmap(2)`], otherwise use `0xffffe000`.\n        ///\n        /// [`mmap(2)`]: https://man7.org/linux/man-pages/man2/mmap.2.html\n        ADDR_LIMIT_3GB;\n        /// User-space function pointers to signal handlers point to descriptors.\n        #[cfg(not(any(target_env = \"musl\", target_env = \"uclibc\", target_env = \"ohos\")))]\n        FDPIC_FUNCPTRS;\n        /// Map page 0 as read-only.\n        MMAP_PAGE_ZERO;\n        /// `PROT_READ` implies `PROT_EXEC` for [`mmap(2)`].\n        ///\n        /// [`mmap(2)`]: https://man7.org/linux/man-pages/man2/mmap.2.html\n        READ_IMPLIES_EXEC;\n        /// No effects.\n        SHORT_INODE;\n        /// [`select(2)`], [`pselect(2)`], and [`ppoll(2)`] do not modify the\n        /// returned timeout argument when interrupted by a signal handler.\n        ///\n        /// [`select(2)`]: https://man7.org/linux/man-pages/man2/select.2.html\n        /// [`pselect(2)`]: https://man7.org/linux/man-pages/man2/pselect.2.html\n        /// [`ppoll(2)`]: https://man7.org/linux/man-pages/man2/ppoll.2.html\n        STICKY_TIMEOUTS;\n        /// Have [`uname(2)`] report a 2.6.40+ version number rather than a 3.x\n        /// version number.\n        ///\n        /// [`uname(2)`]: https://man7.org/linux/man-pages/man2/uname.2.html\n        #[cfg(not(any(target_env = \"musl\", target_env = \"uclibc\", target_env = \"ohos\")))]\n        UNAME26;\n        /// No effects.\n        WHOLE_SECONDS;\n    }\n}\n\n/// Retrieve the current process personality.\n///\n/// Returns a Result containing a Persona instance.\n///\n/// Example:\n///\n/// ```\n/// # use nix::sys::personality::{self, Persona};\n/// let pers = personality::get().unwrap();\n/// assert!(!pers.contains(Persona::WHOLE_SECONDS));\n/// ```\npub fn get() -\u003e Result\u003cPersona\u003e {\n    let res = unsafe { libc::personality(0xFFFFFFFF) };\n\n    Errno::result(res).map(Persona::from_bits_truncate)\n}\n\n/// Set the current process personality.\n///\n/// Returns a Result containing the *previous* personality for the\n/// process, as a Persona.\n///\n/// For more information, see [personality(2)](https://man7.org/linux/man-pages/man2/personality.2.html)\n///\n/// **NOTE**: This call **replaces** the current personality entirely.\n/// To **update** the personality, first call `get()` and then `set()`\n/// with the modified persona.\n///\n/// Example:\n///\n// Disable test on aarch64 until we know why it fails.\n// https://github.com/nix-rust/nix/issues/2060\n#[cfg_attr(target_arch = \"aarch64\", doc = \" ```no_run\")]\n#[cfg_attr(not(target_arch = \"aarch64\"), doc = \" ```\")]\n/// # use nix::sys::personality::{self, Persona};\n/// let mut pers = personality::get().unwrap();\n/// assert!(!pers.contains(Persona::ADDR_NO_RANDOMIZE));\n/// personality::set(pers | Persona::ADDR_NO_RANDOMIZE).unwrap();\n/// ```\npub fn set(persona: Persona) -\u003e Result\u003cPersona\u003e {\n    let res = unsafe { libc::personality(persona.bits() as c_ulong) };\n\n    Errno::result(res).map(Persona::from_bits_truncate)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","prctl.rs"],"content":"//! prctl is a Linux-only API for performing operations on a process or thread.\n//!\n//! Note that careless use of some prctl() operations can confuse the user-space run-time\n//! environment, so these operations should be used with care.\n//!\n//! For more documentation, please read [prctl(2)](https://man7.org/linux/man-pages/man2/prctl.2.html).\n\nuse crate::errno::Errno;\nuse crate::sys::signal::Signal;\nuse crate::Result;\n\nuse libc::{c_int, c_ulong, c_void};\nuse std::convert::TryFrom;\nuse std::ffi::{CStr, CString};\nuse std::num::NonZeroUsize;\nuse std::ptr::NonNull;\n\nlibc_enum! {\n    /// The type of hardware memory corruption kill policy for the thread.\n\n    #[repr(i32)]\n    #[non_exhaustive]\n    #[allow(non_camel_case_types)]\n    pub enum PrctlMCEKillPolicy {\n        /// The thread will receive SIGBUS as soon as a memory corruption is detected.\n        PR_MCE_KILL_EARLY,\n        /// The process is killed only when it accesses a corrupted page.\n        PR_MCE_KILL_LATE,\n        /// Uses the system-wide default.\n        PR_MCE_KILL_DEFAULT,\n    }\n    impl TryFrom\u003ci32\u003e\n}\n\nfn prctl_set_bool(option: c_int, status: bool) -\u003e Result\u003c()\u003e {\n    let res = unsafe { libc::prctl(option, status as c_ulong, 0, 0, 0) };\n    Errno::result(res).map(drop)\n}\n\nfn prctl_get_bool(option: c_int) -\u003e Result\u003cbool\u003e {\n    let res = unsafe { libc::prctl(option, 0, 0, 0, 0) };\n    Errno::result(res).map(|res| res != 0)\n}\n\n/// Set the \"child subreaper\" attribute for this process\npub fn set_child_subreaper(attribute: bool) -\u003e Result\u003c()\u003e {\n    prctl_set_bool(libc::PR_SET_CHILD_SUBREAPER, attribute)\n}\n\n/// Get the \"child subreaper\" attribute for this process\npub fn get_child_subreaper() -\u003e Result\u003cbool\u003e {\n    // prctl writes into this var\n    let mut subreaper: c_int = 0;\n\n    let res = unsafe {\n        libc::prctl(libc::PR_GET_CHILD_SUBREAPER, \u0026mut subreaper, 0, 0, 0)\n    };\n\n    Errno::result(res).map(|_| subreaper != 0)\n}\n\n/// Set the dumpable attribute which determines if core dumps are created for this process.\npub fn set_dumpable(attribute: bool) -\u003e Result\u003c()\u003e {\n    prctl_set_bool(libc::PR_SET_DUMPABLE, attribute)\n}\n\n/// Get the dumpable attribute for this process.\npub fn get_dumpable() -\u003e Result\u003cbool\u003e {\n    prctl_get_bool(libc::PR_GET_DUMPABLE)\n}\n\n/// Set the \"keep capabilities\" attribute for this process. This causes the thread to retain\n/// capabilities even if it switches its UID to a nonzero value.\npub fn set_keepcaps(attribute: bool) -\u003e Result\u003c()\u003e {\n    prctl_set_bool(libc::PR_SET_KEEPCAPS, attribute)\n}\n\n/// Get the \"keep capabilities\" attribute for this process\npub fn get_keepcaps() -\u003e Result\u003cbool\u003e {\n    prctl_get_bool(libc::PR_GET_KEEPCAPS)\n}\n\n/// Clear the thread memory corruption kill policy and use the system-wide default\npub fn clear_mce_kill() -\u003e Result\u003c()\u003e {\n    let res = unsafe {\n        libc::prctl(libc::PR_MCE_KILL, libc::PR_MCE_KILL_CLEAR, 0, 0, 0)\n    };\n\n    Errno::result(res).map(drop)\n}\n\n/// Set the thread memory corruption kill policy\npub fn set_mce_kill(policy: PrctlMCEKillPolicy) -\u003e Result\u003c()\u003e {\n    let res = unsafe {\n        libc::prctl(\n            libc::PR_MCE_KILL,\n            libc::PR_MCE_KILL_SET,\n            policy as c_ulong,\n            0,\n            0,\n        )\n    };\n\n    Errno::result(res).map(drop)\n}\n\n/// Get the thread memory corruption kill policy\npub fn get_mce_kill() -\u003e Result\u003cPrctlMCEKillPolicy\u003e {\n    let res = unsafe { libc::prctl(libc::PR_MCE_KILL_GET, 0, 0, 0, 0) };\n\n    match Errno::result(res) {\n        Ok(val) =\u003e Ok(PrctlMCEKillPolicy::try_from(val)?),\n        Err(e) =\u003e Err(e),\n    }\n}\n\n/// Set the parent-death signal of the calling process. This is the signal that the calling process\n/// will get when its parent dies.\npub fn set_pdeathsig\u003cT: Into\u003cOption\u003cSignal\u003e\u003e\u003e(signal: T) -\u003e Result\u003c()\u003e {\n    let sig = match signal.into() {\n        Some(s) =\u003e s as c_int,\n        None =\u003e 0,\n    };\n\n    let res = unsafe { libc::prctl(libc::PR_SET_PDEATHSIG, sig, 0, 0, 0) };\n\n    Errno::result(res).map(drop)\n}\n\n/// Returns the current parent-death signal\npub fn get_pdeathsig() -\u003e Result\u003cOption\u003cSignal\u003e\u003e {\n    // prctl writes into this var\n    let mut sig: c_int = 0;\n\n    let res = unsafe { libc::prctl(libc::PR_GET_PDEATHSIG, \u0026mut sig, 0, 0, 0) };\n\n    match Errno::result(res) {\n        Ok(_) =\u003e Ok(match sig {\n            0 =\u003e None,\n            _ =\u003e Some(Signal::try_from(sig)?),\n        }),\n        Err(e) =\u003e Err(e),\n    }\n}\n\n/// Set the name of the calling thread. Strings longer than 15 bytes will be truncated.\npub fn set_name(name: \u0026CStr) -\u003e Result\u003c()\u003e {\n    let res = unsafe { libc::prctl(libc::PR_SET_NAME, name.as_ptr(), 0, 0, 0) };\n\n    Errno::result(res).map(drop)\n}\n\n/// Return the name of the calling thread\npub fn get_name() -\u003e Result\u003cCString\u003e {\n    // Size of buffer determined by linux/sched.h TASK_COMM_LEN\n    let buf = [0u8; 16];\n\n    let res = unsafe { libc::prctl(libc::PR_GET_NAME, \u0026buf, 0, 0, 0) };\n\n    Errno::result(res).and_then(|_| {\n        CStr::from_bytes_until_nul(\u0026buf)\n            .map(CStr::to_owned)\n            .map_err(|_| Errno::EINVAL)\n    })\n}\n\n/// Sets the timer slack value for the calling thread. Timer slack is used by the kernel to group\n/// timer expirations and make them the supplied amount of nanoseconds late.\npub fn set_timerslack(ns: c_ulong) -\u003e Result\u003c()\u003e {\n    let res = unsafe { libc::prctl(libc::PR_SET_TIMERSLACK, ns, 0, 0, 0) };\n\n    Errno::result(res).map(drop)\n}\n\n/// Get the timerslack for the calling thread.\npub fn get_timerslack() -\u003e Result\u003ci32\u003e {\n    let res = unsafe { libc::prctl(libc::PR_GET_TIMERSLACK, 0, 0, 0, 0) };\n\n    Errno::result(res)\n}\n\n/// Disable all performance counters attached to the calling process.\npub fn task_perf_events_disable() -\u003e Result\u003c()\u003e {\n    let res =\n        unsafe { libc::prctl(libc::PR_TASK_PERF_EVENTS_DISABLE, 0, 0, 0, 0) };\n\n    Errno::result(res).map(drop)\n}\n\n/// Enable all performance counters attached to the calling process.\npub fn task_perf_events_enable() -\u003e Result\u003c()\u003e {\n    let res =\n        unsafe { libc::prctl(libc::PR_TASK_PERF_EVENTS_ENABLE, 0, 0, 0, 0) };\n\n    Errno::result(res).map(drop)\n}\n\n/// Set the calling threads \"no new privs\" attribute. Once set this option can not be unset.\npub fn set_no_new_privs() -\u003e Result\u003c()\u003e {\n    prctl_set_bool(libc::PR_SET_NO_NEW_PRIVS, true) // Cannot be unset\n}\n\n/// Get the \"no new privs\" attribute for the calling thread.\npub fn get_no_new_privs() -\u003e Result\u003cbool\u003e {\n    prctl_get_bool(libc::PR_GET_NO_NEW_PRIVS)\n}\n\n/// Set the state of the \"THP disable\" flag for the calling thread. Setting this disables\n/// transparent huge pages.\npub fn set_thp_disable(flag: bool) -\u003e Result\u003c()\u003e {\n    prctl_set_bool(libc::PR_SET_THP_DISABLE, flag)\n}\n\n/// Get the \"THP disable\" flag for the calling thread.\npub fn get_thp_disable() -\u003e Result\u003cbool\u003e {\n    prctl_get_bool(libc::PR_GET_THP_DISABLE)\n}\n\n/// Set an identifier (or reset it) to the address memory range.\npub fn set_vma_anon_name(addr: NonNull\u003cc_void\u003e, length: NonZeroUsize, name: Option\u003c\u0026CStr\u003e) -\u003e Result\u003c()\u003e {\n    let nameref = match name {\n        Some(n) =\u003e n.as_ptr(),\n        _ =\u003e std::ptr::null()\n    };\n    let res = unsafe { libc::prctl(libc::PR_SET_VMA, libc::PR_SET_VMA_ANON_NAME, addr.as_ptr(), length, nameref) };\n\n    Errno::result(res).map(drop)\n}\n","traces":[{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","pthread.rs"],"content":"//! Low level threading primitives\n\n#[cfg(not(target_os = \"redox\"))]\nuse crate::errno::Errno;\n#[cfg(not(target_os = \"redox\"))]\nuse crate::Result;\nuse libc::{self, pthread_t};\n\n/// Identifies an individual thread.\npub type Pthread = pthread_t;\n\n/// Obtain ID of the calling thread (see\n/// [`pthread_self(3)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_self.html)\n///\n/// The thread ID returned by `pthread_self()` is not the same thing as\n/// the kernel thread ID returned by a call to `gettid(2)`.\n#[inline]\npub fn pthread_self() -\u003e Pthread {\n    unsafe { libc::pthread_self() }\n}\n\nfeature! {\n#![feature = \"signal\"]\n\n/// Send a signal to a thread (see [`pthread_kill(3)`]).\n///\n/// If `signal` is `None`, `pthread_kill` will only preform error checking and\n/// won't send any signal.\n///\n/// [`pthread_kill(3)`]: https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_kill.html\n#[allow(clippy::not_unsafe_ptr_arg_deref)]\n#[cfg(not(target_os = \"redox\"))]\npub fn pthread_kill\u003cT\u003e(thread: Pthread, signal: T) -\u003e Result\u003c()\u003e\n    where T: Into\u003cOption\u003ccrate::sys::signal::Signal\u003e\u003e\n{\n    let sig = match signal.into() {\n        Some(s) =\u003e s as libc::c_int,\n        None =\u003e 0,\n    };\n    let res = unsafe { libc::pthread_kill(thread, sig) };\n    Errno::result(res).map(drop)\n}\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","ptrace","bsd.rs"],"content":"use crate::errno::Errno;\nuse crate::sys::signal::Signal;\nuse crate::unistd::Pid;\nuse crate::Result;\nuse cfg_if::cfg_if;\nuse libc::{self, c_int};\nuse std::ptr;\n\npub type RequestType = c_int;\n\ncfg_if! {\n    if #[cfg(any(freebsdlike, apple_targets, target_os = \"openbsd\"))] {\n        #[doc(hidden)]\n        pub type AddressType = *mut ::libc::c_char;\n    } else {\n        #[doc(hidden)]\n        pub type AddressType = *mut ::libc::c_void;\n    }\n}\n\nlibc_enum! {\n    #[repr(i32)]\n    /// Ptrace Request enum defining the action to be taken.\n    #[non_exhaustive]\n    pub enum Request {\n        PT_TRACE_ME,\n        PT_READ_I,\n        PT_READ_D,\n        #[cfg(apple_targets)]\n        PT_READ_U,\n        PT_WRITE_I,\n        PT_WRITE_D,\n        #[cfg(apple_targets)]\n        PT_WRITE_U,\n        PT_CONTINUE,\n        PT_KILL,\n        #[cfg(any(any(freebsdlike, apple_targets),\n                  all(target_os = \"openbsd\", target_arch = \"x86_64\"),\n                  all(target_os = \"netbsd\", any(target_arch = \"x86_64\",\n                                                target_arch = \"powerpc\"))))]\n        PT_STEP,\n        PT_ATTACH,\n        PT_DETACH,\n        #[cfg(apple_targets)]\n        PT_SIGEXC,\n        #[cfg(apple_targets)]\n        PT_THUPDATE,\n        #[cfg(apple_targets)]\n        PT_ATTACHEXC\n    }\n}\n\nunsafe fn ptrace_other(\n    request: Request,\n    pid: Pid,\n    addr: AddressType,\n    data: c_int,\n) -\u003e Result\u003cc_int\u003e {\n    unsafe {\n        Errno::result(libc::ptrace(\n            request as RequestType,\n            libc::pid_t::from(pid),\n            addr,\n            data,\n        ))\n        .map(|_| 0)\n    }\n}\n\n/// Sets the process as traceable, as with `ptrace(PT_TRACEME, ...)`\n///\n/// Indicates that this process is to be traced by its parent.\n/// This is the only ptrace request to be issued by the tracee.\npub fn traceme() -\u003e Result\u003c()\u003e {\n    unsafe {\n        ptrace_other(Request::PT_TRACE_ME, Pid::from_raw(0), ptr::null_mut(), 0)\n            .map(drop)\n    }\n}\n\n/// Attach to a running process, as with `ptrace(PT_ATTACH, ...)`\n///\n/// Attaches to the process specified by `pid`, making it a tracee of the calling process.\npub fn attach(pid: Pid) -\u003e Result\u003c()\u003e {\n    unsafe {\n        ptrace_other(Request::PT_ATTACH, pid, ptr::null_mut(), 0).map(drop)\n    }\n}\n\n/// Detaches the current running process, as with `ptrace(PT_DETACH, ...)`\n///\n/// Detaches from the process specified by `pid` allowing it to run freely, optionally delivering a\n/// signal specified by `sig`.\npub fn detach\u003cT: Into\u003cOption\u003cSignal\u003e\u003e\u003e(pid: Pid, sig: T) -\u003e Result\u003c()\u003e {\n    let data = match sig.into() {\n        Some(s) =\u003e s as c_int,\n        None =\u003e 0,\n    };\n    unsafe {\n        ptrace_other(Request::PT_DETACH, pid, ptr::null_mut(), data).map(drop)\n    }\n}\n\n/// Restart the stopped tracee process, as with `ptrace(PTRACE_CONT, ...)`\n///\n/// Continues the execution of the process with PID `pid`, optionally\n/// delivering a signal specified by `sig`.\npub fn cont\u003cT: Into\u003cOption\u003cSignal\u003e\u003e\u003e(pid: Pid, sig: T) -\u003e Result\u003c()\u003e {\n    let data = match sig.into() {\n        Some(s) =\u003e s as c_int,\n        None =\u003e 0,\n    };\n    unsafe {\n        // Ignore the useless return value\n        ptrace_other(Request::PT_CONTINUE, pid, 1 as AddressType, data)\n            .map(drop)\n    }\n}\n\n/// Issues a kill request as with `ptrace(PT_KILL, ...)`\n///\n/// This request is equivalent to `ptrace(PT_CONTINUE, ..., SIGKILL);`\npub fn kill(pid: Pid) -\u003e Result\u003c()\u003e {\n    unsafe {\n        ptrace_other(Request::PT_KILL, pid, 0 as AddressType, 0).map(drop)\n    }\n}\n\n/// Move the stopped tracee process forward by a single step as with\n/// `ptrace(PT_STEP, ...)`\n///\n/// Advances the execution of the process with PID `pid` by a single step optionally delivering a\n/// signal specified by `sig`.\n///\n/// # Example\n/// ```rust\n/// use nix::sys::ptrace::step;\n/// use nix::unistd::Pid;\n/// use nix::sys::signal::Signal;\n/// use nix::sys::wait::*;\n/// // If a process changes state to the stopped state because of a SIGUSR1\n/// // signal, this will step the process forward and forward the user\n/// // signal to the stopped process\n/// match waitpid(Pid::from_raw(-1), None) {\n///     Ok(WaitStatus::Stopped(pid, Signal::SIGUSR1)) =\u003e {\n///         let _ = step(pid, Signal::SIGUSR1);\n///     }\n///     _ =\u003e {},\n/// }\n/// ```\n#[cfg(any(\n    any(freebsdlike, apple_targets),\n    all(target_os = \"openbsd\", target_arch = \"x86_64\"),\n    all(\n        target_os = \"netbsd\",\n        any(target_arch = \"x86_64\", target_arch = \"powerpc\")\n    )\n))]\npub fn step\u003cT: Into\u003cOption\u003cSignal\u003e\u003e\u003e(pid: Pid, sig: T) -\u003e Result\u003c()\u003e {\n    let data = match sig.into() {\n        Some(s) =\u003e s as c_int,\n        None =\u003e 0,\n    };\n    unsafe {\n        ptrace_other(Request::PT_STEP, pid, ptr::null_mut(), data).map(drop)\n    }\n}\n\n/// Reads a word from a processes memory at the given address\n// Technically, ptrace doesn't dereference the pointer.  It passes it directly\n// to the kernel.\n#[allow(clippy::not_unsafe_ptr_arg_deref)]\npub fn read(pid: Pid, addr: AddressType) -\u003e Result\u003cc_int\u003e {\n    unsafe {\n        // Traditionally there was a difference between reading data or\n        // instruction memory but not in modern systems.\n        ptrace_other(Request::PT_READ_D, pid, addr, 0)\n    }\n}\n\n/// Writes a word into the processes memory at the given address\n// Technically, ptrace doesn't dereference the pointer.  It passes it directly\n// to the kernel.\n#[allow(clippy::not_unsafe_ptr_arg_deref)]\npub fn write(pid: Pid, addr: AddressType, data: c_int) -\u003e Result\u003c()\u003e {\n    unsafe { ptrace_other(Request::PT_WRITE_D, pid, addr, data).map(drop) }\n}\n","traces":[{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","ptrace","linux.rs"],"content":"//! For detailed description of the ptrace requests, consult `man ptrace`.\n\nuse crate::errno::Errno;\nuse crate::sys::signal::Signal;\nuse crate::unistd::Pid;\nuse crate::Result;\nuse cfg_if::cfg_if;\nuse libc::{self, c_long, c_void, siginfo_t};\nuse std::{mem, ptr};\n\npub type AddressType = *mut ::libc::c_void;\n\n#[cfg(all(\n    target_os = \"linux\",\n    any(\n        all(\n            any(target_arch = \"x86_64\", target_arch = \"aarch64\"),\n            any(target_env = \"gnu\", target_env = \"musl\")\n        ),\n        all(target_arch = \"x86\", target_env = \"gnu\"),\n        all(target_arch = \"riscv64\", target_env = \"gnu\"),\n    ),\n))]\nuse libc::user_regs_struct;\n\ncfg_if! {\n    if #[cfg(any(all(target_os = \"linux\", target_arch = \"s390x\"),\n                 all(target_os = \"linux\", target_env = \"gnu\"),\n                 target_env = \"uclibc\"))] {\n        #[doc(hidden)]\n        pub type RequestType = ::libc::c_uint;\n    } else {\n        #[doc(hidden)]\n        pub type RequestType = ::libc::c_int;\n    }\n}\n\nlibc_enum! {\n    #[cfg_attr(not(any(target_env = \"musl\", target_env = \"uclibc\", target_os = \"android\", target_env = \"ohos\")), repr(u32))]\n    #[cfg_attr(any(target_env = \"musl\", target_env = \"uclibc\", target_os = \"android\", target_env = \"ohos\"), repr(i32))]\n    /// Ptrace Request enum defining the action to be taken.\n    #[non_exhaustive]\n    pub enum Request {\n        PTRACE_TRACEME,\n        PTRACE_PEEKTEXT,\n        PTRACE_PEEKDATA,\n        PTRACE_PEEKUSER,\n        PTRACE_POKETEXT,\n        PTRACE_POKEDATA,\n        PTRACE_POKEUSER,\n        PTRACE_CONT,\n        PTRACE_KILL,\n        PTRACE_SINGLESTEP,\n        #[cfg(any(all(target_os = \"android\", target_pointer_width = \"32\"),\n                  all(target_os = \"linux\", any(target_env = \"musl\",\n                                               target_env = \"ohos\",\n                                               target_arch = \"mips\",\n                                               target_arch = \"mips32r6\",\n                                               target_arch = \"mips64\",\n                                               target_arch = \"mips64r6\",\n                                               target_arch = \"x86_64\",\n                                               target_pointer_width = \"32\"))))]\n        PTRACE_GETREGS,\n        #[cfg(any(all(target_os = \"android\", target_pointer_width = \"32\"),\n                  all(target_os = \"linux\", any(target_env = \"musl\",\n                                               target_env = \"ohos\",\n                                               target_arch = \"mips\",\n                                               target_arch = \"mips32r6\",\n                                               target_arch = \"mips64\",\n                                               target_arch = \"mips64r6\",\n                                               target_arch = \"x86_64\",\n                                               target_pointer_width = \"32\"))))]\n        PTRACE_SETREGS,\n        #[cfg(any(all(target_os = \"android\", target_pointer_width = \"32\"),\n                  all(target_os = \"linux\", any(target_env = \"musl\",\n                                               target_env = \"ohos\",\n                                               target_arch = \"mips\",\n                                               target_arch = \"mips32r6\",\n                                               target_arch = \"mips64\",\n                                               target_arch = \"mips64r6\",\n                                               target_arch = \"x86_64\",\n                                               target_pointer_width = \"32\"))))]\n        PTRACE_GETFPREGS,\n        #[cfg(any(all(target_os = \"android\", target_pointer_width = \"32\"),\n                  all(target_os = \"linux\", any(target_env = \"musl\",\n                                               target_env = \"ohos\",\n                                               target_arch = \"mips\",\n                                               target_arch = \"mips32r6\",\n                                               target_arch = \"mips64\",\n                                               target_arch = \"mips64r6\",\n                                               target_arch = \"x86_64\",\n                                               target_pointer_width = \"32\"))))]\n        PTRACE_SETFPREGS,\n        PTRACE_ATTACH,\n        PTRACE_DETACH,\n        #[cfg(all(target_os = \"linux\", any(target_env = \"musl\",\n                                           target_env = \"ohos\",\n                                           target_arch = \"mips\",\n                                           target_arch = \"mips32r6\",\n                                           target_arch = \"mips64\",\n                                           target_arch = \"mips64r6\",\n                                           target_arch = \"x86\",\n                                           target_arch = \"x86_64\")))]\n        PTRACE_GETFPXREGS,\n        #[cfg(all(target_os = \"linux\", any(target_env = \"musl\",\n                                           target_env = \"ohos\",\n                                           target_arch = \"mips\",\n                                           target_arch = \"mips32r6\",\n                                           target_arch = \"mips64\",\n                                           target_arch = \"mips64r6\",\n                                           target_arch = \"x86\",\n                                           target_arch = \"x86_64\")))]\n        PTRACE_SETFPXREGS,\n        PTRACE_SYSCALL,\n        PTRACE_SETOPTIONS,\n        PTRACE_GETEVENTMSG,\n        PTRACE_GETSIGINFO,\n        PTRACE_SETSIGINFO,\n        #[cfg(all(target_os = \"linux\", not(any(target_arch = \"mips\",\n                                               target_arch = \"mips32r6\",\n                                               target_arch = \"mips64\",\n                                               target_arch = \"mips64r6\"))))]\n        PTRACE_GETREGSET,\n        #[cfg(all(target_os = \"linux\", not(any(target_arch = \"mips\",\n                                               target_arch = \"mips32r6\",\n                                               target_arch = \"mips64\",\n                                               target_arch = \"mips64r6\"))))]\n        PTRACE_SETREGSET,\n        #[cfg(target_os = \"linux\")]\n        PTRACE_SEIZE,\n        #[cfg(target_os = \"linux\")]\n        PTRACE_INTERRUPT,\n        #[cfg(all(target_os = \"linux\", not(any(target_arch = \"mips\",\n                                               target_arch = \"mips32r6\",\n                                               target_arch = \"mips64\",\n                                               target_arch = \"mips64r6\"))))]\n        PTRACE_LISTEN,\n        #[cfg(all(target_os = \"linux\", not(any(target_arch = \"mips\",\n                                               target_arch = \"mips32r6\",\n                                               target_arch = \"mips64\",\n                                               target_arch = \"mips64r6\"))))]\n        PTRACE_PEEKSIGINFO,\n        #[cfg(all(target_os = \"linux\", target_env = \"gnu\",\n                  any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n        PTRACE_SYSEMU,\n        #[cfg(all(target_os = \"linux\", target_env = \"gnu\",\n                  any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n        PTRACE_SYSEMU_SINGLESTEP,\n        #[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n        PTRACE_GET_SYSCALL_INFO,\n    }\n}\n\nlibc_enum! {\n    #[repr(i32)]\n    /// Using the ptrace options the tracer can configure the tracee to stop\n    /// at certain events. This enum is used to define those events as defined\n    /// in `man ptrace`.\n    #[non_exhaustive]\n    pub enum Event {\n        /// Event that stops before a return from fork or clone.\n        PTRACE_EVENT_FORK,\n        /// Event that stops before a return from vfork or clone.\n        PTRACE_EVENT_VFORK,\n        /// Event that stops before a return from clone.\n        PTRACE_EVENT_CLONE,\n        /// Event that stops before a return from execve.\n        PTRACE_EVENT_EXEC,\n        /// Event for a return from vfork.\n        PTRACE_EVENT_VFORK_DONE,\n        /// Event for a stop before an exit. Unlike the waitpid Exit status program.\n        /// registers can still be examined\n        PTRACE_EVENT_EXIT,\n        /// Stop triggered by a seccomp rule on a tracee.\n        PTRACE_EVENT_SECCOMP,\n        /// Stop triggered by the `INTERRUPT` syscall, or a group stop,\n        /// or when a new child is attached.\n        PTRACE_EVENT_STOP,\n    }\n}\n\n#[cfg(all(\n    target_os = \"linux\",\n    any(\n        all(\n            target_env = \"gnu\",\n            any(\n                target_arch = \"x86_64\",\n                target_arch = \"x86\",\n                target_arch = \"aarch64\",\n                target_arch = \"riscv64\",\n            )\n        ),\n        all(\n            target_env = \"musl\",\n            target_arch = \"aarch64\",\n        )\n    ),\n))]\nlibc_enum! {\n    #[repr(i32)]\n    /// Defines a specific register set, as used in `PTRACE_GETREGSET` and `PTRACE_SETREGSET`.\n    #[non_exhaustive]\n    pub enum RegisterSetValue {\n        NT_PRSTATUS,\n        NT_PRFPREG,\n        NT_PRPSINFO,\n        NT_TASKSTRUCT,\n        NT_AUXV,\n    }\n}\n\n#[cfg(all(\n    target_os = \"linux\",\n    any(\n        all(\n            target_env = \"gnu\",\n            any(\n                target_arch = \"x86_64\",\n                target_arch = \"x86\",\n                target_arch = \"aarch64\",\n                target_arch = \"riscv64\",\n            )\n        ),\n        all(\n            target_env = \"musl\",\n            target_arch = \"aarch64\",\n        )\n    ),\n))]\n/// Represents register set areas, such as general-purpose registers or\n/// floating-point registers.\n///\n/// # Safety\n///\n/// This trait is marked unsafe, since implementation of the trait must match\n/// ptrace's request `VALUE` and return data type `Regs`.\npub unsafe trait RegisterSet {\n    /// Corresponding type of registers in the kernel.\n    const VALUE: RegisterSetValue;\n\n    /// Struct representing the register space.\n    type Regs;\n}\n\n\n#[cfg(all(\n    target_os = \"linux\",\n    any(\n        all(\n            target_env = \"gnu\",\n            any(\n                target_arch = \"x86_64\",\n                target_arch = \"x86\",\n                target_arch = \"aarch64\",\n                target_arch = \"riscv64\",\n            )\n        ),\n        all(\n            target_env = \"musl\",\n            target_arch = \"aarch64\",\n        )\n    ),\n))]\n/// Register sets used in [`getregset`] and [`setregset`]\npub mod regset {\n    use super::*;\n\n    #[derive(Debug, Clone, Copy)]\n    /// General-purpose registers.\n    pub enum NT_PRSTATUS {}\n\n    unsafe impl RegisterSet for NT_PRSTATUS {\n        const VALUE: RegisterSetValue = RegisterSetValue::NT_PRSTATUS;\n        type Regs = user_regs_struct;\n    }\n\n    #[derive(Debug, Clone, Copy)]\n    /// Floating-point registers.\n    pub enum NT_PRFPREG {}\n\n    unsafe impl RegisterSet for NT_PRFPREG {\n        const VALUE: RegisterSetValue = RegisterSetValue::NT_PRFPREG;\n        #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n        type Regs = libc::user_fpregs_struct;\n        #[cfg(target_arch = \"aarch64\")]\n        type Regs = libc::user_fpsimd_struct;\n        #[cfg(target_arch = \"riscv64\")]\n        type Regs = libc::__riscv_mc_d_ext_state;\n    }\n}\n\nlibc_bitflags! {\n    /// Ptrace options used in conjunction with the PTRACE_SETOPTIONS request.\n    /// See `man ptrace` for more details.\n    pub struct Options: libc::c_int {\n        /// When delivering system call traps set a bit to allow tracer to\n        /// distinguish between normal stops or syscall stops. May not work on\n        /// all systems.\n        PTRACE_O_TRACESYSGOOD;\n        /// Stop tracee at next fork and start tracing the forked process.\n        PTRACE_O_TRACEFORK;\n        /// Stop tracee at next vfork call and trace the vforked process.\n        PTRACE_O_TRACEVFORK;\n        /// Stop tracee at next clone call and trace the cloned process.\n        PTRACE_O_TRACECLONE;\n        /// Stop tracee at next execve call.\n        PTRACE_O_TRACEEXEC;\n        /// Stop tracee at vfork completion.\n        PTRACE_O_TRACEVFORKDONE;\n        /// Stop tracee at next exit call. Stops before exit commences allowing\n        /// tracer to see location of exit and register states.\n        PTRACE_O_TRACEEXIT;\n        /// Stop tracee when a SECCOMP_RET_TRACE rule is triggered. See `man seccomp` for more\n        /// details.\n        PTRACE_O_TRACESECCOMP;\n        /// Send a SIGKILL to the tracee if the tracer exits.  This is useful\n        /// for ptrace jailers to prevent tracees from escaping their control.\n        PTRACE_O_EXITKILL;\n    }\n}\n\nfn ptrace_peek(\n    request: Request,\n    pid: Pid,\n    addr: AddressType,\n    data: *mut c_void,\n) -\u003e Result\u003cc_long\u003e {\n    let ret = unsafe {\n        Errno::clear();\n        libc::ptrace(request as RequestType, libc::pid_t::from(pid), addr, data)\n    };\n    match Errno::result(ret) {\n        Ok(..) | Err(Errno::UnknownErrno) =\u003e Ok(ret),\n        err @ Err(..) =\u003e err,\n    }\n}\n\n/// Get user registers, as with `ptrace(PTRACE_GETREGS, ...)`\n///\n/// Note that since `PTRACE_GETREGS` are not available on all platforms (as in [ptrace(2)]),\n/// `ptrace(PTRACE_GETREGSET, pid, NT_PRSTATUS, ...)` is used instead to achieve the same effect\n/// on aarch64 and riscv64.\n///\n/// [ptrace(2)]: https://www.man7.org/linux/man-pages/man2/ptrace.2.html\n#[cfg(all(\n    target_os = \"linux\",\n    any(\n        all(\n            target_arch = \"x86_64\",\n            any(target_env = \"gnu\", target_env = \"musl\")\n        ),\n        all(target_arch = \"x86\", target_env = \"gnu\")\n    )\n))]\npub fn getregs(pid: Pid) -\u003e Result\u003cuser_regs_struct\u003e {\n    ptrace_get_data::\u003cuser_regs_struct\u003e(Request::PTRACE_GETREGS, pid)\n}\n\n/// Get user registers, as with `ptrace(PTRACE_GETREGS, ...)`\n///\n/// Note that since `PTRACE_GETREGS` are not available on all platforms (as in [ptrace(2)]),\n/// `ptrace(PTRACE_GETREGSET, pid, NT_PRSTATUS, ...)` is used instead to achieve the same effect\n/// on aarch64 and riscv64.\n///\n/// [ptrace(2)]: https://www.man7.org/linux/man-pages/man2/ptrace.2.html\n#[cfg(all(\n    target_os = \"linux\",\n    any(\n        all(\n            target_arch = \"aarch64\",\n            any(target_env = \"gnu\", target_env = \"musl\")\n        ),\n        all(target_arch = \"riscv64\", target_env = \"gnu\")\n    )\n))]\npub fn getregs(pid: Pid) -\u003e Result\u003cuser_regs_struct\u003e {\n    getregset::\u003cregset::NT_PRSTATUS\u003e(pid)\n}\n\n/// Get a particular set of user registers, as with `ptrace(PTRACE_GETREGSET, ...)`\n#[cfg(all(\n    target_os = \"linux\",\n    any(\n        all(\n            target_env = \"gnu\",\n            any(\n                target_arch = \"x86_64\",\n                target_arch = \"x86\",\n                target_arch = \"aarch64\",\n                target_arch = \"riscv64\"\n            )\n        ),\n        all(target_env = \"musl\", target_arch = \"aarch64\")\n    )\n))]\npub fn getregset\u003cS: RegisterSet\u003e(pid: Pid) -\u003e Result\u003cS::Regs\u003e {\n    let request = Request::PTRACE_GETREGSET;\n    let mut data = mem::MaybeUninit::\u003cS::Regs\u003e::uninit();\n    let mut iov = libc::iovec {\n        iov_base: data.as_mut_ptr().cast(),\n        iov_len: mem::size_of::\u003cS::Regs\u003e(),\n    };\n    unsafe {\n        ptrace_other(\n            request,\n            pid,\n            S::VALUE as i32 as AddressType,\n            (\u0026mut iov as *mut libc::iovec).cast(),\n        )?;\n    };\n    Ok(unsafe { data.assume_init() })\n}\n\n/// Set user registers, as with `ptrace(PTRACE_SETREGS, ...)`\n///\n/// Note that since `PTRACE_SETREGS` are not available on all platforms (as in [ptrace(2)]),\n/// `ptrace(PTRACE_SETREGSET, pid, NT_PRSTATUS, ...)` is used instead to achieve the same effect\n/// on aarch64 and riscv64.\n///\n/// [ptrace(2)]: https://www.man7.org/linux/man-pages/man2/ptrace.2.html\n#[cfg(all(\n    target_os = \"linux\",\n    any(\n        all(\n            target_arch = \"x86_64\",\n            any(target_env = \"gnu\", target_env = \"musl\")\n        ),\n        all(target_arch = \"x86\", target_env = \"gnu\")\n    )\n))]\npub fn setregs(pid: Pid, regs: user_regs_struct) -\u003e Result\u003c()\u003e {\n    let res = unsafe {\n        libc::ptrace(\n            Request::PTRACE_SETREGS as RequestType,\n            libc::pid_t::from(pid),\n            ptr::null_mut::\u003cc_void\u003e(),\n            \u0026regs as *const user_regs_struct as *const c_void,\n        )\n    };\n    Errno::result(res).map(drop)\n}\n\n/// Set user registers, as with `ptrace(PTRACE_SETREGS, ...)`\n///\n/// Note that since `PTRACE_SETREGS` are not available on all platforms (as in [ptrace(2)]),\n/// `ptrace(PTRACE_SETREGSET, pid, NT_PRSTATUS, ...)` is used instead to achieve the same effect\n/// on aarch64 and riscv64.\n///\n/// [ptrace(2)]: https://www.man7.org/linux/man-pages/man2/ptrace.2.html\n#[cfg(all(\n    target_os = \"linux\",\n    any(\n        all(\n            target_env = \"gnu\",\n            any(target_arch = \"aarch64\", target_arch = \"riscv64\")\n        ),\n        all(target_env = \"musl\", target_arch = \"aarch64\")\n    )\n))]\npub fn setregs(pid: Pid, regs: user_regs_struct) -\u003e Result\u003c()\u003e {\n    setregset::\u003cregset::NT_PRSTATUS\u003e(pid, regs)\n}\n\n/// Set a particular set of user registers, as with `ptrace(PTRACE_SETREGSET, ...)`\n#[cfg(all(\n    target_os = \"linux\",\n    any(\n        all(\n            target_env = \"gnu\",\n            any(\n                target_arch = \"x86_64\",\n                target_arch = \"x86\",\n                target_arch = \"aarch64\",\n                target_arch = \"riscv64\"\n            )\n        ),\n        all(target_env = \"musl\", target_arch = \"aarch64\")\n    )\n))]\npub fn setregset\u003cS: RegisterSet\u003e(pid: Pid, mut regs: S::Regs) -\u003e Result\u003c()\u003e {\n    let mut iov = libc::iovec {\n        iov_base: (\u0026mut regs as *mut S::Regs).cast(),\n        iov_len: mem::size_of::\u003cS::Regs\u003e(),\n    };\n    unsafe {\n        ptrace_other(\n            Request::PTRACE_SETREGSET,\n            pid,\n            S::VALUE as i32 as AddressType,\n            (\u0026mut iov as *mut libc::iovec).cast(),\n        )?;\n    }\n    Ok(())\n}\n\n/// Function for ptrace requests that return values from the data field.\n/// Some ptrace get requests populate structs or larger elements than `c_long`\n/// and therefore use the data field to return values. This function handles these\n/// requests.\nfn ptrace_get_data\u003cT\u003e(request: Request, pid: Pid) -\u003e Result\u003cT\u003e {\n    let mut data = mem::MaybeUninit::\u003cT\u003e::uninit();\n    let res = unsafe {\n        libc::ptrace(\n            request as RequestType,\n            libc::pid_t::from(pid),\n            ptr::null_mut::\u003cT\u003e(),\n            data.as_mut_ptr(),\n        )\n    };\n    Errno::result(res)?;\n    Ok(unsafe { data.assume_init() })\n}\n\nunsafe fn ptrace_other(\n    request: Request,\n    pid: Pid,\n    addr: AddressType,\n    data: *mut c_void,\n) -\u003e Result\u003cc_long\u003e {\n    unsafe {\n        Errno::result(libc::ptrace(\n            request as RequestType,\n            libc::pid_t::from(pid),\n            addr,\n            data,\n        ))\n        .map(|_| 0)\n    }\n}\n\n/// Set options, as with `ptrace(PTRACE_SETOPTIONS, ...)`.\npub fn setoptions(pid: Pid, options: Options) -\u003e Result\u003c()\u003e {\n    let res = unsafe {\n        libc::ptrace(\n            Request::PTRACE_SETOPTIONS as RequestType,\n            libc::pid_t::from(pid),\n            ptr::null_mut::\u003cc_void\u003e(),\n            options.bits() as *mut c_void,\n        )\n    };\n    Errno::result(res).map(drop)\n}\n\n/// Gets a ptrace event as described by `ptrace(PTRACE_GETEVENTMSG, ...)`\npub fn getevent(pid: Pid) -\u003e Result\u003cc_long\u003e {\n    ptrace_get_data::\u003cc_long\u003e(Request::PTRACE_GETEVENTMSG, pid)\n}\n\n/// Get siginfo as with `ptrace(PTRACE_GETSIGINFO, ...)`\npub fn getsiginfo(pid: Pid) -\u003e Result\u003csiginfo_t\u003e {\n    ptrace_get_data::\u003csiginfo_t\u003e(Request::PTRACE_GETSIGINFO, pid)\n}\n\n/// Set siginfo as with `ptrace(PTRACE_SETSIGINFO, ...)`\npub fn setsiginfo(pid: Pid, sig: \u0026siginfo_t) -\u003e Result\u003c()\u003e {\n    let ret = unsafe {\n        Errno::clear();\n        libc::ptrace(\n            Request::PTRACE_SETSIGINFO as RequestType,\n            libc::pid_t::from(pid),\n            ptr::null_mut::\u003cc_void\u003e(),\n            sig as *const _ as *const c_void,\n        )\n    };\n    match Errno::result(ret) {\n        Ok(_) =\u003e Ok(()),\n        Err(e) =\u003e Err(e),\n    }\n}\n\n/// Get the informations of the syscall that caused the stop, as with\n/// `ptrace(PTRACE_GET_SYSCALL_INFO, ...`.\n#[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\npub fn syscall_info(pid: Pid) -\u003e Result\u003clibc::ptrace_syscall_info\u003e {\n    ptrace_get_data::\u003clibc::ptrace_syscall_info\u003e(Request::PTRACE_GET_SYSCALL_INFO, pid)\n}\n\n/// Sets the process as traceable, as with `ptrace(PTRACE_TRACEME, ...)`\n///\n/// Indicates that this process is to be traced by its parent.\n/// This is the only ptrace request to be issued by the tracee.\npub fn traceme() -\u003e Result\u003c()\u003e {\n    unsafe {\n        ptrace_other(\n            Request::PTRACE_TRACEME,\n            Pid::from_raw(0),\n            ptr::null_mut(),\n            ptr::null_mut(),\n        )\n        .map(drop) // ignore the useless return value\n    }\n}\n\n/// Continue execution until the next syscall, as with `ptrace(PTRACE_SYSCALL, ...)`\n///\n/// Arranges for the tracee to be stopped at the next entry to or exit from a system call,\n/// optionally delivering a signal specified by `sig`.\npub fn syscall\u003cT: Into\u003cOption\u003cSignal\u003e\u003e\u003e(pid: Pid, sig: T) -\u003e Result\u003c()\u003e {\n    let data = match sig.into() {\n        Some(s) =\u003e s as i32 as *mut c_void,\n        None =\u003e ptr::null_mut(),\n    };\n    unsafe {\n        ptrace_other(Request::PTRACE_SYSCALL, pid, ptr::null_mut(), data)\n            .map(drop) // ignore the useless return value\n    }\n}\n\n/// Continue execution until the next syscall, as with `ptrace(PTRACE_SYSEMU, ...)`\n///\n/// In contrast to the `syscall` function, the syscall stopped at will not be executed.\n/// Thus the the tracee will only be stopped once per syscall,\n/// optionally delivering a signal specified by `sig`.\n#[cfg(all(\n    target_os = \"linux\",\n    target_env = \"gnu\",\n    any(target_arch = \"x86\", target_arch = \"x86_64\")\n))]\npub fn sysemu\u003cT: Into\u003cOption\u003cSignal\u003e\u003e\u003e(pid: Pid, sig: T) -\u003e Result\u003c()\u003e {\n    let data = match sig.into() {\n        Some(s) =\u003e s as i32 as *mut c_void,\n        None =\u003e ptr::null_mut(),\n    };\n    unsafe {\n        ptrace_other(Request::PTRACE_SYSEMU, pid, ptr::null_mut(), data)\n            .map(drop)\n        // ignore the useless return value\n    }\n}\n\n/// Attach to a running process, as with `ptrace(PTRACE_ATTACH, ...)`\n///\n/// Attaches to the process specified by `pid`, making it a tracee of the calling process.\npub fn attach(pid: Pid) -\u003e Result\u003c()\u003e {\n    unsafe {\n        ptrace_other(\n            Request::PTRACE_ATTACH,\n            pid,\n            ptr::null_mut(),\n            ptr::null_mut(),\n        )\n        .map(drop) // ignore the useless return value\n    }\n}\n\n/// Attach to a running process, as with `ptrace(PTRACE_SEIZE, ...)`\n///\n/// Attaches to the process specified in pid, making it a tracee of the calling process.\n#[cfg(target_os = \"linux\")]\npub fn seize(pid: Pid, options: Options) -\u003e Result\u003c()\u003e {\n    unsafe {\n        ptrace_other(\n            Request::PTRACE_SEIZE,\n            pid,\n            ptr::null_mut(),\n            options.bits() as *mut c_void,\n        )\n        .map(drop) // ignore the useless return value\n    }\n}\n\n/// Detaches the current running process, as with `ptrace(PTRACE_DETACH, ...)`\n///\n/// Detaches from the process specified by `pid` allowing it to run freely, optionally delivering a\n/// signal specified by `sig`.\npub fn detach\u003cT: Into\u003cOption\u003cSignal\u003e\u003e\u003e(pid: Pid, sig: T) -\u003e Result\u003c()\u003e {\n    let data = match sig.into() {\n        Some(s) =\u003e s as i32 as *mut c_void,\n        None =\u003e ptr::null_mut(),\n    };\n    unsafe {\n        ptrace_other(Request::PTRACE_DETACH, pid, ptr::null_mut(), data)\n            .map(drop)\n    }\n}\n\n/// Restart the stopped tracee process, as with `ptrace(PTRACE_CONT, ...)`\n///\n/// Continues the execution of the process with PID `pid`, optionally\n/// delivering a signal specified by `sig`.\npub fn cont\u003cT: Into\u003cOption\u003cSignal\u003e\u003e\u003e(pid: Pid, sig: T) -\u003e Result\u003c()\u003e {\n    let data = match sig.into() {\n        Some(s) =\u003e s as i32 as *mut c_void,\n        None =\u003e ptr::null_mut(),\n    };\n    unsafe {\n        ptrace_other(Request::PTRACE_CONT, pid, ptr::null_mut(), data).map(drop)\n        // ignore the useless return value\n    }\n}\n\n/// Stop a tracee, as with `ptrace(PTRACE_INTERRUPT, ...)`\n///\n/// This request is equivalent to `ptrace(PTRACE_INTERRUPT, ...)`\n#[cfg(target_os = \"linux\")]\npub fn interrupt(pid: Pid) -\u003e Result\u003c()\u003e {\n    unsafe {\n        ptrace_other(\n            Request::PTRACE_INTERRUPT,\n            pid,\n            ptr::null_mut(),\n            ptr::null_mut(),\n        )\n        .map(drop)\n    }\n}\n\n/// Issues a kill request as with `ptrace(PTRACE_KILL, ...)`\n///\n/// This request is equivalent to `ptrace(PTRACE_CONT, ..., SIGKILL);`\npub fn kill(pid: Pid) -\u003e Result\u003c()\u003e {\n    unsafe {\n        ptrace_other(\n            Request::PTRACE_KILL,\n            pid,\n            ptr::null_mut(),\n            ptr::null_mut(),\n        )\n        .map(drop)\n    }\n}\n\n/// Move the stopped tracee process forward by a single step as with\n/// `ptrace(PTRACE_SINGLESTEP, ...)`\n///\n/// Advances the execution of the process with PID `pid` by a single step optionally delivering a\n/// signal specified by `sig`.\n///\n/// # Example\n/// ```rust\n/// use nix::sys::ptrace::step;\n/// use nix::unistd::Pid;\n/// use nix::sys::signal::Signal;\n/// use nix::sys::wait::*;\n///\n/// // If a process changes state to the stopped state because of a SIGUSR1\n/// // signal, this will step the process forward and forward the user\n/// // signal to the stopped process\n/// match waitpid(Pid::from_raw(-1), None) {\n///     Ok(WaitStatus::Stopped(pid, Signal::SIGUSR1)) =\u003e {\n///         let _ = step(pid, Signal::SIGUSR1);\n///     }\n///     _ =\u003e {},\n/// }\n/// ```\npub fn step\u003cT: Into\u003cOption\u003cSignal\u003e\u003e\u003e(pid: Pid, sig: T) -\u003e Result\u003c()\u003e {\n    let data = match sig.into() {\n        Some(s) =\u003e s as i32 as *mut c_void,\n        None =\u003e ptr::null_mut(),\n    };\n    unsafe {\n        ptrace_other(Request::PTRACE_SINGLESTEP, pid, ptr::null_mut(), data)\n            .map(drop)\n    }\n}\n\n/// Move the stopped tracee process forward by a single step or stop at the next syscall\n/// as with `ptrace(PTRACE_SYSEMU_SINGLESTEP, ...)`\n///\n/// Advances the execution by a single step or until the next syscall.\n/// In case the tracee is stopped at a syscall, the syscall will not be executed.\n/// Optionally, the signal specified by `sig` is delivered to the tracee upon continuation.\n#[cfg(all(\n    target_os = \"linux\",\n    target_env = \"gnu\",\n    any(target_arch = \"x86\", target_arch = \"x86_64\")\n))]\npub fn sysemu_step\u003cT: Into\u003cOption\u003cSignal\u003e\u003e\u003e(pid: Pid, sig: T) -\u003e Result\u003c()\u003e {\n    let data = match sig.into() {\n        Some(s) =\u003e s as i32 as *mut c_void,\n        None =\u003e ptr::null_mut(),\n    };\n    unsafe {\n        ptrace_other(\n            Request::PTRACE_SYSEMU_SINGLESTEP,\n            pid,\n            ptr::null_mut(),\n            data,\n        )\n        .map(drop) // ignore the useless return value\n    }\n}\n\n/// Reads a word from a processes memory at the given address, as with\n/// ptrace(PTRACE_PEEKDATA, ...)\npub fn read(pid: Pid, addr: AddressType) -\u003e Result\u003cc_long\u003e {\n    ptrace_peek(Request::PTRACE_PEEKDATA, pid, addr, ptr::null_mut())\n}\n\n/// Writes a word into the processes memory at the given address, as with\n/// ptrace(PTRACE_POKEDATA, ...)\n#[allow(clippy::not_unsafe_ptr_arg_deref)]\npub fn write(pid: Pid, addr: AddressType, data: c_long) -\u003e Result\u003c()\u003e {\n    unsafe {\n        // Safety(not_unsafe_ptr_arg_deref):\n        // `ptrace_other` is a common abstract\n        // but in `PTRACE_POKEDATA` situation, `data` is exactly what will be wtitten\n        ptrace_other(Request::PTRACE_POKEDATA, pid, addr, data as *mut c_void)\n            .map(drop)\n    }\n}\n\n/// Reads a word from a user area at `offset`, as with ptrace(PTRACE_PEEKUSER, ...).\n/// The user struct definition can be found in `/usr/include/sys/user.h`.\npub fn read_user(pid: Pid, offset: AddressType) -\u003e Result\u003cc_long\u003e {\n    ptrace_peek(Request::PTRACE_PEEKUSER, pid, offset, ptr::null_mut())\n}\n\n/// Writes a word to a user area at `offset`, as with ptrace(PTRACE_POKEUSER, ...).\n/// The user struct definition can be found in `/usr/include/sys/user.h`.\n#[allow(clippy::not_unsafe_ptr_arg_deref)]\npub fn write_user(pid: Pid, offset: AddressType, data: c_long) -\u003e Result\u003c()\u003e {\n    unsafe {\n        // Safety(not_unsafe_ptr_arg_deref):\n        // `ptrace_other` is a common abstract\n        // but in `PTRACE_POKEDATA` situation, `data` is exactly what will be wtitten\n        ptrace_other(Request::PTRACE_POKEUSER, pid, offset, data as *mut c_void)\n            .map(drop)\n    }\n}\n","traces":[{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":0}},{"line":771,"address":[],"length":0,"stats":{"Line":0}},{"line":772,"address":[],"length":0,"stats":{"Line":0}},{"line":776,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":62},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","ptrace","mod.rs"],"content":"//! Provides helpers for making ptrace system calls\n\n#[cfg(linux_android)]\nmod linux;\n\n#[cfg(linux_android)]\npub use self::linux::*;\n\n#[cfg(bsd)]\nmod bsd;\n\n#[cfg(bsd)]\npub use self::bsd::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","quota.rs"],"content":"//! Set and configure disk quotas for users, groups, or projects.\n//!\n//! # Examples\n//!\n//! Enabling and setting a quota:\n//!\n//! ```rust,no_run\n//! # use nix::sys::quota::{Dqblk, quotactl_on, quotactl_set, QuotaFmt, QuotaType, QuotaValidFlags};\n//! quotactl_on(QuotaType::USRQUOTA, \"/dev/sda1\", QuotaFmt::QFMT_VFS_V1, \"aquota.user\").unwrap();\n//! let mut dqblk: Dqblk = Default::default();\n//! dqblk.set_blocks_hard_limit(10000);\n//! dqblk.set_blocks_soft_limit(8000);\n//! quotactl_set(QuotaType::USRQUOTA, \"/dev/sda1\", 50, \u0026dqblk, QuotaValidFlags::QIF_BLIMITS).unwrap();\n//! ```\nuse crate::errno::Errno;\nuse crate::{NixPath, Result};\nuse libc::{self, c_char, c_int};\nuse std::default::Default;\nuse std::{mem, ptr};\n\nstruct QuotaCmd(QuotaSubCmd, QuotaType);\n\nimpl QuotaCmd {\n    fn as_int(\u0026self) -\u003e c_int {\n        libc::QCMD(self.0 as i32, self.1 as i32)\n    }\n}\n\n// linux quota version \u003e= 2\nlibc_enum! {\n    #[repr(i32)]\n    enum QuotaSubCmd {\n        Q_SYNC,\n        Q_QUOTAON,\n        Q_QUOTAOFF,\n        Q_GETQUOTA,\n        Q_SETQUOTA,\n    }\n}\n\nlibc_enum! {\n    /// The scope of the quota.\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum QuotaType {\n        /// Specify a user quota\n        USRQUOTA,\n        /// Specify a group quota\n        GRPQUOTA,\n    }\n}\n\nlibc_enum! {\n    /// The type of quota format to use.\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum QuotaFmt {\n        /// Use the original quota format.\n        QFMT_VFS_OLD,\n        /// Use the standard VFS v0 quota format.\n        ///\n        /// Handles 32-bit UIDs/GIDs and quota limits up to 2\u003csup\u003e32\u003c/sup\u003e bytes/2\u003csup\u003e32\u003c/sup\u003e inodes.\n        QFMT_VFS_V0,\n        /// Use the VFS v1 quota format.\n        ///\n        /// Handles 32-bit UIDs/GIDs and quota limits of 2\u003csup\u003e64\u003c/sup\u003e bytes/2\u003csup\u003e64\u003c/sup\u003e inodes.\n        QFMT_VFS_V1,\n    }\n}\n\nlibc_bitflags!(\n    /// Indicates the quota fields that are valid to read from.\n    #[derive(Default)]\n    pub struct QuotaValidFlags: u32 {\n        /// The block hard \u0026 soft limit fields.\n        QIF_BLIMITS;\n        /// The current space field.\n        QIF_SPACE;\n        /// The inode hard \u0026 soft limit fields.\n        QIF_ILIMITS;\n        /// The current inodes field.\n        QIF_INODES;\n        /// The disk use time limit field.\n        QIF_BTIME;\n        /// The file quote time limit field.\n        QIF_ITIME;\n        /// All block \u0026 inode limits.\n        QIF_LIMITS;\n        /// The space \u0026 inodes usage fields.\n        QIF_USAGE;\n        /// The time limit fields.\n        QIF_TIMES;\n        /// All fields.\n        QIF_ALL;\n    }\n);\n\n/// Wrapper type for `if_dqblk`\n#[repr(transparent)]\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct Dqblk(libc::dqblk);\n\nimpl Default for Dqblk {\n    fn default() -\u003e Dqblk {\n        Dqblk(libc::dqblk {\n            dqb_bhardlimit: 0,\n            dqb_bsoftlimit: 0,\n            dqb_curspace: 0,\n            dqb_ihardlimit: 0,\n            dqb_isoftlimit: 0,\n            dqb_curinodes: 0,\n            dqb_btime: 0,\n            dqb_itime: 0,\n            dqb_valid: 0,\n        })\n    }\n}\n\nimpl Dqblk {\n    /// The absolute limit on disk quota blocks allocated.\n    pub fn blocks_hard_limit(\u0026self) -\u003e Option\u003cu64\u003e {\n        let valid_fields =\n            QuotaValidFlags::from_bits_truncate(self.0.dqb_valid);\n        if valid_fields.contains(QuotaValidFlags::QIF_BLIMITS) {\n            Some(self.0.dqb_bhardlimit)\n        } else {\n            None\n        }\n    }\n\n    /// Set the absolute limit on disk quota blocks allocated.\n    pub fn set_blocks_hard_limit(\u0026mut self, limit: u64) {\n        self.0.dqb_bhardlimit = limit;\n    }\n\n    /// Preferred limit on disk quota blocks\n    pub fn blocks_soft_limit(\u0026self) -\u003e Option\u003cu64\u003e {\n        let valid_fields =\n            QuotaValidFlags::from_bits_truncate(self.0.dqb_valid);\n        if valid_fields.contains(QuotaValidFlags::QIF_BLIMITS) {\n            Some(self.0.dqb_bsoftlimit)\n        } else {\n            None\n        }\n    }\n\n    /// Set the preferred limit on disk quota blocks allocated.\n    pub fn set_blocks_soft_limit(\u0026mut self, limit: u64) {\n        self.0.dqb_bsoftlimit = limit;\n    }\n\n    /// Current occupied space (bytes).\n    pub fn occupied_space(\u0026self) -\u003e Option\u003cu64\u003e {\n        let valid_fields =\n            QuotaValidFlags::from_bits_truncate(self.0.dqb_valid);\n        if valid_fields.contains(QuotaValidFlags::QIF_SPACE) {\n            Some(self.0.dqb_curspace)\n        } else {\n            None\n        }\n    }\n\n    /// Maximum number of allocated inodes.\n    pub fn inodes_hard_limit(\u0026self) -\u003e Option\u003cu64\u003e {\n        let valid_fields =\n            QuotaValidFlags::from_bits_truncate(self.0.dqb_valid);\n        if valid_fields.contains(QuotaValidFlags::QIF_ILIMITS) {\n            Some(self.0.dqb_ihardlimit)\n        } else {\n            None\n        }\n    }\n\n    /// Set the maximum number of allocated inodes.\n    pub fn set_inodes_hard_limit(\u0026mut self, limit: u64) {\n        self.0.dqb_ihardlimit = limit;\n    }\n\n    /// Preferred inode limit\n    pub fn inodes_soft_limit(\u0026self) -\u003e Option\u003cu64\u003e {\n        let valid_fields =\n            QuotaValidFlags::from_bits_truncate(self.0.dqb_valid);\n        if valid_fields.contains(QuotaValidFlags::QIF_ILIMITS) {\n            Some(self.0.dqb_isoftlimit)\n        } else {\n            None\n        }\n    }\n\n    /// Set the preferred limit of allocated inodes.\n    pub fn set_inodes_soft_limit(\u0026mut self, limit: u64) {\n        self.0.dqb_isoftlimit = limit;\n    }\n\n    /// Current number of allocated inodes.\n    pub fn allocated_inodes(\u0026self) -\u003e Option\u003cu64\u003e {\n        let valid_fields =\n            QuotaValidFlags::from_bits_truncate(self.0.dqb_valid);\n        if valid_fields.contains(QuotaValidFlags::QIF_INODES) {\n            Some(self.0.dqb_curinodes)\n        } else {\n            None\n        }\n    }\n\n    /// Time limit for excessive disk use.\n    pub fn block_time_limit(\u0026self) -\u003e Option\u003cu64\u003e {\n        let valid_fields =\n            QuotaValidFlags::from_bits_truncate(self.0.dqb_valid);\n        if valid_fields.contains(QuotaValidFlags::QIF_BTIME) {\n            Some(self.0.dqb_btime)\n        } else {\n            None\n        }\n    }\n\n    /// Set the time limit for excessive disk use.\n    pub fn set_block_time_limit(\u0026mut self, limit: u64) {\n        self.0.dqb_btime = limit;\n    }\n\n    /// Time limit for excessive files.\n    pub fn inode_time_limit(\u0026self) -\u003e Option\u003cu64\u003e {\n        let valid_fields =\n            QuotaValidFlags::from_bits_truncate(self.0.dqb_valid);\n        if valid_fields.contains(QuotaValidFlags::QIF_ITIME) {\n            Some(self.0.dqb_itime)\n        } else {\n            None\n        }\n    }\n\n    /// Set the time limit for excessive files.\n    pub fn set_inode_time_limit(\u0026mut self, limit: u64) {\n        self.0.dqb_itime = limit;\n    }\n}\n\nfn quotactl\u003cP: ?Sized + NixPath\u003e(\n    cmd: QuotaCmd,\n    special: Option\u003c\u0026P\u003e,\n    id: c_int,\n    addr: *mut c_char,\n) -\u003e Result\u003c()\u003e {\n    unsafe {\n        Errno::clear();\n        let res = match special {\n            Some(dev) =\u003e dev.with_nix_path(|path| {\n                libc::quotactl(cmd.as_int(), path.as_ptr(), id, addr)\n            }),\n            None =\u003e Ok(libc::quotactl(cmd.as_int(), ptr::null(), id, addr)),\n        }?;\n\n        Errno::result(res).map(drop)\n    }\n}\n\n/// Turn on disk quotas for a block device.\npub fn quotactl_on\u003cP: ?Sized + NixPath\u003e(\n    which: QuotaType,\n    special: \u0026P,\n    format: QuotaFmt,\n    quota_file: \u0026P,\n) -\u003e Result\u003c()\u003e {\n    quota_file.with_nix_path(|path| {\n        let mut path_copy = path.to_bytes_with_nul().to_owned();\n        let p: *mut c_char = path_copy.as_mut_ptr().cast();\n        quotactl(\n            QuotaCmd(QuotaSubCmd::Q_QUOTAON, which),\n            Some(special),\n            format as c_int,\n            p,\n        )\n    })?\n}\n\n/// Disable disk quotas for a block device.\npub fn quotactl_off\u003cP: ?Sized + NixPath\u003e(\n    which: QuotaType,\n    special: \u0026P,\n) -\u003e Result\u003c()\u003e {\n    quotactl(\n        QuotaCmd(QuotaSubCmd::Q_QUOTAOFF, which),\n        Some(special),\n        0,\n        ptr::null_mut(),\n    )\n}\n\n/// Update the on-disk copy of quota usages for a filesystem.\n///\n/// If `special` is `None`, then all file systems with active quotas are sync'd.\npub fn quotactl_sync\u003cP: ?Sized + NixPath\u003e(\n    which: QuotaType,\n    special: Option\u003c\u0026P\u003e,\n) -\u003e Result\u003c()\u003e {\n    quotactl(\n        QuotaCmd(QuotaSubCmd::Q_SYNC, which),\n        special,\n        0,\n        ptr::null_mut(),\n    )\n}\n\n/// Get disk quota limits and current usage for the given user/group id.\npub fn quotactl_get\u003cP: ?Sized + NixPath\u003e(\n    which: QuotaType,\n    special: \u0026P,\n    id: c_int,\n) -\u003e Result\u003cDqblk\u003e {\n    let mut dqblk = mem::MaybeUninit::\u003clibc::dqblk\u003e::uninit();\n    quotactl(\n        QuotaCmd(QuotaSubCmd::Q_GETQUOTA, which),\n        Some(special),\n        id,\n        dqblk.as_mut_ptr().cast(),\n    )?;\n    Ok(unsafe { Dqblk(dqblk.assume_init()) })\n}\n\n/// Configure quota values for the specified fields for a given user/group id.\npub fn quotactl_set\u003cP: ?Sized + NixPath\u003e(\n    which: QuotaType,\n    special: \u0026P,\n    id: c_int,\n    dqblk: \u0026Dqblk,\n    fields: QuotaValidFlags,\n) -\u003e Result\u003c()\u003e {\n    let mut dqblk_copy = *dqblk;\n    dqblk_copy.0.dqb_valid = fields.bits();\n    quotactl(\n        QuotaCmd(QuotaSubCmd::Q_SETQUOTA, which),\n        Some(special),\n        id,\n        \u0026mut dqblk_copy as *mut _ as *mut c_char,\n    )\n}\n","traces":[{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","reboot.rs"],"content":"//! Reboot/shutdown\n//!\n//! On Linux, This can also be used to enable/disable Ctrl-Alt-Delete.\n\nuse crate::errno::Errno;\nuse crate::Result;\nuse cfg_if::cfg_if;\nuse std::convert::Infallible;\n\ncfg_if! {\n    if #[cfg(target_os = \"linux\")] {\n        use std::mem::drop;\n\n        libc_enum! {\n            /// How exactly should the system be rebooted.\n            ///\n            /// See [`set_cad_enabled()`](fn.set_cad_enabled.html) for\n            /// enabling/disabling Ctrl-Alt-Delete.\n            #[repr(i32)]\n            #[non_exhaustive]\n            pub enum RebootMode {\n                /// Halt the system.\n                RB_HALT_SYSTEM,\n                /// Execute a kernel that has been loaded earlier with\n                /// [`kexec_load(2)`](https://man7.org/linux/man-pages/man2/kexec_load.2.html).\n                RB_KEXEC,\n                /// Stop the system and switch off power, if possible.\n                RB_POWER_OFF,\n                /// Restart the system.\n                RB_AUTOBOOT,\n                // we do not support Restart2.\n                /// Suspend the system using software suspend.\n                RB_SW_SUSPEND,\n            }\n        }\n\n        /// Reboots or shuts down the system.\n        pub fn reboot(how: RebootMode) -\u003e Result\u003cInfallible\u003e {\n            unsafe { libc::reboot(how as libc::c_int) };\n            Err(Errno::last())\n        }\n\n        /// Enable or disable the reboot keystroke (Ctrl-Alt-Delete).\n        ///\n        /// Corresponds to calling `reboot(RB_ENABLE_CAD)` or `reboot(RB_DISABLE_CAD)` in C.\n        pub fn set_cad_enabled(enable: bool) -\u003e Result\u003c()\u003e {\n            let cmd = if enable {\n                libc::RB_ENABLE_CAD\n            } else {\n                libc::RB_DISABLE_CAD\n            };\n            let res = unsafe { libc::reboot(cmd) };\n            Errno::result(res).map(drop)\n        }\n    } else if #[cfg(netbsdlike)] {\n        use libc::c_int;\n\n        libc_bitflags! {\n            /// How exactly should the system be rebooted.\n            pub struct RebootMode: c_int {\n                /// The default, causing the system to reboot in its usual fashion.\n                RB_AUTOBOOT;\n                /// Interpreted by the bootstrap program itself, causing it to\n                /// prompt on the console as to what file should be booted.\n                /// Normally, the system is booted from the file xx(0,0)bsd,\n                /// where xx is the default disk name, without prompting for\n                /// the file name.\n                RB_ASKNAME;\n                /// Dump kernel memory before rebooting; see `savecore(8)` for\n                /// more information.\n                RB_DUMP;\n                /// The processor is simply halted; no reboot takes place.\n                RB_HALT;\n                /// Power off the system if the system hardware supports the\n                /// function, otherwise it has no effect.\n                ///\n                /// Should be used in conjunction with `RB_HALT`.\n                RB_POWERDOWN;\n                /// By default, the system will halt if `reboot()` is called during\n                /// startup (before the system has finished autoconfiguration), even\n                /// if `RB_HALT` is not specified. This is because `panic(9)`s\n                /// during startup will probably just repeat on the next boot.\n                /// Use of this option implies that the user has requested the\n                /// action specified (for example, using the `ddb(4)` boot reboot\n                /// command), so the system will reboot if a halt is not explicitly\n                /// requested.\n                #[cfg(target_os = \"openbsd\")]\n                RB_USERREQ;\n                /// Load the symbol table and enable a built-in debugger in the\n                /// system. This option will have no useful function if the kernel\n                /// is not configured for debugging. Several other options have\n                /// different meaning if combined with this option, although their\n                /// use may not be possible via the `reboot()` call. See `ddb(4)` for\n                /// more information.\n                RB_KDB;\n                /// Normally, the disks are sync'd (see `sync(8)`) before the\n                /// processor is halted or rebooted. This option may be useful\n                /// if file system changes have been made manually or if the\n                /// processor is on fire.\n                RB_NOSYNC;\n                /// Normally, the reboot procedure involves an automatic disk\n                /// consistency check and then multi-user operations. `RB_SINGLE`\n                /// prevents this, booting the system with a single-user shell on\n                /// the console. `RB_SINGLE` is actually interpreted by the `init(8)`\n                /// program in the newly booted system.\n                ///\n                /// When no options are given (i.e., `RB_AUTOBOOT` is used), the\n                /// system is rebooted from file /bsd in the root file system of\n                /// unit 0 of a disk chosen in a processor specific way. An automatic\n                /// consistency check of the disks is normally performed (see `fsck(8)`).\n                RB_SINGLE;\n                /// Initially invoke the `userconf(4)` facility when the system\n                /// starts up again, if it has been compiled into the kernel\n                /// that is loaded.\n                #[cfg(target_os = \"netbsd\")]\n                RB_USERCONF;\n                /// Don't update the hardware clock from the system clock, presumably\n                /// because the system clock is suspect.\n                #[cfg(target_os = \"openbsd\")]\n                RB_TIMEBAD;\n            }\n        }\n\n        /// Reboot system or halt processor\n        ///\n        /// For more information, see the man pages:\n        ///\n        /// * [NetBSD](https://man.netbsd.org/reboot.2)\n        /// * [OpenBSD](https://man.openbsd.org/reboot.2)\n        #[cfg(netbsdlike)]\n        pub fn reboot(how: RebootMode) -\u003e Result\u003cInfallible\u003e {\n            #[cfg(target_os = \"openbsd\")]\n            unsafe { libc::reboot(how.bits()) };\n            #[cfg(target_os = \"netbsd\")]\n            unsafe { libc::reboot(how.bits(), std::ptr::null_mut()) };\n\n            Err(Errno::last())\n        }\n    }\n}\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","resource.rs"],"content":"//! Configure the process resource limits.\nuse cfg_if::cfg_if;\nuse libc::{c_int, c_long, rusage};\n\nuse crate::errno::Errno;\nuse crate::sys::time::TimeVal;\nuse crate::Result;\npub use libc::rlim_t;\npub use libc::RLIM_INFINITY;\nuse std::mem;\n\ncfg_if! {\n    if #[cfg(any(\n        all(target_os = \"linux\", any(target_env = \"gnu\", target_env = \"uclibc\")),\n        target_os = \"hurd\"\n    ))]{\n        use libc::{__rlimit_resource_t, rlimit};\n    } else if #[cfg(any(\n        bsd,\n        target_os = \"android\",\n        target_os = \"aix\",\n        all(target_os = \"linux\", not(target_env = \"gnu\")),\n        target_os = \"cygwin\"\n    ))]{\n        use libc::rlimit;\n    }\n}\n\nlibc_enum! {\n    /// Types of process resources.\n    ///\n    /// The Resource enum is platform dependent. Check different platform\n    /// manuals for more details. Some platform links have been provided for\n    /// easier reference (non-exhaustive).\n    ///\n    /// * [Linux](https://man7.org/linux/man-pages/man2/getrlimit.2.html)\n    /// * [FreeBSD](https://www.freebsd.org/cgi/man.cgi?query=setrlimit)\n    /// * [NetBSD](https://man.netbsd.org/setrlimit.2)\n\n    // linux-gnu uses u_int as resource enum, which is implemented in libc as\n    // well.\n    //\n    // https://gcc.gnu.org/legacy-ml/gcc/2015-08/msg00441.html\n    // https://github.com/rust-lang/libc/blob/master/src/unix/linux_like/linux/gnu/mod.rs\n    #[cfg_attr(any(\n            all(target_os = \"linux\", any(target_env = \"gnu\", target_env = \"uclibc\")),\n            target_os = \"hurd\"\n        ), repr(u32))]\n    #[cfg_attr(any(\n            bsd,\n            target_os = \"android\",\n            target_os = \"aix\",\n            all(target_os = \"linux\", not(any(target_env = \"gnu\", target_env = \"uclibc\"))),\n            target_os = \"cygwin\"\n        ), repr(i32))]\n    #[non_exhaustive]\n    pub enum Resource {\n        #[cfg(not(any(target_os = \"freebsd\", netbsdlike)))]\n        /// The maximum amount (in bytes) of virtual memory the process is\n        /// allowed to map.\n        RLIMIT_AS,\n        /// The largest size (in bytes) core(5) file that may be created.\n        RLIMIT_CORE,\n        /// The maximum amount of cpu time (in seconds) to be used by each\n        /// process.\n        RLIMIT_CPU,\n        /// The maximum size (in bytes) of the data segment for a process\n        RLIMIT_DATA,\n        /// The largest size (in bytes) file that may be created.\n        RLIMIT_FSIZE,\n        /// The maximum number of open files for this process.\n        RLIMIT_NOFILE,\n        /// The maximum size (in bytes) of the stack segment for a process.\n        RLIMIT_STACK,\n\n        #[cfg(target_os = \"freebsd\")]\n        /// The maximum number of kqueues this user id is allowed to create.\n        RLIMIT_KQUEUES,\n\n        #[cfg(linux_android)]\n        /// A limit on the combined number of flock locks and fcntl leases that\n        /// this process may establish.\n        RLIMIT_LOCKS,\n\n        #[cfg(any(linux_android, target_os = \"freebsd\", netbsdlike))]\n        /// The maximum size (in bytes) which a process may lock into memory\n        /// using the mlock(2) system call.\n        RLIMIT_MEMLOCK,\n\n        #[cfg(linux_android)]\n        /// A limit on the number of bytes that can be allocated for POSIX\n        /// message queues  for  the  real  user  ID  of  the  calling process.\n        RLIMIT_MSGQUEUE,\n\n        #[cfg(linux_android)]\n        /// A ceiling to which the process's nice value can be raised using\n        /// setpriority or nice.\n        RLIMIT_NICE,\n\n        #[cfg(any(\n            linux_android,\n            target_os = \"freebsd\",\n            netbsdlike,\n            target_os = \"aix\",\n        ))]\n        /// The maximum number of simultaneous processes for this user id.\n        RLIMIT_NPROC,\n\n        #[cfg(target_os = \"freebsd\")]\n        /// The maximum number of pseudo-terminals this user id is allowed to\n        /// create.\n        RLIMIT_NPTS,\n\n        #[cfg(any(linux_android,\n            target_os = \"freebsd\",\n            netbsdlike,\n            target_os = \"aix\",\n        ))]\n        /// When there is memory pressure and swap is available, prioritize\n        /// eviction of a process' resident pages beyond this amount (in bytes).\n        RLIMIT_RSS,\n\n        #[cfg(linux_android)]\n        /// A ceiling on the real-time priority that may be set for this process\n        /// using sched_setscheduler and  sched_set param.\n        RLIMIT_RTPRIO,\n\n        #[cfg(any(target_os = \"linux\"))]\n        /// A limit (in microseconds) on the amount of CPU time that a process\n        /// scheduled under a real-time scheduling policy may con sume without\n        /// making a blocking system call.\n        RLIMIT_RTTIME,\n\n        #[cfg(linux_android)]\n        /// A limit on the number of signals that may be queued for the real\n        /// user ID of the  calling  process.\n        RLIMIT_SIGPENDING,\n\n        #[cfg(freebsdlike)]\n        /// The maximum size (in bytes) of socket buffer usage for this user.\n        RLIMIT_SBSIZE,\n\n        #[cfg(target_os = \"freebsd\")]\n        /// The maximum size (in bytes) of the swap space that may be reserved\n        /// or used by all of this user id's processes.\n        RLIMIT_SWAP,\n\n        #[cfg(target_os = \"freebsd\")]\n        /// An alias for RLIMIT_AS.\n        RLIMIT_VMEM,\n    }\n}\n\n/// Get the current processes resource limits\n///\n/// The special value [`RLIM_INFINITY`] indicates that no limit will be\n/// enforced.\n///\n/// # Parameters\n///\n/// * `resource`: The [`Resource`] that we want to get the limits of.\n///\n/// # Examples\n///\n/// ```\n/// # use nix::sys::resource::{getrlimit, Resource};\n///\n/// let (soft_limit, hard_limit) = getrlimit(Resource::RLIMIT_NOFILE).unwrap();\n/// println!(\"current soft_limit: {}\", soft_limit);\n/// println!(\"current hard_limit: {}\", hard_limit);\n/// ```\n///\n/// # References\n///\n/// [getrlimit(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getrlimit.html#tag_16_215)\n///\n/// [`Resource`]: enum.Resource.html\npub fn getrlimit(resource: Resource) -\u003e Result\u003c(rlim_t, rlim_t)\u003e {\n    let mut old_rlim = mem::MaybeUninit::\u003crlimit\u003e::uninit();\n\n    cfg_if! {\n        if #[cfg(any(\n            all(target_os = \"linux\", any(target_env = \"gnu\", target_env = \"uclibc\")),\n            target_os = \"hurd\"\n        ))] {\n            let res = unsafe { libc::getrlimit(resource as __rlimit_resource_t, old_rlim.as_mut_ptr()) };\n        } else {\n            let res = unsafe { libc::getrlimit(resource as c_int, old_rlim.as_mut_ptr()) };\n        }\n    }\n\n    Errno::result(res).map(|_| {\n        let rlimit { rlim_cur, rlim_max } = unsafe { old_rlim.assume_init() };\n        (rlim_cur, rlim_max)\n    })\n}\n\n/// Set the current processes resource limits\n///\n/// # Parameters\n///\n/// * `resource`: The [`Resource`] that we want to set the limits of.\n/// * `soft_limit`: The value that the kernel enforces for the corresponding\n///   resource.\n/// * `hard_limit`: The ceiling for the soft limit. Must be lower or equal to\n///   the current hard limit for non-root users.\n///\n/// The special value [`RLIM_INFINITY`] indicates that no limit will be\n/// enforced.\n///\n/// # Examples\n///\n/// ```\n/// # use nix::sys::resource::{setrlimit, Resource};\n///\n/// let soft_limit = 512;\n/// let hard_limit = 1024;\n/// setrlimit(Resource::RLIMIT_NOFILE, soft_limit, hard_limit).unwrap();\n/// ```\n///\n/// # References\n///\n/// [setrlimit(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getrlimit.html#tag_16_215)\n///\n/// [`Resource`]: enum.Resource.html\n///\n/// Note: `setrlimit` provides a safe wrapper to libc's `setrlimit`.\npub fn setrlimit(\n    resource: Resource,\n    soft_limit: rlim_t,\n    hard_limit: rlim_t,\n) -\u003e Result\u003c()\u003e {\n    let new_rlim = rlimit {\n        rlim_cur: soft_limit,\n        rlim_max: hard_limit,\n    };\n    cfg_if! {\n        if #[cfg(any(\n            all(target_os = \"linux\", any(target_env = \"gnu\", target_env = \"uclibc\")),\n            target_os = \"hurd\",\n        ))]{\n            let res = unsafe { libc::setrlimit(resource as __rlimit_resource_t, \u0026new_rlim as *const rlimit) };\n        }else{\n            let res = unsafe { libc::setrlimit(resource as c_int, \u0026new_rlim as *const rlimit) };\n        }\n    }\n\n    Errno::result(res).map(drop)\n}\n\nlibc_enum! {\n    /// Whose resource usage should be returned by [`getrusage`].\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum UsageWho {\n        /// Resource usage for the current process.\n        RUSAGE_SELF,\n\n        /// Resource usage for all the children that have terminated and been waited for.\n        RUSAGE_CHILDREN,\n\n        #[cfg(any(target_os = \"linux\", target_os = \"freebsd\", target_os = \"openbsd\"))]\n        /// Resource usage for the calling thread.\n        RUSAGE_THREAD,\n    }\n}\n\n/// Output of `getrusage` with information about resource usage. Some of the fields\n/// may be unused in some platforms, and will be always zeroed out. See their manuals\n/// for details.\n#[repr(transparent)]\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct Usage(rusage);\n\nimpl AsRef\u003crusage\u003e for Usage {\n    fn as_ref(\u0026self) -\u003e \u0026rusage {\n        \u0026self.0\n    }\n}\n\nimpl AsMut\u003crusage\u003e for Usage {\n    fn as_mut(\u0026mut self) -\u003e \u0026mut rusage {\n        \u0026mut self.0\n    }\n}\n\nimpl Usage {\n    /// Total amount of time spent executing in user mode.\n    pub fn user_time(\u0026self) -\u003e TimeVal {\n        TimeVal::from(self.0.ru_utime)\n    }\n\n    /// Total amount of time spent executing in kernel mode.\n    pub fn system_time(\u0026self) -\u003e TimeVal {\n        TimeVal::from(self.0.ru_stime)\n    }\n\n    /// The resident set size at its peak,\n    #[cfg_attr(apple_targets, doc = \" in bytes.\")]\n    #[cfg_attr(not(apple_targets), doc = \" in kilobytes.\")]\n    pub fn max_rss(\u0026self) -\u003e c_long {\n        self.0.ru_maxrss\n    }\n\n    /// Integral value expressed in kilobytes times ticks of execution indicating\n    /// the amount of text memory shared with other processes.\n    pub fn shared_integral(\u0026self) -\u003e c_long {\n        self.0.ru_ixrss\n    }\n\n    /// Integral value expressed in kilobytes times ticks of execution indicating\n    /// the amount of unshared memory used by data.\n    pub fn unshared_data_integral(\u0026self) -\u003e c_long {\n        self.0.ru_idrss\n    }\n\n    /// Integral value expressed in kilobytes times ticks of execution indicating\n    /// the amount of unshared memory used for stack space.\n    pub fn unshared_stack_integral(\u0026self) -\u003e c_long {\n        self.0.ru_isrss\n    }\n\n    /// Number of page faults that were served without resorting to I/O, with pages\n    /// that have been allocated previously by the kernel.\n    pub fn minor_page_faults(\u0026self) -\u003e c_long {\n        self.0.ru_minflt\n    }\n\n    /// Number of page faults that were served through I/O (i.e. swap).\n    pub fn major_page_faults(\u0026self) -\u003e c_long {\n        self.0.ru_majflt\n    }\n\n    /// Number of times all of the memory was fully swapped out.\n    pub fn full_swaps(\u0026self) -\u003e c_long {\n        self.0.ru_nswap\n    }\n\n    /// Number of times a read was done from a block device.\n    pub fn block_reads(\u0026self) -\u003e c_long {\n        self.0.ru_inblock\n    }\n\n    /// Number of times a write was done to a block device.\n    pub fn block_writes(\u0026self) -\u003e c_long {\n        self.0.ru_oublock\n    }\n\n    /// Number of IPC messages sent.\n    pub fn ipc_sends(\u0026self) -\u003e c_long {\n        self.0.ru_msgsnd\n    }\n\n    /// Number of IPC messages received.\n    pub fn ipc_receives(\u0026self) -\u003e c_long {\n        self.0.ru_msgrcv\n    }\n\n    /// Number of signals received.\n    pub fn signals(\u0026self) -\u003e c_long {\n        self.0.ru_nsignals\n    }\n\n    /// Number of times a context switch was voluntarily invoked.\n    pub fn voluntary_context_switches(\u0026self) -\u003e c_long {\n        self.0.ru_nvcsw\n    }\n\n    /// Number of times a context switch was imposed by the kernel (usually due to\n    /// time slice expiring or preemption by a higher priority process).\n    pub fn involuntary_context_switches(\u0026self) -\u003e c_long {\n        self.0.ru_nivcsw\n    }\n}\n\n/// Get usage information for a process, its children or the current thread\n///\n/// Real time information can be obtained for either the current process or (in some\n/// systems) thread, but information about children processes is only provided for\n/// those that have terminated and been waited for (see [`super::wait::wait`]).\n///\n/// Some information may be missing depending on the platform, and the way information\n/// is provided for children may also vary. Check the manuals for details.\n///\n/// # References\n///\n/// * [getrusage(2)](https://pubs.opengroup.org/onlinepubs/009696699/functions/getrusage.html)\n/// * [Linux](https://man7.org/linux/man-pages/man2/getrusage.2.html)\n/// * [FreeBSD](https://www.freebsd.org/cgi/man.cgi?query=getrusage)\n/// * [NetBSD](https://man.netbsd.org/getrusage.2)\n/// * [MacOS](https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/getrusage.2.html)\n///\n/// [`UsageWho`]: enum.UsageWho.html\n///\n/// Note: `getrusage` provides a safe wrapper to libc's [`libc::getrusage`].\npub fn getrusage(who: UsageWho) -\u003e Result\u003cUsage\u003e {\n    unsafe {\n        let mut rusage = mem::MaybeUninit::\u003crusage\u003e::uninit();\n        let res = libc::getrusage(who as c_int, rusage.as_mut_ptr());\n        Errno::result(res).map(|_| Usage(rusage.assume_init()))\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","select.rs"],"content":"//! Portably monitor a group of file descriptors for readiness.\nuse crate::errno::Errno;\nuse crate::sys::time::{TimeSpec, TimeVal};\nuse crate::Result;\nuse libc::{self, c_int};\nuse std::convert::TryFrom;\nuse std::iter::FusedIterator;\nuse std::mem;\nuse std::ops::Range;\nuse std::os::unix::io::{AsRawFd, BorrowedFd, RawFd};\nuse std::ptr::{null, null_mut};\n\npub use libc::FD_SETSIZE;\n\n/// Contains a set of file descriptors used by [`select`]\n#[repr(transparent)]\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct FdSet\u003c'fd\u003e {\n    set: libc::fd_set,\n    _fd: std::marker::PhantomData\u003cBorrowedFd\u003c'fd\u003e\u003e,\n}\n\nfn assert_fd_valid(fd: RawFd) {\n    assert!(\n        usize::try_from(fd).map_or(false, |fd| fd \u003c FD_SETSIZE),\n        \"fd must be in the range 0..FD_SETSIZE\",\n    );\n}\n\nimpl\u003c'fd\u003e FdSet\u003c'fd\u003e {\n    /// Create an empty `FdSet`\n    pub fn new() -\u003e FdSet\u003c'fd\u003e {\n        let mut fdset = mem::MaybeUninit::uninit();\n        unsafe {\n            libc::FD_ZERO(fdset.as_mut_ptr());\n            Self {\n                set: fdset.assume_init(),\n                _fd: std::marker::PhantomData,\n            }\n        }\n    }\n\n    /// Add a file descriptor to an `FdSet`\n    pub fn insert(\u0026mut self, fd: BorrowedFd\u003c'fd\u003e) {\n        assert_fd_valid(fd.as_raw_fd());\n        unsafe { libc::FD_SET(fd.as_raw_fd(), \u0026mut self.set) };\n    }\n\n    /// Remove a file descriptor from an `FdSet`\n    pub fn remove(\u0026mut self, fd: BorrowedFd\u003c'fd\u003e) {\n        assert_fd_valid(fd.as_raw_fd());\n        unsafe { libc::FD_CLR(fd.as_raw_fd(), \u0026mut self.set) };\n    }\n\n    /// Test an `FdSet` for the presence of a certain file descriptor.\n    pub fn contains(\u0026self, fd: BorrowedFd\u003c'fd\u003e) -\u003e bool {\n        assert_fd_valid(fd.as_raw_fd());\n        unsafe { libc::FD_ISSET(fd.as_raw_fd(), \u0026self.set) }\n    }\n\n    /// Remove all file descriptors from this `FdSet`.\n    pub fn clear(\u0026mut self) {\n        unsafe { libc::FD_ZERO(\u0026mut self.set) };\n    }\n\n    /// Finds the highest file descriptor in the set.\n    ///\n    /// Returns `None` if the set is empty.\n    ///\n    /// This can be used to calculate the `nfds` parameter of the [`select`] function.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// # use std::os::unix::io::{AsRawFd, BorrowedFd};\n    /// # use nix::sys::select::FdSet;\n    /// let fd_four = unsafe {BorrowedFd::borrow_raw(4)};\n    /// let fd_nine = unsafe {BorrowedFd::borrow_raw(9)};\n    /// let mut set = FdSet::new();\n    /// set.insert(fd_four);\n    /// set.insert(fd_nine);\n    /// assert_eq!(set.highest().map(|borrowed_fd|borrowed_fd.as_raw_fd()), Some(9));\n    /// ```\n    ///\n    /// [`select`]: fn.select.html\n    pub fn highest(\u0026self) -\u003e Option\u003cBorrowedFd\u003c'_\u003e\u003e {\n        self.fds(None).next_back()\n    }\n\n    /// Returns an iterator over the file descriptors in the set.\n    ///\n    /// For performance, it takes an optional higher bound: the iterator will\n    /// not return any elements of the set greater than the given file\n    /// descriptor.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # use nix::sys::select::FdSet;\n    /// # use std::os::unix::io::{AsRawFd, BorrowedFd, RawFd};\n    /// let mut set = FdSet::new();\n    /// let fd_four = unsafe {BorrowedFd::borrow_raw(4)};\n    /// let fd_nine = unsafe {BorrowedFd::borrow_raw(9)};\n    /// set.insert(fd_four);\n    /// set.insert(fd_nine);\n    /// let fds: Vec\u003cRawFd\u003e = set.fds(None).map(|borrowed_fd|borrowed_fd.as_raw_fd()).collect();\n    /// assert_eq!(fds, vec![4, 9]);\n    /// ```\n    #[inline]\n    pub fn fds(\u0026self, highest: Option\u003cRawFd\u003e) -\u003e Fds {\n        Fds {\n            set: self,\n            range: 0..highest.map(|h| h as usize + 1).unwrap_or(FD_SETSIZE),\n        }\n    }\n}\n\nimpl Default for FdSet\u003c'_\u003e {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Iterator over `FdSet`.\n#[derive(Debug)]\npub struct Fds\u003c'a, 'fd\u003e {\n    set: \u0026'a FdSet\u003c'fd\u003e,\n    range: Range\u003cusize\u003e,\n}\n\nimpl\u003c'fd\u003e Iterator for Fds\u003c'_, 'fd\u003e {\n    type Item = BorrowedFd\u003c'fd\u003e;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        for i in \u0026mut self.range {\n            let borrowed_i = unsafe { BorrowedFd::borrow_raw(i as RawFd) };\n            if self.set.contains(borrowed_i) {\n                return Some(borrowed_i);\n            }\n        }\n        None\n    }\n\n    #[inline]\n    fn size_hint(\u0026self) -\u003e (usize, Option\u003cusize\u003e) {\n        let (_, upper) = self.range.size_hint();\n        (0, upper)\n    }\n}\n\nimpl\u003c'fd\u003e DoubleEndedIterator for Fds\u003c'_, 'fd\u003e {\n    #[inline]\n    fn next_back(\u0026mut self) -\u003e Option\u003cBorrowedFd\u003c'fd\u003e\u003e {\n        while let Some(i) = self.range.next_back() {\n            let borrowed_i = unsafe { BorrowedFd::borrow_raw(i as RawFd) };\n            if self.set.contains(borrowed_i) {\n                return Some(borrowed_i);\n            }\n        }\n        None\n    }\n}\n\nimpl FusedIterator for Fds\u003c'_, '_\u003e {}\n\n/// Monitors file descriptors for readiness\n///\n/// Returns the total number of ready file descriptors in all sets. The sets are changed so that all\n/// file descriptors that are ready for the given operation are set.\n///\n/// When this function returns, `timeout` has an implementation-defined value.\n///\n/// # Parameters\n///\n/// * `nfds`: The highest file descriptor set in any of the passed `FdSet`s, plus 1. If `None`, this\n///   is calculated automatically by calling [`FdSet::highest`] on all descriptor sets and adding 1\n///   to the maximum of that.\n/// * `readfds`: File descriptors to check for being ready to read.\n/// * `writefds`: File descriptors to check for being ready to write.\n/// * `errorfds`: File descriptors to check for pending error conditions.\n/// * `timeout`: Maximum time to wait for descriptors to become ready (`None` to block\n///   indefinitely).\n///\n/// # References\n///\n/// [select(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/select.html)\n///\n/// [`FdSet::highest`]: struct.FdSet.html#method.highest\npub fn select\u003c'a, 'fd, N, R, W, E, T\u003e(\n    nfds: N,\n    readfds: R,\n    writefds: W,\n    errorfds: E,\n    timeout: T,\n) -\u003e Result\u003cc_int\u003e\nwhere\n    'fd: 'a,\n    N: Into\u003cOption\u003cc_int\u003e\u003e,\n    R: Into\u003cOption\u003c\u0026'a mut FdSet\u003c'fd\u003e\u003e\u003e,\n    W: Into\u003cOption\u003c\u0026'a mut FdSet\u003c'fd\u003e\u003e\u003e,\n    E: Into\u003cOption\u003c\u0026'a mut FdSet\u003c'fd\u003e\u003e\u003e,\n    T: Into\u003cOption\u003c\u0026'a mut TimeVal\u003e\u003e,\n{\n    let mut readfds = readfds.into();\n    let mut writefds = writefds.into();\n    let mut errorfds = errorfds.into();\n    let timeout = timeout.into();\n\n    let nfds = nfds.into().unwrap_or_else(|| {\n        readfds\n            .iter_mut()\n            .chain(writefds.iter_mut())\n            .chain(errorfds.iter_mut())\n            .map(|set| {\n                set.highest()\n                    .map(|borrowed_fd| borrowed_fd.as_raw_fd())\n                    .unwrap_or(-1)\n            })\n            .max()\n            .unwrap_or(-1)\n            + 1\n    });\n\n    let readfds = readfds\n        .map(|set| set as *mut _ as *mut libc::fd_set)\n        .unwrap_or(null_mut());\n    let writefds = writefds\n        .map(|set| set as *mut _ as *mut libc::fd_set)\n        .unwrap_or(null_mut());\n    let errorfds = errorfds\n        .map(|set| set as *mut _ as *mut libc::fd_set)\n        .unwrap_or(null_mut());\n    let timeout = timeout\n        .map(|tv| tv as *mut _ as *mut libc::timeval)\n        .unwrap_or(null_mut());\n\n    let res =\n        unsafe { libc::select(nfds, readfds, writefds, errorfds, timeout) };\n\n    Errno::result(res)\n}\n\nfeature! {\n#![feature = \"signal\"]\n\nuse crate::sys::signal::SigSet;\n\n/// Monitors file descriptors for readiness with an altered signal mask.\n///\n/// Returns the total number of ready file descriptors in all sets. The sets are changed so that all\n/// file descriptors that are ready for the given operation are set.\n///\n/// When this function returns, the original signal mask is restored.\n///\n/// Unlike [`select`](#fn.select), `pselect` does not mutate the `timeout` value.\n///\n/// # Parameters\n///\n/// * `nfds`: The highest file descriptor set in any of the passed `FdSet`s, plus 1. If `None`, this\n///   is calculated automatically by calling [`FdSet::highest`] on all descriptor sets and adding 1\n///   to the maximum of that.\n/// * `readfds`: File descriptors to check for read readiness\n/// * `writefds`: File descriptors to check for write readiness\n/// * `errorfds`: File descriptors to check for pending error conditions.\n/// * `timeout`: Maximum time to wait for descriptors to become ready (`None` to block\n///   indefinitely).\n/// * `sigmask`: Signal mask to activate while waiting for file descriptors to turn\n///    ready (`None` to set no alternative signal mask).\n///\n/// # References\n///\n/// [pselect(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pselect.html)\n///\n/// [The new pselect() system call](https://lwn.net/Articles/176911/)\n///\n/// [`FdSet::highest`]: struct.FdSet.html#method.highest\npub fn pselect\u003c'a, 'fd, N, R, W, E, T, S\u003e(nfds: N,\n    readfds: R,\n    writefds: W,\n    errorfds: E,\n    timeout: T,\n                                     sigmask: S) -\u003e Result\u003cc_int\u003e\nwhere\n    'fd: 'a,\n    N: Into\u003cOption\u003cc_int\u003e\u003e,\n    R: Into\u003cOption\u003c\u0026'a mut FdSet\u003c'fd\u003e\u003e\u003e,\n    W: Into\u003cOption\u003c\u0026'a mut FdSet\u003c'fd\u003e\u003e\u003e,\n    E: Into\u003cOption\u003c\u0026'a mut FdSet\u003c'fd\u003e\u003e\u003e,\n    T: Into\u003cOption\u003c\u0026'a TimeSpec\u003e\u003e,\n    S: Into\u003cOption\u003c\u0026'a SigSet\u003e\u003e,\n{\n    let mut readfds = readfds.into();\n    let mut writefds = writefds.into();\n    let mut errorfds = errorfds.into();\n    let sigmask = sigmask.into();\n    let timeout = timeout.into();\n\n    let nfds = nfds.into().unwrap_or_else(|| {\n        readfds.iter_mut()\n            .chain(writefds.iter_mut())\n            .chain(errorfds.iter_mut())\n            .map(|set| set.highest().map(|borrowed_fd|borrowed_fd.as_raw_fd()).unwrap_or(-1))\n            .max()\n            .unwrap_or(-1) + 1\n    });\n\n    let readfds = readfds.map(|set| set as *mut _ as *mut libc::fd_set).unwrap_or(null_mut());\n    let writefds = writefds.map(|set| set as *mut _ as *mut libc::fd_set).unwrap_or(null_mut());\n    let errorfds = errorfds.map(|set| set as *mut _ as *mut libc::fd_set).unwrap_or(null_mut());\n    let timeout = timeout.map(|ts| ts.as_ref() as *const libc::timespec).unwrap_or(null());\n    let sigmask = sigmask.map(|sm| sm.as_ref() as *const libc::sigset_t).unwrap_or(null());\n\n    let res = unsafe {\n        libc::pselect(nfds, readfds, writefds, errorfds, timeout, sigmask)\n    };\n\n    Errno::result(res)\n}\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":65},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","sendfile.rs"],"content":"//! Send data from a file to a socket, bypassing userland.\n\nuse cfg_if::cfg_if;\nuse std::os::unix::io::{AsFd, AsRawFd};\nuse std::ptr;\n\nuse libc::{self, off_t};\n\nuse crate::errno::Errno;\nuse crate::Result;\n\n/// Copy up to `count` bytes to `out_fd` from `in_fd` starting at `offset`.\n///\n/// Returns a `Result` with the number of bytes written.\n///\n/// If `offset` is `None`, `sendfile` will begin reading at the current offset of `in_fd`and will\n/// update the offset of `in_fd`. If `offset` is `Some`, `sendfile` will begin at the specified\n/// offset and will not update the offset of `in_fd`. Instead, it will mutate `offset` to point to\n/// the byte after the last byte copied.\n///\n/// `in_fd` must support `mmap`-like operations and therefore cannot be a socket.\n///\n/// For more information, see [the sendfile(2) man page.](https://man7.org/linux/man-pages/man2/sendfile.2.html) for Linux,\n/// see [the sendfile(2) man page.](https://docs.oracle.com/cd/E88353_01/html/E37843/sendfile-3c.html) for Solaris.\n#[cfg(any(linux_android, solarish))]\npub fn sendfile\u003cF1: AsFd, F2: AsFd\u003e(\n    out_fd: F1,\n    in_fd: F2,\n    offset: Option\u003c\u0026mut off_t\u003e,\n    count: usize,\n) -\u003e Result\u003cusize\u003e {\n    let offset = offset\n        .map(|offset| offset as *mut _)\n        .unwrap_or(ptr::null_mut());\n    let ret = unsafe {\n        libc::sendfile(\n            out_fd.as_fd().as_raw_fd(),\n            in_fd.as_fd().as_raw_fd(),\n            offset,\n            count,\n        )\n    };\n    Errno::result(ret).map(|r| r as usize)\n}\n\n/// Copy up to `count` bytes to `out_fd` from `in_fd` starting at `offset`.\n///\n/// Returns a `Result` with the number of bytes written.\n///\n/// If `offset` is `None`, `sendfile` will begin reading at the current offset of `in_fd`and will\n/// update the offset of `in_fd`. If `offset` is `Some`, `sendfile` will begin at the specified\n/// offset and will not update the offset of `in_fd`. Instead, it will mutate `offset` to point to\n/// the byte after the last byte copied.\n///\n/// `in_fd` must support `mmap`-like operations and therefore cannot be a socket.\n///\n/// For more information, see [the sendfile(2) man page.](https://man7.org/linux/man-pages/man2/sendfile.2.html)\n#[cfg(target_os = \"linux\")]\npub fn sendfile64\u003cF1: AsFd, F2: AsFd\u003e(\n    out_fd: F1,\n    in_fd: F2,\n    offset: Option\u003c\u0026mut libc::off64_t\u003e,\n    count: usize,\n) -\u003e Result\u003cusize\u003e {\n    let offset = offset\n        .map(|offset| offset as *mut _)\n        .unwrap_or(ptr::null_mut());\n    let ret = unsafe {\n        libc::sendfile64(\n            out_fd.as_fd().as_raw_fd(),\n            in_fd.as_fd().as_raw_fd(),\n            offset,\n            count,\n        )\n    };\n    Errno::result(ret).map(|r| r as usize)\n}\n\ncfg_if! {\n    if #[cfg(any(freebsdlike, apple_targets))] {\n        use std::io::IoSlice;\n\n        #[derive(Clone, Debug)]\n        struct SendfileHeaderTrailer\u003c'a\u003e {\n            raw: libc::sf_hdtr,\n            _headers: Option\u003cVec\u003cIoSlice\u003c'a\u003e\u003e\u003e,\n            _trailers: Option\u003cVec\u003cIoSlice\u003c'a\u003e\u003e\u003e,\n        }\n\n        impl\u003c'a\u003e SendfileHeaderTrailer\u003c'a\u003e {\n            fn new(\n                headers: Option\u003c\u0026'a [\u0026'a [u8]]\u003e,\n                trailers: Option\u003c\u0026'a [\u0026'a [u8]]\u003e\n            ) -\u003e SendfileHeaderTrailer\u003c'a\u003e {\n                let mut header_iovecs: Option\u003cVec\u003cIoSlice\u003c'_\u003e\u003e\u003e =\n                    headers.map(|s| s.iter().map(|b| IoSlice::new(b)).collect());\n                let mut trailer_iovecs: Option\u003cVec\u003cIoSlice\u003c'_\u003e\u003e\u003e =\n                    trailers.map(|s| s.iter().map(|b| IoSlice::new(b)).collect());\n\n                SendfileHeaderTrailer {\n                    raw: libc::sf_hdtr {\n                        headers: {\n                            header_iovecs\n                                .as_mut()\n                                .map_or(ptr::null_mut(), |v| v.as_mut_ptr())\n                                .cast()\n                        },\n                        hdr_cnt: header_iovecs.as_ref().map(|v| v.len()).unwrap_or(0) as i32,\n                        trailers: {\n                            trailer_iovecs\n                                .as_mut()\n                                .map_or(ptr::null_mut(), |v| v.as_mut_ptr())\n                                .cast()\n                        },\n                        trl_cnt: trailer_iovecs.as_ref().map(|v| v.len()).unwrap_or(0) as i32\n                    },\n                    _headers: header_iovecs,\n                    _trailers: trailer_iovecs,\n                }\n            }\n        }\n    } else if #[cfg(solarish)] {\n        use std::os::unix::io::BorrowedFd;\n        use std::marker::PhantomData;\n\n        #[derive(Debug, Copy, Clone)]\n        /// Mapping of the raw C sendfilevec_t struct\n        pub struct SendfileVec\u003c'fd\u003e {\n            raw: libc::sendfilevec_t,\n            phantom: PhantomData\u003cBorrowedFd\u003c'fd\u003e\u003e\n        }\n\n        impl\u003c'fd\u003e SendfileVec\u003c'fd\u003e {\n            /// initialises SendfileVec to send data directly from the process's address space\n            /// same in C with sfv_fd set to SFV_FD_SELF.\n            pub fn newself(\n                off: off_t,\n                len: usize\n            ) -\u003e Self {\n                Self{raw: libc::sendfilevec_t{sfv_fd: libc::SFV_FD_SELF, sfv_flag: 0, sfv_off: off, sfv_len: len}, phantom: PhantomData}\n            }\n\n            /// initialises SendfileVec to send data from `fd`.\n            pub fn new(\n                fd: BorrowedFd\u003c'fd\u003e,\n                off: off_t,\n                len: usize\n            ) -\u003e SendfileVec\u003c'fd\u003e {\n                Self{raw: libc::sendfilevec_t{sfv_fd: fd.as_raw_fd(), sfv_flag: 0, sfv_off:off, sfv_len: len}, phantom: PhantomData}\n            }\n        }\n\n        impl From\u003cSendfileVec\u003c'_\u003e\u003e for libc::sendfilevec_t {\n            fn from\u003c'fd\u003e(vec: SendfileVec) -\u003e libc::sendfilevec_t {\n                vec.raw\n            }\n        }\n    }\n}\n\ncfg_if! {\n    if #[cfg(target_os = \"freebsd\")] {\n        use libc::c_int;\n\n        libc_bitflags!{\n            /// Configuration options for [`sendfile`.](fn.sendfile.html)\n            pub struct SfFlags: c_int {\n                /// Causes `sendfile` to return EBUSY instead of blocking when attempting to read a\n                /// busy page.\n                SF_NODISKIO;\n                /// Causes `sendfile` to sleep until the network stack releases its reference to the\n                /// VM pages read. When `sendfile` returns, the data is not guaranteed to have been\n                /// sent, but it is safe to modify the file.\n                SF_SYNC;\n                /// Causes `sendfile` to cache exactly the number of pages specified in the\n                /// `readahead` parameter, disabling caching heuristics.\n                SF_USER_READAHEAD;\n                /// Causes `sendfile` not to cache the data read.\n                SF_NOCACHE;\n            }\n        }\n\n        /// Read up to `count` bytes from `in_fd` starting at `offset` and write to `out_sock`.\n        ///\n        /// Returns a `Result` and a count of bytes written. Bytes written may be non-zero even if\n        /// an error occurs.\n        ///\n        /// `in_fd` must describe a regular file or shared memory object. `out_sock` must describe a\n        /// stream socket.\n        ///\n        /// If `offset` falls past the end of the file, the function returns success and zero bytes\n        /// written.\n        ///\n        /// If `count` is `None` or 0, bytes will be read from `in_fd` until reaching the end of\n        /// file (EOF).\n        ///\n        /// `headers` and `trailers` specify optional slices of byte slices to be sent before and\n        /// after the data read from `in_fd`, respectively. The length of headers and trailers sent\n        /// is included in the returned count of bytes written. The values of `offset` and `count`\n        /// do not apply to headers or trailers.\n        ///\n        /// `readahead` specifies the minimum number of pages to cache in memory ahead of the page\n        /// currently being sent.\n        ///\n        /// For more information, see\n        /// [the sendfile(2) man page.](https://www.freebsd.org/cgi/man.cgi?query=sendfile\u0026sektion=2)\n        #[allow(clippy::too_many_arguments)]\n        pub fn sendfile\u003cF1: AsFd, F2: AsFd\u003e(\n            in_fd: F1,\n            out_sock: F2,\n            offset: off_t,\n            count: Option\u003cusize\u003e,\n            headers: Option\u003c\u0026[\u0026[u8]]\u003e,\n            trailers: Option\u003c\u0026[\u0026[u8]]\u003e,\n            flags: SfFlags,\n            readahead: u16\n        ) -\u003e (Result\u003c()\u003e, off_t) {\n            // Readahead goes in upper 16 bits\n            // Flags goes in lower 16 bits\n            // see `man 2 sendfile`\n            let ra32 = u32::from(readahead);\n            let flags: u32 = (ra32 \u003c\u003c 16) | (flags.bits() as u32);\n            let mut bytes_sent: off_t = 0;\n            let hdtr = headers.or(trailers).map(|_| SendfileHeaderTrailer::new(headers, trailers));\n            let hdtr_ptr = hdtr.as_ref().map_or(ptr::null(), |s| \u0026s.raw as *const libc::sf_hdtr);\n            let return_code = unsafe {\n                libc::sendfile(in_fd.as_fd().as_raw_fd(),\n                               out_sock.as_fd().as_raw_fd(),\n                               offset,\n                               count.unwrap_or(0),\n                               hdtr_ptr as *mut libc::sf_hdtr,\n                               \u0026mut bytes_sent as *mut off_t,\n                               flags as c_int)\n            };\n            (Errno::result(return_code).and(Ok(())), bytes_sent)\n        }\n    } else if #[cfg(target_os = \"dragonfly\")] {\n        /// Read up to `count` bytes from `in_fd` starting at `offset` and write to `out_sock`.\n        ///\n        /// Returns a `Result` and a count of bytes written. Bytes written may be non-zero even if\n        /// an error occurs.\n        ///\n        /// `in_fd` must describe a regular file. `out_sock` must describe a stream socket.\n        ///\n        /// If `offset` falls past the end of the file, the function returns success and zero bytes\n        /// written.\n        ///\n        /// If `count` is `None` or 0, bytes will be read from `in_fd` until reaching the end of\n        /// file (EOF).\n        ///\n        /// `headers` and `trailers` specify optional slices of byte slices to be sent before and\n        /// after the data read from `in_fd`, respectively. The length of headers and trailers sent\n        /// is included in the returned count of bytes written. The values of `offset` and `count`\n        /// do not apply to headers or trailers.\n        ///\n        /// For more information, see\n        /// [the sendfile(2) man page.](https://leaf.dragonflybsd.org/cgi/web-man?command=sendfile\u0026section=2)\n        pub fn sendfile\u003cF1: AsFd, F2: AsFd\u003e(\n            in_fd: F1,\n            out_sock: F2,\n            offset: off_t,\n            count: Option\u003cusize\u003e,\n            headers: Option\u003c\u0026[\u0026[u8]]\u003e,\n            trailers: Option\u003c\u0026[\u0026[u8]]\u003e,\n        ) -\u003e (Result\u003c()\u003e, off_t) {\n            let mut bytes_sent: off_t = 0;\n            let hdtr = headers.or(trailers).map(|_| SendfileHeaderTrailer::new(headers, trailers));\n            let hdtr_ptr = hdtr.as_ref().map_or(ptr::null(), |s| \u0026s.raw as *const libc::sf_hdtr);\n            let return_code = unsafe {\n                libc::sendfile(in_fd.as_fd().as_raw_fd(),\n                               out_sock.as_fd().as_raw_fd(),\n                               offset,\n                               count.unwrap_or(0),\n                               hdtr_ptr as *mut libc::sf_hdtr,\n                               \u0026mut bytes_sent as *mut off_t,\n                               0)\n            };\n            (Errno::result(return_code).and(Ok(())), bytes_sent)\n        }\n    } else if #[cfg(apple_targets)] {\n        /// Read bytes from `in_fd` starting at `offset` and write up to `count` bytes to\n        /// `out_sock`.\n        ///\n        /// Returns a `Result` and a count of bytes written. Bytes written may be non-zero even if\n        /// an error occurs.\n        ///\n        /// `in_fd` must describe a regular file. `out_sock` must describe a stream socket.\n        ///\n        /// If `offset` falls past the end of the file, the function returns success and zero bytes\n        /// written.\n        ///\n        /// If `count` is `None` or 0, bytes will be read from `in_fd` until reaching the end of\n        /// file (EOF).\n        ///\n        /// `hdtr` specifies an optional list of headers and trailers to be sent before and after\n        /// the data read from `in_fd`, respectively. The length of headers and trailers sent is\n        /// included in the returned count of bytes written. If any headers are specified and\n        /// `count` is non-zero, the length of the headers will be counted in the limit of total\n        /// bytes sent. Trailers do not count toward the limit of bytes sent and will always be sent\n        /// regardless. The value of `offset` does not affect headers or trailers.\n        ///\n        /// For more information, see\n        /// [the sendfile(2) man page.](https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man2/sendfile.2.html)\n        pub fn sendfile\u003cF1: AsFd, F2: AsFd\u003e(\n            in_fd: F1,\n            out_sock: F2,\n            offset: off_t,\n            count: Option\u003coff_t\u003e,\n            headers: Option\u003c\u0026[\u0026[u8]]\u003e,\n            trailers: Option\u003c\u0026[\u0026[u8]]\u003e\n        ) -\u003e (Result\u003c()\u003e, off_t) {\n            let mut len = count.unwrap_or(0);\n            let hdtr = headers.or(trailers).map(|_| SendfileHeaderTrailer::new(headers, trailers));\n            let hdtr_ptr = hdtr.as_ref().map_or(ptr::null(), |s| \u0026s.raw as *const libc::sf_hdtr);\n            let return_code = unsafe {\n                libc::sendfile(in_fd.as_fd().as_raw_fd(),\n                               out_sock.as_fd().as_raw_fd(),\n                               offset,\n                               \u0026mut len as *mut off_t,\n                               hdtr_ptr as *mut libc::sf_hdtr,\n                               0)\n            };\n            (Errno::result(return_code).and(Ok(())), len)\n        }\n    } else if #[cfg(solarish)] {\n        /// Write data from the vec arrays to `out_sock` and returns a `Result` and a\n        /// count of bytes written.\n        ///\n        /// Each `SendfileVec` set needs to be instantiated either with `SendfileVec::new` or\n        /// `SendfileVec::newself`.\n        ///\n        /// The former allows to send data from a file descriptor through `fd`,\n        ///  from an offset `off` and for a given amount of data `len`.\n        ///\n        /// The latter allows to send data from the process's address space, from an offset `off`\n        /// and for a given amount of data `len`.\n        ///\n        /// For more information, see\n        /// [the sendfilev(3) man page.](https://illumos.org/man/3EXT/sendfilev)\n        pub fn sendfilev\u003cF: AsFd\u003e(\n            out_sock: F,\n            vec: \u0026[SendfileVec]\n        ) -\u003e (Result\u003c()\u003e, usize) {\n            let mut len = 0usize;\n            let return_code = unsafe {\n                libc::sendfilev(out_sock.as_fd().as_raw_fd(), vec.as_ptr() as *const libc::sendfilevec_t, vec.len() as i32, \u0026mut len)\n            };\n            (Errno::result(return_code).and(Ok(())), len)\n        }\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":16},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","signal.rs"],"content":"//! Operating system signals.\n\nuse crate::errno::Errno;\nuse crate::{Error, Result};\nuse cfg_if::cfg_if;\nuse std::fmt;\nuse std::hash::{Hash, Hasher};\nuse std::mem;\nuse std::ops::BitOr;\nuse std::ptr;\nuse std::str::FromStr;\n\n#[cfg(not(any(\n    target_os = \"fuchsia\",\n    target_os = \"hurd\",\n    target_os = \"openbsd\",\n    target_os = \"redox\"\n)))]\n#[cfg(any(feature = \"aio\", feature = \"signal\"))]\npub use self::sigevent::*;\n\n#[cfg(any(feature = \"aio\", feature = \"process\", feature = \"signal\"))]\nlibc_enum! {\n    /// Types of operating system signals\n    // Currently there is only one definition of c_int in libc, as well as only one\n    // type for signal constants.\n    // We would prefer to use the libc::c_int alias in the repr attribute. Unfortunately\n    // this is not (yet) possible.\n    #[repr(i32)]\n    #[non_exhaustive]\n    #[cfg_attr(docsrs, doc(cfg(any(feature = \"aio\", feature = \"signal\"))))]\n    pub enum Signal {\n        /// Hangup\n        SIGHUP,\n        /// Interrupt\n        SIGINT,\n        /// Quit\n        SIGQUIT,\n        /// Illegal instruction (not reset when caught)\n        SIGILL,\n        /// Trace trap (not reset when caught)\n        SIGTRAP,\n        /// Abort\n        SIGABRT,\n        /// Bus error\n        SIGBUS,\n        /// Floating point exception\n        SIGFPE,\n        /// Kill (cannot be caught or ignored)\n        SIGKILL,\n        /// User defined signal 1\n        SIGUSR1,\n        /// Segmentation violation\n        SIGSEGV,\n        /// User defined signal 2\n        SIGUSR2,\n        /// Write on a pipe with no one to read it\n        SIGPIPE,\n        /// Alarm clock\n        SIGALRM,\n        /// Software termination signal from kill\n        SIGTERM,\n        /// Stack fault (obsolete)\n        #[cfg(all(any(linux_android, target_os = \"emscripten\",\n                      target_os = \"fuchsia\"),\n                  not(any(target_arch = \"mips\",\n                          target_arch = \"mips32r6\",\n                          target_arch = \"mips64\",\n                          target_arch = \"mips64r6\",\n                          target_arch = \"sparc\",\n                          target_arch = \"sparc64\"))))]\n        SIGSTKFLT,\n        /// To parent on child stop or exit\n        SIGCHLD,\n        /// Continue a stopped process\n        SIGCONT,\n        /// Sendable stop signal not from tty\n        SIGSTOP,\n        /// Stop signal from tty\n        SIGTSTP,\n        /// To readers pgrp upon background tty read\n        SIGTTIN,\n        /// Like TTIN if (tp-\u003et_local\u0026LTOSTOP)\n        SIGTTOU,\n        /// Urgent condition on IO channel\n        SIGURG,\n        /// Exceeded CPU time limit\n        SIGXCPU,\n        /// Exceeded file size limit\n        SIGXFSZ,\n        /// Virtual time alarm\n        SIGVTALRM,\n        /// Profiling time alarm\n        SIGPROF,\n        /// Window size changes\n        SIGWINCH,\n        /// Input/output possible signal\n        #[cfg(not(target_os = \"haiku\"))]\n        SIGIO,\n        #[cfg(any(linux_android, target_os = \"emscripten\",\n                  target_os = \"fuchsia\", target_os = \"aix\"))]\n        /// Power failure imminent.\n        SIGPWR,\n        /// Bad system call\n        SIGSYS,\n        #[cfg(not(any(linux_android, target_os = \"emscripten\",\n                      target_os = \"fuchsia\",\n                      target_os = \"redox\", target_os = \"haiku\")))]\n        /// Emulator trap\n        SIGEMT,\n        #[cfg(not(any(linux_android, target_os = \"emscripten\",\n                      target_os = \"fuchsia\", target_os = \"redox\",\n                      target_os = \"haiku\", target_os = \"aix\",\n                      target_os = \"solaris\", target_os = \"cygwin\")))]\n        /// Information request\n        SIGINFO,\n    }\n    impl TryFrom\u003ci32\u003e\n}\n\n#[cfg(feature = \"signal\")]\nimpl FromStr for Signal {\n    type Err = Error;\n    fn from_str(s: \u0026str) -\u003e Result\u003cSignal\u003e {\n        Ok(match s {\n            \"SIGHUP\" =\u003e Signal::SIGHUP,\n            \"SIGINT\" =\u003e Signal::SIGINT,\n            \"SIGQUIT\" =\u003e Signal::SIGQUIT,\n            \"SIGILL\" =\u003e Signal::SIGILL,\n            \"SIGTRAP\" =\u003e Signal::SIGTRAP,\n            \"SIGABRT\" =\u003e Signal::SIGABRT,\n            \"SIGBUS\" =\u003e Signal::SIGBUS,\n            \"SIGFPE\" =\u003e Signal::SIGFPE,\n            \"SIGKILL\" =\u003e Signal::SIGKILL,\n            \"SIGUSR1\" =\u003e Signal::SIGUSR1,\n            \"SIGSEGV\" =\u003e Signal::SIGSEGV,\n            \"SIGUSR2\" =\u003e Signal::SIGUSR2,\n            \"SIGPIPE\" =\u003e Signal::SIGPIPE,\n            \"SIGALRM\" =\u003e Signal::SIGALRM,\n            \"SIGTERM\" =\u003e Signal::SIGTERM,\n            #[cfg(all(\n                any(\n                    linux_android,\n                    target_os = \"emscripten\",\n                    target_os = \"fuchsia\",\n                ),\n                not(any(\n                    target_arch = \"mips\",\n                    target_arch = \"mips32r6\",\n                    target_arch = \"mips64\",\n                    target_arch = \"mips64r6\",\n                    target_arch = \"sparc\",\n                    target_arch = \"sparc64\"\n                ))\n            ))]\n            \"SIGSTKFLT\" =\u003e Signal::SIGSTKFLT,\n            \"SIGCHLD\" =\u003e Signal::SIGCHLD,\n            \"SIGCONT\" =\u003e Signal::SIGCONT,\n            \"SIGSTOP\" =\u003e Signal::SIGSTOP,\n            \"SIGTSTP\" =\u003e Signal::SIGTSTP,\n            \"SIGTTIN\" =\u003e Signal::SIGTTIN,\n            \"SIGTTOU\" =\u003e Signal::SIGTTOU,\n            \"SIGURG\" =\u003e Signal::SIGURG,\n            \"SIGXCPU\" =\u003e Signal::SIGXCPU,\n            \"SIGXFSZ\" =\u003e Signal::SIGXFSZ,\n            \"SIGVTALRM\" =\u003e Signal::SIGVTALRM,\n            \"SIGPROF\" =\u003e Signal::SIGPROF,\n            \"SIGWINCH\" =\u003e Signal::SIGWINCH,\n            #[cfg(not(target_os = \"haiku\"))]\n            \"SIGIO\" =\u003e Signal::SIGIO,\n            #[cfg(any(\n                linux_android,\n                target_os = \"emscripten\",\n                target_os = \"fuchsia\",\n            ))]\n            \"SIGPWR\" =\u003e Signal::SIGPWR,\n            \"SIGSYS\" =\u003e Signal::SIGSYS,\n            #[cfg(not(any(\n                linux_android,\n                target_os = \"emscripten\",\n                target_os = \"fuchsia\",\n                target_os = \"redox\",\n                target_os = \"haiku\"\n            )))]\n            \"SIGEMT\" =\u003e Signal::SIGEMT,\n            #[cfg(not(any(\n                linux_android,\n                target_os = \"emscripten\",\n                target_os = \"fuchsia\",\n                target_os = \"redox\",\n                target_os = \"aix\",\n                target_os = \"haiku\",\n                target_os = \"solaris\",\n                target_os = \"cygwin\"\n            )))]\n            \"SIGINFO\" =\u003e Signal::SIGINFO,\n            _ =\u003e return Err(Errno::EINVAL),\n        })\n    }\n}\n\n#[cfg(feature = \"signal\")]\nimpl Signal {\n    /// Returns name of signal.\n    ///\n    /// This function is equivalent to `\u003cSignal as AsRef\u003cstr\u003e\u003e::as_ref()`,\n    /// with difference that returned string is `'static`\n    /// and not bound to `self`'s lifetime.\n    pub const fn as_str(self) -\u003e \u0026'static str {\n        match self {\n            Signal::SIGHUP =\u003e \"SIGHUP\",\n            Signal::SIGINT =\u003e \"SIGINT\",\n            Signal::SIGQUIT =\u003e \"SIGQUIT\",\n            Signal::SIGILL =\u003e \"SIGILL\",\n            Signal::SIGTRAP =\u003e \"SIGTRAP\",\n            Signal::SIGABRT =\u003e \"SIGABRT\",\n            Signal::SIGBUS =\u003e \"SIGBUS\",\n            Signal::SIGFPE =\u003e \"SIGFPE\",\n            Signal::SIGKILL =\u003e \"SIGKILL\",\n            Signal::SIGUSR1 =\u003e \"SIGUSR1\",\n            Signal::SIGSEGV =\u003e \"SIGSEGV\",\n            Signal::SIGUSR2 =\u003e \"SIGUSR2\",\n            Signal::SIGPIPE =\u003e \"SIGPIPE\",\n            Signal::SIGALRM =\u003e \"SIGALRM\",\n            Signal::SIGTERM =\u003e \"SIGTERM\",\n            #[cfg(all(\n                any(\n                    linux_android,\n                    target_os = \"emscripten\",\n                    target_os = \"fuchsia\",\n                ),\n                not(any(\n                    target_arch = \"mips\",\n                    target_arch = \"mips32r6\",\n                    target_arch = \"mips64\",\n                    target_arch = \"mips64r6\",\n                    target_arch = \"sparc\",\n                    target_arch = \"sparc64\"\n                ))\n            ))]\n            Signal::SIGSTKFLT =\u003e \"SIGSTKFLT\",\n            Signal::SIGCHLD =\u003e \"SIGCHLD\",\n            Signal::SIGCONT =\u003e \"SIGCONT\",\n            Signal::SIGSTOP =\u003e \"SIGSTOP\",\n            Signal::SIGTSTP =\u003e \"SIGTSTP\",\n            Signal::SIGTTIN =\u003e \"SIGTTIN\",\n            Signal::SIGTTOU =\u003e \"SIGTTOU\",\n            Signal::SIGURG =\u003e \"SIGURG\",\n            Signal::SIGXCPU =\u003e \"SIGXCPU\",\n            Signal::SIGXFSZ =\u003e \"SIGXFSZ\",\n            Signal::SIGVTALRM =\u003e \"SIGVTALRM\",\n            Signal::SIGPROF =\u003e \"SIGPROF\",\n            Signal::SIGWINCH =\u003e \"SIGWINCH\",\n            #[cfg(not(target_os = \"haiku\"))]\n            Signal::SIGIO =\u003e \"SIGIO\",\n            #[cfg(any(\n                linux_android,\n                target_os = \"emscripten\",\n                target_os = \"fuchsia\",\n                target_os = \"aix\",\n            ))]\n            Signal::SIGPWR =\u003e \"SIGPWR\",\n            Signal::SIGSYS =\u003e \"SIGSYS\",\n            #[cfg(not(any(\n                linux_android,\n                target_os = \"emscripten\",\n                target_os = \"fuchsia\",\n                target_os = \"redox\",\n                target_os = \"haiku\"\n            )))]\n            Signal::SIGEMT =\u003e \"SIGEMT\",\n            #[cfg(not(any(\n                linux_android,\n                target_os = \"emscripten\",\n                target_os = \"fuchsia\",\n                target_os = \"redox\",\n                target_os = \"aix\",\n                target_os = \"haiku\",\n                target_os = \"solaris\",\n                target_os = \"cygwin\"\n            )))]\n            Signal::SIGINFO =\u003e \"SIGINFO\",\n        }\n    }\n}\n\n#[cfg(feature = \"signal\")]\nimpl AsRef\u003cstr\u003e for Signal {\n    fn as_ref(\u0026self) -\u003e \u0026str {\n        self.as_str()\n    }\n}\n\n#[cfg(feature = \"signal\")]\nimpl fmt::Display for Signal {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        f.write_str(self.as_ref())\n    }\n}\n\n#[cfg(feature = \"signal\")]\npub use self::Signal::*;\n\n#[cfg(target_os = \"redox\")]\n#[cfg(feature = \"signal\")]\nconst SIGNALS: [Signal; 29] = [\n    SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGBUS, SIGFPE, SIGKILL,\n    SIGUSR1, SIGSEGV, SIGUSR2, SIGPIPE, SIGALRM, SIGTERM, SIGCHLD, SIGCONT,\n    SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM,\n    SIGPROF, SIGWINCH, SIGIO, SIGSYS,\n];\n#[cfg(target_os = \"haiku\")]\n#[cfg(feature = \"signal\")]\nconst SIGNALS: [Signal; 28] = [\n    SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGBUS, SIGFPE, SIGKILL,\n    SIGUSR1, SIGSEGV, SIGUSR2, SIGPIPE, SIGALRM, SIGTERM, SIGCHLD, SIGCONT,\n    SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM,\n    SIGPROF, SIGWINCH, SIGSYS,\n];\n#[cfg(all(\n    any(linux_android, target_os = \"emscripten\", target_os = \"fuchsia\"),\n    not(any(\n        target_arch = \"mips\",\n        target_arch = \"mips32r6\",\n        target_arch = \"mips64\",\n        target_arch = \"mips64r6\",\n        target_arch = \"sparc\",\n        target_arch = \"sparc64\"\n    ))\n))]\n#[cfg(feature = \"signal\")]\nconst SIGNALS: [Signal; 31] = [\n    SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGBUS, SIGFPE, SIGKILL,\n    SIGUSR1, SIGSEGV, SIGUSR2, SIGPIPE, SIGALRM, SIGTERM, SIGSTKFLT, SIGCHLD,\n    SIGCONT, SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU, SIGURG, SIGXCPU, SIGXFSZ,\n    SIGVTALRM, SIGPROF, SIGWINCH, SIGIO, SIGPWR, SIGSYS,\n];\n#[cfg(all(\n    any(linux_android, target_os = \"emscripten\", target_os = \"fuchsia\"),\n    any(\n        target_arch = \"mips\",\n        target_arch = \"mips32r6\",\n        target_arch = \"mips64\",\n        target_arch = \"mips64r6\",\n        target_arch = \"sparc\",\n        target_arch = \"sparc64\"\n    )\n))]\n#[cfg(feature = \"signal\")]\nconst SIGNALS: [Signal; 30] = [\n    SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGBUS, SIGFPE, SIGKILL,\n    SIGUSR1, SIGSEGV, SIGUSR2, SIGPIPE, SIGALRM, SIGTERM, SIGCHLD, SIGCONT,\n    SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM,\n    SIGPROF, SIGWINCH, SIGIO, SIGPWR, SIGSYS,\n];\n#[cfg(target_os = \"aix\")]\n#[cfg(feature = \"signal\")]\nconst SIGNALS: [Signal; 30] = [\n    SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGABRT, SIGEMT, SIGFPE, SIGKILL, SIGSEGV,\n    SIGSYS, SIGPIPE, SIGALRM, SIGTERM, SIGUSR1, SIGUSR2, SIGPWR, SIGWINCH,\n    SIGURG, SIGPOLL, SIGIO, SIGSTOP, SIGTSTP, SIGCONT, SIGTTIN, SIGTTOU,\n    SIGVTALRM, SIGPROF, SIGXCPU, SIGXFSZ, SIGTRAP,\n];\n#[cfg(any(target_os = \"solaris\", target_os = \"cygwin\"))]\n#[cfg(feature = \"signal\")]\nconst SIGNALS: [Signal; 30] = [\n    SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGBUS, SIGFPE, SIGKILL,\n    SIGUSR1, SIGSEGV, SIGUSR2, SIGPIPE, SIGALRM, SIGTERM, SIGCHLD, SIGCONT,\n    SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM,\n    SIGPROF, SIGWINCH, SIGIO, SIGSYS, SIGEMT,\n];\n#[cfg(not(any(\n    linux_android,\n    target_os = \"fuchsia\",\n    target_os = \"emscripten\",\n    target_os = \"aix\",\n    target_os = \"redox\",\n    target_os = \"haiku\",\n    target_os = \"solaris\",\n    target_os = \"cygwin\"\n)))]\n#[cfg(feature = \"signal\")]\nconst SIGNALS: [Signal; 31] = [\n    SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGBUS, SIGFPE, SIGKILL,\n    SIGUSR1, SIGSEGV, SIGUSR2, SIGPIPE, SIGALRM, SIGTERM, SIGCHLD, SIGCONT,\n    SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM,\n    SIGPROF, SIGWINCH, SIGIO, SIGSYS, SIGEMT, SIGINFO,\n];\n\nfeature! {\n#![feature = \"signal\"]\n\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\n/// Iterate through all signals defined by this operating system\npub struct SignalIterator {\n    next: usize,\n}\n\nimpl Iterator for SignalIterator {\n    type Item = Signal;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSignal\u003e {\n        if self.next \u003c SIGNALS.len() {\n            let next_signal = SIGNALS[self.next];\n            self.next += 1;\n            Some(next_signal)\n        } else {\n            None\n        }\n    }\n}\n\nimpl Signal {\n    /// Iterate through all signals defined by this OS\n    pub const fn iterator() -\u003e SignalIterator {\n        SignalIterator{next: 0}\n    }\n}\n\n/// Alias for [`SIGABRT`]\npub const SIGIOT : Signal = SIGABRT;\n/// Alias for [`SIGIO`]\n#[cfg(not(target_os = \"haiku\"))]\npub const SIGPOLL : Signal = SIGIO;\n/// Alias for [`SIGSYS`]\npub const SIGUNUSED : Signal = SIGSYS;\n\ncfg_if! {\n    if #[cfg(target_os = \"redox\")] {\n        type SaFlags_t = libc::c_ulong;\n    } else if #[cfg(target_env = \"uclibc\")] {\n        type SaFlags_t = libc::c_ulong;\n    } else {\n        type SaFlags_t = libc::c_int;\n    }\n}\n}\n\n#[cfg(feature = \"signal\")]\nlibc_bitflags! {\n    /// Controls the behavior of a [`SigAction`]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"signal\")))]\n    pub struct SaFlags: SaFlags_t {\n        /// When catching a [`Signal::SIGCHLD`] signal, the signal will be\n        /// generated only when a child process exits, not when a child process\n        /// stops.\n        SA_NOCLDSTOP;\n        /// When catching a [`Signal::SIGCHLD`] signal, the system will not\n        /// create zombie processes when children of the calling process exit.\n        #[cfg(not(target_os = \"hurd\"))]\n        SA_NOCLDWAIT;\n        /// Further occurrences of the delivered signal are not masked during\n        /// the execution of the handler.\n        SA_NODEFER;\n        /// The system will deliver the signal to the process on a signal stack,\n        /// specified by each thread with sigaltstack(2).\n        SA_ONSTACK;\n        /// The handler is reset back to the default at the moment the signal is\n        /// delivered.\n        SA_RESETHAND;\n        /// Requests that certain system calls restart if interrupted by this\n        /// signal.  See the man page for complete details.\n        SA_RESTART;\n        /// This flag is controlled internally by Nix.\n        SA_SIGINFO;\n    }\n}\n\n#[cfg(feature = \"signal\")]\nlibc_enum! {\n    /// Specifies how certain functions should manipulate a signal mask\n    #[repr(i32)]\n    #[non_exhaustive]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"signal\")))]\n    pub enum SigmaskHow {\n        /// The new mask is the union of the current mask and the specified set.\n        SIG_BLOCK,\n        /// The new mask is the intersection of the current mask and the\n        /// complement of the specified set.\n        SIG_UNBLOCK,\n        /// The current mask is replaced by the specified set.\n        SIG_SETMASK,\n    }\n}\n\nfeature! {\n#![feature = \"signal\"]\n\nuse crate::unistd::Pid;\nuse std::iter::Extend;\nuse std::iter::FromIterator;\nuse std::iter::IntoIterator;\n\n/// Specifies a set of [`Signal`]s that may be blocked, waited for, etc.\n// We are using `transparent` here to be super sure that `SigSet`\n// is represented exactly like the `sigset_t` struct from C.\n#[repr(transparent)]\n#[derive(Clone, Copy, Debug, Eq)]\npub struct SigSet {\n    sigset: libc::sigset_t\n}\n\nimpl SigSet {\n    /// Initialize to include all signals.\n    #[doc(alias(\"sigfillset\"))]\n    pub fn all() -\u003e SigSet {\n        let mut sigset = mem::MaybeUninit::uninit();\n        let _ = unsafe { libc::sigfillset(sigset.as_mut_ptr()) };\n\n        unsafe{ SigSet { sigset: sigset.assume_init() } }\n    }\n\n    /// Initialize to include nothing.\n    #[doc(alias(\"sigemptyset\"))]\n    pub fn empty() -\u003e SigSet {\n        let mut sigset = mem::MaybeUninit::uninit();\n        let _ = unsafe { libc::sigemptyset(sigset.as_mut_ptr()) };\n\n        unsafe{ SigSet { sigset: sigset.assume_init() } }\n    }\n\n    /// Add the specified signal to the set.\n    #[doc(alias(\"sigaddset\"))]\n    pub fn add(\u0026mut self, signal: Signal) {\n        unsafe { libc::sigaddset(\u0026mut self.sigset as *mut libc::sigset_t, signal as libc::c_int) };\n    }\n\n    /// Remove all signals from this set.\n    #[doc(alias(\"sigemptyset\"))]\n    pub fn clear(\u0026mut self) {\n        unsafe { libc::sigemptyset(\u0026mut self.sigset as *mut libc::sigset_t) };\n    }\n\n    /// Remove the specified signal from this set.\n    #[doc(alias(\"sigdelset\"))]\n    pub fn remove(\u0026mut self, signal: Signal) {\n        unsafe { libc::sigdelset(\u0026mut self.sigset as *mut libc::sigset_t, signal as libc::c_int) };\n    }\n\n    /// Return whether this set includes the specified signal.\n    #[doc(alias(\"sigismember\"))]\n    pub fn contains(\u0026self, signal: Signal) -\u003e bool {\n        let res = unsafe { libc::sigismember(\u0026self.sigset as *const libc::sigset_t, signal as libc::c_int) };\n\n        match res {\n            1 =\u003e true,\n            0 =\u003e false,\n            _ =\u003e unreachable!(\"unexpected value from sigismember\"),\n        }\n    }\n\n    /// Returns an iterator that yields the signals contained in this set.\n    pub fn iter(\u0026self) -\u003e SigSetIter\u003c'_\u003e {\n        self.into_iter()\n    }\n\n    /// Gets the currently blocked (masked) set of signals for the calling thread.\n    pub fn thread_get_mask() -\u003e Result\u003cSigSet\u003e {\n        let mut oldmask = mem::MaybeUninit::uninit();\n        do_pthread_sigmask(SigmaskHow::SIG_SETMASK, None, Some(oldmask.as_mut_ptr()))?;\n        Ok(unsafe{ SigSet{sigset: oldmask.assume_init()}})\n    }\n\n    /// Sets the set of signals as the signal mask for the calling thread.\n    pub fn thread_set_mask(\u0026self) -\u003e Result\u003c()\u003e {\n        pthread_sigmask(SigmaskHow::SIG_SETMASK, Some(self), None)\n    }\n\n    /// Adds the set of signals to the signal mask for the calling thread.\n    pub fn thread_block(\u0026self) -\u003e Result\u003c()\u003e {\n        pthread_sigmask(SigmaskHow::SIG_BLOCK, Some(self), None)\n    }\n\n    /// Removes the set of signals from the signal mask for the calling thread.\n    pub fn thread_unblock(\u0026self) -\u003e Result\u003c()\u003e {\n        pthread_sigmask(SigmaskHow::SIG_UNBLOCK, Some(self), None)\n    }\n\n    /// Sets the set of signals as the signal mask, and returns the old mask.\n    pub fn thread_swap_mask(\u0026self, how: SigmaskHow) -\u003e Result\u003cSigSet\u003e {\n        let mut oldmask = mem::MaybeUninit::uninit();\n        do_pthread_sigmask(how, Some(self), Some(oldmask.as_mut_ptr()))?;\n        Ok(unsafe{ SigSet{sigset: oldmask.assume_init()}})\n    }\n\n    /// Suspends execution of the calling thread until one of the signals in the\n    /// signal mask becomes pending, and returns the accepted signal.\n    #[cfg(not(target_os = \"redox\"))] // RedoxFS does not yet support sigwait\n    pub fn wait(\u0026self) -\u003e Result\u003cSignal\u003e {\n        use std::convert::TryFrom;\n\n        let mut signum = mem::MaybeUninit::uninit();\n        let res = unsafe { libc::sigwait(\u0026self.sigset as *const libc::sigset_t, signum.as_mut_ptr()) };\n\n        Errno::result(res).map(|_| unsafe {\n            Signal::try_from(signum.assume_init()).unwrap()\n        })\n    }\n\n    /// Wait for a signal\n    ///\n    /// # Return value\n    /// If `sigsuspend(2)` is interrupted (EINTR), this function returns `Ok`.\n    /// If `sigsuspend(2)` set other error, this function returns `Err`.\n    ///\n    /// For more information see the\n    /// [`sigsuspend(2)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/sigsuspend.html).\n    #[cfg(any(\n        bsd,\n        linux_android,\n        solarish,\n        target_os = \"haiku\",\n        target_os = \"hurd\",\n        target_os = \"aix\",\n        target_os = \"fuchsia\"\n    ))]\n    #[doc(alias(\"sigsuspend\"))]\n    pub fn suspend(\u0026self) -\u003e Result\u003c()\u003e {\n        let res = unsafe {\n            libc::sigsuspend(\u0026self.sigset as *const libc::sigset_t)\n        };\n        match Errno::result(res).map(drop) {\n            Err(Errno::EINTR) =\u003e Ok(()),\n            Err(e) =\u003e Err(e),\n            Ok(_) =\u003e unreachable!(\"because this syscall always returns -1 if returns\"),\n        }\n    }\n\n    /// Converts a `libc::sigset_t` object to a [`SigSet`] without checking  whether the\n    /// `libc::sigset_t` is already initialized.\n    ///\n    /// # Safety\n    ///\n    /// The `sigset` passed in must be a valid an initialized `libc::sigset_t` by calling either\n    /// [`sigemptyset(3)`](https://man7.org/linux/man-pages/man3/sigemptyset.3p.html) or\n    /// [`sigfillset(3)`](https://man7.org/linux/man-pages/man3/sigfillset.3p.html).\n    /// Otherwise, the results are undefined.\n    pub unsafe fn from_sigset_t_unchecked(sigset: libc::sigset_t) -\u003e SigSet {\n        SigSet { sigset }\n    }\n}\n\nimpl From\u003cSignal\u003e for SigSet {\n    fn from(signal: Signal) -\u003e SigSet {\n        let mut sigset = SigSet::empty();\n        sigset.add(signal);\n        sigset\n    }\n}\n\nimpl BitOr for Signal {\n    type Output = SigSet;\n\n    fn bitor(self, rhs: Self) -\u003e Self::Output {\n        let mut sigset = SigSet::empty();\n        sigset.add(self);\n        sigset.add(rhs);\n        sigset\n    }\n}\n\nimpl BitOr\u003cSignal\u003e for SigSet {\n    type Output = SigSet;\n\n    fn bitor(mut self, rhs: Signal) -\u003e Self::Output {\n        self.add(rhs);\n        self\n    }\n}\n\nimpl BitOr for SigSet {\n    type Output = Self;\n\n    fn bitor(self, rhs: Self) -\u003e Self::Output {\n        self.iter().chain(rhs.iter()).collect()\n    }\n}\n\nimpl AsRef\u003clibc::sigset_t\u003e for SigSet {\n    fn as_ref(\u0026self) -\u003e \u0026libc::sigset_t {\n        \u0026self.sigset\n    }\n}\n\n// TODO: Consider specialization for the case where T is \u0026SigSet and libc::sigorset is available.\nimpl Extend\u003cSignal\u003e for SigSet {\n    fn extend\u003cT\u003e(\u0026mut self, iter: T)\n    where T: IntoIterator\u003cItem = Signal\u003e {\n        for signal in iter {\n            self.add(signal);\n        }\n    }\n}\n\nimpl FromIterator\u003cSignal\u003e for SigSet {\n    fn from_iter\u003cT\u003e(iter: T) -\u003e Self\n    where T: IntoIterator\u003cItem = Signal\u003e {\n        let mut sigset = SigSet::empty();\n        sigset.extend(iter);\n        sigset\n    }\n}\n\nimpl PartialEq for SigSet {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        for signal in Signal::iterator() {\n            if self.contains(signal) != other.contains(signal) {\n                return false;\n            }\n        }\n        true\n    }\n}\n\nimpl Hash for SigSet {\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\n        for signal in Signal::iterator() {\n            if self.contains(signal) {\n                signal.hash(state);\n            }\n        }\n    }\n}\n\n/// Iterator for a [`SigSet`].\n///\n/// Call [`SigSet::iter`] to create an iterator.\n#[derive(Clone, Debug)]\npub struct SigSetIter\u003c'a\u003e {\n    sigset: \u0026'a SigSet,\n    inner: SignalIterator,\n}\n\nimpl Iterator for SigSetIter\u003c'_\u003e {\n    type Item = Signal;\n    fn next(\u0026mut self) -\u003e Option\u003cSignal\u003e {\n        loop {\n            match self.inner.next() {\n                None =\u003e return None,\n                Some(signal) if self.sigset.contains(signal) =\u003e return Some(signal),\n                Some(_signal) =\u003e continue,\n            }\n        }\n    }\n}\n\nimpl\u003c'a\u003e IntoIterator for \u0026'a SigSet {\n    type Item = Signal;\n    type IntoIter = SigSetIter\u003c'a\u003e;\n    fn into_iter(self) -\u003e Self::IntoIter {\n        SigSetIter { sigset: self, inner: Signal::iterator() }\n    }\n}\n\n/// A signal handler.\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub enum SigHandler {\n    /// Default signal handling.\n    SigDfl,\n    /// Request that the signal be ignored.\n    SigIgn,\n    /// Use the given signal-catching function, which takes in the signal.\n    Handler(extern \"C\" fn(libc::c_int)),\n    /// Use the given signal-catching function, which takes in the signal, information about how\n    /// the signal was generated, and a pointer to the threads `ucontext_t`.\n    #[cfg(not(target_os = \"redox\"))]\n    SigAction(extern \"C\" fn(libc::c_int, *mut libc::siginfo_t, *mut libc::c_void))\n}\n\n/// Action to take on receipt of a signal. Corresponds to `sigaction`.\n#[repr(transparent)]\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct SigAction {\n    sigaction: libc::sigaction\n}\n\nimpl From\u003cSigAction\u003e for libc::sigaction {\n    fn from(value: SigAction) -\u003e libc::sigaction {\n        value.sigaction\n    }\n}\n\nimpl SigAction {\n    /// Creates a new action.\n    ///\n    /// The `SA_SIGINFO` bit in the `flags` argument is ignored (it will be set only if `handler`\n    /// is the `SigAction` variant). `mask` specifies other signals to block during execution of\n    /// the signal-catching function.\n    pub fn new(handler: SigHandler, flags: SaFlags, mask: SigSet) -\u003e SigAction {\n        unsafe fn install_sig(p: *mut libc::sigaction, handler: SigHandler) {\n            unsafe {\n                 (*p).sa_sigaction = match handler {\n                    SigHandler::SigDfl =\u003e libc::SIG_DFL,\n                    SigHandler::SigIgn =\u003e libc::SIG_IGN,\n                    SigHandler::Handler(f) =\u003e f as *const extern \"C\" fn(libc::c_int) as usize,\n                    #[cfg(not(target_os = \"redox\"))]\n                    SigHandler::SigAction(f) =\u003e f as *const extern \"C\" fn(libc::c_int, *mut libc::siginfo_t, *mut libc::c_void) as usize,\n                };\n            }\n        }\n\n        let mut s = mem::MaybeUninit::\u003clibc::sigaction\u003e::uninit();\n        unsafe {\n            let p = s.as_mut_ptr();\n            install_sig(p, handler);\n            (*p).sa_flags = match handler {\n                #[cfg(not(target_os = \"redox\"))]\n                SigHandler::SigAction(_) =\u003e (flags | SaFlags::SA_SIGINFO).bits(),\n                _ =\u003e (flags - SaFlags::SA_SIGINFO).bits(),\n            };\n            (*p).sa_mask = mask.sigset;\n\n            SigAction { sigaction: s.assume_init() }\n        }\n    }\n\n    /// Returns the flags set on the action.\n    pub fn flags(\u0026self) -\u003e SaFlags {\n        SaFlags::from_bits_truncate(self.sigaction.sa_flags)\n    }\n\n    /// Returns the set of signals that are blocked during execution of the action's\n    /// signal-catching function.\n    pub fn mask(\u0026self) -\u003e SigSet {\n        SigSet { sigset: self.sigaction.sa_mask }\n    }\n\n    /// Returns the action's handler.\n    pub fn handler(\u0026self) -\u003e SigHandler {\n        match self.sigaction.sa_sigaction {\n            libc::SIG_DFL =\u003e SigHandler::SigDfl,\n            libc::SIG_IGN =\u003e SigHandler::SigIgn,\n            #[cfg(not(target_os = \"redox\"))]\n            p if self.flags().contains(SaFlags::SA_SIGINFO) =\u003e\n                SigHandler::SigAction(\n                // Safe for one of two reasons:\n                // * The SigHandler was created by SigHandler::new, in which\n                //   case the pointer is correct, or\n                // * The SigHandler was created by signal or sigaction, which\n                //   are unsafe functions, so the caller should've somehow\n                //   ensured that it is correctly initialized.\n                unsafe{\n                    *(\u0026p as *const usize\n                         as *const extern \"C\" fn(_, _, _))\n                }\n                as extern \"C\" fn(_, _, _)),\n            p =\u003e SigHandler::Handler(\n                // Safe for one of two reasons:\n                // * The SigHandler was created by SigHandler::new, in which\n                //   case the pointer is correct, or\n                // * The SigHandler was created by signal or sigaction, which\n                //   are unsafe functions, so the caller should've somehow\n                //   ensured that it is correctly initialized.\n                unsafe{\n                    *(\u0026p as *const usize\n                         as *const extern \"C\" fn(libc::c_int))\n                }\n                as extern \"C\" fn(libc::c_int)),\n        }\n    }\n}\n\n/// Changes the action taken by a process on receipt of a specific signal.\n///\n/// `signal` can be any signal except `SIGKILL` or `SIGSTOP`. On success, it returns the previous\n/// action for the given signal. If `sigaction` fails, no new signal handler is installed.\n///\n/// # Safety\n///\n/// * Signal handlers may be called at any point during execution, which limits\n///   what is safe to do in the body of the signal-catching function. Be certain\n///   to only make syscalls that are explicitly marked safe for signal handlers\n///   and only share global data using atomics.\n///\n/// * There is also no guarantee that the old signal handler was installed\n///   correctly.  If it was installed by this crate, it will be.  But if it was\n///   installed by, for example, C code, then there is no guarantee its function\n///   pointer is valid.  In that case, this function effectively dereferences a\n///   raw pointer of unknown provenance.\npub unsafe fn sigaction(signal: Signal, sigaction: \u0026SigAction) -\u003e Result\u003cSigAction\u003e {\n    let mut oldact = mem::MaybeUninit::\u003clibc::sigaction\u003e::uninit();\n\n    let res = unsafe { libc::sigaction(signal as libc::c_int,\n                              \u0026sigaction.sigaction as *const libc::sigaction,\n                              oldact.as_mut_ptr()) };\n\n    Errno::result(res).map(|_| SigAction { sigaction: unsafe { oldact.assume_init() } })\n}\n\n/// Signal management (see [signal(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/signal.html))\n///\n/// Installs `handler` for the given `signal`, returning the previous signal\n/// handler. `signal` should only be used following another call to `signal` or\n/// if the current handler is the default. The return value of `signal` is\n/// undefined after setting the handler with [`sigaction`][SigActionFn].\n///\n/// # Safety\n///\n/// If the pointer to the previous signal handler is invalid, undefined\n/// behavior could be invoked when casting it back to a [`SigAction`][SigActionStruct].\n///\n/// # Examples\n///\n/// Ignore `SIGINT`:\n///\n/// ```no_run\n/// # use nix::sys::signal::{self, Signal, SigHandler};\n/// unsafe { signal::signal(Signal::SIGINT, SigHandler::SigIgn) }.unwrap();\n/// ```\n///\n/// Use a signal handler to set a flag variable:\n///\n/// ```no_run\n/// # use std::convert::TryFrom;\n/// # use std::sync::atomic::{AtomicBool, Ordering};\n/// # use nix::sys::signal::{self, Signal, SigHandler};\n/// static SIGNALED: AtomicBool = AtomicBool::new(false);\n///\n/// extern \"C\" fn handle_sigint(signal: libc::c_int) {\n///     let signal = Signal::try_from(signal).unwrap();\n///     SIGNALED.store(signal == Signal::SIGINT, Ordering::Relaxed);\n/// }\n///\n/// fn main() {\n///     let handler = SigHandler::Handler(handle_sigint);\n///     unsafe { signal::signal(Signal::SIGINT, handler) }.unwrap();\n/// }\n/// ```\n///\n/// # Errors\n///\n/// Returns [`Error(Errno::EOPNOTSUPP)`] if `handler` is\n/// [`SigAction`][SigActionStruct]. Use [`sigaction`][SigActionFn] instead.\n///\n/// `signal` also returns any error from `libc::signal`, such as when an attempt\n/// is made to catch a signal that cannot be caught or to ignore a signal that\n/// cannot be ignored.\n///\n/// [`Error::UnsupportedOperation`]: ../../enum.Error.html#variant.UnsupportedOperation\n/// [SigActionStruct]: struct.SigAction.html\n/// [sigactionFn]: fn.sigaction.html\npub unsafe fn signal(signal: Signal, handler: SigHandler) -\u003e Result\u003cSigHandler\u003e {\n    let signal = signal as libc::c_int;\n    let res = match handler {\n        SigHandler::SigDfl =\u003e unsafe { libc::signal(signal, libc::SIG_DFL) },\n        SigHandler::SigIgn =\u003e unsafe { libc::signal(signal, libc::SIG_IGN) },\n        SigHandler::Handler(handler) =\u003e unsafe { libc::signal(signal, handler as libc::sighandler_t) },\n        #[cfg(not(target_os = \"redox\"))]\n        SigHandler::SigAction(_) =\u003e return Err(Errno::ENOTSUP),\n    };\n    Errno::result(res).map(|oldhandler| {\n        match oldhandler {\n            libc::SIG_DFL =\u003e SigHandler::SigDfl,\n            libc::SIG_IGN =\u003e SigHandler::SigIgn,\n            p =\u003e SigHandler::Handler(\n                unsafe { *(\u0026p as *const usize as *const extern \"C\" fn(libc::c_int)) } as extern \"C\" fn(libc::c_int)),\n        }\n    })\n}\n\nfn do_pthread_sigmask(how: SigmaskHow,\n                       set: Option\u003c\u0026SigSet\u003e,\n                       oldset: Option\u003c*mut libc::sigset_t\u003e) -\u003e Result\u003c()\u003e {\n    if set.is_none() \u0026\u0026 oldset.is_none() {\n        return Ok(())\n    }\n\n    let res = unsafe {\n        // if set or oldset is None, pass in null pointers instead\n        libc::pthread_sigmask(how as libc::c_int,\n                             set.map_or_else(ptr::null::\u003clibc::sigset_t\u003e,\n                                             |s| \u0026s.sigset as *const libc::sigset_t),\n                             oldset.unwrap_or(ptr::null_mut())\n                             )\n    };\n\n    Errno::result(res).map(drop)\n}\n\n/// Manages the signal mask (set of blocked signals) for the calling thread.\n///\n/// If the `set` parameter is `Some(..)`, then the signal mask will be updated with the signal set.\n/// The `how` flag decides the type of update. If `set` is `None`, `how` will be ignored,\n/// and no modification will take place.\n///\n/// If the 'oldset' parameter is `Some(..)` then the current signal mask will be written into it.\n///\n/// If both `set` and `oldset` is `Some(..)`, the current signal mask will be written into oldset,\n/// and then it will be updated with `set`.\n///\n/// If both `set` and `oldset` is None, this function is a no-op.\n///\n/// For more information, visit the [`pthread_sigmask`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_sigmask.html),\n/// or [`sigprocmask`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/sigprocmask.html) man pages.\npub fn pthread_sigmask(how: SigmaskHow,\n                       set: Option\u003c\u0026SigSet\u003e,\n                       oldset: Option\u003c\u0026mut SigSet\u003e) -\u003e Result\u003c()\u003e\n{\n    do_pthread_sigmask(how, set, oldset.map(|os| \u0026mut os.sigset as *mut _ ))\n}\n\n/// Examine and change blocked signals.\n///\n/// For more information see the [`sigprocmask` man\n/// pages](https://pubs.opengroup.org/onlinepubs/9699919799/functions/sigprocmask.html).\npub fn sigprocmask(how: SigmaskHow, set: Option\u003c\u0026SigSet\u003e, oldset: Option\u003c\u0026mut SigSet\u003e) -\u003e Result\u003c()\u003e {\n    if set.is_none() \u0026\u0026 oldset.is_none() {\n        return Ok(())\n    }\n\n    let res = unsafe {\n        // if set or oldset is None, pass in null pointers instead\n        libc::sigprocmask(how as libc::c_int,\n                          set.map_or_else(ptr::null::\u003clibc::sigset_t\u003e,\n                                          |s| \u0026s.sigset as *const libc::sigset_t),\n                          oldset.map_or_else(ptr::null_mut::\u003clibc::sigset_t\u003e,\n                                             |os| \u0026mut os.sigset as *mut libc::sigset_t))\n    };\n\n    Errno::result(res).map(drop)\n}\n\n/// Send a signal to a process\n///\n/// # Arguments\n///\n/// * `pid` -    Specifies which processes should receive the signal.\n///   - If positive, specifies an individual process.\n///   - If zero, the signal will be sent to all processes whose group\n///     ID is equal to the process group ID of the sender.  This is a\n#[cfg_attr(target_os = \"fuchsia\", doc = \"variant of `killpg`.\")]\n#[cfg_attr(not(target_os = \"fuchsia\"), doc = \"variant of [`killpg`].\")]\n///   - If `-1` and the process has super-user privileges, the signal\n///     is sent to all processes exclusing system processes.\n///   - If less than `-1`, the signal is sent to all processes whose\n///     process group ID is equal to the absolute value of `pid`.\n/// * `signal` - Signal to send. If `None`, error checking is performed\n///              but no signal is actually sent.\n///\n/// See Also\n/// [`kill(2)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/kill.html)\npub fn kill\u003cT: Into\u003cOption\u003cSignal\u003e\u003e\u003e(pid: Pid, signal: T) -\u003e Result\u003c()\u003e {\n    let res = unsafe { libc::kill(pid.into(),\n                                  match signal.into() {\n                                      Some(s) =\u003e s as libc::c_int,\n                                      None =\u003e 0,\n                                  }) };\n\n    Errno::result(res).map(drop)\n}\n\n/// Send a signal to a process group\n///\n/// # Arguments\n///\n/// * `pgrp` -   Process group to signal.  If less then or equal 1, the behavior\n///              is platform-specific.\n/// * `signal` - Signal to send. If `None`, `killpg` will only preform error\n///              checking and won't send any signal.\n///\n/// See Also [killpg(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/killpg.html).\n#[cfg(not(target_os = \"fuchsia\"))]\npub fn killpg\u003cT: Into\u003cOption\u003cSignal\u003e\u003e\u003e(pgrp: Pid, signal: T) -\u003e Result\u003c()\u003e {\n    let res = unsafe { libc::killpg(pgrp.into(),\n                                  match signal.into() {\n                                      Some(s) =\u003e s as libc::c_int,\n                                      None =\u003e 0,\n                                  }) };\n\n    Errno::result(res).map(drop)\n}\n\n/// Send a signal to the current thread\n///\n/// See Also [raise(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/raise.html)\npub fn raise(signal: Signal) -\u003e Result\u003c()\u003e {\n    let res = unsafe { libc::raise(signal as libc::c_int) };\n\n    Errno::result(res).map(drop)\n}\n}\n\nfeature! {\n#![any(feature = \"aio\", feature = \"signal\")]\n\n/// Identifies a thread for [`SigevNotify::SigevThreadId`]\n#[cfg(target_os = \"freebsd\")]\npub type type_of_thread_id = libc::lwpid_t;\n/// Identifies a thread for [`SigevNotify::SigevThreadId`]\n#[cfg(all(not(target_os = \"hurd\"), any(target_env = \"gnu\", target_env = \"uclibc\")))]\npub type type_of_thread_id = libc::pid_t;\n\n/// Specifies the notification method used by a [`SigEvent`]\n// sigval is actually a union of a int and a void*.  But it's never really used\n// as a pointer, because neither libc nor the kernel ever dereference it.  nix\n// therefore presents it as an intptr_t, which is how kevent uses it.\n#[cfg(not(any(target_os = \"fuchsia\", target_os = \"hurd\", target_os = \"openbsd\", target_os = \"redox\")))]\n#[derive(Clone, Copy, Debug)]\npub enum SigevNotify\u003c'fd\u003e {\n    /// No notification will be delivered\n    SigevNone,\n    /// Notify by delivering a signal to the process.\n    SigevSignal {\n        /// Signal to deliver\n        signal: Signal,\n        /// Will be present in the `si_value` field of the [`libc::siginfo_t`]\n        /// structure of the queued signal.\n        si_value: libc::intptr_t\n    },\n    // Note: SIGEV_THREAD is not implemented, but could be if desired.\n    /// Notify by delivering an event to a kqueue.\n    #[cfg(freebsdlike)]\n    SigevKevent {\n        /// File descriptor of the kqueue to notify.\n        kq: std::os::fd::BorrowedFd\u003c'fd\u003e,\n        /// Will be contained in the kevent's `udata` field.\n        udata: libc::intptr_t\n    },\n    /// Notify by delivering an event to a kqueue, with optional event flags set\n    #[cfg(target_os = \"freebsd\")]\n    #[cfg(feature = \"event\")]\n    SigevKeventFlags {\n        /// File descriptor of the kqueue to notify.\n        kq: std::os::fd::BorrowedFd\u003c'fd\u003e,\n        /// Will be contained in the kevent's `udata` field.\n        udata: libc::intptr_t,\n        /// Flags that will be set on the delivered event.  See `kevent(2)`.\n        flags: crate::sys::event::EvFlags\n    },\n    /// Notify by delivering a signal to a thread.\n    #[cfg(any(\n            target_os = \"freebsd\",\n            target_env = \"gnu\",\n            target_env = \"uclibc\",\n    ))]\n    SigevThreadId {\n        /// Signal to send\n        signal: Signal,\n        /// LWP ID of the thread to notify\n        thread_id: type_of_thread_id,\n        /// Will be present in the `si_value` field of the [`libc::siginfo_t`]\n        /// structure of the queued signal.\n        si_value: libc::intptr_t\n    },\n    /// A helper variant to resolve the unused parameter (`'fd`) problem on\n    /// platforms other than FreeBSD and DragonFlyBSD.\n    ///\n    /// This variant can never be constructed due to the usage of an enum with 0\n    /// variants.\n    #[doc(hidden)]\n    #[cfg(not(freebsdlike))]\n    _Unreachable(\u0026'fd std::convert::Infallible),\n}\n}\n\n#[cfg(not(any(\n    target_os = \"fuchsia\",\n    target_os = \"hurd\",\n    target_os = \"openbsd\",\n    target_os = \"redox\"\n)))]\nmod sigevent {\n    feature! {\n    #![any(feature = \"aio\", feature = \"signal\")]\n\n    use std::mem;\n    use super::SigevNotify;\n\n    #[cfg(target_os = \"freebsd\")]\n    pub(crate) use ffi::sigevent as libc_sigevent;\n    #[cfg(not(target_os = \"freebsd\"))]\n    pub(crate) use libc::sigevent as libc_sigevent;\n\n    // For FreeBSD only, we define the C structure here.  Because the structure\n    // defined in libc isn't correct.  The real sigevent contains union fields,\n    // but libc could not represent those when sigevent was originally added, so\n    // instead libc simply defined the most useful field.  Now that Rust can\n    // represent unions, there's a PR to libc to fix it.  However, it's stuck\n    // forever due to backwards compatibility concerns.  Even though there's a\n    // workaround, libc refuses to merge it.  I think it's just too complicated\n    // for them to want to think about right now, because that project is\n    // short-staffed.  So we define it here instead, so we won't have to wait on\n    // libc.\n    // https://github.com/rust-lang/libc/pull/2813\n    #[cfg(target_os = \"freebsd\")]\n    mod ffi {\n        use std::{fmt, hash};\n\n        #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\n        #[repr(C)]\n        pub struct __c_anonymous_sigev_thread {\n            pub _function: *mut libc::c_void,   // Actually a function pointer\n            pub _attribute: *mut libc::pthread_attr_t,\n        }\n        #[derive(Clone, Copy)]\n        // This will never be used on its own, and its parent has a Debug impl,\n        // so it doesn't need one.\n        #[allow(missing_debug_implementations)]\n        #[repr(C)]\n        pub union __c_anonymous_sigev_un {\n            pub _threadid: libc::__lwpid_t,\n            pub _sigev_thread: __c_anonymous_sigev_thread,\n            pub _kevent_flags: libc::c_ushort,\n            __spare__: [libc::c_long; 8],\n        }\n\n        #[derive(Clone, Copy)]\n        #[repr(C)]\n        pub struct sigevent {\n            pub sigev_notify: libc::c_int,\n            pub sigev_signo: libc::c_int,\n            pub sigev_value: libc::sigval,\n            pub _sigev_un: __c_anonymous_sigev_un,\n        }\n\n        impl fmt::Debug for sigevent {\n            fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n                let mut ds = f.debug_struct(\"sigevent\");\n                ds.field(\"sigev_notify\", \u0026self.sigev_notify)\n                    .field(\"sigev_signo\", \u0026self.sigev_signo)\n                    .field(\"sigev_value\", \u0026self.sigev_value);\n                // Safe because we check the sigev_notify discriminant\n                unsafe {\n                    match self.sigev_notify {\n                        libc::SIGEV_KEVENT =\u003e {\n                            ds.field(\"sigev_notify_kevent_flags\", \u0026self._sigev_un._kevent_flags);\n                        }\n                        libc::SIGEV_THREAD_ID =\u003e {\n                            ds.field(\"sigev_notify_thread_id\", \u0026self._sigev_un._threadid);\n                        }\n                        libc::SIGEV_THREAD =\u003e {\n                            ds.field(\"sigev_notify_function\", \u0026self._sigev_un._sigev_thread._function);\n                            ds.field(\"sigev_notify_attributes\", \u0026self._sigev_un._sigev_thread._attribute);\n                        }\n                        _ =\u003e ()\n                    };\n                }\n                ds.finish()\n            }\n        }\n\n        impl PartialEq for sigevent {\n            fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n                let mut equals = self.sigev_notify == other.sigev_notify;\n                equals \u0026= self.sigev_signo == other.sigev_signo;\n                equals \u0026= self.sigev_value == other.sigev_value;\n                // Safe because we check the sigev_notify discriminant\n                unsafe {\n                    match self.sigev_notify {\n                        libc::SIGEV_KEVENT =\u003e {\n                            equals \u0026= self._sigev_un._kevent_flags == other._sigev_un._kevent_flags;\n                        }\n                        libc::SIGEV_THREAD_ID =\u003e {\n                            equals \u0026= self._sigev_un._threadid == other._sigev_un._threadid;\n                        }\n                        libc::SIGEV_THREAD =\u003e {\n                            equals \u0026= self._sigev_un._sigev_thread == other._sigev_un._sigev_thread;\n                        }\n                        _ =\u003e /* The union field is don't care */ ()\n                    }\n                }\n                equals\n            }\n        }\n\n        impl Eq for sigevent {}\n\n        impl hash::Hash for sigevent {\n            fn hash\u003cH: hash::Hasher\u003e(\u0026self, s: \u0026mut H) {\n                self.sigev_notify.hash(s);\n                self.sigev_signo.hash(s);\n                self.sigev_value.hash(s);\n                // Safe because we check the sigev_notify discriminant\n                unsafe {\n                    match self.sigev_notify {\n                        libc::SIGEV_KEVENT =\u003e {\n                            self._sigev_un._kevent_flags.hash(s);\n                        }\n                        libc::SIGEV_THREAD_ID =\u003e {\n                            self._sigev_un._threadid.hash(s);\n                        }\n                        libc::SIGEV_THREAD =\u003e {\n                            self._sigev_un._sigev_thread.hash(s);\n                        }\n                        _ =\u003e /* The union field is don't care */ ()\n                    }\n                }\n            }\n        }\n    }\n\n    /// Used to request asynchronous notification of the completion of certain\n    /// events, such as POSIX AIO and timers.\n    #[repr(C)]\n    #[derive(Clone, Debug, Eq, Hash, PartialEq)]\n    // It can't be Copy on all platforms.\n    #[allow(missing_copy_implementations)]\n    pub struct SigEvent {\n        sigevent: libc_sigevent\n    }\n\n    impl SigEvent {\n        /// **Note:** this constructor does not allow the user to set the\n        /// `sigev_notify_kevent_flags` field.  That's considered ok because on FreeBSD\n        /// at least those flags don't do anything useful.  That field is part of a\n        /// union that shares space with the more genuinely useful fields.\n        ///\n        /// **Note:** This constructor also doesn't allow the caller to set the\n        /// `sigev_notify_function` or `sigev_notify_attributes` fields, which are\n        /// required for `SIGEV_THREAD`.  That's considered ok because on no operating\n        /// system is `SIGEV_THREAD` the most efficient way to deliver AIO\n        /// notification.  FreeBSD and DragonFly BSD programs should prefer `SIGEV_KEVENT`.\n        /// Linux, Solaris, and portable programs should prefer `SIGEV_THREAD_ID` or\n        /// `SIGEV_SIGNAL`.  That field is part of a union that shares space with the\n        /// more genuinely useful `sigev_notify_thread_id`\n        pub fn new(sigev_notify: SigevNotify) -\u003e SigEvent {\n            let mut sev: libc_sigevent = unsafe { mem::zeroed() };\n            match sigev_notify {\n                SigevNotify::SigevNone =\u003e {\n                    sev.sigev_notify = libc::SIGEV_NONE;\n                },\n                SigevNotify::SigevSignal{signal, si_value} =\u003e {\n                    sev.sigev_notify = libc::SIGEV_SIGNAL;\n                    sev.sigev_signo = signal as libc::c_int;\n                    sev.sigev_value.sival_ptr = si_value as *mut libc::c_void\n                },\n                #[cfg(freebsdlike)]\n                SigevNotify::SigevKevent{kq, udata} =\u003e {\n                    use std::os::fd::AsRawFd;\n\n                    sev.sigev_notify = libc::SIGEV_KEVENT;\n                    sev.sigev_signo = kq.as_raw_fd();\n                    sev.sigev_value.sival_ptr = udata as *mut libc::c_void;\n                },\n                #[cfg(target_os = \"freebsd\")]\n                #[cfg(feature = \"event\")]\n                SigevNotify::SigevKeventFlags{kq, udata, flags} =\u003e {\n                    use std::os::fd::AsRawFd;\n\n                    sev.sigev_notify = libc::SIGEV_KEVENT;\n                    sev.sigev_signo = kq.as_raw_fd();\n                    sev.sigev_value.sival_ptr = udata as *mut libc::c_void;\n                    sev._sigev_un._kevent_flags = flags.bits();\n                },\n                #[cfg(target_os = \"freebsd\")]\n                SigevNotify::SigevThreadId{signal, thread_id, si_value} =\u003e {\n                    sev.sigev_notify = libc::SIGEV_THREAD_ID;\n                    sev.sigev_signo = signal as libc::c_int;\n                    sev.sigev_value.sival_ptr = si_value as *mut libc::c_void;\n                    sev._sigev_un._threadid = thread_id;\n                }\n                #[cfg(any(target_env = \"gnu\", target_env = \"uclibc\"))]\n                SigevNotify::SigevThreadId{signal, thread_id, si_value} =\u003e {\n                    sev.sigev_notify = libc::SIGEV_THREAD_ID;\n                    sev.sigev_signo = signal as libc::c_int;\n                    sev.sigev_value.sival_ptr = si_value as *mut libc::c_void;\n                    sev.sigev_notify_thread_id = thread_id;\n                }\n                #[cfg(not(freebsdlike))]\n                SigevNotify::_Unreachable(_) =\u003e unreachable!(\"This variant could never be constructed\")\n            }\n            SigEvent{sigevent: sev}\n        }\n\n        /// Return a copy of the inner structure\n        #[cfg(target_os = \"freebsd\")]\n        pub fn sigevent(\u0026self) -\u003e libc::sigevent {\n            // Safe because they're really the same structure.  See\n            // https://github.com/rust-lang/libc/pull/2813\n            unsafe {\n                mem::transmute::\u003clibc_sigevent, libc::sigevent\u003e(self.sigevent)\n            }\n        }\n\n        /// Return a copy of the inner structure\n        #[cfg(not(target_os = \"freebsd\"))]\n        pub fn sigevent(\u0026self) -\u003e libc::sigevent {\n            self.sigevent\n        }\n\n        /// Returns a mutable pointer to the `sigevent` wrapped by `self`\n        #[cfg(target_os = \"freebsd\")]\n        pub fn as_mut_ptr(\u0026mut self) -\u003e *mut libc::sigevent {\n            // Safe because they're really the same structure.  See\n            // https://github.com/rust-lang/libc/pull/2813\n            \u0026mut self.sigevent as *mut libc_sigevent as *mut libc::sigevent\n        }\n\n        /// Returns a mutable pointer to the `sigevent` wrapped by `self`\n        #[cfg(not(target_os = \"freebsd\"))]\n        pub fn as_mut_ptr(\u0026mut self) -\u003e *mut libc::sigevent {\n            \u0026mut self.sigevent\n        }\n    }\n\n    impl From\u003c\u0026'_ libc::sigevent\u003e for SigEvent {\n        #[cfg(target_os = \"freebsd\")]\n        fn from(sigevent: \u0026libc::sigevent) -\u003e Self {\n            // Safe because they're really the same structure.  See\n            // https://github.com/rust-lang/libc/pull/2813\n            let sigevent = unsafe {\n                mem::transmute::\u003clibc::sigevent, libc_sigevent\u003e(*sigevent)\n            };\n            SigEvent{ sigevent }\n        }\n        #[cfg(not(target_os = \"freebsd\"))]\n        fn from(sigevent: \u0026libc::sigevent) -\u003e Self {\n            SigEvent{ sigevent: *sigevent }\n        }\n    }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","signalfd.rs"],"content":"//! Interface for the `signalfd` syscall.\n//!\n//! # Signal discarding\n//! When a signal can't be delivered to a process (or thread), it will become a pending signal.\n//! Failure to deliver could happen if the signal is blocked by every thread in the process or if\n//! the signal handler is still handling a previous signal.\n//!\n//! If a signal is sent to a process (or thread) that already has a pending signal of the same\n//! type, it will be discarded. This means that if signals of the same type are received faster than\n//! they are processed, some of those signals will be dropped. Because of this limitation,\n//! `signalfd` in itself cannot be used for reliable communication between processes or threads.\n//!\n//! Once the signal is unblocked, or the signal handler is finished, and a signal is still pending\n//! (ie. not consumed from a signalfd) it will be delivered to the signal handler.\n//!\n//! Please note that signal discarding is not specific to `signalfd`, but also happens with regular\n//! signal handlers.\nuse crate::errno::Errno;\npub use crate::sys::signal::{self, SigSet};\nuse crate::Result;\n\n/// Information of a received signal, the return type of [`SignalFd::read_signal()`].\npub use libc::signalfd_siginfo as siginfo;\n\nuse std::mem;\nuse std::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, OwnedFd, RawFd};\n\nlibc_bitflags! {\n    pub struct SfdFlags: libc::c_int {\n        SFD_NONBLOCK;\n        SFD_CLOEXEC;\n    }\n}\n\n#[deprecated(since = \"0.23.0\", note = \"use mem::size_of::\u003csiginfo\u003e() instead\")]\npub const SIGNALFD_SIGINFO_SIZE: usize = mem::size_of::\u003csiginfo\u003e();\n\n/// Creates a new file descriptor for reading signals.\n///\n/// **Important:** please read the module level documentation about signal discarding before using\n/// this function!\n///\n/// The `mask` parameter specifies the set of signals that can be accepted via this file descriptor.\n///\n/// A signal must be blocked on every thread in a process, otherwise it won't be visible from\n/// signalfd (the default handler will be invoked instead).\n///\n/// See [the signalfd man page for more information](https://man7.org/linux/man-pages/man2/signalfd.2.html)\n#[deprecated(since = \"0.27.0\", note = \"Use SignalFd instead\")]\npub fn signalfd\u003cF: AsFd\u003e(\n    fd: Option\u003cF\u003e,\n    mask: \u0026SigSet,\n    flags: SfdFlags,\n) -\u003e Result\u003cOwnedFd\u003e {\n    _signalfd(fd, mask, flags)\n}\n\nfn _signalfd\u003cF: AsFd\u003e(\n    fd: Option\u003cF\u003e,\n    mask: \u0026SigSet,\n    flags: SfdFlags,\n) -\u003e Result\u003cOwnedFd\u003e {\n    let raw_fd = fd.map_or(-1, |x| x.as_fd().as_raw_fd());\n    unsafe {\n        Errno::result(libc::signalfd(raw_fd, mask.as_ref(), flags.bits()))\n            .map(|raw_fd| FromRawFd::from_raw_fd(raw_fd))\n    }\n}\n\n/// A helper struct for creating, reading and closing a `signalfd` instance.\n///\n/// **Important:** please read the module level documentation about signal discarding before using\n/// this struct!\n///\n/// # Examples\n///\n/// ```\n/// # use nix::sys::signalfd::*;\n/// // Set the thread to block the SIGUSR1 signal, otherwise the default handler will be used\n/// let mut mask = SigSet::empty();\n/// mask.add(signal::SIGUSR1);\n/// mask.thread_block().unwrap();\n///\n/// // Signals are queued up on the file descriptor\n/// let mut sfd = SignalFd::with_flags(\u0026mask, SfdFlags::SFD_NONBLOCK).unwrap();\n///\n/// match sfd.read_signal() {\n///     // we caught a signal\n///     Ok(Some(sig)) =\u003e (),\n///     // there were no signals waiting (only happens when the SFD_NONBLOCK flag is set,\n///     // otherwise the read_signal call blocks)\n///     Ok(None) =\u003e (),\n///     Err(err) =\u003e (), // some error happend\n/// }\n/// ```\n#[derive(Debug)]\npub struct SignalFd(OwnedFd);\n\nimpl SignalFd {\n    pub fn new(mask: \u0026SigSet) -\u003e Result\u003cSignalFd\u003e {\n        Self::with_flags(mask, SfdFlags::empty())\n    }\n\n    pub fn with_flags(mask: \u0026SigSet, flags: SfdFlags) -\u003e Result\u003cSignalFd\u003e {\n        let fd = _signalfd(None::\u003cOwnedFd\u003e, mask, flags)?;\n\n        Ok(SignalFd(fd))\n    }\n\n    pub fn set_mask(\u0026self, mask: \u0026SigSet) -\u003e Result\u003c()\u003e {\n        self.update(mask, SfdFlags::empty())\n    }\n\n    pub fn read_signal(\u0026self) -\u003e Result\u003cOption\u003csiginfo\u003e\u003e {\n        let mut buffer = mem::MaybeUninit::\u003csiginfo\u003e::uninit();\n\n        let size = mem::size_of_val(\u0026buffer);\n        let res = Errno::result(unsafe {\n            libc::read(self.0.as_raw_fd(), buffer.as_mut_ptr().cast(), size)\n        })\n        .map(|r| r as usize);\n        match res {\n            Ok(x) if x == size =\u003e Ok(Some(unsafe { buffer.assume_init() })),\n            Ok(_) =\u003e unreachable!(\"partial read on signalfd\"),\n            Err(Errno::EAGAIN) =\u003e Ok(None),\n            Err(error) =\u003e Err(error),\n        }\n    }\n\n    /// Constructs a `SignalFd` wrapping an existing `OwnedFd`.\n    ///\n    /// # Safety\n    ///\n    /// `OwnedFd` is a valid `SignalFd`.\n    pub unsafe fn from_owned_fd(fd: OwnedFd) -\u003e Self {\n        Self(fd)\n    }\n\n    fn update(\u0026self, mask: \u0026SigSet, flags: SfdFlags) -\u003e Result\u003c()\u003e {\n        let raw_fd = self.0.as_raw_fd();\n        unsafe {\n            Errno::result(libc::signalfd(raw_fd, mask.as_ref(), flags.bits()))\n                .map(drop)\n        }\n    }\n}\n\nimpl AsFd for SignalFd {\n    fn as_fd(\u0026self) -\u003e BorrowedFd {\n        self.0.as_fd()\n    }\n}\nimpl AsRawFd for SignalFd {\n    fn as_raw_fd(\u0026self) -\u003e RawFd {\n        self.0.as_raw_fd()\n    }\n}\n\nimpl From\u003cSignalFd\u003e for OwnedFd {\n    fn from(value: SignalFd) -\u003e Self {\n        value.0 \n    }\n}\n\nimpl Iterator for SignalFd {\n    type Item = siginfo;\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        match self.read_signal() {\n            Ok(Some(sig)) =\u003e Some(sig),\n            Ok(None) | Err(_) =\u003e None,\n        }\n    }\n}\n","traces":[{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","socket","addr.rs"],"content":"#[cfg(any(\n    bsd,\n    linux_android,\n    solarish,\n    target_os = \"haiku\",\n    target_os = \"fuchsia\",\n    target_os = \"aix\",\n))]\n#[cfg(feature = \"net\")]\npub use self::datalink::LinkAddr;\n#[cfg(any(linux_android, apple_targets))]\npub use self::vsock::VsockAddr;\nuse super::sa_family_t;\nuse crate::errno::Errno;\n#[cfg(linux_android)]\nuse crate::sys::socket::addr::alg::AlgAddr;\n#[cfg(linux_android)]\nuse crate::sys::socket::addr::netlink::NetlinkAddr;\n#[cfg(all(feature = \"ioctl\", apple_targets))]\nuse crate::sys::socket::addr::sys_control::SysControlAddr;\nuse crate::{NixPath, Result};\nuse cfg_if::cfg_if;\nuse memoffset::offset_of;\nuse std::convert::TryInto;\nuse std::ffi::OsStr;\nuse std::hash::{Hash, Hasher};\nuse std::net::{Ipv4Addr, Ipv6Addr};\nuse std::os::unix::ffi::OsStrExt;\nuse std::path::Path;\nuse std::{fmt, mem, net, ptr, slice};\n\n/// Convert a std::net::Ipv4Addr into the libc form.\n#[cfg(feature = \"net\")]\npub(crate) const fn ipv4addr_to_libc(addr: net::Ipv4Addr) -\u003e libc::in_addr {\n    libc::in_addr {\n        s_addr: u32::from_ne_bytes(addr.octets()),\n    }\n}\n\n/// Convert a std::net::Ipv6Addr into the libc form.\n#[cfg(feature = \"net\")]\npub(crate) const fn ipv6addr_to_libc(addr: \u0026net::Ipv6Addr) -\u003e libc::in6_addr {\n    libc::in6_addr {\n        s6_addr: addr.octets(),\n    }\n}\n\n/// These constants specify the protocol family to be used\n/// in [`socket`](fn.socket.html) and [`socketpair`](fn.socketpair.html)\n///\n/// # References\n///\n/// [address_families(7)](https://man7.org/linux/man-pages/man7/address_families.7.html)\n// Should this be u8?\n#[repr(i32)]\n#[non_exhaustive]\n#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\npub enum AddressFamily {\n    /// Local communication (see [`unix(7)`](https://man7.org/linux/man-pages/man7/unix.7.html))\n    Unix = libc::AF_UNIX,\n    /// IPv4 Internet protocols (see [`ip(7)`](https://man7.org/linux/man-pages/man7/ip.7.html))\n    Inet = libc::AF_INET,\n    /// IPv6 Internet protocols (see [`ipv6(7)`](https://man7.org/linux/man-pages/man7/ipv6.7.html))\n    Inet6 = libc::AF_INET6,\n    /// Kernel user interface device (see [`netlink(7)`](https://man7.org/linux/man-pages/man7/netlink.7.html))\n    #[cfg(linux_android)]\n    Netlink = libc::AF_NETLINK,\n    /// Kernel interface for interacting with the routing table\n    #[cfg(not(any(linux_android, target_os = \"redox\", target_os = \"cygwin\")))]\n    Route = libc::PF_ROUTE,\n    /// Low level packet interface (see [`packet(7)`](https://man7.org/linux/man-pages/man7/packet.7.html))\n    #[cfg(any(linux_android, solarish, target_os = \"fuchsia\"))]\n    Packet = libc::AF_PACKET,\n    /// KEXT Controls and Notifications\n    #[cfg(apple_targets)]\n    System = libc::AF_SYSTEM,\n    /// Amateur radio AX.25 protocol\n    #[cfg(linux_android)]\n    Ax25 = libc::AF_AX25,\n    /// IPX - Novell protocols\n    #[cfg(not(any(target_os = \"aix\", target_os = \"redox\", target_os = \"cygwin\")))]\n    Ipx = libc::AF_IPX,\n    /// AppleTalk\n    #[cfg(not(target_os = \"redox\"))]\n    AppleTalk = libc::AF_APPLETALK,\n    /// AX.25 packet layer protocol.\n    /// (see [netrom(4)](https://www.unix.com/man-page/linux/4/netrom/))\n    #[cfg(linux_android)]\n    NetRom = libc::AF_NETROM,\n    /// Can't be used for creating sockets; mostly used for bridge\n    /// links in\n    /// [rtnetlink(7)](https://man7.org/linux/man-pages/man7/rtnetlink.7.html)\n    /// protocol commands.\n    #[cfg(linux_android)]\n    Bridge = libc::AF_BRIDGE,\n    /// Access to raw ATM PVCs\n    #[cfg(linux_android)]\n    AtmPvc = libc::AF_ATMPVC,\n    /// ITU-T X.25 / ISO-8208 protocol (see [`x25(7)`](https://man7.org/linux/man-pages/man7/x25.7.html))\n    #[cfg(linux_android)]\n    X25 = libc::AF_X25,\n    /// RATS (Radio Amateur Telecommunications Society) Open\n    /// Systems environment (ROSE) AX.25 packet layer protocol.\n    /// (see [netrom(4)](https://www.unix.com/man-page/linux/4/netrom/))\n    #[cfg(linux_android)]\n    Rose = libc::AF_ROSE,\n    /// DECet protocol sockets.\n    #[cfg(not(any(target_os = \"haiku\", target_os = \"redox\")))]\n    Decnet = libc::AF_DECnet,\n    /// Reserved for \"802.2LLC project\"; never used.\n    #[cfg(linux_android)]\n    NetBeui = libc::AF_NETBEUI,\n    /// This was a short-lived (between Linux 2.1.30 and\n    /// 2.1.99pre2) protocol family for firewall upcalls.\n    #[cfg(linux_android)]\n    Security = libc::AF_SECURITY,\n    /// Key management protocol.\n    #[cfg(linux_android)]\n    Key = libc::AF_KEY,\n    #[allow(missing_docs)] // Not documented anywhere that I can find\n    #[cfg(linux_android)]\n    Ash = libc::AF_ASH,\n    /// Acorn Econet protocol\n    #[cfg(linux_android)]\n    Econet = libc::AF_ECONET,\n    /// Access to ATM Switched Virtual Circuits\n    #[cfg(linux_android)]\n    AtmSvc = libc::AF_ATMSVC,\n    /// Reliable Datagram Sockets (RDS) protocol\n    #[cfg(linux_android)]\n    Rds = libc::AF_RDS,\n    /// IBM SNA\n    #[cfg(not(any(target_os = \"haiku\", target_os = \"redox\")))]\n    Sna = libc::AF_SNA,\n    /// Socket interface over IrDA\n    #[cfg(linux_android)]\n    Irda = libc::AF_IRDA,\n    /// Generic PPP transport layer, for setting up L2 tunnels (L2TP and PPPoE)\n    #[cfg(linux_android)]\n    Pppox = libc::AF_PPPOX,\n    /// Legacy protocol for wide area network (WAN) connectivity that was used\n    /// by Sangoma WAN cards\n    #[cfg(linux_android)]\n    Wanpipe = libc::AF_WANPIPE,\n    /// Logical link control (IEEE 802.2 LLC) protocol\n    #[cfg(linux_android)]\n    Llc = libc::AF_LLC,\n    /// InfiniBand native addressing\n    #[cfg(all(target_os = \"linux\", not(target_env = \"uclibc\")))]\n    Ib = libc::AF_IB,\n    /// Multiprotocol Label Switching\n    #[cfg(all(target_os = \"linux\", not(target_env = \"uclibc\")))]\n    Mpls = libc::AF_MPLS,\n    /// Controller Area Network automotive bus protocol\n    #[cfg(linux_android)]\n    Can = libc::AF_CAN,\n    /// TIPC, \"cluster domain sockets\" protocol\n    #[cfg(linux_android)]\n    Tipc = libc::AF_TIPC,\n    /// Bluetooth low-level socket protocol\n    #[cfg(not(any(\n        target_os = \"aix\",\n        solarish,\n        apple_targets,\n        target_os = \"hurd\",\n        target_os = \"redox\",\n        target_os = \"cygwin\",\n    )))]\n    Bluetooth = libc::AF_BLUETOOTH,\n    /// IUCV (inter-user communication vehicle) z/VM protocol for\n    /// hypervisor-guest interaction\n    #[cfg(linux_android)]\n    Iucv = libc::AF_IUCV,\n    /// Rx, Andrew File System remote procedure call protocol\n    #[cfg(linux_android)]\n    RxRpc = libc::AF_RXRPC,\n    /// New \"modular ISDN\" driver interface protocol\n    #[cfg(not(any(\n        target_os = \"aix\",\n        solarish,\n        target_os = \"haiku\",\n        target_os = \"hurd\",\n        target_os = \"redox\",\n        target_os = \"cygwin\",\n    )))]\n    Isdn = libc::AF_ISDN,\n    /// Nokia cellular modem IPC/RPC interface\n    #[cfg(linux_android)]\n    Phonet = libc::AF_PHONET,\n    /// IEEE 802.15.4 WPAN (wireless personal area network) raw packet protocol\n    #[cfg(linux_android)]\n    Ieee802154 = libc::AF_IEEE802154,\n    /// Ericsson's Communication CPU to Application CPU interface (CAIF)\n    /// protocol.\n    #[cfg(linux_android)]\n    Caif = libc::AF_CAIF,\n    /// Interface to kernel crypto API\n    #[cfg(linux_android)]\n    Alg = libc::AF_ALG,\n    /// Near field communication\n    #[cfg(target_os = \"linux\")]\n    Nfc = libc::AF_NFC,\n    /// VMWare VSockets protocol for hypervisor-guest interaction.\n    #[cfg(any(linux_android, apple_targets))]\n    Vsock = libc::AF_VSOCK,\n    /// ARPANet IMP addresses\n    #[cfg(bsd)]\n    ImpLink = libc::AF_IMPLINK,\n    /// PUP protocols, e.g. BSP\n    #[cfg(bsd)]\n    Pup = libc::AF_PUP,\n    /// MIT CHAOS protocols\n    #[cfg(bsd)]\n    Chaos = libc::AF_CHAOS,\n    /// Novell and Xerox protocol\n    #[cfg(any(apple_targets, netbsdlike))]\n    Ns = libc::AF_NS,\n    #[allow(missing_docs)] // Not documented anywhere that I can find\n    #[cfg(bsd)]\n    Iso = libc::AF_ISO,\n    /// Bell Labs virtual circuit switch ?\n    #[cfg(bsd)]\n    Datakit = libc::AF_DATAKIT,\n    /// CCITT protocols, X.25 etc\n    #[cfg(bsd)]\n    Ccitt = libc::AF_CCITT,\n    /// DEC Direct data link interface\n    #[cfg(bsd)]\n    Dli = libc::AF_DLI,\n    #[allow(missing_docs)] // Not documented anywhere that I can find\n    #[cfg(bsd)]\n    Lat = libc::AF_LAT,\n    /// NSC Hyperchannel\n    #[cfg(bsd)]\n    Hylink = libc::AF_HYLINK,\n    /// Link layer interface\n    #[cfg(any(bsd, solarish))]\n    Link = libc::AF_LINK,\n    /// connection-oriented IP, aka ST II\n    #[cfg(bsd)]\n    Coip = libc::AF_COIP,\n    /// Computer Network Technology\n    #[cfg(bsd)]\n    Cnt = libc::AF_CNT,\n    /// Native ATM access\n    #[cfg(bsd)]\n    Natm = libc::AF_NATM,\n    /// Unspecified address family, (see [`getaddrinfo(3)`](https://man7.org/linux/man-pages/man3/getaddrinfo.3.html))\n    #[cfg(linux_android)]\n    Unspec = libc::AF_UNSPEC,\n}\n\nimpl AddressFamily {\n    /// Create a new `AddressFamily` from an integer value retrieved from `libc`, usually from\n    /// the `sa_family` field of a `sockaddr`.\n    ///\n    /// Currently only supports these address families: Unix, Inet (v4 \u0026 v6), Netlink, Link/Packet\n    /// and System. Returns None for unsupported or unknown address families.\n    pub const fn from_i32(family: i32) -\u003e Option\u003cAddressFamily\u003e {\n        match family {\n            libc::AF_UNIX =\u003e Some(AddressFamily::Unix),\n            libc::AF_INET =\u003e Some(AddressFamily::Inet),\n            libc::AF_INET6 =\u003e Some(AddressFamily::Inet6),\n            #[cfg(linux_android)]\n            libc::AF_NETLINK =\u003e Some(AddressFamily::Netlink),\n            #[cfg(apple_targets)]\n            libc::AF_SYSTEM =\u003e Some(AddressFamily::System),\n            #[cfg(not(any(linux_android, target_os = \"redox\", target_os = \"cygwin\")))]\n            libc::PF_ROUTE =\u003e Some(AddressFamily::Route),\n            #[cfg(linux_android)]\n            libc::AF_PACKET =\u003e Some(AddressFamily::Packet),\n            #[cfg(any(bsd, solarish))]\n            libc::AF_LINK =\u003e Some(AddressFamily::Link),\n            #[cfg(any(linux_android, apple_targets))]\n            libc::AF_VSOCK =\u003e Some(AddressFamily::Vsock),\n            _ =\u003e None,\n        }\n    }\n}\n\n/// A wrapper around `sockaddr_un`.\n#[derive(Clone, Copy, Debug)]\n#[repr(C)]\npub struct UnixAddr {\n    // INVARIANT: sun \u0026 sun_len are valid as defined by docs for from_raw_parts\n    sun: libc::sockaddr_un,\n    /// The length of the valid part of `sun`, including the sun_family field\n    /// but excluding any trailing nul.\n    // On the BSDs, this field is built into sun\n    #[cfg(not(any(bsd, target_os = \"haiku\", target_os = \"hurd\")))]\n    sun_len: u8,\n}\n\n// linux man page unix(7) says there are 3 kinds of unix socket:\n// pathname: addrlen = offsetof(struct sockaddr_un, sun_path) + strlen(sun_path) + 1\n// unnamed: addrlen = sizeof(sa_family_t)\n// abstract: addren \u003e sizeof(sa_family_t), name = sun_path[..(addrlen - sizeof(sa_family_t))]\n//\n// what we call path_len = addrlen - offsetof(struct sockaddr_un, sun_path)\n#[derive(PartialEq, Eq, Hash)]\nenum UnixAddrKind\u003c'a\u003e {\n    Pathname(\u0026'a Path),\n    Unnamed,\n    #[cfg(linux_android)]\n    Abstract(\u0026'a [u8]),\n}\nimpl\u003c'a\u003e UnixAddrKind\u003c'a\u003e {\n    /// Safety: sun \u0026 sun_len must be valid\n    #[allow(clippy::unnecessary_cast)] // Not unnecessary on all platforms\n    unsafe fn get(sun: \u0026'a libc::sockaddr_un, sun_len: u8) -\u003e Self {\n        assert!(sun_len as usize \u003e= offset_of!(libc::sockaddr_un, sun_path));\n        let path_len =\n            sun_len as usize - offset_of!(libc::sockaddr_un, sun_path);\n        if path_len == 0 {\n            return Self::Unnamed;\n        }\n        #[cfg(linux_android)]\n        if sun.sun_path[0] == 0 {\n            let name = unsafe {\n                slice::from_raw_parts(\n                    sun.sun_path.as_ptr().add(1).cast(),\n                    path_len - 1,\n                )\n            };\n            return Self::Abstract(name);\n        }\n        let pathname = unsafe {\n            slice::from_raw_parts(sun.sun_path.as_ptr().cast(), path_len)\n        };\n        if pathname.last() == Some(\u00260) {\n            // A trailing NUL is not considered part of the path, and it does\n            // not need to be included in the addrlen passed to functions like\n            // bind().  However, Linux adds a trailing NUL, even if one was not\n            // originally present, when returning addrs from functions like\n            // getsockname() (the BSDs do not do that).  So we need to filter\n            // out any trailing NUL here, so sockaddrs can round-trip through\n            // the kernel and still compare equal.\n            Self::Pathname(Path::new(OsStr::from_bytes(\n                \u0026pathname[0..pathname.len() - 1],\n            )))\n        } else {\n            Self::Pathname(Path::new(OsStr::from_bytes(pathname)))\n        }\n    }\n}\n\nimpl UnixAddr {\n    /// Create a new sockaddr_un representing a filesystem path.\n    #[allow(clippy::unnecessary_cast)] // Not unnecessary on all platforms\n    pub fn new\u003cP: ?Sized + NixPath\u003e(path: \u0026P) -\u003e Result\u003cUnixAddr\u003e {\n        path.with_nix_path(|cstr| unsafe {\n            let mut ret = libc::sockaddr_un {\n                sun_family: AddressFamily::Unix as sa_family_t,\n                ..mem::zeroed()\n            };\n\n            let bytes = cstr.to_bytes();\n\n            if bytes.len() \u003e= ret.sun_path.len() {\n                return Err(Errno::ENAMETOOLONG);\n            }\n\n            let sun_len = (bytes.len()\n                + offset_of!(libc::sockaddr_un, sun_path))\n            .try_into()\n            .unwrap();\n\n            #[cfg(any(bsd, target_os = \"haiku\", target_os = \"hurd\"))]\n            {\n                ret.sun_len = sun_len;\n            }\n            ptr::copy_nonoverlapping(\n                bytes.as_ptr(),\n                ret.sun_path.as_mut_ptr().cast(),\n                bytes.len(),\n            );\n\n            Ok(UnixAddr::from_raw_parts(ret, sun_len))\n        })?\n    }\n\n    /// Create a new `sockaddr_un` representing an address in the \"abstract namespace\".\n    ///\n    /// The leading nul byte for the abstract namespace is automatically added;\n    /// thus the input `path` is expected to be the bare name, not NUL-prefixed.\n    /// This is a Linux-specific extension, primarily used to allow chrooted\n    /// processes to communicate with processes having a different filesystem view.\n    #[cfg(linux_android)]\n    #[allow(clippy::unnecessary_cast)] // Not unnecessary on all platforms\n    pub fn new_abstract(path: \u0026[u8]) -\u003e Result\u003cUnixAddr\u003e {\n        unsafe {\n            let mut ret = libc::sockaddr_un {\n                sun_family: AddressFamily::Unix as sa_family_t,\n                ..mem::zeroed()\n            };\n\n            if path.len() \u003e= ret.sun_path.len() {\n                return Err(Errno::ENAMETOOLONG);\n            }\n            let sun_len =\n                (path.len() + 1 + offset_of!(libc::sockaddr_un, sun_path))\n                    .try_into()\n                    .unwrap();\n\n            // Abstract addresses are represented by sun_path[0] ==\n            // b'\\0', so copy starting one byte in.\n            ptr::copy_nonoverlapping(\n                path.as_ptr(),\n                ret.sun_path.as_mut_ptr().offset(1).cast(),\n                path.len(),\n            );\n\n            Ok(UnixAddr::from_raw_parts(ret, sun_len))\n        }\n    }\n\n    /// Create a new `sockaddr_un` representing an \"unnamed\" unix socket address.\n    #[cfg(linux_android)]\n    pub fn new_unnamed() -\u003e UnixAddr {\n        let ret = libc::sockaddr_un {\n            sun_family: AddressFamily::Unix as sa_family_t,\n            ..unsafe { mem::zeroed() }\n        };\n\n        let sun_len: u8 =\n            offset_of!(libc::sockaddr_un, sun_path).try_into().unwrap();\n\n        unsafe { UnixAddr::from_raw_parts(ret, sun_len) }\n    }\n\n    /// Create a UnixAddr from a raw `sockaddr_un` struct and a size. `sun_len`\n    /// is the size of the valid portion of the struct, excluding any trailing\n    /// NUL.\n    ///\n    /// # Safety\n    /// This pair of sockaddr_un \u0026 sun_len must be a valid unix addr, which\n    /// means:\n    /// - sun_len \u003e= offset_of(sockaddr_un, sun_path)\n    /// - sun_len \u003c= sockaddr_un.sun_path.len() - offset_of(sockaddr_un, sun_path)\n    /// - if this is a unix addr with a pathname, sun.sun_path is a\n    ///   fs path, not necessarily nul-terminated.\n    pub(crate) unsafe fn from_raw_parts(\n        sun: libc::sockaddr_un,\n        sun_len: u8,\n    ) -\u003e UnixAddr {\n        cfg_if! {\n            if #[cfg(any(linux_android,\n                     target_os = \"fuchsia\",\n                     solarish,\n                     target_os = \"redox\",\n                     target_os = \"cygwin\",\n                ))]\n            {\n                UnixAddr { sun, sun_len }\n            } else {\n                assert_eq!(sun_len, sun.sun_len);\n                UnixAddr {sun}\n            }\n        }\n    }\n\n    fn kind(\u0026self) -\u003e UnixAddrKind\u003c'_\u003e {\n        // SAFETY: our sockaddr is always valid because of the invariant on the struct\n        unsafe { UnixAddrKind::get(\u0026self.sun, self.sun_len()) }\n    }\n\n    /// If this address represents a filesystem path, return that path.\n    pub fn path(\u0026self) -\u003e Option\u003c\u0026Path\u003e {\n        match self.kind() {\n            UnixAddrKind::Pathname(path) =\u003e Some(path),\n            _ =\u003e None,\n        }\n    }\n\n    /// If this address represents an abstract socket, return its name.\n    ///\n    /// For abstract sockets only the bare name is returned, without the\n    /// leading NUL byte. `None` is returned for unnamed or path-backed sockets.\n    #[cfg(linux_android)]\n    pub fn as_abstract(\u0026self) -\u003e Option\u003c\u0026[u8]\u003e {\n        match self.kind() {\n            UnixAddrKind::Abstract(name) =\u003e Some(name),\n            _ =\u003e None,\n        }\n    }\n\n    /// Check if this address is an \"unnamed\" unix socket address.\n    #[cfg(linux_android)]\n    #[inline]\n    pub fn is_unnamed(\u0026self) -\u003e bool {\n        matches!(self.kind(), UnixAddrKind::Unnamed)\n    }\n\n    /// Returns the addrlen of this socket - `offsetof(struct sockaddr_un, sun_path)`\n    #[inline]\n    pub fn path_len(\u0026self) -\u003e usize {\n        self.sun_len() as usize - offset_of!(libc::sockaddr_un, sun_path)\n    }\n    /// Returns a pointer to the raw `sockaddr_un` struct\n    #[inline]\n    pub fn as_ptr(\u0026self) -\u003e *const libc::sockaddr_un {\n        \u0026self.sun\n    }\n    /// Returns a mutable pointer to the raw `sockaddr_un` struct\n    #[inline]\n    pub fn as_mut_ptr(\u0026mut self) -\u003e *mut libc::sockaddr_un {\n        \u0026mut self.sun\n    }\n\n    fn sun_len(\u0026self) -\u003e u8 {\n        cfg_if! {\n            if #[cfg(any(linux_android,\n                     target_os = \"fuchsia\",\n                     solarish,\n                     target_os = \"redox\",\n                     target_os = \"cygwin\",\n                ))]\n            {\n                self.sun_len\n            } else {\n                self.sun.sun_len\n            }\n        }\n    }\n}\n\nimpl private::SockaddrLikePriv for UnixAddr {}\nimpl SockaddrLike for UnixAddr {\n    #[cfg(any(\n        linux_android,\n        target_os = \"fuchsia\",\n        solarish,\n        target_os = \"redox\",\n        target_os = \"cygwin\",\n    ))]\n    fn len(\u0026self) -\u003e libc::socklen_t {\n        self.sun_len.into()\n    }\n\n    unsafe fn from_raw(\n        addr: *const libc::sockaddr,\n        len: Option\u003clibc::socklen_t\u003e,\n    ) -\u003e Option\u003cSelf\u003e\n    where\n        Self: Sized,\n    {\n        if let Some(l) = len {\n            if (l as usize) \u003c offset_of!(libc::sockaddr_un, sun_path)\n                || l \u003e u8::MAX as libc::socklen_t\n            {\n                return None;\n            }\n        }\n        if unsafe { (*addr).sa_family as i32 != libc::AF_UNIX } {\n            return None;\n        }\n        let mut su: libc::sockaddr_un = unsafe { mem::zeroed() };\n        let sup = \u0026mut su as *mut libc::sockaddr_un as *mut u8;\n        cfg_if! {\n            if #[cfg(any(linux_android,\n                         target_os = \"fuchsia\",\n                         solarish,\n                         target_os = \"redox\",\n                         target_os = \"cygwin\",\n                ))] {\n                let su_len = len.unwrap_or(\n                    mem::size_of::\u003clibc::sockaddr_un\u003e() as libc::socklen_t\n                );\n            } else {\n                let su_len = unsafe { len.unwrap_or((*addr).sa_len as libc::socklen_t) };\n            }\n        }\n        unsafe { ptr::copy(addr as *const u8, sup, su_len as usize) };\n        Some(unsafe { Self::from_raw_parts(su, su_len as u8) })\n    }\n\n    fn size() -\u003e libc::socklen_t\n    where\n        Self: Sized,\n    {\n        mem::size_of::\u003clibc::sockaddr_un\u003e() as libc::socklen_t\n    }\n\n    unsafe fn set_length(\n        \u0026mut self,\n        new_length: usize,\n    ) -\u003e std::result::Result\u003c(), SocketAddressLengthNotDynamic\u003e {\n        // `new_length` is only used on some platforms, so it must be provided even when not used\n        #![allow(unused_variables)]\n        cfg_if! {\n            if #[cfg(any(linux_android,\n                         target_os = \"fuchsia\",\n                         solarish,\n                         target_os = \"redox\",\n                ))] {\n                self.sun_len = new_length as u8;\n            }\n        };\n        Ok(())\n    }\n}\n\nimpl AsRef\u003clibc::sockaddr_un\u003e for UnixAddr {\n    fn as_ref(\u0026self) -\u003e \u0026libc::sockaddr_un {\n        \u0026self.sun\n    }\n}\n\n#[cfg(linux_android)]\nfn fmt_abstract(abs: \u0026[u8], f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n    use fmt::Write;\n    f.write_str(\"@\\\"\")?;\n    for \u0026b in abs {\n        use fmt::Display;\n        char::from(b).escape_default().fmt(f)?;\n    }\n    f.write_char('\"')?;\n    Ok(())\n}\n\nimpl fmt::Display for UnixAddr {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match self.kind() {\n            UnixAddrKind::Pathname(path) =\u003e path.display().fmt(f),\n            UnixAddrKind::Unnamed =\u003e f.pad(\"\u003cunbound UNIX socket\u003e\"),\n            #[cfg(linux_android)]\n            UnixAddrKind::Abstract(name) =\u003e fmt_abstract(name, f),\n        }\n    }\n}\n\nimpl PartialEq for UnixAddr {\n    fn eq(\u0026self, other: \u0026UnixAddr) -\u003e bool {\n        self.kind() == other.kind()\n    }\n}\n\nimpl Eq for UnixAddr {}\n\nimpl Hash for UnixAddr {\n    fn hash\u003cH: Hasher\u003e(\u0026self, s: \u0026mut H) {\n        self.kind().hash(s)\n    }\n}\n\n/// Anything that, in C, can be cast back and forth to `sockaddr`.\n///\n/// Most implementors also implement `AsRef\u003clibc::XXX\u003e` to access their\n/// inner type read-only.\n#[allow(clippy::len_without_is_empty)]\npub trait SockaddrLike: private::SockaddrLikePriv {\n    /// Returns a raw pointer to the inner structure.  Useful for FFI.\n    fn as_ptr(\u0026self) -\u003e *const libc::sockaddr {\n        self as *const Self as *const libc::sockaddr\n    }\n\n    /// Unsafe constructor from a variable length source\n    ///\n    /// Some C APIs from provide `len`, and others do not.  If it's provided it\n    /// will be validated.  If not, it will be guessed based on the family.\n    ///\n    /// # Arguments\n    ///\n    /// - `addr`:   raw pointer to something that can be cast to a `libc::sockaddr`.\n    ///   For example, `libc::sockaddr_in`, `libc::sockaddr_in6`, etc.\n    /// - `len`:    For fixed-width types like `sockaddr_in`, it will be validated\n    ///   if present and ignored if not. For variable-width types it is required \n    ///   and must be the total length of valid data. For example, if `addr` \n    ///   points to a named `sockaddr_un`, then `len` must be the length of the\n    ///   structure up to but not including the trailing NUL.\n    ///\n    /// # Safety\n    ///\n    /// `addr` must be valid for the specific type of sockaddr.  `len`, if\n    /// present, must not exceed the length of valid data in `addr`.\n    unsafe fn from_raw(\n        addr: *const libc::sockaddr,\n        len: Option\u003clibc::socklen_t\u003e,\n    ) -\u003e Option\u003cSelf\u003e\n    where\n        Self: Sized;\n\n    /// Return the address family of this socket\n    ///\n    /// # Examples\n    /// One common use is to match on the family of a union type, like this:\n    /// ```\n    /// # use nix::sys::socket::*;\n    /// # use std::os::unix::io::AsRawFd;\n    /// let fd = socket(AddressFamily::Inet, SockType::Stream,\n    ///     SockFlag::empty(), None).unwrap();\n    /// let ss: SockaddrStorage = getsockname(fd.as_raw_fd()).unwrap();\n    /// match ss.family().unwrap() {\n    ///     AddressFamily::Inet =\u003e println!(\"{}\", ss.as_sockaddr_in().unwrap()),\n    ///     AddressFamily::Inet6 =\u003e println!(\"{}\", ss.as_sockaddr_in6().unwrap()),\n    ///     _ =\u003e println!(\"Unexpected address family\")\n    /// }\n    /// ```\n    fn family(\u0026self) -\u003e Option\u003cAddressFamily\u003e {\n        // Safe since all implementors have a sa_family field at the same\n        // address, and they're all repr(C)\n        AddressFamily::from_i32(unsafe {\n            (*(self as *const Self as *const libc::sockaddr)).sa_family as i32\n        })\n    }\n\n    cfg_if! {\n        if #[cfg(bsd)] {\n            /// Return the length of valid data in the sockaddr structure.\n            ///\n            /// For fixed-size sockaddrs, this should be the size of the\n            /// structure.  But for variable-sized types like [`UnixAddr`] it\n            /// may be less.\n            fn len(\u0026self) -\u003e libc::socklen_t {\n                // Safe since all implementors have a sa_len field at the same\n                // address, and they're all repr(transparent).\n                // Robust for all implementors.\n                unsafe {\n                    (*(self as *const Self as *const libc::sockaddr)).sa_len\n                }.into()\n            }\n        } else {\n            /// Return the length of valid data in the sockaddr structure.\n            ///\n            /// For fixed-size sockaddrs, this should be the size of the\n            /// structure.  But for variable-sized types like [`UnixAddr`] it\n            /// may be less.\n            fn len(\u0026self) -\u003e libc::socklen_t {\n                // No robust default implementation is possible without an\n                // sa_len field.  Implementors with a variable size must\n                // override this method.\n                mem::size_of_val(self) as libc::socklen_t\n            }\n        }\n    }\n\n    /// Return the available space in the structure\n    fn size() -\u003e libc::socklen_t\n    where\n        Self: Sized,\n    {\n        mem::size_of::\u003cSelf\u003e() as libc::socklen_t\n    }\n\n    /// Set the length of this socket address\n    ///\n    /// This method may only be called on socket addresses whose lengths are dynamic, and it\n    /// returns an error if called on a type whose length is static.\n    ///\n    /// # Safety\n    ///\n    /// `new_length` must be a valid length for this type of address. Specifically, reads of that\n    /// length from `self` must be valid.\n    #[doc(hidden)]\n    unsafe fn set_length(\n        \u0026mut self,\n        _new_length: usize,\n    ) -\u003e std::result::Result\u003c(), SocketAddressLengthNotDynamic\u003e {\n        Err(SocketAddressLengthNotDynamic)\n    }\n}\n\n/// The error returned by [`SockaddrLike::set_length`] on an address whose length is statically\n/// fixed.\n#[derive(Copy, Clone, Debug)]\npub struct SocketAddressLengthNotDynamic;\nimpl fmt::Display for SocketAddressLengthNotDynamic {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.write_str(\"Attempted to set length on socket whose length is statically fixed\")\n    }\n}\nimpl std::error::Error for SocketAddressLengthNotDynamic {}\n\nimpl private::SockaddrLikePriv for () {\n    fn as_mut_ptr(\u0026mut self) -\u003e *mut libc::sockaddr {\n        ptr::null_mut()\n    }\n}\n\n/// `()` can be used in place of a real Sockaddr when no address is expected,\n/// for example for a field of `Option\u003cS\u003e where S: SockaddrLike`.\n// If this RFC ever stabilizes, then ! will be a better choice.\n// https://github.com/rust-lang/rust/issues/35121\nimpl SockaddrLike for () {\n    fn as_ptr(\u0026self) -\u003e *const libc::sockaddr {\n        ptr::null()\n    }\n\n    unsafe fn from_raw(\n        _: *const libc::sockaddr,\n        _: Option\u003clibc::socklen_t\u003e,\n    ) -\u003e Option\u003cSelf\u003e\n    where\n        Self: Sized,\n    {\n        None\n    }\n\n    fn family(\u0026self) -\u003e Option\u003cAddressFamily\u003e {\n        None\n    }\n\n    fn len(\u0026self) -\u003e libc::socklen_t {\n        0\n    }\n}\n\n/// An IPv4 socket address\n#[cfg(feature = \"net\")]\n#[repr(transparent)]\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct SockaddrIn(libc::sockaddr_in);\n\n#[cfg(feature = \"net\")]\nimpl SockaddrIn {\n    /// Returns the IP address associated with this socket address, in native\n    /// endian.\n    pub const fn ip(\u0026self) -\u003e net::Ipv4Addr {\n        let bytes = self.0.sin_addr.s_addr.to_ne_bytes();\n        let (a, b, c, d) = (bytes[0], bytes[1], bytes[2], bytes[3]);\n        Ipv4Addr::new(a, b, c, d)\n    }\n\n    /// Creates a new socket address from IPv4 octets and a port number.\n    pub fn new(a: u8, b: u8, c: u8, d: u8, port: u16) -\u003e Self {\n        Self(libc::sockaddr_in {\n            #[cfg(any(\n                bsd,\n                target_os = \"aix\",\n                target_os = \"haiku\",\n                target_os = \"hurd\"\n            ))]\n            sin_len: Self::size() as u8,\n            sin_family: AddressFamily::Inet as sa_family_t,\n            sin_port: u16::to_be(port),\n            sin_addr: libc::in_addr {\n                s_addr: u32::from_ne_bytes([a, b, c, d]),\n            },\n            sin_zero: unsafe { mem::zeroed() },\n        })\n    }\n\n    /// Returns the port number associated with this socket address, in native\n    /// endian.\n    pub const fn port(\u0026self) -\u003e u16 {\n        u16::from_be(self.0.sin_port)\n    }\n}\n\n#[cfg(feature = \"net\")]\nimpl private::SockaddrLikePriv for SockaddrIn {}\n#[cfg(feature = \"net\")]\nimpl SockaddrLike for SockaddrIn {\n    unsafe fn from_raw(\n        addr: *const libc::sockaddr,\n        len: Option\u003clibc::socklen_t\u003e,\n    ) -\u003e Option\u003cSelf\u003e\n    where\n        Self: Sized,\n    {\n        if let Some(l) = len {\n            if l != mem::size_of::\u003clibc::sockaddr_in\u003e() as libc::socklen_t {\n                return None;\n            }\n        }\n        if unsafe { (*addr).sa_family as i32 != libc::AF_INET } {\n            return None;\n        }\n        Some(Self(unsafe { ptr::read_unaligned(addr as *const _) }))\n    }\n}\n\n#[cfg(feature = \"net\")]\nimpl AsRef\u003clibc::sockaddr_in\u003e for SockaddrIn {\n    fn as_ref(\u0026self) -\u003e \u0026libc::sockaddr_in {\n        \u0026self.0\n    }\n}\n\n#[cfg(feature = \"net\")]\nimpl fmt::Display for SockaddrIn {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        let ne = u32::from_be(self.0.sin_addr.s_addr);\n        let port = u16::from_be(self.0.sin_port);\n        write!(\n            f,\n            \"{}.{}.{}.{}:{}\",\n            ne \u003e\u003e 24,\n            (ne \u003e\u003e 16) \u0026 0xFF,\n            (ne \u003e\u003e 8) \u0026 0xFF,\n            ne \u0026 0xFF,\n            port\n        )\n    }\n}\n\n#[cfg(feature = \"net\")]\nimpl From\u003cnet::SocketAddrV4\u003e for SockaddrIn {\n    fn from(addr: net::SocketAddrV4) -\u003e Self {\n        Self(libc::sockaddr_in {\n            #[cfg(any(\n                bsd,\n                target_os = \"haiku\",\n                target_os = \"hermit\",\n                target_os = \"hurd\"\n            ))]\n            sin_len: mem::size_of::\u003clibc::sockaddr_in\u003e() as u8,\n            sin_family: AddressFamily::Inet as sa_family_t,\n            sin_port: addr.port().to_be(), // network byte order\n            sin_addr: ipv4addr_to_libc(*addr.ip()),\n            ..unsafe { mem::zeroed() }\n        })\n    }\n}\n\n#[cfg(feature = \"net\")]\nimpl From\u003cSockaddrIn\u003e for net::SocketAddrV4 {\n    fn from(addr: SockaddrIn) -\u003e Self {\n        net::SocketAddrV4::new(\n            net::Ipv4Addr::from(addr.0.sin_addr.s_addr.to_ne_bytes()),\n            u16::from_be(addr.0.sin_port),\n        )\n    }\n}\n\n#[cfg(feature = \"net\")]\nimpl From\u003cSockaddrIn\u003e for net::SocketAddr {\n    fn from(addr: SockaddrIn) -\u003e Self {\n        net::SocketAddr::from(net::SocketAddrV4::from(addr))\n    }\n}\n\n#[cfg(feature = \"net\")]\nimpl From\u003cSockaddrIn\u003e for libc::sockaddr_in {\n    fn from(sin: SockaddrIn) -\u003e libc::sockaddr_in {\n        sin.0\n    }\n}\n#[cfg(feature = \"net\")]\nimpl From\u003clibc::sockaddr_in\u003e for SockaddrIn {\n    fn from(sin: libc::sockaddr_in) -\u003e SockaddrIn {\n        SockaddrIn(sin)\n    }\n}\n\n#[cfg(feature = \"net\")]\nimpl std::str::FromStr for SockaddrIn {\n    type Err = net::AddrParseError;\n\n    fn from_str(s: \u0026str) -\u003e std::result::Result\u003cSelf, Self::Err\u003e {\n        net::SocketAddrV4::from_str(s).map(SockaddrIn::from)\n    }\n}\n\n/// An IPv6 socket address\n#[cfg(feature = \"net\")]\n#[repr(transparent)]\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct SockaddrIn6(libc::sockaddr_in6);\n\n#[cfg(feature = \"net\")]\nimpl SockaddrIn6 {\n    /// Returns the flow information associated with this address.\n    pub const fn flowinfo(\u0026self) -\u003e u32 {\n        self.0.sin6_flowinfo\n    }\n\n    /// Returns the IP address associated with this socket address.\n    pub const fn ip(\u0026self) -\u003e net::Ipv6Addr {\n        let bytes = self.0.sin6_addr.s6_addr;\n        let (a, b, c, d, e, f, g, h) = (\n            ((bytes[0] as u16) \u003c\u003c 8) | bytes[1] as u16,\n            ((bytes[2] as u16) \u003c\u003c 8) | bytes[3] as u16,\n            ((bytes[4] as u16) \u003c\u003c 8) | bytes[5] as u16,\n            ((bytes[6] as u16) \u003c\u003c 8) | bytes[7] as u16,\n            ((bytes[8] as u16) \u003c\u003c 8) | bytes[9] as u16,\n            ((bytes[10] as u16) \u003c\u003c 8) | bytes[11] as u16,\n            ((bytes[12] as u16) \u003c\u003c 8) | bytes[13] as u16,\n            ((bytes[14] as u16) \u003c\u003c 8) | bytes[15] as u16,\n        );\n        Ipv6Addr::new(a, b, c, d, e, f, g, h)\n    }\n\n    /// Returns the port number associated with this socket address, in native\n    /// endian.\n    pub const fn port(\u0026self) -\u003e u16 {\n        u16::from_be(self.0.sin6_port)\n    }\n\n    /// Returns the scope ID associated with this address.\n    pub const fn scope_id(\u0026self) -\u003e u32 {\n        self.0.sin6_scope_id\n    }\n}\n\n#[cfg(feature = \"net\")]\nimpl From\u003cSockaddrIn6\u003e for libc::sockaddr_in6 {\n    fn from(sin6: SockaddrIn6) -\u003e libc::sockaddr_in6 {\n        sin6.0\n    }\n}\n\n#[cfg(feature = \"net\")]\nimpl From\u003clibc::sockaddr_in6\u003e for SockaddrIn6 {\n    fn from(sin6: libc::sockaddr_in6) -\u003e SockaddrIn6 {\n        SockaddrIn6(sin6)\n    }\n}\n\n#[cfg(feature = \"net\")]\nimpl private::SockaddrLikePriv for SockaddrIn6 {}\n#[cfg(feature = \"net\")]\nimpl SockaddrLike for SockaddrIn6 {\n    unsafe fn from_raw(\n        addr: *const libc::sockaddr,\n        len: Option\u003clibc::socklen_t\u003e,\n    ) -\u003e Option\u003cSelf\u003e\n    where\n        Self: Sized,\n    {\n        if let Some(l) = len {\n            if l != mem::size_of::\u003clibc::sockaddr_in6\u003e() as libc::socklen_t {\n                return None;\n            }\n        }\n        if unsafe { (*addr).sa_family as i32 != libc::AF_INET6 } {\n            return None;\n        }\n        Some(Self(unsafe { ptr::read_unaligned(addr as *const _) }))\n    }\n}\n\n#[cfg(feature = \"net\")]\nimpl AsRef\u003clibc::sockaddr_in6\u003e for SockaddrIn6 {\n    fn as_ref(\u0026self) -\u003e \u0026libc::sockaddr_in6 {\n        \u0026self.0\n    }\n}\n\n#[cfg(feature = \"net\")]\nimpl fmt::Display for SockaddrIn6 {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        // These things are really hard to display properly.  Easier to let std\n        // do it.\n        let std = net::SocketAddrV6::new(\n            self.ip(),\n            self.port(),\n            self.flowinfo(),\n            self.scope_id(),\n        );\n        std.fmt(f)\n    }\n}\n\n#[cfg(feature = \"net\")]\nimpl From\u003cnet::SocketAddrV6\u003e for SockaddrIn6 {\n    fn from(addr: net::SocketAddrV6) -\u003e Self {\n        #[allow(clippy::needless_update)] // It isn't needless on Illumos\n        Self(libc::sockaddr_in6 {\n            #[cfg(any(\n                bsd,\n                target_os = \"haiku\",\n                target_os = \"hermit\",\n                target_os = \"hurd\"\n            ))]\n            sin6_len: mem::size_of::\u003clibc::sockaddr_in6\u003e() as u8,\n            sin6_family: AddressFamily::Inet6 as sa_family_t,\n            sin6_port: addr.port().to_be(), // network byte order\n            sin6_addr: ipv6addr_to_libc(addr.ip()),\n            sin6_flowinfo: addr.flowinfo(), // host byte order\n            sin6_scope_id: addr.scope_id(), // host byte order\n            ..unsafe { mem::zeroed() }\n        })\n    }\n}\n\n#[cfg(feature = \"net\")]\nimpl From\u003cSockaddrIn6\u003e for net::SocketAddrV6 {\n    fn from(addr: SockaddrIn6) -\u003e Self {\n        net::SocketAddrV6::new(\n            net::Ipv6Addr::from(addr.0.sin6_addr.s6_addr),\n            u16::from_be(addr.0.sin6_port),\n            addr.0.sin6_flowinfo,\n            addr.0.sin6_scope_id,\n        )\n    }\n}\n\n#[cfg(feature = \"net\")]\nimpl From\u003cSockaddrIn6\u003e for net::SocketAddr {\n    fn from(addr: SockaddrIn6) -\u003e Self {\n        net::SocketAddr::from(net::SocketAddrV6::from(addr))\n    }\n}\n\n#[cfg(feature = \"net\")]\nimpl std::str::FromStr for SockaddrIn6 {\n    type Err = net::AddrParseError;\n\n    fn from_str(s: \u0026str) -\u003e std::result::Result\u003cSelf, Self::Err\u003e {\n        net::SocketAddrV6::from_str(s).map(SockaddrIn6::from)\n    }\n}\n\n/// A container for any sockaddr type\n///\n/// Just like C's `sockaddr_storage`, this type is large enough to hold any type\n/// of sockaddr.  It can be used as an argument with functions like\n/// [`bind`](super::bind) and [`getsockname`](super::getsockname).  Though it is\n/// a union, it can be safely accessed through the `as_*` methods.\n///\n/// # Example\n/// ```\n/// # use nix::sys::socket::*;\n/// # use std::str::FromStr;\n/// # use std::os::unix::io::AsRawFd;\n/// let localhost = SockaddrIn::from_str(\"127.0.0.1:8081\").unwrap();\n/// let fd = socket(AddressFamily::Inet, SockType::Stream, SockFlag::empty(),\n///     None).unwrap();\n/// bind(fd.as_raw_fd(), \u0026localhost).expect(\"bind\");\n/// let ss: SockaddrStorage = getsockname(fd.as_raw_fd()).expect(\"getsockname\");\n/// assert_eq!(\u0026localhost, ss.as_sockaddr_in().unwrap());\n/// ```\n#[derive(Clone, Copy, Eq)]\n#[repr(C)]\npub union SockaddrStorage {\n    #[cfg(linux_android)]\n    alg: AlgAddr,\n    #[cfg(all(\n        feature = \"net\",\n        not(any(target_os = \"hurd\", target_os = \"redox\", target_os = \"cygwin\"))\n    ))]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    dl: LinkAddr,\n    #[cfg(linux_android)]\n    nl: NetlinkAddr,\n    #[cfg(all(feature = \"ioctl\", apple_targets))]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"ioctl\")))]\n    sctl: SysControlAddr,\n    #[cfg(feature = \"net\")]\n    sin: SockaddrIn,\n    #[cfg(feature = \"net\")]\n    sin6: SockaddrIn6,\n    ss: libc::sockaddr_storage,\n    su: UnixAddr,\n    #[cfg(any(linux_android, apple_targets))]\n    vsock: VsockAddr,\n}\nimpl private::SockaddrLikePriv for SockaddrStorage {}\nimpl SockaddrLike for SockaddrStorage {\n    unsafe fn from_raw(\n        addr: *const libc::sockaddr,\n        l: Option\u003clibc::socklen_t\u003e,\n    ) -\u003e Option\u003cSelf\u003e\n    where\n        Self: Sized,\n    {\n        if addr.is_null() {\n            return None;\n        }\n        if let Some(len) = l {\n            let ulen = len as usize;\n            if ulen \u003c offset_of!(libc::sockaddr, sa_data)\n                || ulen \u003e mem::size_of::\u003clibc::sockaddr_storage\u003e()\n            {\n                None\n            } else {\n                let mut ss: libc::sockaddr_storage = unsafe { mem::zeroed() };\n                let ssp = \u0026mut ss as *mut libc::sockaddr_storage as *mut u8;\n                unsafe { ptr::copy(addr as *const u8, ssp, len as usize) };\n                #[cfg(any(\n                    linux_android,\n                    target_os = \"fuchsia\",\n                    solarish,\n                    target_os = \"cygwin\",\n                ))]\n                if i32::from(ss.ss_family) == libc::AF_UNIX {\n                    // Safe because we UnixAddr is strictly smaller than\n                    // SockaddrStorage, and we just initialized the structure.\n                    unsafe {\n                        (*(\u0026mut ss as *mut libc::sockaddr_storage\n                            as *mut UnixAddr))\n                            .sun_len = len as u8;\n                    }\n                }\n                Some(Self { ss })\n            }\n        } else {\n            // If length is not available and addr is of a fixed-length type,\n            // copy it.  If addr is of a variable length type and len is not\n            // available, then there's nothing we can do.\n            match unsafe { (*addr).sa_family as i32 } {\n                #[cfg(linux_android)]\n                libc::AF_ALG =\u003e unsafe {\n                    AlgAddr::from_raw(addr, l).map(|alg| Self { alg })\n                },\n                #[cfg(feature = \"net\")]\n                libc::AF_INET =\u003e unsafe {\n                    SockaddrIn::from_raw(addr, l).map(|sin| Self { sin })\n                },\n                #[cfg(feature = \"net\")]\n                libc::AF_INET6 =\u003e unsafe {\n                    SockaddrIn6::from_raw(addr, l).map(|sin6| Self { sin6 })\n                },\n                #[cfg(any(bsd, solarish, target_os = \"haiku\"))]\n                #[cfg(feature = \"net\")]\n                libc::AF_LINK =\u003e unsafe {\n                    LinkAddr::from_raw(addr, l).map(|dl| Self { dl })\n                },\n                #[cfg(linux_android)]\n                libc::AF_NETLINK =\u003e unsafe {\n                    NetlinkAddr::from_raw(addr, l).map(|nl| Self { nl })\n                },\n                #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n                #[cfg(feature = \"net\")]\n                libc::AF_PACKET =\u003e unsafe {\n                    LinkAddr::from_raw(addr, l).map(|dl| Self { dl })\n                },\n                #[cfg(all(feature = \"ioctl\", apple_targets))]\n                libc::AF_SYSTEM =\u003e unsafe {\n                    SysControlAddr::from_raw(addr, l).map(|sctl| Self { sctl })\n                },\n                #[cfg(any(linux_android, apple_targets))]\n                libc::AF_VSOCK =\u003e unsafe {\n                    VsockAddr::from_raw(addr, l).map(|vsock| Self { vsock })\n                },\n                _ =\u003e None,\n            }\n        }\n    }\n\n    #[cfg(any(linux_android, target_os = \"fuchsia\", solarish, target_os = \"cygwin\"))]\n    fn len(\u0026self) -\u003e libc::socklen_t {\n        match self.as_unix_addr() {\n            // The UnixAddr type knows its own length\n            Some(ua) =\u003e ua.len(),\n            // For all else, we're just a boring SockaddrStorage\n            None =\u003e mem::size_of_val(self) as libc::socklen_t,\n        }\n    }\n\n    unsafe fn set_length(\n        \u0026mut self,\n        new_length: usize,\n    ) -\u003e std::result::Result\u003c(), SocketAddressLengthNotDynamic\u003e {\n        match self.as_unix_addr_mut() {\n            Some(addr) =\u003e unsafe { addr.set_length(new_length) },\n            None =\u003e Err(SocketAddressLengthNotDynamic),\n        }\n    }\n}\n\nmacro_rules! accessors {\n    (\n        $fname:ident,\n        $fname_mut:ident,\n        $sockty:ty,\n        $family:expr,\n        $libc_ty:ty,\n        $field:ident) =\u003e {\n        /// Safely and falliably downcast to an immutable reference\n        pub fn $fname(\u0026self) -\u003e Option\u003c\u0026$sockty\u003e {\n            if self.family() == Some($family)\n                \u0026\u0026 self.len() \u003e= mem::size_of::\u003c$libc_ty\u003e() as libc::socklen_t\n            {\n                // Safe because family and len are validated\n                Some(unsafe { \u0026self.$field })\n            } else {\n                None\n            }\n        }\n\n        /// Safely and falliably downcast to a mutable reference\n        pub fn $fname_mut(\u0026mut self) -\u003e Option\u003c\u0026mut $sockty\u003e {\n            if self.family() == Some($family)\n                \u0026\u0026 self.len() \u003e= mem::size_of::\u003c$libc_ty\u003e() as libc::socklen_t\n            {\n                // Safe because family and len are validated\n                Some(unsafe { \u0026mut self.$field })\n            } else {\n                None\n            }\n        }\n    };\n}\n\nimpl SockaddrStorage {\n    /// Downcast to an immutable `[UnixAddr]` reference.\n    pub fn as_unix_addr(\u0026self) -\u003e Option\u003c\u0026UnixAddr\u003e {\n        cfg_if! {\n            if #[cfg(any(linux_android,\n                     target_os = \"fuchsia\",\n                     solarish,\n                     target_os = \"cygwin\",\n                ))]\n            {\n                let p = unsafe{ \u0026self.ss as *const libc::sockaddr_storage };\n                // Safe because UnixAddr is strictly smaller than\n                // sockaddr_storage, and we're fully initialized\n                let len = unsafe {\n                    (*(p as *const UnixAddr )).sun_len as usize\n                };\n            } else {\n                let len = self.len() as usize;\n            }\n        }\n        // Sanity checks\n        if self.family() != Some(AddressFamily::Unix)\n            || len \u003c offset_of!(libc::sockaddr_un, sun_path)\n            || len \u003e mem::size_of::\u003clibc::sockaddr_un\u003e()\n        {\n            None\n        } else {\n            Some(unsafe { \u0026self.su })\n        }\n    }\n\n    /// Downcast to a mutable `[UnixAddr]` reference.\n    pub fn as_unix_addr_mut(\u0026mut self) -\u003e Option\u003c\u0026mut UnixAddr\u003e {\n        cfg_if! {\n            if #[cfg(any(linux_android,\n                     target_os = \"fuchsia\",\n                     solarish,\n                     target_os = \"cygwin\",\n                ))]\n            {\n                let p = unsafe{ \u0026self.ss as *const libc::sockaddr_storage };\n                // Safe because UnixAddr is strictly smaller than\n                // sockaddr_storage, and we're fully initialized\n                let len = unsafe {\n                    (*(p as *const UnixAddr )).sun_len as usize\n                };\n            } else {\n                let len = self.len() as usize;\n            }\n        }\n        // Sanity checks\n        if self.family() != Some(AddressFamily::Unix)\n            || len \u003c offset_of!(libc::sockaddr_un, sun_path)\n            || len \u003e mem::size_of::\u003clibc::sockaddr_un\u003e()\n        {\n            None\n        } else {\n            Some(unsafe { \u0026mut self.su })\n        }\n    }\n\n    #[cfg(linux_android)]\n    accessors! {as_alg_addr, as_alg_addr_mut, AlgAddr,\n    AddressFamily::Alg, libc::sockaddr_alg, alg}\n\n    #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n    #[cfg(feature = \"net\")]\n    accessors! {\n    as_link_addr, as_link_addr_mut, LinkAddr,\n    AddressFamily::Packet, libc::sockaddr_ll, dl}\n\n    #[cfg(any(bsd, solarish))]\n    #[cfg(feature = \"net\")]\n    accessors! {\n    as_link_addr, as_link_addr_mut, LinkAddr,\n    AddressFamily::Link, libc::sockaddr_dl, dl}\n\n    #[cfg(feature = \"net\")]\n    accessors! {\n    as_sockaddr_in, as_sockaddr_in_mut, SockaddrIn,\n    AddressFamily::Inet, libc::sockaddr_in, sin}\n\n    #[cfg(feature = \"net\")]\n    accessors! {\n    as_sockaddr_in6, as_sockaddr_in6_mut, SockaddrIn6,\n    AddressFamily::Inet6, libc::sockaddr_in6, sin6}\n\n    #[cfg(linux_android)]\n    accessors! {as_netlink_addr, as_netlink_addr_mut, NetlinkAddr,\n    AddressFamily::Netlink, libc::sockaddr_nl, nl}\n\n    #[cfg(all(feature = \"ioctl\", apple_targets))]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"ioctl\")))]\n    accessors! {as_sys_control_addr, as_sys_control_addr_mut, SysControlAddr,\n    AddressFamily::System, libc::sockaddr_ctl, sctl}\n\n    #[cfg(any(linux_android, apple_targets))]\n    accessors! {as_vsock_addr, as_vsock_addr_mut, VsockAddr,\n    AddressFamily::Vsock, libc::sockaddr_vm, vsock}\n}\n\nimpl fmt::Debug for SockaddrStorage {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        f.debug_struct(\"SockaddrStorage\")\n            // Safe because sockaddr_storage has the least specific\n            // field types\n            .field(\"ss\", unsafe { \u0026self.ss })\n            .finish()\n    }\n}\n\nimpl fmt::Display for SockaddrStorage {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        unsafe {\n            match self.ss.ss_family as i32 {\n                #[cfg(linux_android)]\n                libc::AF_ALG =\u003e self.alg.fmt(f),\n                #[cfg(feature = \"net\")]\n                libc::AF_INET =\u003e self.sin.fmt(f),\n                #[cfg(feature = \"net\")]\n                libc::AF_INET6 =\u003e self.sin6.fmt(f),\n                #[cfg(any(bsd, solarish))]\n                #[cfg(feature = \"net\")]\n                libc::AF_LINK =\u003e self.dl.fmt(f),\n                #[cfg(linux_android)]\n                libc::AF_NETLINK =\u003e self.nl.fmt(f),\n                #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n                #[cfg(feature = \"net\")]\n                libc::AF_PACKET =\u003e self.dl.fmt(f),\n                #[cfg(apple_targets)]\n                #[cfg(feature = \"ioctl\")]\n                libc::AF_SYSTEM =\u003e self.sctl.fmt(f),\n                libc::AF_UNIX =\u003e self.su.fmt(f),\n                #[cfg(any(linux_android, apple_targets))]\n                libc::AF_VSOCK =\u003e self.vsock.fmt(f),\n                _ =\u003e \"\u003cAddress family unspecified\u003e\".fmt(f),\n            }\n        }\n    }\n}\n\n#[cfg(feature = \"net\")]\nimpl From\u003cnet::SocketAddrV4\u003e for SockaddrStorage {\n    fn from(s: net::SocketAddrV4) -\u003e Self {\n        unsafe {\n            let mut ss: Self = mem::zeroed();\n            ss.sin = SockaddrIn::from(s);\n            ss\n        }\n    }\n}\n\n#[cfg(feature = \"net\")]\nimpl From\u003cnet::SocketAddrV6\u003e for SockaddrStorage {\n    fn from(s: net::SocketAddrV6) -\u003e Self {\n        unsafe {\n            let mut ss: Self = mem::zeroed();\n            ss.sin6 = SockaddrIn6::from(s);\n            ss\n        }\n    }\n}\n\n#[cfg(feature = \"net\")]\nimpl From\u003cnet::SocketAddr\u003e for SockaddrStorage {\n    fn from(s: net::SocketAddr) -\u003e Self {\n        match s {\n            net::SocketAddr::V4(sa4) =\u003e Self::from(sa4),\n            net::SocketAddr::V6(sa6) =\u003e Self::from(sa6),\n        }\n    }\n}\n\nimpl Hash for SockaddrStorage {\n    fn hash\u003cH: Hasher\u003e(\u0026self, s: \u0026mut H) {\n        unsafe {\n            match self.ss.ss_family as i32 {\n                #[cfg(linux_android)]\n                libc::AF_ALG =\u003e self.alg.hash(s),\n                #[cfg(feature = \"net\")]\n                libc::AF_INET =\u003e self.sin.hash(s),\n                #[cfg(feature = \"net\")]\n                libc::AF_INET6 =\u003e self.sin6.hash(s),\n                #[cfg(any(bsd, solarish))]\n                #[cfg(feature = \"net\")]\n                libc::AF_LINK =\u003e self.dl.hash(s),\n                #[cfg(linux_android)]\n                libc::AF_NETLINK =\u003e self.nl.hash(s),\n                #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n                #[cfg(feature = \"net\")]\n                libc::AF_PACKET =\u003e self.dl.hash(s),\n                #[cfg(apple_targets)]\n                #[cfg(feature = \"ioctl\")]\n                libc::AF_SYSTEM =\u003e self.sctl.hash(s),\n                libc::AF_UNIX =\u003e self.su.hash(s),\n                #[cfg(any(linux_android, apple_targets))]\n                libc::AF_VSOCK =\u003e self.vsock.hash(s),\n                _ =\u003e self.ss.hash(s),\n            }\n        }\n    }\n}\n\nimpl PartialEq for SockaddrStorage {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        unsafe {\n            match (self.ss.ss_family as i32, other.ss.ss_family as i32) {\n                #[cfg(linux_android)]\n                (libc::AF_ALG, libc::AF_ALG) =\u003e self.alg == other.alg,\n                #[cfg(feature = \"net\")]\n                (libc::AF_INET, libc::AF_INET) =\u003e self.sin == other.sin,\n                #[cfg(feature = \"net\")]\n                (libc::AF_INET6, libc::AF_INET6) =\u003e self.sin6 == other.sin6,\n                #[cfg(any(bsd, solarish))]\n                #[cfg(feature = \"net\")]\n                (libc::AF_LINK, libc::AF_LINK) =\u003e self.dl == other.dl,\n                #[cfg(linux_android)]\n                (libc::AF_NETLINK, libc::AF_NETLINK) =\u003e self.nl == other.nl,\n                #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n                #[cfg(feature = \"net\")]\n                (libc::AF_PACKET, libc::AF_PACKET) =\u003e self.dl == other.dl,\n                #[cfg(apple_targets)]\n                #[cfg(feature = \"ioctl\")]\n                (libc::AF_SYSTEM, libc::AF_SYSTEM) =\u003e self.sctl == other.sctl,\n                (libc::AF_UNIX, libc::AF_UNIX) =\u003e self.su == other.su,\n                #[cfg(any(linux_android, apple_targets))]\n                (libc::AF_VSOCK, libc::AF_VSOCK) =\u003e self.vsock == other.vsock,\n                _ =\u003e false,\n            }\n        }\n    }\n}\n\npub(super) mod private {\n    pub trait SockaddrLikePriv {\n        /// Returns a mutable raw pointer to the inner structure.\n        ///\n        /// # Safety\n        ///\n        /// This method is technically safe, but modifying the inner structure's\n        /// `family` or `len` fields may result in violating Nix's invariants.\n        /// It is best to use this method only with foreign functions that do\n        /// not change the sockaddr type.\n        fn as_mut_ptr(\u0026mut self) -\u003e *mut libc::sockaddr {\n            self as *mut Self as *mut libc::sockaddr\n        }\n    }\n}\n\n#[cfg(linux_android)]\npub mod netlink {\n    use super::*;\n    use crate::sys::socket::addr::AddressFamily;\n    use libc::{sa_family_t, sockaddr_nl};\n    use std::{fmt, mem};\n\n    /// Address for the Linux kernel user interface device.\n    ///\n    /// # References\n    ///\n    /// [netlink(7)](https://man7.org/linux/man-pages/man7/netlink.7.html)\n    #[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]\n    #[repr(transparent)]\n    pub struct NetlinkAddr(pub(in super::super) sockaddr_nl);\n\n    impl NetlinkAddr {\n        /// Construct a new socket address from its port ID and multicast groups\n        /// mask.\n        pub fn new(pid: u32, groups: u32) -\u003e NetlinkAddr {\n            let mut addr: sockaddr_nl = unsafe { mem::zeroed() };\n            addr.nl_family = AddressFamily::Netlink as sa_family_t;\n            addr.nl_pid = pid;\n            addr.nl_groups = groups;\n\n            NetlinkAddr(addr)\n        }\n\n        /// Return the socket's port ID.\n        pub const fn pid(\u0026self) -\u003e u32 {\n            self.0.nl_pid\n        }\n\n        /// Return the socket's multicast groups mask\n        pub const fn groups(\u0026self) -\u003e u32 {\n            self.0.nl_groups\n        }\n    }\n\n    impl private::SockaddrLikePriv for NetlinkAddr {}\n    impl SockaddrLike for NetlinkAddr {\n        unsafe fn from_raw(\n            addr: *const libc::sockaddr,\n            len: Option\u003clibc::socklen_t\u003e,\n        ) -\u003e Option\u003cSelf\u003e\n        where\n            Self: Sized,\n        {\n            if let Some(l) = len {\n                if l != mem::size_of::\u003clibc::sockaddr_nl\u003e() as libc::socklen_t {\n                    return None;\n                }\n            }\n            if unsafe { (*addr).sa_family as i32 != libc::AF_NETLINK } {\n                return None;\n            }\n            Some(Self(unsafe { ptr::read_unaligned(addr as *const _) }))\n        }\n    }\n\n    impl AsRef\u003clibc::sockaddr_nl\u003e for NetlinkAddr {\n        fn as_ref(\u0026self) -\u003e \u0026libc::sockaddr_nl {\n            \u0026self.0\n        }\n    }\n\n    impl fmt::Display for NetlinkAddr {\n        fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            write!(f, \"pid: {} groups: {}\", self.pid(), self.groups())\n        }\n    }\n}\n\n#[cfg(linux_android)]\npub mod alg {\n    use super::*;\n    use libc::{sockaddr_alg, AF_ALG};\n    use std::ffi::CStr;\n    use std::hash::{Hash, Hasher};\n    use std::{fmt, mem, str};\n\n    /// Socket address for the Linux kernel crypto API\n    #[derive(Copy, Clone)]\n    #[repr(transparent)]\n    pub struct AlgAddr(pub(in super::super) sockaddr_alg);\n\n    impl private::SockaddrLikePriv for AlgAddr {}\n    impl SockaddrLike for AlgAddr {\n        unsafe fn from_raw(\n            addr: *const libc::sockaddr,\n            l: Option\u003clibc::socklen_t\u003e,\n        ) -\u003e Option\u003cSelf\u003e\n        where\n            Self: Sized,\n        {\n            if let Some(l) = l {\n                if l != mem::size_of::\u003clibc::sockaddr_alg\u003e() as libc::socklen_t\n                {\n                    return None;\n                }\n            }\n            if unsafe { (*addr).sa_family as i32 != libc::AF_ALG } {\n                return None;\n            }\n            Some(Self(unsafe { ptr::read_unaligned(addr as *const _) }))\n        }\n    }\n\n    impl AsRef\u003clibc::sockaddr_alg\u003e for AlgAddr {\n        fn as_ref(\u0026self) -\u003e \u0026libc::sockaddr_alg {\n            \u0026self.0\n        }\n    }\n\n    // , PartialEq, Eq, Debug, Hash\n    impl PartialEq for AlgAddr {\n        fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n            let (inner, other) = (self.0, other.0);\n            (\n                inner.salg_family,\n                \u0026inner.salg_type[..],\n                inner.salg_feat,\n                inner.salg_mask,\n                \u0026inner.salg_name[..],\n            ) == (\n                other.salg_family,\n                \u0026other.salg_type[..],\n                other.salg_feat,\n                other.salg_mask,\n                \u0026other.salg_name[..],\n            )\n        }\n    }\n\n    impl Eq for AlgAddr {}\n\n    impl Hash for AlgAddr {\n        fn hash\u003cH: Hasher\u003e(\u0026self, s: \u0026mut H) {\n            let inner = self.0;\n            (\n                inner.salg_family,\n                \u0026inner.salg_type[..],\n                inner.salg_feat,\n                inner.salg_mask,\n                \u0026inner.salg_name[..],\n            )\n                .hash(s);\n        }\n    }\n\n    impl AlgAddr {\n        /// Construct an `AF_ALG` socket from its cipher name and type.\n        pub fn new(alg_type: \u0026str, alg_name: \u0026str) -\u003e AlgAddr {\n            let mut addr: sockaddr_alg = unsafe { mem::zeroed() };\n            addr.salg_family = AF_ALG as u16;\n            addr.salg_type[..alg_type.len()]\n                .copy_from_slice(alg_type.to_string().as_bytes());\n            addr.salg_name[..alg_name.len()]\n                .copy_from_slice(alg_name.to_string().as_bytes());\n\n            AlgAddr(addr)\n        }\n\n        /// Return the socket's cipher type, for example `hash` or `aead`.\n        pub fn alg_type(\u0026self) -\u003e \u0026CStr {\n            unsafe { CStr::from_ptr(self.0.salg_type.as_ptr().cast()) }\n        }\n\n        /// Return the socket's cipher name, for example `sha1`.\n        pub fn alg_name(\u0026self) -\u003e \u0026CStr {\n            unsafe { CStr::from_ptr(self.0.salg_name.as_ptr().cast()) }\n        }\n    }\n\n    impl fmt::Display for AlgAddr {\n        fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            write!(\n                f,\n                \"type: {} alg: {}\",\n                self.alg_name().to_string_lossy(),\n                self.alg_type().to_string_lossy()\n            )\n        }\n    }\n\n    impl fmt::Debug for AlgAddr {\n        fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            fmt::Display::fmt(self, f)\n        }\n    }\n}\n\nfeature! {\n#![feature = \"ioctl\"]\n#[cfg(apple_targets)]\npub mod sys_control {\n    use crate::sys::socket::addr::AddressFamily;\n    use libc::{self, c_uchar};\n    use std::{fmt, mem, ptr};\n    use std::os::unix::io::RawFd;\n    use crate::{Errno, Result};\n    use super::{private, SockaddrLike};\n\n    // FIXME: Move type into `libc`\n    #[repr(C)]\n    #[derive(Clone, Copy)]\n    #[allow(missing_debug_implementations)]\n    pub struct ctl_ioc_info {\n        pub ctl_id: u32,\n        pub ctl_name: [c_uchar; MAX_KCTL_NAME],\n    }\n\n    const CTL_IOC_MAGIC: u8 = b'N';\n    const CTL_IOC_INFO: u8 = 3;\n    const MAX_KCTL_NAME: usize = 96;\n\n    ioctl_readwrite!(ctl_info, CTL_IOC_MAGIC, CTL_IOC_INFO, ctl_ioc_info);\n\n    /// Apple system control socket\n    ///\n    /// # References\n    ///\n    /// \u003chttps://developer.apple.com/documentation/kernel/sockaddr_ctl\u003e\n    #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\n    #[repr(transparent)]\n    pub struct SysControlAddr(pub(in super::super) libc::sockaddr_ctl);\n\n    impl private::SockaddrLikePriv for SysControlAddr {}\n    impl SockaddrLike for SysControlAddr {\n        unsafe fn from_raw(addr: *const libc::sockaddr, len: Option\u003clibc::socklen_t\u003e)\n            -\u003e Option\u003cSelf\u003e where Self: Sized\n        {\n            if let Some(l) = len {\n                if l != mem::size_of::\u003clibc::sockaddr_ctl\u003e() as libc::socklen_t {\n                    return None;\n                }\n            }\n            if unsafe { (*addr).sa_family as i32 != libc::AF_SYSTEM } {\n                return None;\n            }\n            Some(Self(unsafe { ptr::read_unaligned(addr as *const _) } ))\n        }\n    }\n\n    impl AsRef\u003clibc::sockaddr_ctl\u003e for SysControlAddr {\n        fn as_ref(\u0026self) -\u003e \u0026libc::sockaddr_ctl {\n            \u0026self.0\n        }\n    }\n\n    impl SysControlAddr {\n        /// Construct a new `SysControlAddr` from its kernel unique identifier\n        /// and unit number.\n        pub const fn new(id: u32, unit: u32) -\u003e SysControlAddr {\n            let addr = libc::sockaddr_ctl {\n                sc_len: mem::size_of::\u003clibc::sockaddr_ctl\u003e() as c_uchar,\n                sc_family: AddressFamily::System as c_uchar,\n                ss_sysaddr: libc::AF_SYS_CONTROL as u16,\n                sc_id: id,\n                sc_unit: unit,\n                sc_reserved: [0; 5]\n            };\n\n            SysControlAddr(addr)\n        }\n\n        /// Construct a new `SysControlAddr` from its human readable name and\n        /// unit number.\n        pub fn from_name(sockfd: RawFd, name: \u0026str, unit: u32) -\u003e Result\u003cSysControlAddr\u003e {\n            if name.len() \u003e MAX_KCTL_NAME {\n                return Err(Errno::ENAMETOOLONG);\n            }\n\n            let mut ctl_name = [0; MAX_KCTL_NAME];\n            ctl_name[..name.len()].clone_from_slice(name.as_bytes());\n            let mut info = ctl_ioc_info { ctl_id: 0, ctl_name };\n\n            unsafe { ctl_info(sockfd, \u0026mut info)?; }\n\n            Ok(SysControlAddr::new(info.ctl_id, unit))\n        }\n\n        /// Return the kernel unique identifier\n        pub const fn id(\u0026self) -\u003e u32 {\n            self.0.sc_id\n        }\n\n        /// Return the kernel controller private unit number.\n        pub const fn unit(\u0026self) -\u003e u32 {\n            self.0.sc_unit\n        }\n    }\n\n    impl fmt::Display for SysControlAddr {\n        fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            fmt::Debug::fmt(self, f)\n        }\n    }\n}\n}\n\n#[cfg(any(linux_android, target_os = \"fuchsia\"))]\nmod datalink {\n    feature! {\n    #![feature = \"net\"]\n    use super::{fmt, mem, private, ptr, SockaddrLike};\n\n    /// Hardware Address\n    #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\n    #[repr(transparent)]\n    pub struct LinkAddr(pub(in super::super) libc::sockaddr_ll);\n\n    impl LinkAddr {\n        /// Physical-layer protocol\n        pub fn protocol(\u0026self) -\u003e u16 {\n            self.0.sll_protocol\n        }\n\n        /// Interface number\n        pub fn ifindex(\u0026self) -\u003e usize {\n            self.0.sll_ifindex as usize\n        }\n\n        /// ARP hardware type\n        pub fn hatype(\u0026self) -\u003e u16 {\n            self.0.sll_hatype\n        }\n\n        /// Packet type\n        pub fn pkttype(\u0026self) -\u003e u8 {\n            self.0.sll_pkttype\n        }\n\n        /// Length of MAC address\n        pub fn halen(\u0026self) -\u003e usize {\n            self.0.sll_halen as usize\n        }\n\n        /// Physical-layer address (MAC)\n        // Returns an Option just for cross-platform compatibility\n        pub fn addr(\u0026self) -\u003e Option\u003c[u8; 6]\u003e {\n            Some([\n                self.0.sll_addr[0],\n                self.0.sll_addr[1],\n                self.0.sll_addr[2],\n                self.0.sll_addr[3],\n                self.0.sll_addr[4],\n                self.0.sll_addr[5],\n            ])\n        }\n    }\n\n    impl fmt::Display for LinkAddr {\n        fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            if let Some(addr) = self.addr() {\n                write!(f, \"{:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}\",\n                    addr[0],\n                    addr[1],\n                    addr[2],\n                    addr[3],\n                    addr[4],\n                    addr[5])\n            } else {\n                Ok(())\n            }\n        }\n    }\n    impl private::SockaddrLikePriv for LinkAddr {}\n    impl SockaddrLike for LinkAddr {\n        unsafe fn from_raw(addr: *const libc::sockaddr,\n                           len: Option\u003clibc::socklen_t\u003e)\n            -\u003e Option\u003cSelf\u003e where Self: Sized\n        {\n            if let Some(l) = len {\n                if l != mem::size_of::\u003clibc::sockaddr_ll\u003e() as libc::socklen_t {\n                    return None;\n                }\n            }\n            if unsafe { (*addr).sa_family as i32 != libc::AF_PACKET } {\n                return None;\n            }\n            Some(Self(unsafe { ptr::read_unaligned(addr as *const _) }))\n        }\n    }\n\n    impl AsRef\u003clibc::sockaddr_ll\u003e for LinkAddr {\n        fn as_ref(\u0026self) -\u003e \u0026libc::sockaddr_ll {\n            \u0026self.0\n        }\n    }\n\n    }\n}\n\n#[cfg(any(bsd, solarish, target_os = \"haiku\", target_os = \"aix\"))]\nmod datalink {\n    feature! {\n    #![feature = \"net\"]\n    use super::{fmt, mem, private, ptr, SockaddrLike};\n\n    /// Hardware Address\n    #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\n    #[repr(transparent)]\n    pub struct LinkAddr(pub(in super::super) libc::sockaddr_dl);\n\n    impl LinkAddr {\n        /// interface index, if != 0, system given index for interface\n        #[cfg(not(target_os = \"haiku\"))]\n        pub fn ifindex(\u0026self) -\u003e usize {\n            self.0.sdl_index as usize\n        }\n\n        /// Datalink type\n        #[cfg(not(target_os = \"haiku\"))]\n        pub fn datalink_type(\u0026self) -\u003e u8 {\n            self.0.sdl_type\n        }\n\n        /// MAC address start position\n        pub fn nlen(\u0026self) -\u003e usize {\n            self.0.sdl_nlen as usize\n        }\n\n        /// link level address length\n        pub fn alen(\u0026self) -\u003e usize {\n            self.0.sdl_alen as usize\n        }\n\n        /// link layer selector length\n        #[cfg(not(target_os = \"haiku\"))]\n        pub fn slen(\u0026self) -\u003e usize {\n            self.0.sdl_slen as usize\n        }\n\n        /// if link level address length == 0,\n        /// or `sdl_data` not be larger.\n        pub fn is_empty(\u0026self) -\u003e bool {\n            let nlen = self.nlen();\n            let alen = self.alen();\n            let data_len = self.0.sdl_data.len();\n\n            alen == 0 || nlen + alen \u003e= data_len\n        }\n\n        /// Physical-layer address (MAC)\n        // The cast is not unnecessary on all platforms.\n        #[allow(clippy::unnecessary_cast)]\n        pub fn addr(\u0026self) -\u003e Option\u003c[u8; 6]\u003e {\n            let nlen = self.nlen();\n            let data = self.0.sdl_data;\n\n            if self.is_empty() {\n                None\n            } else {\n                Some([\n                    data[nlen] as u8,\n                    data[nlen + 1] as u8,\n                    data[nlen + 2] as u8,\n                    data[nlen + 3] as u8,\n                    data[nlen + 4] as u8,\n                    data[nlen + 5] as u8,\n                ])\n            }\n        }\n    }\n\n    impl fmt::Display for LinkAddr {\n        fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            if let Some(addr) = self.addr() {\n                write!(f, \"{:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}\",\n                    addr[0],\n                    addr[1],\n                    addr[2],\n                    addr[3],\n                    addr[4],\n                    addr[5])\n            } else {\n                Ok(())\n            }\n        }\n    }\n    impl private::SockaddrLikePriv for LinkAddr {}\n    impl SockaddrLike for LinkAddr {\n        unsafe fn from_raw(addr: *const libc::sockaddr,\n                           len: Option\u003clibc::socklen_t\u003e)\n            -\u003e Option\u003cSelf\u003e where Self: Sized\n        {\n            if let Some(l) = len {\n                if l != mem::size_of::\u003clibc::sockaddr_dl\u003e() as libc::socklen_t {\n                    return None;\n                }\n            }\n            if unsafe { (*addr).sa_family as i32 != libc::AF_LINK } {\n                return None;\n            }\n            Some(Self(unsafe { ptr::read_unaligned(addr as *const _) }))\n        }\n    }\n\n    impl AsRef\u003clibc::sockaddr_dl\u003e for LinkAddr {\n        fn as_ref(\u0026self) -\u003e \u0026libc::sockaddr_dl {\n            \u0026self.0\n        }\n    }\n    }\n}\n\n#[cfg(any(linux_android, apple_targets))]\npub mod vsock {\n    use super::*;\n    use crate::sys::socket::addr::AddressFamily;\n    use libc::{sa_family_t, sockaddr_vm};\n    use std::hash::{Hash, Hasher};\n    use std::{fmt, mem};\n\n    /// Socket address for VMWare VSockets protocol\n    ///\n    /// # References\n    ///\n    /// [vsock(7)](https://man7.org/linux/man-pages/man7/vsock.7.html)\n    #[derive(Copy, Clone)]\n    #[repr(transparent)]\n    pub struct VsockAddr(pub(in super::super) sockaddr_vm);\n\n    impl private::SockaddrLikePriv for VsockAddr {}\n    impl SockaddrLike for VsockAddr {\n        unsafe fn from_raw(\n            addr: *const libc::sockaddr,\n            len: Option\u003clibc::socklen_t\u003e,\n        ) -\u003e Option\u003cSelf\u003e\n        where\n            Self: Sized,\n        {\n            if let Some(l) = len {\n                if l != mem::size_of::\u003clibc::sockaddr_vm\u003e() as libc::socklen_t {\n                    return None;\n                }\n            }\n            if unsafe { (*addr).sa_family as i32 != libc::AF_VSOCK } {\n                return None;\n            }\n            unsafe { Some(Self(ptr::read_unaligned(addr as *const _))) }\n        }\n    }\n\n    impl AsRef\u003clibc::sockaddr_vm\u003e for VsockAddr {\n        fn as_ref(\u0026self) -\u003e \u0026libc::sockaddr_vm {\n            \u0026self.0\n        }\n    }\n\n    impl PartialEq for VsockAddr {\n        #[cfg(linux_android)]\n        fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n            let (inner, other) = (self.0, other.0);\n            (inner.svm_family, inner.svm_cid, inner.svm_port)\n                == (other.svm_family, other.svm_cid, other.svm_port)\n        }\n        #[cfg(apple_targets)]\n        fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n            let (inner, other) = (self.0, other.0);\n            (\n                inner.svm_family,\n                inner.svm_cid,\n                inner.svm_port,\n                inner.svm_len,\n            ) == (\n                other.svm_family,\n                other.svm_cid,\n                other.svm_port,\n                inner.svm_len,\n            )\n        }\n    }\n\n    impl Eq for VsockAddr {}\n\n    impl Hash for VsockAddr {\n        #[cfg(linux_android)]\n        fn hash\u003cH: Hasher\u003e(\u0026self, s: \u0026mut H) {\n            let inner = self.0;\n            (inner.svm_family, inner.svm_cid, inner.svm_port).hash(s);\n        }\n        #[cfg(apple_targets)]\n        fn hash\u003cH: Hasher\u003e(\u0026self, s: \u0026mut H) {\n            let inner = self.0;\n            (\n                inner.svm_family,\n                inner.svm_cid,\n                inner.svm_port,\n                inner.svm_len,\n            )\n                .hash(s);\n        }\n    }\n\n    /// VSOCK Address\n    ///\n    /// The address for AF_VSOCK socket is defined as a combination of a\n    /// 32-bit Context Identifier (CID) and a 32-bit port number.\n    impl VsockAddr {\n        /// Construct a `VsockAddr` from its raw fields.\n        pub fn new(cid: u32, port: u32) -\u003e VsockAddr {\n            let mut addr: sockaddr_vm = unsafe { mem::zeroed() };\n            addr.svm_family = AddressFamily::Vsock as sa_family_t;\n            addr.svm_cid = cid;\n            addr.svm_port = port;\n\n            #[cfg(apple_targets)]\n            {\n                addr.svm_len = std::mem::size_of::\u003csockaddr_vm\u003e() as u8;\n            }\n            VsockAddr(addr)\n        }\n\n        /// Context Identifier (CID)\n        pub fn cid(\u0026self) -\u003e u32 {\n            self.0.svm_cid\n        }\n\n        /// Port number\n        pub fn port(\u0026self) -\u003e u32 {\n            self.0.svm_port\n        }\n    }\n\n    impl fmt::Display for VsockAddr {\n        fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            write!(f, \"cid: {} port: {}\", self.cid(), self.port())\n        }\n    }\n\n    impl fmt::Debug for VsockAddr {\n        fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            fmt::Display::fmt(self, f)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    mod types {\n        use super::*;\n\n        #[test]\n        fn test_ipv4addr_to_libc() {\n            let s = std::net::Ipv4Addr::new(1, 2, 3, 4);\n            let l = ipv4addr_to_libc(s);\n            assert_eq!(l.s_addr, u32::to_be(0x01020304));\n        }\n\n        #[test]\n        fn test_ipv6addr_to_libc() {\n            let s = std::net::Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8);\n            let l = ipv6addr_to_libc(\u0026s);\n            assert_eq!(\n                l.s6_addr,\n                [0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0, 8]\n            );\n        }\n    }\n\n    #[cfg(not(any(target_os = \"hurd\", target_os = \"redox\", target_os = \"cygwin\")))]\n    #[allow(clippy::cast_ptr_alignment)]\n    mod link {\n        #[cfg(any(apple_targets, solarish))]\n        use super::super::super::socklen_t;\n        use super::*;\n\n        /// Don't panic when trying to display an empty datalink address\n        #[cfg(bsd)]\n        #[test]\n        fn test_datalink_display() {\n            use super::super::LinkAddr;\n            use std::mem;\n\n            let la = LinkAddr(libc::sockaddr_dl {\n                sdl_len: 56,\n                sdl_family: 18,\n                sdl_index: 5,\n                sdl_type: 24,\n                sdl_nlen: 3,\n                sdl_alen: 0,\n                sdl_slen: 0,\n                ..unsafe { mem::zeroed() }\n            });\n            let _ = format!(\"{la}\");\n        }\n\n        #[cfg(all(\n            any(linux_android, target_os = \"fuchsia\"),\n            target_endian = \"little\"\n        ))]\n        #[test]\n        fn linux_loopback() {\n            #[repr(align(2))]\n            struct Raw([u8; 20]);\n\n            let bytes = Raw([\n                17u8, 0, 0, 0, 1, 0, 0, 0, 4, 3, 0, 6, 1, 2, 3, 4, 5, 6, 0, 0,\n            ]);\n            let sa = bytes.0.as_ptr().cast();\n            let len = None;\n            let sock_addr =\n                unsafe { SockaddrStorage::from_raw(sa, len) }.unwrap();\n            assert_eq!(sock_addr.family(), Some(AddressFamily::Packet));\n            match sock_addr.as_link_addr() {\n                Some(dl) =\u003e assert_eq!(dl.addr(), Some([1, 2, 3, 4, 5, 6])),\n                None =\u003e panic!(\"Can't unwrap sockaddr storage\"),\n            }\n        }\n\n        #[cfg(apple_targets)]\n        #[test]\n        fn macos_loopback() {\n            let bytes =\n                [20i8, 18, 1, 0, 24, 3, 0, 0, 108, 111, 48, 0, 0, 0, 0, 0];\n            let sa = bytes.as_ptr().cast();\n            let len = Some(bytes.len() as socklen_t);\n            let sock_addr =\n                unsafe { SockaddrStorage::from_raw(sa, len) }.unwrap();\n            assert_eq!(sock_addr.family(), Some(AddressFamily::Link));\n            match sock_addr.as_link_addr() {\n                Some(dl) =\u003e {\n                    assert!(dl.addr().is_none());\n                }\n                None =\u003e panic!(\"Can't unwrap sockaddr storage\"),\n            }\n        }\n\n        #[cfg(apple_targets)]\n        #[test]\n        fn macos_tap() {\n            let bytes = [\n                20i8, 18, 7, 0, 6, 3, 6, 0, 101, 110, 48, 24, 101, -112, -35,\n                76, -80,\n            ];\n            let ptr = bytes.as_ptr();\n            let sa = ptr as *const libc::sockaddr;\n            let len = Some(bytes.len() as socklen_t);\n\n            let sock_addr =\n                unsafe { SockaddrStorage::from_raw(sa, len).unwrap() };\n            assert_eq!(sock_addr.family(), Some(AddressFamily::Link));\n            match sock_addr.as_link_addr() {\n                Some(dl) =\u003e {\n                    assert_eq!(dl.addr(), Some([24u8, 101, 144, 221, 76, 176]))\n                }\n                None =\u003e panic!(\"Can't unwrap sockaddr storage\"),\n            }\n        }\n\n        #[cfg(solarish)]\n        #[test]\n        fn solarish_tap() {\n            let bytes = [25u8, 0, 0, 0, 6, 0, 6, 0, 24, 101, 144, 221, 76, 176];\n            let ptr = bytes.as_ptr();\n            let sa = ptr as *const libc::sockaddr;\n            let len = Some(bytes.len() as socklen_t);\n            let _sock_addr = unsafe { SockaddrStorage::from_raw(sa, len) };\n\n            assert!(_sock_addr.is_some());\n\n            let sock_addr = _sock_addr.unwrap();\n\n            assert_eq!(sock_addr.family().unwrap(), AddressFamily::Link);\n\n            assert_eq!(\n                sock_addr.as_link_addr().unwrap().addr(),\n                Some([24u8, 101, 144, 221, 76, 176])\n            );\n        }\n\n        #[test]\n        fn size() {\n            #[cfg(any(bsd, target_os = \"aix\", solarish, target_os = \"haiku\"))]\n            let l = mem::size_of::\u003clibc::sockaddr_dl\u003e();\n            #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n            let l = mem::size_of::\u003clibc::sockaddr_ll\u003e();\n            assert_eq!(LinkAddr::size() as usize, l);\n        }\n    }\n\n    mod sockaddr_in {\n        use super::*;\n        use std::str::FromStr;\n\n        #[test]\n        fn display() {\n            let s = \"127.0.0.1:8080\";\n            let addr = SockaddrIn::from_str(s).unwrap();\n            assert_eq!(s, format!(\"{addr}\"));\n        }\n\n        #[test]\n        fn size() {\n            assert_eq!(\n                mem::size_of::\u003clibc::sockaddr_in\u003e(),\n                SockaddrIn::size() as usize\n            );\n        }\n\n        #[test]\n        fn ip() {\n            let s = \"127.0.0.1:8082\";\n            let ip = SockaddrIn::from_str(s).unwrap().ip();\n            assert_eq!(\"127.0.0.1\", format!(\"{ip}\"));\n        }\n    }\n\n    mod sockaddr_in6 {\n        use super::*;\n        use std::str::FromStr;\n\n        #[test]\n        fn display() {\n            let s = \"[1234:5678:90ab:cdef::1111:2222]:8080\";\n            let addr = SockaddrIn6::from_str(s).unwrap();\n            assert_eq!(s, format!(\"{addr}\"));\n        }\n\n        #[test]\n        fn size() {\n            assert_eq!(\n                mem::size_of::\u003clibc::sockaddr_in6\u003e(),\n                SockaddrIn6::size() as usize\n            );\n        }\n\n        #[test]\n        fn ip() {\n            let s = \"[1234:5678:90ab:cdef::1111:2222]:8080\";\n            let ip = SockaddrIn6::from_str(s).unwrap().ip();\n            assert_eq!(\"1234:5678:90ab:cdef::1111:2222\", format!(\"{ip}\"));\n        }\n\n        #[test]\n        // Ensure that we can convert to-and-from std::net variants without change.\n        fn to_and_from() {\n            let s = \"[1234:5678:90ab:cdef::1111:2222]:8080\";\n            let mut nix_sin6 = SockaddrIn6::from_str(s).unwrap();\n            nix_sin6.0.sin6_flowinfo = 0x12345678;\n            nix_sin6.0.sin6_scope_id = 0x9abcdef0;\n\n            let std_sin6: std::net::SocketAddrV6 = nix_sin6.into();\n            assert_eq!(nix_sin6, std_sin6.into());\n        }\n    }\n\n    mod sockaddr_storage {\n        use super::*;\n\n        #[test]\n        fn from_sockaddr_un_named() {\n            let ua = UnixAddr::new(\"/var/run/mysock\").unwrap();\n            let ptr = ua.as_ptr().cast();\n            let ss = unsafe { SockaddrStorage::from_raw(ptr, Some(ua.len())) }\n                .unwrap();\n            assert_eq!(ss.len(), ua.len());\n        }\n\n        #[cfg(linux_android)]\n        #[test]\n        fn from_sockaddr_un_abstract_named() {\n            let name = String::from(\"nix\\0abstract\\0test\");\n            let ua = UnixAddr::new_abstract(name.as_bytes()).unwrap();\n            let ptr = ua.as_ptr().cast();\n            let ss = unsafe { SockaddrStorage::from_raw(ptr, Some(ua.len())) }\n                .unwrap();\n            assert_eq!(ss.len(), ua.len());\n        }\n\n        #[cfg(linux_android)]\n        #[test]\n        fn from_sockaddr_un_abstract_unnamed() {\n            let ua = UnixAddr::new_unnamed();\n            let ptr = ua.as_ptr().cast();\n            let ss = unsafe { SockaddrStorage::from_raw(ptr, Some(ua.len())) }\n                .unwrap();\n            assert_eq!(ss.len(), ua.len());\n        }\n    }\n\n    mod unixaddr {\n        use super::*;\n\n        #[cfg(linux_android)]\n        #[test]\n        fn abstract_sun_path() {\n            let name = String::from(\"nix\\0abstract\\0test\");\n            let addr = UnixAddr::new_abstract(name.as_bytes()).unwrap();\n\n            let sun_path1 =\n                unsafe { \u0026(\u0026(*addr.as_ptr()).sun_path)[..addr.path_len()] };\n            let sun_path2 = [\n                0, 110, 105, 120, 0, 97, 98, 115, 116, 114, 97, 99, 116, 0,\n                116, 101, 115, 116,\n            ];\n            assert_eq!(sun_path1, sun_path2);\n        }\n\n        #[test]\n        fn size() {\n            assert_eq!(\n                mem::size_of::\u003clibc::sockaddr_un\u003e(),\n                UnixAddr::size() as usize\n            );\n        }\n    }\n}\n","traces":[{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":1461,"address":[],"length":0,"stats":{"Line":0}},{"line":1463,"address":[],"length":0,"stats":{"Line":0}},{"line":1465,"address":[],"length":0,"stats":{"Line":0}},{"line":1467,"address":[],"length":0,"stats":{"Line":0}},{"line":1469,"address":[],"length":0,"stats":{"Line":0}},{"line":1472,"address":[],"length":0,"stats":{"Line":0}},{"line":1474,"address":[],"length":0,"stats":{"Line":0}},{"line":1477,"address":[],"length":0,"stats":{"Line":0}},{"line":1480,"address":[],"length":0,"stats":{"Line":0}},{"line":1481,"address":[],"length":0,"stats":{"Line":0}},{"line":1483,"address":[],"length":0,"stats":{"Line":0}},{"line":1484,"address":[],"length":0,"stats":{"Line":0}},{"line":1530,"address":[],"length":0,"stats":{"Line":0}},{"line":1531,"address":[],"length":0,"stats":{"Line":0}},{"line":1673,"address":[],"length":0,"stats":{"Line":0}},{"line":1674,"address":[],"length":0,"stats":{"Line":0}},{"line":1676,"address":[],"length":0,"stats":{"Line":0}},{"line":1677,"address":[],"length":0,"stats":{"Line":0}},{"line":1678,"address":[],"length":0,"stats":{"Line":0}},{"line":1679,"address":[],"length":0,"stats":{"Line":0}},{"line":1680,"address":[],"length":0,"stats":{"Line":0}},{"line":1682,"address":[],"length":0,"stats":{"Line":0}},{"line":2115,"address":[],"length":0,"stats":{"Line":0}},{"line":2116,"address":[],"length":0,"stats":{"Line":0}},{"line":2117,"address":[],"length":0,"stats":{"Line":0}},{"line":2120,"address":[],"length":0,"stats":{"Line":0}},{"line":2121,"address":[],"length":0,"stats":{"Line":0}},{"line":2123,"address":[],"length":0,"stats":{"Line":0}},{"line":2124,"address":[],"length":0,"stats":{"Line":0}},{"line":2125,"address":[],"length":0,"stats":{"Line":0}},{"line":2126,"address":[],"length":0,"stats":{"Line":0}},{"line":2128,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":84},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","socket","mod.rs"],"content":"//! Socket interface functions\n//!\n//! [Further reading](https://man7.org/linux/man-pages/man7/socket.7.html)\n#[cfg(any(target_os = \"freebsd\", linux_android))]\n#[cfg(feature = \"uio\")]\nuse crate::sys::time::TimeSpec;\n#[cfg(not(target_os = \"redox\"))]\n#[cfg(feature = \"uio\")]\nuse crate::sys::time::TimeVal;\nuse crate::{errno::Errno, Result};\nuse cfg_if::cfg_if;\nuse libc::{self, c_int, size_t, socklen_t};\n#[cfg(all(feature = \"uio\", not(target_os = \"redox\")))]\nuse libc::{\n    c_void, iovec, CMSG_DATA, CMSG_FIRSTHDR, CMSG_LEN, CMSG_NXTHDR, CMSG_SPACE,\n    MSG_CTRUNC,\n};\n#[cfg(not(target_os = \"redox\"))]\nuse std::io::{IoSlice, IoSliceMut};\n#[cfg(feature = \"net\")]\nuse std::net;\nuse std::os::unix::io::{AsFd, AsRawFd, FromRawFd, OwnedFd, RawFd};\nuse std::{mem, ptr};\n\n#[deny(missing_docs)]\nmod addr;\n#[deny(missing_docs)]\npub mod sockopt;\n\n/*\n *\n * ===== Re-exports =====\n *\n */\n\npub use self::addr::{SockaddrLike, SockaddrStorage};\n\n#[cfg(solarish)]\npub use self::addr::{AddressFamily, UnixAddr};\n#[cfg(not(solarish))]\npub use self::addr::{AddressFamily, UnixAddr};\n#[cfg(not(any(\n    solarish,\n    target_os = \"haiku\",\n    target_os = \"hurd\",\n    target_os = \"redox\",\n    target_os = \"cygwin\",\n)))]\n#[cfg(feature = \"net\")]\npub use self::addr::{LinkAddr, SockaddrIn, SockaddrIn6};\n#[cfg(any(\n    solarish,\n    target_os = \"haiku\",\n    target_os = \"hurd\",\n    target_os = \"redox\",\n    target_os = \"cygwin\",\n))]\n#[cfg(feature = \"net\")]\npub use self::addr::{SockaddrIn, SockaddrIn6};\n\n#[cfg(linux_android)]\npub use crate::sys::socket::addr::alg::AlgAddr;\n#[cfg(linux_android)]\npub use crate::sys::socket::addr::netlink::NetlinkAddr;\n#[cfg(apple_targets)]\n#[cfg(feature = \"ioctl\")]\npub use crate::sys::socket::addr::sys_control::SysControlAddr;\n#[cfg(any(linux_android, apple_targets))]\npub use crate::sys::socket::addr::vsock::VsockAddr;\n\n#[cfg(all(feature = \"uio\", not(target_os = \"redox\")))]\npub use libc::{cmsghdr, msghdr};\npub use libc::{sa_family_t, sockaddr, sockaddr_storage, sockaddr_un};\n#[cfg(feature = \"net\")]\npub use libc::{sockaddr_in, sockaddr_in6};\n\n#[cfg(feature = \"net\")]\nuse crate::sys::socket::addr::{ipv4addr_to_libc, ipv6addr_to_libc};\n\n/// These constants are used to specify the communication semantics\n/// when creating a socket with [`socket()`](fn.socket.html)\n#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n#[repr(i32)]\n#[non_exhaustive]\npub enum SockType {\n    /// Provides sequenced, reliable, two-way, connection-\n    /// based byte streams.  An out-of-band data transmission\n    /// mechanism may be supported.\n    Stream = libc::SOCK_STREAM,\n    /// Supports datagrams (connectionless, unreliable\n    /// messages of a fixed maximum length).\n    Datagram = libc::SOCK_DGRAM,\n    /// Provides a sequenced, reliable, two-way connection-\n    /// based data transmission path for datagrams of fixed\n    /// maximum length; a consumer is required to read an\n    /// entire packet with each input system call.\n    SeqPacket = libc::SOCK_SEQPACKET,\n    /// Provides raw network protocol access.\n    #[cfg(not(target_os = \"redox\"))]\n    Raw = libc::SOCK_RAW,\n    /// Provides a reliable datagram layer that does not\n    /// guarantee ordering.\n    #[cfg(not(any(target_os = \"haiku\", target_os = \"redox\")))]\n    Rdm = libc::SOCK_RDM,\n}\n// The TryFrom impl could've been derived using libc_enum!.  But for\n// backwards-compatibility with Nix-0.25.0 we manually implement it, so as to\n// keep the old variant names.\nimpl TryFrom\u003ci32\u003e for SockType {\n    type Error = crate::Error;\n\n    fn try_from(x: i32) -\u003e Result\u003cSelf\u003e {\n        match x {\n            libc::SOCK_STREAM =\u003e Ok(Self::Stream),\n            libc::SOCK_DGRAM =\u003e Ok(Self::Datagram),\n            libc::SOCK_SEQPACKET =\u003e Ok(Self::SeqPacket),\n            #[cfg(not(target_os = \"redox\"))]\n            libc::SOCK_RAW =\u003e Ok(Self::Raw),\n            #[cfg(not(any(target_os = \"haiku\", target_os = \"redox\")))]\n            libc::SOCK_RDM =\u003e Ok(Self::Rdm),\n            _ =\u003e Err(Errno::EINVAL),\n        }\n    }\n}\n\n/// Constants used in [`socket`](fn.socket.html) and [`socketpair`](fn.socketpair.html)\n/// to specify the protocol to use.\n#[repr(i32)]\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\n#[non_exhaustive]\npub enum SockProtocol {\n    /// TCP protocol ([ip(7)](https://man7.org/linux/man-pages/man7/ip.7.html))\n    Tcp = libc::IPPROTO_TCP,\n    /// UDP protocol ([ip(7)](https://man7.org/linux/man-pages/man7/ip.7.html))\n    Udp = libc::IPPROTO_UDP,\n    /// Raw sockets ([raw(7)](https://man7.org/linux/man-pages/man7/raw.7.html))\n    Raw = libc::IPPROTO_RAW,\n    /// Allows applications to configure and control a KEXT\n    /// ([ref](https://developer.apple.com/library/content/documentation/Darwin/Conceptual/NKEConceptual/control/control.html))\n    #[cfg(apple_targets)]\n    KextControl = libc::SYSPROTO_CONTROL,\n    /// Receives routing and link updates and may be used to modify the routing tables (both IPv4 and IPv6), IP addresses, link\n    // parameters, neighbor setups, queueing disciplines, traffic classes and packet classifiers\n    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))\n    #[cfg(linux_android)]\n    NetlinkRoute = libc::NETLINK_ROUTE,\n    /// Reserved for user-mode socket protocols\n    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))\n    #[cfg(linux_android)]\n    NetlinkUserSock = libc::NETLINK_USERSOCK,\n    /// Query information about sockets of various protocol families from the kernel\n    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))\n    #[cfg(linux_android)]\n    NetlinkSockDiag = libc::NETLINK_SOCK_DIAG,\n    /// Netfilter/iptables ULOG.\n    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))\n    #[cfg(linux_android)]\n    NetlinkNFLOG = libc::NETLINK_NFLOG,\n    /// SELinux event notifications.\n    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))\n    #[cfg(linux_android)]\n    NetlinkSELinux = libc::NETLINK_SELINUX,\n    /// Open-iSCSI\n    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))\n    #[cfg(linux_android)]\n    NetlinkISCSI = libc::NETLINK_ISCSI,\n    /// Auditing\n    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))\n    #[cfg(linux_android)]\n    NetlinkAudit = libc::NETLINK_AUDIT,\n    /// Access to FIB lookup from user space\n    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))\n    #[cfg(linux_android)]\n    NetlinkFIBLookup = libc::NETLINK_FIB_LOOKUP,\n    /// Netfilter subsystem\n    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))\n    #[cfg(linux_android)]\n    NetlinkNetFilter = libc::NETLINK_NETFILTER,\n    /// SCSI Transports\n    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))\n    #[cfg(linux_android)]\n    NetlinkSCSITransport = libc::NETLINK_SCSITRANSPORT,\n    /// Infiniband RDMA\n    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))\n    #[cfg(linux_android)]\n    NetlinkRDMA = libc::NETLINK_RDMA,\n    /// Transport IPv6 packets from netfilter to user space.  Used by ip6_queue kernel module.\n    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))\n    #[cfg(linux_android)]\n    NetlinkIPv6Firewall = libc::NETLINK_IP6_FW,\n    /// DECnet routing messages\n    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))\n    #[cfg(linux_android)]\n    NetlinkDECNetRoutingMessage = libc::NETLINK_DNRTMSG,\n    /// Kernel messages to user space\n    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))\n    #[cfg(linux_android)]\n    NetlinkKObjectUEvent = libc::NETLINK_KOBJECT_UEVENT,\n    /// Generic netlink family for simplified netlink usage.\n    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))\n    #[cfg(linux_android)]\n    NetlinkGeneric = libc::NETLINK_GENERIC,\n    /// Netlink interface to request information about ciphers registered with the kernel crypto API as well as allow\n    /// configuration of the kernel crypto API.\n    /// ([ref](https://www.man7.org/linux/man-pages/man7/netlink.7.html))\n    #[cfg(linux_android)]\n    NetlinkCrypto = libc::NETLINK_CRYPTO,\n    /// Non-DIX type protocol number defined for the Ethernet IEEE 802.3 interface that allows packets of all protocols\n    /// defined in the interface to be received.\n    /// ([ref](https://man7.org/linux/man-pages/man7/packet.7.html))\n    // The protocol number is fed into the socket syscall in network byte order.\n    #[cfg(linux_android)]\n    EthAll = (libc::ETH_P_ALL as u16).to_be() as i32,\n    #[cfg(linux_android)]\n    /// Packet filter on loopback traffic\n    EthLoop = (libc::ETH_P_LOOP as u16).to_be() as i32,\n    /// Packet filter on IPv4 traffic\n    #[cfg(linux_android)]\n    #[cfg(target_endian = \"big\")]\n    EthIp = libc::ETH_P_IP,\n    /// Packet filter on IPv6 traffic\n    #[cfg(linux_android)]\n    EthIpv6 = (libc::ETH_P_IPV6 as u16).to_be() as i32,\n    /// ICMP protocol ([icmp(7)](https://man7.org/linux/man-pages/man7/icmp.7.html))\n    Icmp = libc::IPPROTO_ICMP,\n    /// ICMPv6 protocol (ICMP over IPv6)\n    IcmpV6 = libc::IPPROTO_ICMPV6,\n    /// SCTP ([sctp(7)](https://man7.org/linux/man-pages/man7/sctp.7.html))\n    #[cfg(any(\n        apple_targets,\n        linux_android,\n        target_os = \"freebsd\",\n        target_os = \"netbsd\"\n    ))]\n    Sctp = libc::IPPROTO_SCTP,\n}\n\nimpl SockProtocol {\n    /// The Controller Area Network raw socket protocol\n    /// ([ref](https://docs.kernel.org/networking/can.html#how-to-use-socketcan))\n    #[cfg(target_os = \"linux\")]\n    #[allow(non_upper_case_globals)]\n    pub const CanRaw: SockProtocol = SockProtocol::Icmp; // Matches libc::CAN_RAW\n\n    /// The Controller Area Network broadcast manager protocol\n    /// ([ref](https://docs.kernel.org/networking/can.html#how-to-use-socketcan))\n    #[cfg(target_os = \"linux\")]\n    #[allow(non_upper_case_globals)]\n    pub const CanBcm: SockProtocol = SockProtocol::NetlinkUserSock; // Matches libc::CAN_BCM\n\n    /// Allows applications and other KEXTs to be notified when certain kernel events occur\n    /// ([ref](https://developer.apple.com/library/content/documentation/Darwin/Conceptual/NKEConceptual/control/control.html))\n    #[cfg(apple_targets)]\n    #[allow(non_upper_case_globals)]\n    pub const KextEvent: SockProtocol = SockProtocol::Icmp; // Matches libc::SYSPROTO_EVENT\n\n    /// Packet filter on IPv4 traffic\n    // NOTE: placed here due to conflict (little endian arch) with SockProtocol::NetLinkISCI\n    #[cfg(linux_android)]\n    #[allow(non_upper_case_globals)]\n    #[cfg(target_endian = \"little\")]\n    pub const EthIp: SockProtocol = unsafe { std::mem::transmute::\u003ci32, SockProtocol\u003e((libc::ETH_P_IP as u16).to_be() as i32) };\n\n}\n#[cfg(linux_android)]\nlibc_bitflags! {\n    /// Configuration flags for `SO_TIMESTAMPING` interface\n    ///\n    /// For use with [`Timestamping`][sockopt::Timestamping].\n    /// [Further reading](https://www.kernel.org/doc/html/latest/networking/timestamping.html)\n    pub struct TimestampingFlag: libc::c_uint {\n        /// Report any software timestamps when available.\n        SOF_TIMESTAMPING_SOFTWARE;\n        /// Report hardware timestamps as generated by SOF_TIMESTAMPING_TX_HARDWARE when available.\n        SOF_TIMESTAMPING_RAW_HARDWARE;\n        /// Collect transmitting timestamps as reported by hardware\n        SOF_TIMESTAMPING_TX_HARDWARE;\n        /// Collect transmitting timestamps as reported by software\n        SOF_TIMESTAMPING_TX_SOFTWARE;\n        /// Collect receiving timestamps as reported by hardware\n        SOF_TIMESTAMPING_RX_HARDWARE;\n        /// Collect receiving timestamps as reported by software\n        SOF_TIMESTAMPING_RX_SOFTWARE;\n        /// Generate a unique identifier along with each transmitted packet\n        SOF_TIMESTAMPING_OPT_ID;\n        /// Return transmit timestamps alongside an empty packet instead of the original packet\n        SOF_TIMESTAMPING_OPT_TSONLY;\n    }\n}\n\nlibc_bitflags! {\n    /// Additional socket options\n    pub struct SockFlag: c_int {\n        /// Set non-blocking mode on the new socket\n        #[cfg(any(linux_android,\n                  freebsdlike,\n                  netbsdlike,\n                  solarish))]\n        SOCK_NONBLOCK;\n        /// Set close-on-exec on the new descriptor\n        #[cfg(any(linux_android,\n                  freebsdlike,\n                  netbsdlike,\n                  solarish))]\n        SOCK_CLOEXEC;\n        /// Return `EPIPE` instead of raising `SIGPIPE`\n        #[cfg(target_os = \"netbsd\")]\n        SOCK_NOSIGPIPE;\n        /// For domains `AF_INET(6)`, only allow `connect(2)`, `sendto(2)`, or `sendmsg(2)`\n        /// to the DNS port (typically 53)\n        #[cfg(target_os = \"openbsd\")]\n        SOCK_DNS;\n    }\n}\n\nlibc_bitflags! {\n    /// Flags for send/recv and their relatives\n    pub struct MsgFlags: c_int {\n        /// Sends or requests out-of-band data on sockets that support this notion\n        /// (e.g., of type [`Stream`](enum.SockType.html)); the underlying protocol must also\n        /// support out-of-band data.\n        MSG_OOB;\n        /// Peeks at an incoming message. The data is treated as unread and the next\n        /// [`recv()`](fn.recv.html)\n        /// or similar function shall still return this data.\n        MSG_PEEK;\n        /// Receive operation blocks until the full amount of data can be\n        /// returned. The function may return smaller amount of data if a signal\n        /// is caught, an error or disconnect occurs.\n        MSG_WAITALL;\n        /// Enables nonblocking operation; if the operation would block,\n        /// `EAGAIN` or `EWOULDBLOCK` is returned.  This provides similar\n        /// behavior to setting the `O_NONBLOCK` flag\n        /// (via the [`fcntl`](../../fcntl/fn.fcntl.html)\n        /// `F_SETFL` operation), but differs in that `MSG_DONTWAIT` is a per-\n        /// call option, whereas `O_NONBLOCK` is a setting on the open file\n        /// description (see [open(2)](https://man7.org/linux/man-pages/man2/open.2.html)),\n        /// which will affect all threads in\n        /// the calling process and as well as other processes that hold\n        /// file descriptors referring to the same open file description.\n        #[cfg(not(target_os = \"aix\"))]\n        MSG_DONTWAIT;\n        /// Receive flags: Control Data was discarded (buffer too small)\n        MSG_CTRUNC;\n        /// For raw ([`Packet`](addr/enum.AddressFamily.html)), Internet datagram\n        /// (since Linux 2.4.27/2.6.8),\n        /// netlink (since Linux 2.6.22) and UNIX datagram (since Linux 3.4)\n        /// sockets: return the real length of the packet or datagram, even\n        /// when it was longer than the passed buffer. Not implemented for UNIX\n        /// domain ([unix(7)](https://linux.die.net/man/7/unix)) sockets.\n        ///\n        /// For use with Internet stream sockets, see [tcp(7)](https://linux.die.net/man/7/tcp).\n        MSG_TRUNC;\n        /// Terminates a record (when this notion is supported, as for\n        /// sockets of type [`SeqPacket`](enum.SockType.html)).\n        MSG_EOR;\n        /// This flag specifies that queued errors should be received from\n        /// the socket error queue. (For more details, see\n        /// [recvfrom(2)](https://linux.die.net/man/2/recvfrom))\n        #[cfg(linux_android)]\n        MSG_ERRQUEUE;\n        /// Set the `close-on-exec` flag for the file descriptor received via a UNIX domain\n        /// file descriptor using the `SCM_RIGHTS` operation (described in\n        /// [unix(7)](https://linux.die.net/man/7/unix)).\n        /// This flag is useful for the same reasons as the `O_CLOEXEC` flag of\n        /// [open(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html).\n        ///\n        /// Only used in [`recvmsg`](fn.recvmsg.html) function.\n        #[cfg(any(linux_android, freebsdlike, netbsdlike))]\n        MSG_CMSG_CLOEXEC;\n        /// Requests not to send `SIGPIPE` errors when the other end breaks the connection.\n        /// (For more details, see [send(2)](https://linux.die.net/man/2/send)).\n        #[cfg(any(linux_android,\n                  freebsdlike,\n                  solarish,\n                  netbsdlike,\n                  target_os = \"fuchsia\",\n                  target_os = \"haiku\"))]\n        MSG_NOSIGNAL;\n        /// Turns on [`MSG_DONTWAIT`] after the first message has been received (only for\n        /// `recvmmsg()`).\n        #[cfg(any(linux_android,\n                  netbsdlike,\n                  target_os = \"fuchsia\",\n                  target_os = \"freebsd\"))]\n        MSG_WAITFORONE;\n        /// Indicates that this message is not a user message but an SCTP notification.\n        #[cfg(target_os = \"linux\")]\n        MSG_NOTIFICATION;\n    }\n}\n\n#[cfg(target_os = \"freebsd\")]\nlibc_enum! {\n    /// A selector for which clock to use when generating packet timestamps.\n    /// Used when setting [`TsClock`](crate::sys::socket::sockopt::TsClock) on a socket.\n    /// (For more details, see [setsockopt(2)](https://man.freebsd.org/cgi/man.cgi?setsockopt)).\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum SocketTimestamp {\n        /// Microsecond resolution, realtime. This is the default.\n        SO_TS_REALTIME_MICRO,\n        /// Sub-nanosecond resolution, realtime.\n        SO_TS_BINTIME,\n        /// Nanosecond resolution, realtime.\n        SO_TS_REALTIME,\n        /// Nanosecond resolution, monotonic.\n        SO_TS_MONOTONIC,\n    }\n}\n\ncfg_if! {\n    if #[cfg(linux_android)] {\n        /// Unix credentials of the sending process.\n        ///\n        /// This struct is used with the `SO_PEERCRED` ancillary message\n        /// and the `SCM_CREDENTIALS` control message for UNIX sockets.\n        #[repr(transparent)]\n        #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n        pub struct UnixCredentials(libc::ucred);\n\n        impl UnixCredentials {\n            /// Creates a new instance with the credentials of the current process\n            pub fn new() -\u003e Self {\n                // Safe because these FFI functions are inherently safe\n                unsafe {\n                    UnixCredentials(libc::ucred {\n                        pid: libc::getpid(),\n                        uid: libc::getuid(),\n                        gid: libc::getgid()\n                    })\n                }\n            }\n\n            /// Returns the process identifier\n            pub fn pid(\u0026self) -\u003e libc::pid_t {\n                self.0.pid\n            }\n\n            /// Returns the user identifier\n            pub fn uid(\u0026self) -\u003e libc::uid_t {\n                self.0.uid\n            }\n\n            /// Returns the group identifier\n            pub fn gid(\u0026self) -\u003e libc::gid_t {\n                self.0.gid\n            }\n        }\n\n        impl Default for UnixCredentials {\n            fn default() -\u003e Self {\n                Self::new()\n            }\n        }\n\n        impl From\u003clibc::ucred\u003e for UnixCredentials {\n            fn from(cred: libc::ucred) -\u003e Self {\n                UnixCredentials(cred)\n            }\n        }\n\n        impl From\u003cUnixCredentials\u003e for libc::ucred {\n            fn from(uc: UnixCredentials) -\u003e Self {\n                uc.0\n            }\n        }\n    } else if #[cfg(freebsdlike)] {\n        /// Unix credentials of the sending process.\n        ///\n        /// This struct is used with the `SCM_CREDS` ancillary message for UNIX sockets.\n        #[repr(transparent)]\n        #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n        pub struct UnixCredentials(libc::cmsgcred);\n\n        impl UnixCredentials {\n            /// Returns the process identifier\n            pub fn pid(\u0026self) -\u003e libc::pid_t {\n                self.0.cmcred_pid\n            }\n\n            /// Returns the real user identifier\n            pub fn uid(\u0026self) -\u003e libc::uid_t {\n                self.0.cmcred_uid\n            }\n\n            /// Returns the effective user identifier\n            pub fn euid(\u0026self) -\u003e libc::uid_t {\n                self.0.cmcred_euid\n            }\n\n            /// Returns the real group identifier\n            pub fn gid(\u0026self) -\u003e libc::gid_t {\n                self.0.cmcred_gid\n            }\n\n            /// Returns a list group identifiers (the first one being the effective GID)\n            pub fn groups(\u0026self) -\u003e \u0026[libc::gid_t] {\n                unsafe {\n                    std::slice::from_raw_parts(\n                        self.0.cmcred_groups.as_ptr(),\n                        self.0.cmcred_ngroups as _\n                    )\n                }\n            }\n        }\n\n        impl From\u003clibc::cmsgcred\u003e for UnixCredentials {\n            fn from(cred: libc::cmsgcred) -\u003e Self {\n                UnixCredentials(cred)\n            }\n        }\n    }\n}\n\ncfg_if! {\n    if #[cfg(any(freebsdlike, apple_targets))] {\n        /// Return type of [`LocalPeerCred`](crate::sys::socket::sockopt::LocalPeerCred)\n        #[repr(transparent)]\n        #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n        pub struct XuCred(libc::xucred);\n\n        impl XuCred {\n            /// Structure layout version\n            pub fn version(\u0026self) -\u003e u32 {\n                self.0.cr_version\n            }\n\n            /// Effective user ID\n            pub fn uid(\u0026self) -\u003e libc::uid_t {\n                self.0.cr_uid\n            }\n\n            /// Returns a list of group identifiers (the first one being the\n            /// effective GID)\n            pub fn groups(\u0026self) -\u003e \u0026[libc::gid_t] {\n                \u0026self.0.cr_groups\n            }\n        }\n    }\n}\n\ncfg_if! {\n    if #[cfg(apple_targets)] {\n        use std::fmt;\n\n        /// Return type of [`LocalPeerToken`].\n        ///\n        /// The audit token is an opaque token which identifies Mach tasks and\n        /// senders of Mach messages as subjects to the BSM audit system. Only\n        /// the appropriate BSM library routines should be used to interpret\n        /// the contents of the audit token as the representation of the\n        /// subject identity within the token may change over time.\n        ///\n        /// Starting with macOS 11, almost all audit functions have been\n        /// deprecated (see the system header `bsm/libbsm.h`), do not use them\n        /// if your program target more recent versions of macOS.\n        ///\n        /// [`LocalPeerToken`]: crate::sys::socket::sockopt::LocalPeerToken\n        #[repr(C)]\n        #[derive(Default, Copy, Clone, PartialEq, Eq, Hash)]\n        pub struct audit_token_t {\n            /// Value of the token.\n            ///\n            /// This is considered an opaque value, do not rely on its format.\n            pub val: [libc::c_uint; 8],\n        }\n\n        // Make the debug representation a hex string to make it shorter and clearer.\n        impl fmt::Debug for audit_token_t {\n            fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                f.debug_tuple(\"audit_token_t\")\n                    .field(\u0026format!(\"0x{:08X}\", self))\n                    .finish()\n            }\n        }\n\n        impl fmt::LowerHex for audit_token_t {\n            fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                for v in self.val {\n                    fmt::LowerHex::fmt(\u0026v, f)?;\n                }\n\n                Ok(())\n            }\n        }\n\n        impl fmt::UpperHex for audit_token_t {\n            fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                for v in self.val {\n                    fmt::UpperHex::fmt(\u0026v, f)?;\n                }\n\n                Ok(())\n            }\n        }\n    }\n}\n\nfeature! {\n#![feature = \"net\"]\n/// Request for multicast socket operations\n///\n/// This is a wrapper type around `ip_mreq`.\n#[repr(transparent)]\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub struct IpMembershipRequest(libc::ip_mreq);\n\nimpl IpMembershipRequest {\n    /// Instantiate a new `IpMembershipRequest`\n    ///\n    /// If `interface` is `None`, then `Ipv4Addr::any()` will be used for the interface.\n    pub fn new(group: net::Ipv4Addr, interface: Option\u003cnet::Ipv4Addr\u003e)\n        -\u003e Self\n    {\n        let imr_addr = match interface {\n            None =\u003e net::Ipv4Addr::UNSPECIFIED,\n            Some(addr) =\u003e addr\n        };\n        IpMembershipRequest(libc::ip_mreq {\n            imr_multiaddr: ipv4addr_to_libc(group),\n            imr_interface: ipv4addr_to_libc(imr_addr)\n        })\n    }\n}\n\n/// Request for ipv6 multicast socket operations\n///\n/// This is a wrapper type around `ipv6_mreq`.\n#[repr(transparent)]\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub struct Ipv6MembershipRequest(libc::ipv6_mreq);\n\nimpl Ipv6MembershipRequest {\n    /// Instantiate a new `Ipv6MembershipRequest`\n    pub const fn new(group: net::Ipv6Addr) -\u003e Self {\n        Ipv6MembershipRequest(libc::ipv6_mreq {\n            ipv6mr_multiaddr: ipv6addr_to_libc(\u0026group),\n            ipv6mr_interface: 0,\n        })\n    }\n}\n}\n\n#[cfg(not(target_os = \"redox\"))]\nfeature! {\n#![feature = \"uio\"]\n\n/// Create a buffer large enough for storing some control messages as returned\n/// by [`recvmsg`](fn.recvmsg.html).\n///\n/// # Examples\n///\n/// ```\n/// # #[macro_use] extern crate nix;\n/// # use nix::sys::time::TimeVal;\n/// # use std::os::unix::io::RawFd;\n/// # fn main() {\n/// // Create a buffer for a `ControlMessageOwned::ScmTimestamp` message\n/// let _ = cmsg_space!(TimeVal);\n/// // Create a buffer big enough for a `ControlMessageOwned::ScmRights` message\n/// // with two file descriptors\n/// let _ = cmsg_space!([RawFd; 2]);\n/// // Create a buffer big enough for a `ControlMessageOwned::ScmRights` message\n/// // and a `ControlMessageOwned::ScmTimestamp` message\n/// let _ = cmsg_space!(RawFd, TimeVal);\n/// # }\n/// ```\n#[macro_export]\nmacro_rules! cmsg_space {\n    ( $( $x:ty ),* ) =\u003e {\n        {\n            let space = 0 $(+ $crate::sys::socket::cmsg_space::\u003c$x\u003e())*;\n            vec![0u8; space]\n        }\n    }\n}\n\n#[inline]\n#[doc(hidden)]\npub const fn cmsg_space\u003cT\u003e() -\u003e usize {\n    // SAFETY: CMSG_SPACE is always safe\n    unsafe { libc::CMSG_SPACE(mem::size_of::\u003cT\u003e() as libc::c_uint) as usize }\n}\n\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n/// Contains outcome of sending or receiving a message\n///\n/// Use [`cmsgs`][RecvMsg::cmsgs] to access all the control messages present, and\n/// [`iovs`][RecvMsg::iovs`] to access underlying io slices.\npub struct RecvMsg\u003c'a, 's, S\u003e {\n    pub bytes: usize,\n    cmsghdr: Option\u003c\u0026'a cmsghdr\u003e,\n    pub address: Option\u003cS\u003e,\n    pub flags: MsgFlags,\n    iobufs: std::marker::PhantomData\u003c\u0026 's()\u003e,\n    mhdr: msghdr,\n}\n\nimpl\u003cS\u003e RecvMsg\u003c'_, '_, S\u003e {\n    /// Iterate over the valid control messages pointed to by this msghdr. If\n    /// allocated space for CMSGs was too small it is not safe to iterate,\n    /// instead return an `Error::ENOBUFS` error.\n    pub fn cmsgs(\u0026self) -\u003e Result\u003cCmsgIterator\u003e {\n\n        if self.mhdr.msg_flags \u0026 MSG_CTRUNC == MSG_CTRUNC {\n            return Err(Errno::ENOBUFS);\n        }\n\n        Ok(CmsgIterator {\n            cmsghdr: self.cmsghdr,\n            mhdr: \u0026self.mhdr\n        })\n    }\n}\n\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub struct CmsgIterator\u003c'a\u003e {\n    /// Control message buffer to decode from. Must adhere to cmsg alignment.\n    cmsghdr: Option\u003c\u0026'a cmsghdr\u003e,\n    mhdr: \u0026'a msghdr\n}\n\nimpl Iterator for CmsgIterator\u003c'_\u003e {\n    type Item = ControlMessageOwned;\n\n    fn next(\u0026mut self) -\u003e Option\u003cControlMessageOwned\u003e {\n        match self.cmsghdr {\n            None =\u003e None,   // No more messages\n            Some(hdr) =\u003e {\n                // Get the data.\n                // Safe if cmsghdr points to valid data returned by recvmsg(2)\n                let cm = unsafe { Some(ControlMessageOwned::decode_from(hdr))};\n                // Advance the internal pointer.  Safe if mhdr and cmsghdr point\n                // to valid data returned by recvmsg(2)\n                self.cmsghdr = unsafe {\n                    let p = CMSG_NXTHDR(self.mhdr as *const _, hdr as *const _);\n                    p.as_ref()\n                };\n                cm\n            }\n        }\n    }\n}\n\n/// A type-safe wrapper around a single control message, as used with\n/// [`recvmsg`].\n///\n/// [Further reading](https://man7.org/linux/man-pages/man3/cmsg.3.html)\n//  Nix version 0.13.0 and earlier used ControlMessage for both recvmsg and\n//  sendmsg.  However, on some platforms the messages returned by recvmsg may be\n//  unaligned.  ControlMessageOwned takes those messages by copy, obviating any\n//  alignment issues.\n//\n//  See https://github.com/nix-rust/nix/issues/999\n#[derive(Clone, Debug, Eq, PartialEq)]\n#[non_exhaustive]\npub enum ControlMessageOwned {\n    /// Received version of [`ControlMessage::ScmRights`]\n    ScmRights(Vec\u003cRawFd\u003e),\n    /// Received version of [`ControlMessage::ScmCredentials`]\n    #[cfg(linux_android)]\n    ScmCredentials(UnixCredentials),\n    /// Received version of [`ControlMessage::ScmCreds`]\n    #[cfg(freebsdlike)]\n    ScmCreds(UnixCredentials),\n    /// A message of type `SCM_TIMESTAMP`, containing the time the\n    /// packet was received by the kernel.\n    ///\n    /// See the kernel's explanation in \"SO_TIMESTAMP\" of\n    /// [networking/timestamping](https://www.kernel.org/doc/Documentation/networking/timestamping.txt).\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// # #[macro_use] extern crate nix;\n    /// # use nix::sys::socket::*;\n    /// # use nix::sys::time::*;\n    /// # use std::io::{IoSlice, IoSliceMut};\n    /// # use std::time::*;\n    /// # use std::str::FromStr;\n    /// # use std::os::unix::io::AsRawFd;\n    /// # fn main() {\n    /// // Set up\n    /// let message = \"Ohay!\".as_bytes();\n    /// let in_socket = socket(\n    ///     AddressFamily::Inet,\n    ///     SockType::Datagram,\n    ///     SockFlag::empty(),\n    ///     None).unwrap();\n    /// setsockopt(\u0026in_socket, sockopt::ReceiveTimestamp, \u0026true).unwrap();\n    /// let localhost = SockaddrIn::from_str(\"127.0.0.1:0\").unwrap();\n    /// bind(in_socket.as_raw_fd(), \u0026localhost).unwrap();\n    /// let address: SockaddrIn = getsockname(in_socket.as_raw_fd()).unwrap();\n    /// // Get initial time\n    /// let time0 = SystemTime::now();\n    /// // Send the message\n    /// let iov = [IoSlice::new(message)];\n    /// let flags = MsgFlags::empty();\n    /// let l = sendmsg(in_socket.as_raw_fd(), \u0026iov, \u0026[], flags, Some(\u0026address)).unwrap();\n    /// assert_eq!(message.len(), l);\n    /// // Receive the message\n    /// let mut buffer = vec![0u8; message.len()];\n    /// let mut cmsgspace = cmsg_space!(TimeVal);\n    /// let mut iov = [IoSliceMut::new(\u0026mut buffer)];\n    /// let r = recvmsg::\u003cSockaddrIn\u003e(in_socket.as_raw_fd(), \u0026mut iov, Some(\u0026mut cmsgspace), flags)\n    ///     .unwrap();\n    /// let rtime = match r.cmsgs().unwrap().next() {\n    ///     Some(ControlMessageOwned::ScmTimestamp(rtime)) =\u003e rtime,\n    ///     Some(_) =\u003e panic!(\"Unexpected control message\"),\n    ///     None =\u003e panic!(\"No control message\")\n    /// };\n    /// // Check the final time\n    /// let time1 = SystemTime::now();\n    /// // the packet's received timestamp should lie in-between the two system\n    /// // times, unless the system clock was adjusted in the meantime.\n    /// let rduration = Duration::new(rtime.tv_sec() as u64,\n    ///                               rtime.tv_usec() as u32 * 1000);\n    /// assert!(time0.duration_since(UNIX_EPOCH).unwrap() \u003c= rduration);\n    /// assert!(rduration \u003c= time1.duration_since(UNIX_EPOCH).unwrap());\n    /// // Close socket\n    /// # }\n    /// ```\n    ScmTimestamp(TimeVal),\n    /// A set of nanosecond resolution timestamps\n    ///\n    /// [Further reading](https://www.kernel.org/doc/html/latest/networking/timestamping.html)\n    #[cfg(linux_android)]\n    ScmTimestampsns(Timestamps),\n    /// Nanoseconds resolution timestamp\n    ///\n    /// [Further reading](https://www.kernel.org/doc/html/latest/networking/timestamping.html)\n    #[cfg(linux_android)]\n    ScmTimestampns(TimeSpec),\n    /// Realtime clock timestamp\n    ///\n    /// [Further reading](https://man.freebsd.org/cgi/man.cgi?setsockopt)\n    #[cfg(target_os = \"freebsd\")]\n    ScmRealtime(TimeSpec),\n    /// Monotonic clock timestamp\n    ///\n    /// [Further reading](https://man.freebsd.org/cgi/man.cgi?setsockopt)\n    #[cfg(target_os = \"freebsd\")]\n    ScmMonotonic(TimeSpec),\n    #[cfg(any(linux_android, apple_targets, target_os = \"netbsd\"))]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    Ipv4PacketInfo(libc::in_pktinfo),\n    #[cfg(any(linux_android, bsd))]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    Ipv6PacketInfo(libc::in6_pktinfo),\n    #[cfg(bsd)]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    Ipv4RecvIf(libc::sockaddr_dl),\n    #[cfg(bsd)]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    Ipv4RecvDstAddr(libc::in_addr),\n    #[cfg(any(linux_android, target_os = \"freebsd\"))]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    Ipv4OrigDstAddr(libc::sockaddr_in),\n    #[cfg(any(linux_android, target_os = \"freebsd\"))]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    Ipv6OrigDstAddr(libc::sockaddr_in6),\n\n    /// Time-to-Live (TTL) header field of the incoming IPv4 packet.\n    ///\n    /// [Further reading](https://www.man7.org/linux/man-pages/man7/ip.7.html)\n    #[cfg(linux_android)]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    Ipv4Ttl(i32),\n\n    /// Time-to-Live (TTL) header field of the incoming IPv4 packet.\n    ///\n    /// [Further reading](https://datatracker.ietf.org/doc/html/rfc3542.html)\n    #[cfg(target_os = \"freebsd\")]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    Ipv4Ttl(u8),\n\n    /// Hop Limit header field of the incoming IPv6 packet.\n    ///\n    /// [Further reading for Linux](https://www.man7.org/linux/man-pages/man7/ip.7.html)\n    /// [Further reading for FreeBSD](https://datatracker.ietf.org/doc/html/rfc3542.html)\n    #[cfg(any(linux_android, target_os = \"freebsd\"))]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    Ipv6HopLimit(i32),\n\n    /// Retrieve the DSCP (ToS) header field of the incoming IPv4 packet.\n    #[cfg(any(linux_android, target_os = \"freebsd\"))]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    Ipv4Tos(u8),\n\n    /// Retrieve the DSCP (Traffic Class) header field of the incoming IPv6 packet.\n    #[cfg(any(linux_android, target_os = \"freebsd\"))]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    Ipv6TClass(i32),\n\n    /// UDP Generic Receive Offload (GRO) allows receiving multiple UDP\n    /// packets from a single sender.\n    /// Fixed-size payloads are following one by one in a receive buffer.\n    /// This Control Message indicates the size of all smaller packets,\n    /// except, maybe, the last one.\n    ///\n    /// `UdpGroSegment` socket option should be enabled on a socket\n    /// to allow receiving GRO packets.\n    #[cfg(target_os = \"linux\")]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    UdpGroSegments(i32),\n\n    /// SO_RXQ_OVFL indicates that an unsigned 32 bit value\n    /// ancilliary msg (cmsg) should be attached to recieved\n    /// skbs indicating the number of packets dropped by the\n    /// socket between the last recieved packet and this\n    /// received packet.\n    ///\n    /// `RxqOvfl` socket option should be enabled on a socket\n    /// to allow receiving the drop counter.\n    #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n    RxqOvfl(u32),\n\n    /// Socket error queue control messages read with the `MSG_ERRQUEUE` flag.\n    #[cfg(linux_android)]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    Ipv4RecvErr(libc::sock_extended_err, Option\u003csockaddr_in\u003e),\n    /// Socket error queue control messages read with the `MSG_ERRQUEUE` flag.\n    #[cfg(linux_android)]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    Ipv6RecvErr(libc::sock_extended_err, Option\u003csockaddr_in6\u003e),\n\n    /// `SOL_TLS` messages of type `TLS_GET_RECORD_TYPE`\n    #[cfg(any(target_os = \"linux\"))]\n    TlsGetRecordType(TlsGetRecordType),\n\n    /// Catch-all variant for unimplemented cmsg types.\n    Unknown(UnknownCmsg),\n}\n\n/// For representing packet timestamps via `SO_TIMESTAMPING` interface\n#[cfg(linux_android)]\n#[derive(Copy, Clone, Debug, Eq, PartialEq)]\npub struct Timestamps {\n    /// software based timestamp, usually one containing data\n    pub system: TimeSpec,\n    /// legacy timestamp, usually empty\n    pub hw_trans: TimeSpec,\n    /// hardware based timestamp\n    pub hw_raw: TimeSpec,\n}\n\n/// These constants correspond to TLS 1.2 message types, as defined in\n/// RFC 5246, Appendix A.1\n#[cfg(any(target_os = \"linux\"))]\n#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n#[repr(u8)]\n#[non_exhaustive]\npub enum TlsGetRecordType {\n    ChangeCipherSpec ,\n    Alert,\n    Handshake,\n    ApplicationData,\n    Unknown(u8),\n}\n\n#[cfg(any(target_os = \"linux\"))]\nimpl From\u003cu8\u003e for TlsGetRecordType {\n    fn from(x: u8) -\u003e Self {\n        match x {\n            20 =\u003e TlsGetRecordType::ChangeCipherSpec,\n            21 =\u003e TlsGetRecordType::Alert,\n            22 =\u003e TlsGetRecordType::Handshake,\n            23 =\u003e TlsGetRecordType::ApplicationData,\n            _ =\u003e TlsGetRecordType::Unknown(x),\n        }\n    }\n}\n\nimpl ControlMessageOwned {\n    /// Decodes a `ControlMessageOwned` from raw bytes.\n    ///\n    /// This is only safe to call if the data is correct for the message type\n    /// specified in the header. Normally, the kernel ensures that this is the\n    /// case. \"Correct\" in this case includes correct length, alignment and\n    /// actual content.\n    // Clippy complains about the pointer alignment of `p`, not understanding\n    // that it's being fed to a function that can handle that.\n    #[allow(clippy::cast_ptr_alignment)]\n    unsafe fn decode_from(header: \u0026cmsghdr) -\u003e ControlMessageOwned\n    {\n        let p = unsafe { CMSG_DATA(header) };\n        // The cast is not unnecessary on all platforms.\n        #[allow(clippy::unnecessary_cast)]\n        let len = header as *const _ as usize + header.cmsg_len as usize\n            - p as usize;\n        match (header.cmsg_level, header.cmsg_type) {\n            (libc::SOL_SOCKET, libc::SCM_RIGHTS) =\u003e {\n                let n = len / mem::size_of::\u003cRawFd\u003e();\n                let mut fds = Vec::with_capacity(n);\n                for i in 0..n {\n                    unsafe {\n                        let fdp = (p as *const RawFd).add(i);\n                        fds.push(ptr::read_unaligned(fdp));\n                    }\n                }\n                ControlMessageOwned::ScmRights(fds)\n            },\n            #[cfg(linux_android)]\n            (libc::SOL_SOCKET, libc::SCM_CREDENTIALS) =\u003e {\n                let cred: libc::ucred = unsafe { ptr::read_unaligned(p as *const _) };\n                ControlMessageOwned::ScmCredentials(cred.into())\n            }\n            #[cfg(freebsdlike)]\n            (libc::SOL_SOCKET, libc::SCM_CREDS) =\u003e {\n                let cred: libc::cmsgcred = unsafe { ptr::read_unaligned(p as *const _) };\n                ControlMessageOwned::ScmCreds(cred.into())\n            }\n            #[cfg(not(any(target_os = \"aix\", target_os = \"haiku\", target_os = \"cygwin\")))]\n            (libc::SOL_SOCKET, libc::SCM_TIMESTAMP) =\u003e {\n                let tv: libc::timeval = unsafe { ptr::read_unaligned(p as *const _) };\n                ControlMessageOwned::ScmTimestamp(TimeVal::from(tv))\n            },\n            #[cfg(linux_android)]\n            (libc::SOL_SOCKET, libc::SCM_TIMESTAMPNS) =\u003e {\n                let ts: libc::timespec = unsafe { ptr::read_unaligned(p as *const _) };\n                ControlMessageOwned::ScmTimestampns(TimeSpec::from(ts))\n            }\n            #[cfg(target_os = \"freebsd\")]\n            (libc::SOL_SOCKET, libc::SCM_REALTIME) =\u003e {\n                let ts: libc::timespec = unsafe { ptr::read_unaligned(p as *const _) };\n                ControlMessageOwned::ScmRealtime(TimeSpec::from(ts))\n            }\n            #[cfg(target_os = \"freebsd\")]\n            (libc::SOL_SOCKET, libc::SCM_MONOTONIC) =\u003e {\n                let ts: libc::timespec = unsafe { ptr::read_unaligned(p as *const _) };\n                ControlMessageOwned::ScmMonotonic(TimeSpec::from(ts))\n            }\n            #[cfg(linux_android)]\n            (libc::SOL_SOCKET, libc::SCM_TIMESTAMPING) =\u003e {\n                let tp = p as *const libc::timespec;\n                let ts: libc::timespec = unsafe { ptr::read_unaligned(tp) };\n                let system = TimeSpec::from(ts);\n                let ts: libc::timespec = unsafe { ptr::read_unaligned(tp.add(1)) };\n                let hw_trans = TimeSpec::from(ts);\n                let ts: libc::timespec = unsafe { ptr::read_unaligned(tp.add(2)) };\n                let hw_raw = TimeSpec::from(ts);\n                let timestamping = Timestamps { system, hw_trans, hw_raw };\n                ControlMessageOwned::ScmTimestampsns(timestamping)\n            }\n            #[cfg(any(target_os = \"freebsd\", linux_android, apple_targets))]\n            #[cfg(feature = \"net\")]\n            (libc::IPPROTO_IPV6, libc::IPV6_PKTINFO) =\u003e {\n                let info = unsafe { ptr::read_unaligned(p as *const libc::in6_pktinfo) };\n                ControlMessageOwned::Ipv6PacketInfo(info)\n            }\n            #[cfg(any(linux_android, apple_targets, target_os = \"netbsd\"))]\n            #[cfg(feature = \"net\")]\n            (libc::IPPROTO_IP, libc::IP_PKTINFO) =\u003e {\n                let info = unsafe { ptr::read_unaligned(p as *const libc::in_pktinfo) };\n                ControlMessageOwned::Ipv4PacketInfo(info)\n            }\n            #[cfg(bsd)]\n            #[cfg(feature = \"net\")]\n            (libc::IPPROTO_IP, libc::IP_RECVIF) =\u003e {\n                let dl = unsafe { ptr::read_unaligned(p as *const libc::sockaddr_dl) };\n                ControlMessageOwned::Ipv4RecvIf(dl)\n            },\n            #[cfg(bsd)]\n            #[cfg(feature = \"net\")]\n            (libc::IPPROTO_IP, libc::IP_RECVDSTADDR) =\u003e {\n                let dl = unsafe { ptr::read_unaligned(p as *const libc::in_addr) };\n                ControlMessageOwned::Ipv4RecvDstAddr(dl)\n            },\n            #[cfg(any(linux_android, target_os = \"freebsd\"))]\n            #[cfg(feature = \"net\")]\n            (libc::IPPROTO_IP, libc::IP_ORIGDSTADDR) =\u003e {\n                let dl = unsafe { ptr::read_unaligned(p as *const libc::sockaddr_in) };\n                ControlMessageOwned::Ipv4OrigDstAddr(dl)\n            },\n            #[cfg(target_os = \"linux\")]\n            #[cfg(feature = \"net\")]\n            (libc::SOL_UDP, libc::UDP_GRO) =\u003e {\n                let gso_size: i32 = unsafe { ptr::read_unaligned(p as *const _) };\n                ControlMessageOwned::UdpGroSegments(gso_size)\n            },\n            #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n            (libc::SOL_SOCKET, libc::SO_RXQ_OVFL) =\u003e {\n                let drop_counter = unsafe { ptr::read_unaligned(p as *const u32) };\n                ControlMessageOwned::RxqOvfl(drop_counter)\n            },\n            #[cfg(linux_android)]\n            #[cfg(feature = \"net\")]\n            (libc::IPPROTO_IP, libc::IP_RECVERR) =\u003e {\n                let (err, addr) = unsafe { Self::recv_err_helper::\u003csockaddr_in\u003e(p, len) };\n                ControlMessageOwned::Ipv4RecvErr(err, addr)\n            },\n            #[cfg(linux_android)]\n            #[cfg(feature = \"net\")]\n            (libc::IPPROTO_IPV6, libc::IPV6_RECVERR) =\u003e {\n                let (err, addr) = unsafe { Self::recv_err_helper::\u003csockaddr_in6\u003e(p, len) };\n                ControlMessageOwned::Ipv6RecvErr(err, addr)\n            },\n            #[cfg(any(linux_android, target_os = \"freebsd\"))]\n            #[cfg(feature = \"net\")]\n            (libc::IPPROTO_IPV6, libc::IPV6_ORIGDSTADDR) =\u003e {\n                let dl = unsafe { ptr::read_unaligned(p as *const libc::sockaddr_in6) };\n                ControlMessageOwned::Ipv6OrigDstAddr(dl)\n            },\n            #[cfg(any(target_os = \"linux\"))]\n            (libc::SOL_TLS, libc::TLS_GET_RECORD_TYPE) =\u003e {\n                let content_type = unsafe { ptr::read_unaligned(p as *const u8) };\n                ControlMessageOwned::TlsGetRecordType(content_type.into())\n            },\n            #[cfg(linux_android)]\n            #[cfg(feature = \"net\")]\n            (libc::IPPROTO_IP, libc::IP_TTL) =\u003e {\n                let ttl = unsafe { ptr::read_unaligned(p as *const i32) };\n                ControlMessageOwned::Ipv4Ttl(ttl)\n            },\n            #[cfg(target_os = \"freebsd\")]\n            #[cfg(feature = \"net\")]\n            (libc::IPPROTO_IP, libc::IP_RECVTTL) =\u003e {\n                let ttl: u8 = unsafe { ptr::read_unaligned(p as *const u8) };\n                ControlMessageOwned::Ipv4Ttl(ttl)\n            },\n            #[cfg(any(linux_android, target_os = \"freebsd\"))]\n            #[cfg(feature = \"net\")]\n            (libc::IPPROTO_IPV6, libc::IPV6_HOPLIMIT) =\u003e {\n                let ttl = unsafe { ptr::read_unaligned(p as *const i32) };\n                ControlMessageOwned::Ipv6HopLimit(ttl)\n            },\n            #[cfg(linux_android)]\n            #[cfg(feature = \"net\")]\n            (libc::IPPROTO_IP, libc::IP_TOS) =\u003e {\n                let tos = unsafe { ptr::read_unaligned(p as *const u8) };\n                ControlMessageOwned::Ipv4Tos(tos)\n            },\n            #[cfg(target_os = \"freebsd\")]\n            #[cfg(feature = \"net\")]\n            (libc::IPPROTO_IP, libc::IP_RECVTOS) =\u003e {\n                let tos = unsafe { ptr::read_unaligned(p as *const u8) };\n                ControlMessageOwned::Ipv4Tos(tos)\n            },\n            #[cfg(any(linux_android, target_os = \"freebsd\"))]\n            #[cfg(feature = \"net\")]\n            (libc::IPPROTO_IPV6, libc::IPV6_TCLASS) =\u003e {\n                let tc = unsafe { ptr::read_unaligned(p as *const i32) };\n                ControlMessageOwned::Ipv6TClass(tc)\n            },\n            (_, _) =\u003e {\n                let sl = unsafe { std::slice::from_raw_parts(p, len) };\n                let ucmsg = UnknownCmsg {\n                    cmsg_header: *header,\n                    data_bytes: Vec::\u003cu8\u003e::from(sl),\n                };\n                ControlMessageOwned::Unknown(ucmsg)\n            }\n        }\n    }\n\n    #[cfg(linux_android)]\n    #[cfg(feature = \"net\")]\n    #[allow(clippy::cast_ptr_alignment)]    // False positive\n    unsafe fn recv_err_helper\u003cT\u003e(p: *mut libc::c_uchar, len: usize) -\u003e (libc::sock_extended_err, Option\u003cT\u003e) {\n        let ee = p as *const libc::sock_extended_err;\n        let err = unsafe { ptr::read_unaligned(ee) };\n\n        // For errors originating on the network, SO_EE_OFFENDER(ee) points inside the p[..len]\n        // CMSG_DATA buffer.  For local errors, there is no address included in the control\n        // message, and SO_EE_OFFENDER(ee) points beyond the end of the buffer.  So, we need to\n        // validate that the address object is in-bounds before we attempt to copy it.\n        let addrp = unsafe { libc::SO_EE_OFFENDER(ee) as *const T };\n\n        if unsafe { addrp.offset(1) } as usize - (p as usize) \u003e len {\n            (err, None)\n        } else {\n            (err, Some(unsafe { ptr::read_unaligned(addrp) }))\n        }\n    }\n}\n\n/// A type-safe zero-copy wrapper around a single control message, as used with\n/// [`sendmsg`].  More types may be added to this enum; do not exhaustively\n/// pattern-match it.\n///\n/// [Further reading](https://man7.org/linux/man-pages/man3/cmsg.3.html)\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n#[non_exhaustive]\npub enum ControlMessage\u003c'a\u003e {\n    /// A message of type `SCM_RIGHTS`, containing an array of file\n    /// descriptors passed between processes.\n    ///\n    /// See the description in the \"Ancillary messages\" section of the\n    /// [unix(7) man page](https://man7.org/linux/man-pages/man7/unix.7.html).\n    ///\n    /// Using multiple `ScmRights` messages for a single `sendmsg` call isn't\n    /// recommended since it causes platform-dependent behaviour: It might\n    /// swallow all but the first `ScmRights` message or fail with `EINVAL`.\n    /// Instead, you can put all fds to be passed into a single `ScmRights`\n    /// message.\n    ScmRights(\u0026'a [RawFd]),\n    /// A message of type `SCM_CREDENTIALS`, containing the pid, uid and gid of\n    /// a process connected to the socket.\n    ///\n    /// This is similar to the socket option `SO_PEERCRED`, but requires a\n    /// process to explicitly send its credentials. A process running as root is\n    /// allowed to specify any credentials, while credentials sent by other\n    /// processes are verified by the kernel.\n    ///\n    /// For further information, please refer to the\n    /// [`unix(7)`](https://man7.org/linux/man-pages/man7/unix.7.html) man page.\n    #[cfg(linux_android)]\n    ScmCredentials(\u0026'a UnixCredentials),\n    /// A message of type `SCM_CREDS`, containing the pid, uid, euid, gid and groups of\n    /// a process connected to the socket.\n    ///\n    /// This is similar to the socket options `LOCAL_CREDS` and `LOCAL_PEERCRED`, but\n    /// requires a process to explicitly send its credentials.\n    ///\n    /// Credentials are always overwritten by the kernel, so this variant does have\n    /// any data, unlike the receive-side\n    /// [`ControlMessageOwned::ScmCreds`].\n    ///\n    /// For further information, please refer to the\n    /// [`unix(4)`](https://www.freebsd.org/cgi/man.cgi?query=unix) man page.\n    #[cfg(freebsdlike)]\n    ScmCreds,\n\n    /// Set IV for `AF_ALG` crypto API.\n    ///\n    /// For further information, please refer to the\n    /// [`documentation`](https://kernel.readthedocs.io/en/sphinx-samples/crypto-API.html)\n    #[cfg(linux_android)]\n    AlgSetIv(\u0026'a [u8]),\n    /// Set crypto operation for `AF_ALG` crypto API. It may be one of\n    /// `ALG_OP_ENCRYPT` or `ALG_OP_DECRYPT`\n    ///\n    /// For further information, please refer to the\n    /// [`documentation`](https://kernel.readthedocs.io/en/sphinx-samples/crypto-API.html)\n    #[cfg(linux_android)]\n    AlgSetOp(\u0026'a libc::c_int),\n    /// Set the length of associated authentication data (AAD) (applicable only to AEAD algorithms)\n    /// for `AF_ALG` crypto API.\n    ///\n    /// For further information, please refer to the\n    /// [`documentation`](https://kernel.readthedocs.io/en/sphinx-samples/crypto-API.html)\n    #[cfg(linux_android)]\n    AlgSetAeadAssoclen(\u0026'a u32),\n\n    /// UDP GSO makes it possible for applications to generate network packets\n    /// for a virtual MTU much greater than the real one.\n    /// The length of the send data no longer matches the expected length on\n    /// the wire.\n    /// The size of the datagram payload as it should appear on the wire may be\n    /// passed through this control message.\n    /// Send buffer should consist of multiple fixed-size wire payloads\n    /// following one by one, and the last, possibly smaller one.\n    #[cfg(target_os = \"linux\")]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    UdpGsoSegments(\u0026'a u16),\n\n    /// Configure the sending addressing and interface for v4.\n    ///\n    /// For further information, please refer to the\n    /// [`ip(7)`](https://man7.org/linux/man-pages/man7/ip.7.html) man page.\n    #[cfg(any(linux_android, target_os = \"netbsd\", apple_targets))]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    Ipv4PacketInfo(\u0026'a libc::in_pktinfo),\n\n    /// Configure the sending addressing and interface for v6.\n    ///\n    /// For further information, please refer to the\n    /// [`ipv6(7)`](https://man7.org/linux/man-pages/man7/ipv6.7.html) man page.\n    #[cfg(any(linux_android,\n              target_os = \"netbsd\",\n              target_os = \"freebsd\",\n              apple_targets))]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    Ipv6PacketInfo(\u0026'a libc::in6_pktinfo),\n\n    /// Configure the IPv4 source address with `IP_SENDSRCADDR`.\n    #[cfg(any(freebsdlike, netbsdlike))]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    Ipv4SendSrcAddr(\u0026'a libc::in_addr),\n\n    /// Configure the Time-to-Live for v4 traffic.\n    #[cfg(linux_android)]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    Ipv4Ttl(\u0026'a libc::c_int),\n\n    /// Configure the Time-to-Live for v4 traffic.\n    #[cfg(target_os = \"freebsd\")]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    Ipv4Ttl(\u0026'a libc::c_uchar),\n\n    /// Configure the hop limit for v6 multicast traffic.\n    ///\n    /// Set the IPv6 hop limit for this message. The argument is an integer\n    /// between 0 and 255. A value of -1 will set the hop limit to the route\n    /// default if possible on the interface. Without this cmsg,  packets sent\n    /// with sendmsg have a hop limit of 1 and will not leave the local network.\n    /// For further information, please refer to the\n    /// [`ipv6(7)`](https://man7.org/linux/man-pages/man7/ipv6.7.html) man page.\n    #[cfg(any(linux_android, freebsdlike, apple_targets, target_os = \"haiku\"))]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    Ipv6HopLimit(\u0026'a libc::c_int),\n\n    /// SO_RXQ_OVFL indicates that an unsigned 32 bit value\n    /// ancillary msg (cmsg) should be attached to received\n    /// skbs indicating the number of packets dropped by the\n    /// socket between the last received packet and this\n    /// received packet.\n    #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n    RxqOvfl(\u0026'a u32),\n\n    /// Configure the transmission time of packets.\n    ///\n    /// For further information, please refer to the\n    /// [`tc-etf(8)`](https://man7.org/linux/man-pages/man8/tc-etf.8.html) man\n    /// page.\n    #[cfg(target_os = \"linux\")]\n    TxTime(\u0026'a u64),\n\n    /// Configure DSCP / IP TOS for outgoing v4 packets.\n    ///\n    /// Further information can be found [here](https://en.wikipedia.org/wiki/Differentiated_services).\n    #[cfg(any(linux_android, target_os = \"freebsd\"))]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    Ipv4Tos(\u0026'a u8),\n\n    /// Configure DSCP / IPv6 TCLASS for outgoing v6 packets.\n    ///\n    /// Further information can be found [here](https://en.wikipedia.org/wiki/Differentiated_services).\n    #[cfg(any(linux_android, target_os = \"freebsd\"))]\n    #[cfg(feature = \"net\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    Ipv6TClass(\u0026'a i32),\n}\n\n/// Control messages that are currently not supported by Nix.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct UnknownCmsg {\n    /// Control message header.\n    pub cmsg_header: cmsghdr,\n    /// Bytes of the control message data.\n    pub data_bytes: Vec\u003cu8\u003e\n}\n\nimpl ControlMessage\u003c'_\u003e {\n    /// The value of CMSG_SPACE on this message.\n    /// Safe because CMSG_SPACE is always safe\n    fn space(\u0026self) -\u003e usize {\n        unsafe{CMSG_SPACE(self.len() as libc::c_uint) as usize}\n    }\n\n    /// The value of CMSG_LEN on this message.\n    /// Safe because CMSG_LEN is always safe\n    #[cfg(any(target_os = \"android\",\n              all(target_os = \"linux\", not(any(target_env = \"musl\", target_env = \"ohos\"))),\n              target_os = \"cygwin\"))]\n    fn cmsg_len(\u0026self) -\u003e usize {\n        unsafe{CMSG_LEN(self.len() as libc::c_uint) as usize}\n    }\n\n    #[cfg(not(any(target_os = \"android\",\n              all(target_os = \"linux\", not(any(target_env = \"musl\", target_env = \"ohos\"))),\n              target_os = \"cygwin\")))]\n    fn cmsg_len(\u0026self) -\u003e libc::c_uint {\n        unsafe{CMSG_LEN(self.len() as libc::c_uint)}\n    }\n\n    /// Return a reference to the payload data as a byte pointer\n    fn copy_to_cmsg_data(\u0026self, cmsg_data: *mut u8) {\n        let data_ptr = match *self {\n            ControlMessage::ScmRights(fds) =\u003e {\n                fds as *const _ as *const u8\n            },\n            #[cfg(linux_android)]\n            ControlMessage::ScmCredentials(creds) =\u003e {\n                \u0026creds.0 as *const libc::ucred as *const u8\n            }\n            #[cfg(freebsdlike)]\n            ControlMessage::ScmCreds =\u003e {\n                // The kernel overwrites the data, we just zero it\n                // to make sure it's not uninitialized memory\n                unsafe { ptr::write_bytes(cmsg_data, 0, self.len()) };\n                return\n            }\n            #[cfg(linux_android)]\n            ControlMessage::AlgSetIv(iv) =\u003e {\n                #[allow(deprecated)] // https://github.com/rust-lang/libc/issues/1501\n                let af_alg_iv = libc::af_alg_iv {\n                    ivlen: iv.len() as u32,\n                    iv: [0u8; 0],\n                };\n\n                let size = mem::size_of_val(\u0026af_alg_iv);\n\n                unsafe {\n                    ptr::copy_nonoverlapping(\n                        \u0026af_alg_iv as *const _ as *const u8,\n                        cmsg_data,\n                        size,\n                    );\n                    ptr::copy_nonoverlapping(\n                        iv.as_ptr(),\n                        cmsg_data.add(size),\n                        iv.len()\n                    );\n                };\n\n                return\n            },\n            #[cfg(linux_android)]\n            ControlMessage::AlgSetOp(op) =\u003e {\n                op as *const _ as *const u8\n            },\n            #[cfg(linux_android)]\n            ControlMessage::AlgSetAeadAssoclen(len) =\u003e {\n                len as *const _ as *const u8\n            },\n            #[cfg(target_os = \"linux\")]\n            #[cfg(feature = \"net\")]\n            ControlMessage::UdpGsoSegments(gso_size) =\u003e {\n                gso_size as *const _ as *const u8\n            },\n            #[cfg(any(linux_android, target_os = \"netbsd\", apple_targets))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv4PacketInfo(info) =\u003e info as *const _ as *const u8,\n            #[cfg(any(linux_android, target_os = \"netbsd\",\n                      target_os = \"freebsd\", apple_targets))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv6PacketInfo(info) =\u003e info as *const _ as *const u8,\n            #[cfg(any(freebsdlike, netbsdlike))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv4SendSrcAddr(addr) =\u003e addr as *const _ as *const u8,\n            #[cfg(linux_android)]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv4Ttl(ttl) =\u003e ttl as *const i32 as *const u8,\n            #[cfg(target_os = \"freebsd\")]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv4Ttl(ttl) =\u003e ttl as *const u8,\n            #[cfg(any(linux_android, freebsdlike, apple_targets, target_os = \"haiku\"))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv6HopLimit(limit) =\u003e limit as *const _ as *const u8,\n            #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n            ControlMessage::RxqOvfl(drop_count) =\u003e {\n                drop_count as *const _ as *const u8\n            },\n            #[cfg(target_os = \"linux\")]\n            ControlMessage::TxTime(tx_time) =\u003e {\n                tx_time as *const _ as *const u8\n            },\n            #[cfg(any(linux_android, target_os = \"freebsd\"))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv4Tos(tos) =\u003e {\n                tos as *const _\n            },\n            #[cfg(any(linux_android, target_os = \"freebsd\"))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv6TClass(tclass) =\u003e {\n                tclass as *const _ as *const u8\n            },\n        };\n        unsafe {\n            ptr::copy_nonoverlapping(\n                data_ptr,\n                cmsg_data,\n                self.len()\n            )\n        };\n    }\n\n    /// The size of the payload, excluding its cmsghdr\n    fn len(\u0026self) -\u003e usize {\n        match *self {\n            ControlMessage::ScmRights(fds) =\u003e {\n                mem::size_of_val(fds)\n            },\n            #[cfg(linux_android)]\n            ControlMessage::ScmCredentials(creds) =\u003e {\n                mem::size_of_val(creds)\n            }\n            #[cfg(freebsdlike)]\n            ControlMessage::ScmCreds =\u003e {\n                mem::size_of::\u003clibc::cmsgcred\u003e()\n            }\n            #[cfg(linux_android)]\n            ControlMessage::AlgSetIv(iv) =\u003e {\n                mem::size_of::\u003c\u0026[u8]\u003e() + iv.len()\n            },\n            #[cfg(linux_android)]\n            ControlMessage::AlgSetOp(op) =\u003e {\n                mem::size_of_val(op)\n            },\n            #[cfg(linux_android)]\n            ControlMessage::AlgSetAeadAssoclen(len) =\u003e {\n                mem::size_of_val(len)\n            },\n            #[cfg(target_os = \"linux\")]\n            #[cfg(feature = \"net\")]\n            ControlMessage::UdpGsoSegments(gso_size) =\u003e {\n                mem::size_of_val(gso_size)\n            },\n            #[cfg(any(linux_android, target_os = \"netbsd\", apple_targets))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv4PacketInfo(info) =\u003e mem::size_of_val(info),\n            #[cfg(any(linux_android, target_os = \"netbsd\",\n                      target_os = \"freebsd\", apple_targets))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv6PacketInfo(info) =\u003e mem::size_of_val(info),\n            #[cfg(any(freebsdlike, netbsdlike))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv4SendSrcAddr(addr) =\u003e mem::size_of_val(addr),\n            #[cfg(any(linux_android, target_os = \"freebsd\"))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv4Ttl(ttl) =\u003e {\n                mem::size_of_val(ttl)\n            },\n            #[cfg(any(linux_android, freebsdlike, apple_targets, target_os = \"haiku\"))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv6HopLimit(limit) =\u003e {\n                mem::size_of_val(limit)\n            },\n            #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n            ControlMessage::RxqOvfl(drop_count) =\u003e {\n                mem::size_of_val(drop_count)\n            },\n            #[cfg(target_os = \"linux\")]\n            ControlMessage::TxTime(tx_time) =\u003e {\n                mem::size_of_val(tx_time)\n            },\n            #[cfg(any(linux_android, target_os = \"freebsd\"))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv4Tos(tos) =\u003e {\n                mem::size_of_val(tos)\n            },\n            #[cfg(any(linux_android, target_os = \"freebsd\"))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv6TClass(tclass) =\u003e {\n                mem::size_of_val(tclass)\n            },\n        }\n    }\n\n    /// Returns the value to put into the `cmsg_level` field of the header.\n    fn cmsg_level(\u0026self) -\u003e libc::c_int {\n        match *self {\n            ControlMessage::ScmRights(_) =\u003e libc::SOL_SOCKET,\n            #[cfg(linux_android)]\n            ControlMessage::ScmCredentials(_) =\u003e libc::SOL_SOCKET,\n            #[cfg(freebsdlike)]\n            ControlMessage::ScmCreds =\u003e libc::SOL_SOCKET,\n            #[cfg(linux_android)]\n            ControlMessage::AlgSetIv(_) | ControlMessage::AlgSetOp(_) |\n                ControlMessage::AlgSetAeadAssoclen(_) =\u003e libc::SOL_ALG,\n            #[cfg(target_os = \"linux\")]\n            #[cfg(feature = \"net\")]\n            ControlMessage::UdpGsoSegments(_) =\u003e libc::SOL_UDP,\n            #[cfg(any(linux_android, target_os = \"netbsd\", apple_targets))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv4PacketInfo(_) =\u003e libc::IPPROTO_IP,\n            #[cfg(any(linux_android, target_os = \"netbsd\",\n                      target_os = \"freebsd\", apple_targets))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv6PacketInfo(_) =\u003e libc::IPPROTO_IPV6,\n            #[cfg(any(freebsdlike, netbsdlike))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv4SendSrcAddr(_) =\u003e libc::IPPROTO_IP,\n            #[cfg(any(linux_android, target_os = \"freebsd\"))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv4Ttl(_) =\u003e libc::IPPROTO_IP,\n            #[cfg(any(linux_android, freebsdlike, apple_targets, target_os = \"haiku\"))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv6HopLimit(_) =\u003e libc::IPPROTO_IPV6,\n            #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n            ControlMessage::RxqOvfl(_) =\u003e libc::SOL_SOCKET,\n            #[cfg(target_os = \"linux\")]\n            ControlMessage::TxTime(_) =\u003e libc::SOL_SOCKET,\n            #[cfg(any(linux_android, target_os = \"freebsd\"))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv4Tos(_) =\u003e libc::IPPROTO_IP,\n            #[cfg(any(linux_android, target_os = \"freebsd\"))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv6TClass(_) =\u003e libc::IPPROTO_IPV6,\n        }\n    }\n\n    /// Returns the value to put into the `cmsg_type` field of the header.\n    fn cmsg_type(\u0026self) -\u003e libc::c_int {\n        match *self {\n            ControlMessage::ScmRights(_) =\u003e libc::SCM_RIGHTS,\n            #[cfg(linux_android)]\n            ControlMessage::ScmCredentials(_) =\u003e libc::SCM_CREDENTIALS,\n            #[cfg(freebsdlike)]\n            ControlMessage::ScmCreds =\u003e libc::SCM_CREDS,\n            #[cfg(linux_android)]\n            ControlMessage::AlgSetIv(_) =\u003e {\n                libc::ALG_SET_IV\n            },\n            #[cfg(linux_android)]\n            ControlMessage::AlgSetOp(_) =\u003e {\n                libc::ALG_SET_OP\n            },\n            #[cfg(linux_android)]\n            ControlMessage::AlgSetAeadAssoclen(_) =\u003e {\n                libc::ALG_SET_AEAD_ASSOCLEN\n            },\n            #[cfg(target_os = \"linux\")]\n            #[cfg(feature = \"net\")]\n            ControlMessage::UdpGsoSegments(_) =\u003e {\n                libc::UDP_SEGMENT\n            },\n            #[cfg(any(linux_android, target_os = \"netbsd\", apple_targets))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv4PacketInfo(_) =\u003e libc::IP_PKTINFO,\n            #[cfg(any(linux_android, target_os = \"netbsd\",\n                      target_os = \"freebsd\", apple_targets))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv6PacketInfo(_) =\u003e libc::IPV6_PKTINFO,\n            #[cfg(any(freebsdlike, netbsdlike))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv4SendSrcAddr(_) =\u003e libc::IP_SENDSRCADDR,\n            #[cfg(any(linux_android, target_os = \"freebsd\"))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv4Ttl(_) =\u003e libc::IP_TTL,\n            #[cfg(any(linux_android, freebsdlike, apple_targets, target_os = \"haiku\"))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv6HopLimit(_) =\u003e libc::IPV6_HOPLIMIT,\n            #[cfg(any(linux_android, target_os = \"fuchsia\"))]\n            ControlMessage::RxqOvfl(_) =\u003e {\n                libc::SO_RXQ_OVFL\n            },\n            #[cfg(target_os = \"linux\")]\n            ControlMessage::TxTime(_) =\u003e {\n                libc::SCM_TXTIME\n            },\n            #[cfg(any(linux_android, target_os = \"freebsd\"))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv4Tos(_) =\u003e {\n                libc::IP_TOS\n            },\n            #[cfg(any(linux_android, target_os = \"freebsd\"))]\n            #[cfg(feature = \"net\")]\n            ControlMessage::Ipv6TClass(_) =\u003e {\n                libc::IPV6_TCLASS\n            },\n        }\n    }\n\n    // Unsafe: cmsg must point to a valid cmsghdr with enough space to\n    // encode self.\n    unsafe fn encode_into(\u0026self, cmsg: *mut cmsghdr) {\n        unsafe {\n            (*cmsg).cmsg_level = self.cmsg_level();\n            (*cmsg).cmsg_type = self.cmsg_type();\n            (*cmsg).cmsg_len = self.cmsg_len();\n            self.copy_to_cmsg_data( CMSG_DATA(cmsg) );\n        }\n    }\n}\n\n\n/// Send data in scatter-gather vectors to a socket, possibly accompanied\n/// by ancillary data. Optionally direct the message at the given address,\n/// as with sendto.\n///\n/// Allocates if cmsgs is nonempty.\n///\n/// # Examples\n/// When not directing to any specific address, use `()` for the generic type\n/// ```\n/// # use nix::sys::socket::*;\n/// # use nix::unistd::pipe;\n/// # use std::io::IoSlice;\n/// # use std::os::unix::io::AsRawFd;\n/// let (fd1, fd2) = socketpair(AddressFamily::Unix, SockType::Stream, None,\n///     SockFlag::empty())\n///     .unwrap();\n/// let (r, w) = pipe().unwrap();\n///\n/// let iov = [IoSlice::new(b\"hello\")];\n/// let fds = [r.as_raw_fd()];\n/// let cmsg = ControlMessage::ScmRights(\u0026fds);\n/// sendmsg::\u003c()\u003e(fd1.as_raw_fd(), \u0026iov, \u0026[cmsg], MsgFlags::empty(), None).unwrap();\n/// ```\n/// When directing to a specific address, the generic type will be inferred.\n/// Note that SCM_RIGHTS ancillary data are valid only for AF_UNIX sockets on Solaris.\n/// ```\n/// # use nix::sys::socket::*;\n/// # use nix::unistd::pipe;\n/// # use std::io::IoSlice;\n/// # use std::str::FromStr;\n/// # use std::os::unix::io::AsRawFd;\n/// let localhost = SockaddrIn::from_str(\"1.2.3.4:8080\").unwrap();\n/// let fd = socket(AddressFamily::Inet, SockType::Datagram, SockFlag::empty(),\n///     None).unwrap();\n/// let (r, w) = pipe().unwrap();\n///\n/// let iov = [IoSlice::new(b\"hello\")];\n/// let fds = [r.as_raw_fd()];\n/// let cmsg = ControlMessage::ScmRights(\u0026fds);\n/// #[cfg(not(target_os = \"solaris\"))]\n/// sendmsg(fd.as_raw_fd(), \u0026iov, \u0026[cmsg], MsgFlags::empty(), Some(\u0026localhost)).unwrap();\n/// ```\npub fn sendmsg\u003cS\u003e(fd: RawFd, iov: \u0026[IoSlice\u003c'_\u003e], cmsgs: \u0026[ControlMessage],\n               flags: MsgFlags, addr: Option\u003c\u0026S\u003e) -\u003e Result\u003cusize\u003e\n    where S: SockaddrLike\n{\n    let capacity = cmsgs.iter().map(|c| c.space()).sum();\n\n    // First size the buffer needed to hold the cmsgs.  It must be zeroed,\n    // because subsequent code will not clear the padding bytes.\n    let mut cmsg_buffer = vec![0u8; capacity];\n\n    let mhdr = pack_mhdr_to_send(\u0026mut cmsg_buffer[..], iov, cmsgs, addr);\n\n    let ret = unsafe { libc::sendmsg(fd, \u0026mhdr, flags.bits()) };\n\n    Errno::result(ret).map(|r| r as usize)\n}\n\n\n/// An extension of `sendmsg` that allows the caller to transmit multiple\n/// messages on a socket using a single system call. This has performance\n/// benefits for some applications.\n///\n/// Allocations are performed for cmsgs and to build `msghdr` buffer\n///\n/// # Arguments\n///\n/// * `fd`:             Socket file descriptor\n/// * `data`:           Struct that implements `IntoIterator` with `SendMmsgData` items\n/// * `flags`:          Optional flags passed directly to the operating system.\n///\n/// # Returns\n/// `Vec` with numbers of sent bytes on each sent message.\n///\n/// # References\n/// [`sendmsg`](fn.sendmsg.html)\n#[cfg(any(linux_android, target_os = \"freebsd\", target_os = \"netbsd\"))]\npub fn sendmmsg\u003c'a, XS, AS, C, I, S\u003e(\n    fd: RawFd,\n    data: \u0026'a mut MultiHeaders\u003cS\u003e,\n    slices: XS,\n    // one address per group of slices\n    addrs: AS,\n    // shared across all the messages\n    cmsgs: C,\n    flags: MsgFlags\n) -\u003e crate::Result\u003cMultiResults\u003c'a, S\u003e\u003e\n    where\n        XS: IntoIterator\u003cItem = \u0026'a I\u003e,\n        AS: AsRef\u003c[Option\u003cS\u003e]\u003e,\n        I: AsRef\u003c[IoSlice\u003c'a\u003e]\u003e + 'a,\n        C: AsRef\u003c[ControlMessage\u003c'a\u003e]\u003e + 'a,\n        S: SockaddrLike + 'a,\n{\n\n    let mut count = 0;\n\n\n    for (i, ((slice, addr), mmsghdr)) in slices.into_iter().zip(addrs.as_ref()).zip(data.items.iter_mut() ).enumerate() {\n        let p = \u0026mut mmsghdr.msg_hdr;\n        p.msg_iov = slice.as_ref().as_ptr().cast_mut().cast();\n        p.msg_iovlen = slice.as_ref().len() as _;\n\n        p.msg_namelen = addr.as_ref().map_or(0, S::len);\n        p.msg_name = addr.as_ref().map_or(ptr::null(), S::as_ptr).cast_mut().cast();\n\n        // Encode each cmsg.  This must happen after initializing the header because\n        // CMSG_NEXT_HDR and friends read the msg_control and msg_controllen fields.\n        // CMSG_FIRSTHDR is always safe\n        let mut pmhdr: *mut cmsghdr = unsafe { CMSG_FIRSTHDR(p) };\n        for cmsg in cmsgs.as_ref() {\n            assert_ne!(pmhdr, ptr::null_mut());\n            // Safe because we know that pmhdr is valid, and we initialized it with\n            // sufficient space\n            unsafe { cmsg.encode_into(pmhdr) };\n            // Safe because mhdr is valid\n            pmhdr = unsafe { CMSG_NXTHDR(p, pmhdr) };\n        }\n\n        // Doing an unchecked addition is alright here, as the only way to obtain an instance of `MultiHeaders`\n        // is through the `preallocate` function, which takes an `usize` as an argument to define its size,\n        // which also provides an upper bound for the size of this zipped iterator. Thus, `i \u003c usize::MAX` or in\n        // other words: `count` doesn't overflow\n        count = i + 1;\n    }\n\n    // SAFETY: all pointers are guaranteed to be valid for the scope of this function. `count` does represent the\n    // maximum number of messages that can be sent safely (i.e. `count` is the minimum of the sizes of `slices`,\n    // `data.items` and `addrs`)\n    let sent = Errno::result(unsafe {\n        libc::sendmmsg(\n            fd,\n            data.items.as_mut_ptr(),\n            count as _,\n            flags.bits() as _\n        )\n    })? as usize;\n\n    Ok(MultiResults {\n        rmm: data,\n        current_index: 0,\n        received: sent\n    })\n\n}\n\n\n#[cfg(any(linux_android, target_os = \"freebsd\", target_os = \"netbsd\"))]\n#[derive(Debug)]\n/// Preallocated structures needed for [`recvmmsg`] and [`sendmmsg`] functions\npub struct MultiHeaders\u003cS\u003e {\n    // preallocated boxed slice of mmsghdr\n    items: Box\u003c[libc::mmsghdr]\u003e,\n    addresses: Box\u003c[mem::MaybeUninit\u003cS\u003e]\u003e,\n    // while we are not using it directly - this is used to store control messages\n    // and we retain pointers to them inside items array\n    _cmsg_buffers: Option\u003cBox\u003c[u8]\u003e\u003e,\n    msg_controllen: usize,\n}\n\n#[cfg(any(linux_android, target_os = \"freebsd\", target_os = \"netbsd\"))]\nimpl\u003cS\u003e MultiHeaders\u003cS\u003e {\n    /// Preallocate structure used by [`recvmmsg`] and [`sendmmsg`] takes number of headers to preallocate\n    ///\n    /// `cmsg_buffer` should be created with [`cmsg_space!`] if needed\n    pub fn preallocate(num_slices: usize, cmsg_buffer: Option\u003cVec\u003cu8\u003e\u003e) -\u003e Self\n    where\n        S: Copy + SockaddrLike,\n    {\n        // we will be storing pointers to addresses inside mhdr - convert it into boxed\n        // slice so it can'be changed later by pushing anything into self.addresses\n        let mut addresses = vec![std::mem::MaybeUninit::\u003cS\u003e::uninit(); num_slices].into_boxed_slice();\n\n        let msg_controllen = cmsg_buffer.as_ref().map_or(0, |v| v.capacity());\n\n        // we'll need a cmsg_buffer for each slice, we preallocate a vector and split\n        // it into \"slices\" parts\n        let mut cmsg_buffers =\n            cmsg_buffer.map(|v| vec![0u8; v.capacity() * num_slices].into_boxed_slice());\n\n        let items = addresses\n            .iter_mut()\n            .enumerate()\n            .map(|(ix, address)| {\n                let (ptr, cap) = match \u0026mut cmsg_buffers {\n                    Some(v) =\u003e (\u0026mut v[ix * msg_controllen] as *mut u8, msg_controllen),\n                    None =\u003e (std::ptr::null_mut(), 0),\n                };\n                let msg_hdr = unsafe { pack_mhdr_to_receive(std::ptr::null_mut(), 0, ptr, cap, address.as_mut_ptr()) };\n                libc::mmsghdr {\n                    msg_hdr,\n                    msg_len: 0,\n                }\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n\n        Self {\n            items: items.into_boxed_slice(),\n            addresses,\n            _cmsg_buffers: cmsg_buffers,\n            msg_controllen,\n        }\n    }\n}\n\n/// An extension of recvmsg that allows the caller to receive multiple messages from a socket using a single system call.\n///\n/// This has performance benefits for some applications.\n///\n/// This method performs no allocations.\n///\n/// Returns an iterator producing [`RecvMsg`], one per received messages. Each `RecvMsg` can produce\n/// iterators over [`IoSlice`] with [`iovs`][RecvMsg::iovs`] and\n/// `ControlMessageOwned` with [`cmsgs`][RecvMsg::cmsgs].\n///\n/// # Bugs (in underlying implementation, at least in Linux)\n/// The timeout argument does not work as intended. The timeout is checked only after the receipt\n/// of each datagram, so that if up to `vlen`-1 datagrams are received before the timeout expires,\n/// but then no further datagrams are received, the call will block forever.\n///\n/// If an error occurs after at least one message has been received, the call succeeds, and returns\n/// the number of messages received. The error code is expected to be returned on a subsequent\n/// call to recvmmsg(). In the current implementation, however, the error code can be\n/// overwritten in the meantime by an unrelated network event on a socket, for example an\n/// incoming ICMP packet.\n// On aarch64 linux using recvmmsg and trying to get hardware/kernel timestamps might not\n// always produce the desired results - see https://github.com/nix-rust/nix/pull/1744 for more\n// details\n#[cfg(any(linux_android, target_os = \"freebsd\", target_os = \"netbsd\"))]\npub fn recvmmsg\u003c'a, XS, S, I\u003e(\n    fd: RawFd,\n    data: \u0026'a mut MultiHeaders\u003cS\u003e,\n    slices: XS,\n    flags: MsgFlags,\n    mut timeout: Option\u003ccrate::sys::time::TimeSpec\u003e,\n) -\u003e crate::Result\u003cMultiResults\u003c'a, S\u003e\u003e\nwhere\n    XS: IntoIterator\u003cItem = \u0026'a mut I\u003e,\n    I: AsMut\u003c[IoSliceMut\u003c'a\u003e]\u003e + 'a,\n{\n    let mut count = 0;\n    for (i, (slice, mmsghdr)) in slices.into_iter().zip(data.items.iter_mut()).enumerate() {\n        let p = \u0026mut mmsghdr.msg_hdr;\n        p.msg_iov = slice.as_mut().as_mut_ptr().cast();\n        p.msg_iovlen = slice.as_mut().len() as _;\n\n        // Doing an unchecked addition is alright here, as the only way to obtain an instance of `MultiHeaders`\n        // is through the `preallocate` function, which takes an `usize` as an argument to define its size,\n        // which also provides an upper bound for the size of this zipped iterator. Thus, `i \u003c usize::MAX` or in\n        // other words: `count` doesn't overflow\n        count = i + 1;\n    }\n\n    let timeout_ptr = timeout\n        .as_mut()\n        .map_or_else(std::ptr::null_mut, |t| t as *mut _ as *mut libc::timespec);\n\n    // SAFETY: all pointers are guaranteed to be valid for the scope of this function. `count` does represent the\n    // maximum number of messages that can be received safely (i.e. `count` is the minimum of the sizes of `slices` and `data.items`)\n    let received = Errno::result(unsafe {\n        libc::recvmmsg(\n            fd,\n            data.items.as_mut_ptr(),\n            count as _,\n            flags.bits() as _,\n            timeout_ptr,\n        )\n    })? as usize;\n\n    Ok(MultiResults {\n        rmm: data,\n        current_index: 0,\n        received,\n    })\n}\n\n/// Iterator over results of [`recvmmsg`]/[`sendmmsg`]\n#[cfg(any(linux_android, target_os = \"freebsd\", target_os = \"netbsd\"))]\n#[derive(Debug)]\npub struct MultiResults\u003c'a, S\u003e {\n    // preallocated structures\n    rmm: \u0026'a MultiHeaders\u003cS\u003e,\n    current_index: usize,\n    received: usize,\n}\n\n#[cfg(any(linux_android, target_os = \"freebsd\", target_os = \"netbsd\"))]\nimpl\u003c'a, S\u003e Iterator for MultiResults\u003c'a, S\u003e\nwhere\n    S: Copy + SockaddrLike,\n{\n    type Item = RecvMsg\u003c'a, 'a, S\u003e;\n\n    // The cast is not unnecessary on all platforms.\n    #[allow(clippy::unnecessary_cast)]\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        if self.current_index \u003e= self.received {\n            return None;\n        }\n        let mmsghdr = self.rmm.items[self.current_index];\n\n        // as long as we are not reading past the index writen by recvmmsg - address\n        // will be initialized\n        let address = unsafe { self.rmm.addresses[self.current_index].assume_init() };\n\n        self.current_index += 1;\n        Some(unsafe {\n            read_mhdr(\n                mmsghdr.msg_hdr,\n                mmsghdr.msg_len as isize,\n                self.rmm.msg_controllen,\n                address,\n            )\n        })\n    }\n}\n\nimpl\u003c'a, S\u003e RecvMsg\u003c'_, 'a, S\u003e {\n    /// Iterate over the filled io slices pointed by this msghdr\n    pub fn iovs(\u0026self) -\u003e IoSliceIterator\u003c'a\u003e {\n        IoSliceIterator {\n            index: 0,\n            remaining: self.bytes,\n            slices: unsafe {\n                // safe for as long as mgdr is properly initialized and references are valid.\n                // for multi messages API we initialize it with an empty\n                // slice and replace with a concrete buffer\n                // for single message API we hold a lifetime reference to ioslices\n                std::slice::from_raw_parts(self.mhdr.msg_iov as *const _, self.mhdr.msg_iovlen as _)\n            },\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct IoSliceIterator\u003c'a\u003e {\n    index: usize,\n    remaining: usize,\n    slices: \u0026'a [IoSlice\u003c'a\u003e],\n}\n\nimpl\u003c'a\u003e Iterator for IoSliceIterator\u003c'a\u003e {\n    type Item = \u0026'a [u8];\n\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\n        if self.index \u003e= self.slices.len() {\n            return None;\n        }\n        let slice = \u0026self.slices[self.index][..self.remaining.min(self.slices[self.index].len())];\n        self.remaining -= slice.len();\n        self.index += 1;\n        if slice.is_empty() {\n            return None;\n        }\n\n        Some(slice)\n    }\n}\n\nunsafe fn read_mhdr\u003c'a, 'i, S\u003e(\n    mhdr: msghdr,\n    r: isize,\n    msg_controllen: usize,\n    mut address: S,\n) -\u003e RecvMsg\u003c'a, 'i, S\u003e\n    where S: SockaddrLike\n{\n    // The cast is not unnecessary on all platforms.\n    #[allow(clippy::unnecessary_cast)]\n    let cmsghdr = {\n        let ptr = if mhdr.msg_controllen \u003e 0 {\n            debug_assert!(!mhdr.msg_control.is_null());\n            debug_assert!(msg_controllen \u003e= mhdr.msg_controllen as usize);\n            unsafe { CMSG_FIRSTHDR(\u0026mhdr as *const msghdr) }\n        } else {\n            ptr::null()\n        };\n\n        unsafe {\n            ptr.as_ref()\n        }\n    };\n\n    // Ignore errors if this socket address has statically-known length\n    //\n    // This is to ensure that unix socket addresses have their length set appropriately.\n    let _ = unsafe { address.set_length(mhdr.msg_namelen as usize) };\n\n    RecvMsg {\n        bytes: r as usize,\n        cmsghdr,\n        address: Some(address),\n        flags: MsgFlags::from_bits_truncate(mhdr.msg_flags),\n        mhdr,\n        iobufs: std::marker::PhantomData,\n    }\n}\n\n/// Pack pointers to various structures into into msghdr\n///\n/// # Safety\n/// `iov_buffer` and `iov_buffer_len` must point to a slice\n/// of `IoSliceMut` and number of available elements or be a null pointer and 0\n///\n/// `cmsg_buffer` and `cmsg_capacity` must point to a byte buffer used\n/// to store control headers later or be a null pointer and 0 if control\n/// headers are not used\n///\n/// Buffers must remain valid for the whole lifetime of msghdr\nunsafe fn pack_mhdr_to_receive\u003cS\u003e(\n    iov_buffer: *mut IoSliceMut,\n    iov_buffer_len: usize,\n    cmsg_buffer: *mut u8,\n    cmsg_capacity: usize,\n    address: *mut S,\n) -\u003e msghdr\n    where\n        S: SockaddrLike\n{\n    // Musl's msghdr has private fields, so this is the only way to\n    // initialize it.\n    let mut mhdr = mem::MaybeUninit::\u003cmsghdr\u003e::zeroed();\n    let p = mhdr.as_mut_ptr();\n    unsafe {\n        // it is important to use as_mut_ptr() here since S can be\n        // a zero sized type representing by a dangling pointer.\n        // as_mut_ptr() handles this case and uses a null pointer instead\n        (*p).msg_name = (*address).as_mut_ptr() as *mut c_void;\n        (*p).msg_namelen = S::size();\n        (*p).msg_iov = iov_buffer as *mut iovec;\n        (*p).msg_iovlen = iov_buffer_len as _;\n        (*p).msg_control = cmsg_buffer as *mut c_void;\n        (*p).msg_controllen = cmsg_capacity as _;\n        (*p).msg_flags = 0;\n        mhdr.assume_init()\n    }\n}\n\nfn pack_mhdr_to_send\u003c'a, I, C, S\u003e(\n    cmsg_buffer: \u0026mut [u8],\n    iov: I,\n    cmsgs: C,\n    addr: Option\u003c\u0026S\u003e\n) -\u003e msghdr\n    where\n        I: AsRef\u003c[IoSlice\u003c'a\u003e]\u003e,\n        C: AsRef\u003c[ControlMessage\u003c'a\u003e]\u003e,\n        S: SockaddrLike + 'a\n{\n    let capacity = cmsg_buffer.len();\n\n    // The message header must be initialized before the individual cmsgs.\n    let cmsg_ptr = if capacity \u003e 0 {\n        cmsg_buffer.as_mut_ptr().cast()\n    } else {\n        ptr::null_mut()\n    };\n\n    let mhdr = unsafe {\n        // Musl's msghdr has private fields, so this is the only way to\n        // initialize it.\n        let mut mhdr = mem::MaybeUninit::\u003cmsghdr\u003e::zeroed();\n        let p = mhdr.as_mut_ptr();\n        (*p).msg_name = addr.map(S::as_ptr).unwrap_or(ptr::null()).cast_mut().cast();\n        (*p).msg_namelen = addr.map(S::len).unwrap_or(0);\n        // transmute iov into a mutable pointer.  sendmsg doesn't really mutate\n        // the buffer, but the standard says that it takes a mutable pointer\n        (*p).msg_iov = iov.as_ref().as_ptr().cast_mut().cast();\n        (*p).msg_iovlen = iov.as_ref().len() as _;\n        (*p).msg_control = cmsg_ptr;\n        (*p).msg_controllen = capacity as _;\n        (*p).msg_flags = 0;\n        mhdr.assume_init()\n    };\n\n    // Encode each cmsg.  This must happen after initializing the header because\n    // CMSG_NEXT_HDR and friends read the msg_control and msg_controllen fields.\n    // CMSG_FIRSTHDR is always safe\n    let mut pmhdr: *mut cmsghdr = unsafe { CMSG_FIRSTHDR(\u0026mhdr as *const msghdr) };\n    for cmsg in cmsgs.as_ref() {\n        assert_ne!(pmhdr, ptr::null_mut());\n        // Safe because we know that pmhdr is valid, and we initialized it with\n        // sufficient space\n        unsafe { cmsg.encode_into(pmhdr) };\n        // Safe because mhdr is valid\n        pmhdr = unsafe { CMSG_NXTHDR(\u0026mhdr as *const msghdr, pmhdr) };\n    }\n\n    mhdr\n}\n\n/// Receive message in scatter-gather vectors from a socket, and\n/// optionally receive ancillary data into the provided buffer.\n/// If no ancillary data is desired, use () as the type parameter.\n///\n/// # Arguments\n///\n/// * `fd`:             Socket file descriptor\n/// * `iov`:            Scatter-gather list of buffers to receive the message\n/// * `cmsg_buffer`:    Space to receive ancillary data.  Should be created by\n///                     [`cmsg_space!`](../../macro.cmsg_space.html)\n/// * `flags`:          Optional flags passed directly to the operating system.\n///\n/// # References\n/// [recvmsg(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvmsg.html)\npub fn recvmsg\u003c'a, 'outer, 'inner, S\u003e(fd: RawFd, iov: \u0026'outer mut [IoSliceMut\u003c'inner\u003e],\n                   mut cmsg_buffer: Option\u003c\u0026'a mut [u8]\u003e,\n                   flags: MsgFlags) -\u003e Result\u003cRecvMsg\u003c'a, 'outer, S\u003e\u003e\n    where S: SockaddrLike + 'a,\n    'inner: 'outer\n{\n    let mut address = mem::MaybeUninit::uninit();\n\n    let (msg_control, msg_controllen) = cmsg_buffer.as_mut()\n        .map(|v| (v.as_mut_ptr(), v.len()))\n        .unwrap_or((ptr::null_mut(), 0));\n    let mut mhdr = unsafe {\n        pack_mhdr_to_receive(iov.as_mut().as_mut_ptr(), iov.len(), msg_control, msg_controllen, address.as_mut_ptr())\n    };\n\n    let ret = unsafe { libc::recvmsg(fd, \u0026mut mhdr, flags.bits()) };\n\n    let r = Errno::result(ret)?;\n\n    Ok(unsafe { read_mhdr(mhdr, r, msg_controllen, address.assume_init()) })\n}\n}\n\n/// Create an endpoint for communication\n///\n/// The `protocol` specifies a particular protocol to be used with the\n/// socket.  Normally only a single protocol exists to support a\n/// particular socket type within a given protocol family, in which case\n/// protocol can be specified as `None`.  However, it is possible that many\n/// protocols may exist, in which case a particular protocol must be\n/// specified in this manner.\n///\n/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html)\npub fn socket\u003cT: Into\u003cOption\u003cSockProtocol\u003e\u003e\u003e(\n    domain: AddressFamily,\n    ty: SockType,\n    flags: SockFlag,\n    protocol: T,\n) -\u003e Result\u003cOwnedFd\u003e {\n    let protocol = match protocol.into() {\n        None =\u003e 0,\n        Some(p) =\u003e p as c_int,\n    };\n\n    // SockFlags are usually embedded into `ty`, but we don't do that in `nix` because it's a\n    // little easier to understand by separating it out. So we have to merge these bitfields\n    // here.\n    let mut ty = ty as c_int;\n    ty |= flags.bits();\n\n    let res = unsafe { libc::socket(domain as c_int, ty, protocol) };\n\n    match res {\n        -1 =\u003e Err(Errno::last()),\n        fd =\u003e {\n            // Safe because libc::socket returned success\n            unsafe { Ok(OwnedFd::from_raw_fd(fd)) }\n        }\n    }\n}\n\n/// Create a pair of connected sockets\n///\n/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/socketpair.html)\npub fn socketpair\u003cT: Into\u003cOption\u003cSockProtocol\u003e\u003e\u003e(\n    domain: AddressFamily,\n    ty: SockType,\n    protocol: T,\n    flags: SockFlag,\n) -\u003e Result\u003c(OwnedFd, OwnedFd)\u003e {\n    let protocol = match protocol.into() {\n        None =\u003e 0,\n        Some(p) =\u003e p as c_int,\n    };\n\n    // SockFlags are usually embedded into `ty`, but we don't do that in `nix` because it's a\n    // little easier to understand by separating it out. So we have to merge these bitfields\n    // here.\n    let mut ty = ty as c_int;\n    ty |= flags.bits();\n\n    let mut fds = [-1, -1];\n\n    let res = unsafe {\n        libc::socketpair(domain as c_int, ty, protocol, fds.as_mut_ptr())\n    };\n    Errno::result(res)?;\n\n    // Safe because socketpair returned success.\n    unsafe { Ok((OwnedFd::from_raw_fd(fds[0]), OwnedFd::from_raw_fd(fds[1]))) }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct Backlog(i32);\n\nimpl Backlog {\n    /// Sets the listen queue size to system `SOMAXCONN` value\n    pub const MAXCONN: Self = Self(libc::SOMAXCONN);\n    /// Sets the listen queue size to -1 for system supporting it\n    #[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))]\n    pub const MAXALLOWABLE: Self = Self(-1);\n\n    /// Create a `Backlog`, an `EINVAL` will be returned if `val` is invalid.\n    pub fn new\u003cI: Into\u003ci32\u003e\u003e(val: I) -\u003e Result\u003cSelf\u003e {\n        cfg_if! {\n            if #[cfg(any(target_os = \"linux\", target_os = \"freebsd\"))] {\n                const MIN: i32 = -1;\n            } else {\n                const MIN: i32 = 0;\n            }\n        }\n\n        let val = val.into();\n\n        if !(MIN..=Self::MAXCONN.0).contains(\u0026val) {\n            return Err(Errno::EINVAL);\n        }\n\n        Ok(Self(val))\n    }\n}\n\nimpl From\u003cBacklog\u003e for i32 {\n    fn from(backlog: Backlog) -\u003e Self {\n        backlog.0\n    }\n}\n\n/// Listen for connections on a socket\n///\n/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/listen.html)\npub fn listen\u003cF: AsFd\u003e(sock: \u0026F, backlog: Backlog) -\u003e Result\u003c()\u003e {\n    let fd = sock.as_fd().as_raw_fd();\n    let res = unsafe { libc::listen(fd, backlog.into()) };\n\n    Errno::result(res).map(drop)\n}\n\n/// Bind a name to a socket\n///\n/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html)\npub fn bind(fd: RawFd, addr: \u0026dyn SockaddrLike) -\u003e Result\u003c()\u003e {\n    let res = unsafe { libc::bind(fd, addr.as_ptr(), addr.len()) };\n\n    Errno::result(res).map(drop)\n}\n\n/// Accept a connection on a socket\n///\n/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/accept.html)\npub fn accept(sockfd: RawFd) -\u003e Result\u003cRawFd\u003e {\n    let res = unsafe { libc::accept(sockfd, ptr::null_mut(), ptr::null_mut()) };\n\n    Errno::result(res)\n}\n\n/// Accept a connection on a socket\n///\n/// [Further reading](https://man7.org/linux/man-pages/man2/accept.2.html)\n#[cfg(any(\n    all(\n        target_os = \"android\",\n        any(\n            target_arch = \"aarch64\",\n            target_arch = \"x86\",\n            target_arch = \"x86_64\"\n        )\n    ),\n    freebsdlike,\n    netbsdlike,\n    target_os = \"emscripten\",\n    target_os = \"fuchsia\",\n    solarish,\n    target_os = \"linux\",\n))]\npub fn accept4(sockfd: RawFd, flags: SockFlag) -\u003e Result\u003cRawFd\u003e {\n    let res = unsafe {\n        libc::accept4(sockfd, ptr::null_mut(), ptr::null_mut(), flags.bits())\n    };\n\n    Errno::result(res)\n}\n\n/// Initiate a connection on a socket\n///\n/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html)\npub fn connect(fd: RawFd, addr: \u0026dyn SockaddrLike) -\u003e Result\u003c()\u003e {\n    let res = unsafe { libc::connect(fd, addr.as_ptr(), addr.len()) };\n\n    Errno::result(res).map(drop)\n}\n\n/// Receive data from a connection-oriented socket. Returns the number of\n/// bytes read\n///\n/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/recv.html)\npub fn recv(sockfd: RawFd, buf: \u0026mut [u8], flags: MsgFlags) -\u003e Result\u003cusize\u003e {\n    unsafe {\n        let ret = libc::recv(\n            sockfd,\n            buf.as_mut_ptr().cast(),\n            buf.len() as size_t,\n            flags.bits(),\n        );\n\n        Errno::result(ret).map(|r| r as usize)\n    }\n}\n\n/// Receive data from a connectionless or connection-oriented socket. Returns\n/// the number of bytes read and, for connectionless sockets,  the socket\n/// address of the sender.\n///\n/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvfrom.html)\npub fn recvfrom\u003cT: SockaddrLike\u003e(\n    sockfd: RawFd,\n    buf: \u0026mut [u8],\n) -\u003e Result\u003c(usize, Option\u003cT\u003e)\u003e {\n    unsafe {\n        let mut addr = mem::MaybeUninit::\u003cT\u003e::uninit();\n        let mut len = mem::size_of_val(\u0026addr) as socklen_t;\n\n        let ret = Errno::result(libc::recvfrom(\n            sockfd,\n            buf.as_mut_ptr().cast(),\n            buf.len() as size_t,\n            0,\n            addr.as_mut_ptr().cast(),\n            \u0026mut len as *mut socklen_t,\n        ))? as usize;\n\n        Ok((ret, T::from_raw(addr.assume_init().as_ptr(), Some(len))))\n    }\n}\n\n/// Send a message to a socket\n///\n/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendto.html)\npub fn sendto(\n    fd: RawFd,\n    buf: \u0026[u8],\n    addr: \u0026dyn SockaddrLike,\n    flags: MsgFlags,\n) -\u003e Result\u003cusize\u003e {\n    let ret = unsafe {\n        libc::sendto(\n            fd,\n            buf.as_ptr().cast(),\n            buf.len() as size_t,\n            flags.bits(),\n            addr.as_ptr(),\n            addr.len(),\n        )\n    };\n\n    Errno::result(ret).map(|r| r as usize)\n}\n\n/// Send data to a connection-oriented socket. Returns the number of bytes read\n///\n/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/send.html)\npub fn send(fd: RawFd, buf: \u0026[u8], flags: MsgFlags) -\u003e Result\u003cusize\u003e {\n    let ret = unsafe {\n        libc::send(fd, buf.as_ptr().cast(), buf.len() as size_t, flags.bits())\n    };\n\n    Errno::result(ret).map(|r| r as usize)\n}\n\n/*\n *\n * ===== Socket Options =====\n *\n */\n\n/// Represents a socket option that can be retrieved.\npub trait GetSockOpt: Copy {\n    type Val;\n\n    /// Look up the value of this socket option on the given socket.\n    fn get\u003cF: AsFd\u003e(\u0026self, fd: \u0026F) -\u003e Result\u003cSelf::Val\u003e;\n}\n\n/// Represents a socket option that can be set.\npub trait SetSockOpt: Clone {\n    type Val: ?Sized;\n\n    /// Set the value of this socket option on the given socket.\n    fn set\u003cF: AsFd\u003e(\u0026self, fd: \u0026F, val: \u0026Self::Val) -\u003e Result\u003c()\u003e;\n}\n\n/// Get the current value for the requested socket option\n///\n/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockopt.html)\npub fn getsockopt\u003cF: AsFd, O: GetSockOpt\u003e(fd: \u0026F, opt: O) -\u003e Result\u003cO::Val\u003e {\n    opt.get(fd)\n}\n\n/// Sets the value for the requested socket option\n///\n/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/setsockopt.html)\n///\n/// # Examples\n///\n/// ```\n/// use nix::sys::socket::setsockopt;\n/// use nix::sys::socket::sockopt::KeepAlive;\n/// use std::net::TcpListener;\n///\n/// let listener = TcpListener::bind(\"0.0.0.0:0\").unwrap();\n/// let fd = listener;\n/// let res = setsockopt(\u0026fd, KeepAlive, \u0026true);\n/// assert!(res.is_ok());\n/// ```\npub fn setsockopt\u003cF: AsFd, O: SetSockOpt\u003e(\n    fd: \u0026F,\n    opt: O,\n    val: \u0026O::Val,\n) -\u003e Result\u003c()\u003e {\n    opt.set(fd, val)\n}\n\n/// Get the address of the peer connected to the socket `fd`.\n///\n/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html)\npub fn getpeername\u003cT: SockaddrLike\u003e(fd: RawFd) -\u003e Result\u003cT\u003e {\n    unsafe {\n        let mut addr = mem::MaybeUninit::\u003cT\u003e::uninit();\n        let mut len = T::size();\n\n        let ret = libc::getpeername(fd, addr.as_mut_ptr().cast(), \u0026mut len);\n\n        Errno::result(ret)?;\n\n        T::from_raw(addr.assume_init().as_ptr(), Some(len)).ok_or(Errno::EINVAL)\n    }\n}\n\n/// Get the current address to which the socket `fd` is bound.\n///\n/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html)\npub fn getsockname\u003cT: SockaddrLike\u003e(fd: RawFd) -\u003e Result\u003cT\u003e {\n    unsafe {\n        let mut addr = mem::MaybeUninit::\u003cT\u003e::uninit();\n        let mut len = T::size();\n\n        let ret = libc::getsockname(fd, addr.as_mut_ptr().cast(), \u0026mut len);\n\n        Errno::result(ret)?;\n\n        T::from_raw(addr.assume_init().as_ptr(), Some(len)).ok_or(Errno::EINVAL)\n    }\n}\n\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub enum Shutdown {\n    /// Further receptions will be disallowed.\n    Read,\n    /// Further  transmissions will be disallowed.\n    Write,\n    /// Further receptions and transmissions will be disallowed.\n    Both,\n}\n\n/// Shut down part of a full-duplex connection.\n///\n/// [Further reading](https://pubs.opengroup.org/onlinepubs/9699919799/functions/shutdown.html)\npub fn shutdown(df: RawFd, how: Shutdown) -\u003e Result\u003c()\u003e {\n    unsafe {\n        use libc::shutdown;\n\n        let how = match how {\n            Shutdown::Read =\u003e libc::SHUT_RD,\n            Shutdown::Write =\u003e libc::SHUT_WR,\n            Shutdown::Both =\u003e libc::SHUT_RDWR,\n        };\n\n        Errno::result(shutdown(df, how)).map(drop)\n    }\n}\n","traces":[{"line":2227,"address":[],"length":0,"stats":{"Line":0}},{"line":2228,"address":[],"length":0,"stats":{"Line":0}},{"line":2229,"address":[],"length":0,"stats":{"Line":0}},{"line":2235,"address":[],"length":0,"stats":{"Line":0}},{"line":2236,"address":[],"length":0,"stats":{"Line":0}},{"line":2238,"address":[],"length":0,"stats":{"Line":0}},{"line":2240,"address":[],"length":0,"stats":{"Line":0}},{"line":2241,"address":[],"length":0,"stats":{"Line":0}},{"line":2242,"address":[],"length":0,"stats":{"Line":0}},{"line":2244,"address":[],"length":0,"stats":{"Line":0}},{"line":2258,"address":[],"length":0,"stats":{"Line":0}},{"line":2259,"address":[],"length":0,"stats":{"Line":0}},{"line":2260,"address":[],"length":0,"stats":{"Line":0}},{"line":2266,"address":[],"length":0,"stats":{"Line":0}},{"line":2267,"address":[],"length":0,"stats":{"Line":0}},{"line":2269,"address":[],"length":0,"stats":{"Line":0}},{"line":2272,"address":[],"length":0,"stats":{"Line":0}},{"line":2274,"address":[],"length":0,"stats":{"Line":0}},{"line":2277,"address":[],"length":0,"stats":{"Line":0}},{"line":2291,"address":[],"length":0,"stats":{"Line":0}},{"line":2292,"address":[],"length":0,"stats":{"Line":0}},{"line":2293,"address":[],"length":0,"stats":{"Line":0}},{"line":2294,"address":[],"length":0,"stats":{"Line":0}},{"line":2296,"address":[],"length":0,"stats":{"Line":0}},{"line":2300,"address":[],"length":0,"stats":{"Line":0}},{"line":2302,"address":[],"length":0,"stats":{"Line":0}},{"line":2303,"address":[],"length":0,"stats":{"Line":0}},{"line":2306,"address":[],"length":0,"stats":{"Line":0}},{"line":2319,"address":[],"length":0,"stats":{"Line":0}},{"line":2320,"address":[],"length":0,"stats":{"Line":0}},{"line":2321,"address":[],"length":0,"stats":{"Line":0}},{"line":2323,"address":[],"length":0,"stats":{"Line":0}},{"line":2407,"address":[],"length":0,"stats":{"Line":0}},{"line":2408,"address":[],"length":0,"stats":{"Line":0}},{"line":2410,"address":[],"length":0,"stats":{"Line":0}},{"line":2411,"address":[],"length":0,"stats":{"Line":0}},{"line":2412,"address":[],"length":0,"stats":{"Line":0}},{"line":2413,"address":[],"length":0,"stats":{"Line":0}},{"line":2414,"address":[],"length":0,"stats":{"Line":0}},{"line":2415,"address":[],"length":0,"stats":{"Line":0}},{"line":2416,"address":[],"length":0,"stats":{"Line":0}},{"line":2417,"address":[],"length":0,"stats":{"Line":0}},{"line":2419,"address":[],"length":0,"stats":{"Line":0}},{"line":2482,"address":[],"length":0,"stats":{"Line":0}},{"line":2483,"address":[],"length":0,"stats":{"Line":0}},{"line":2507,"address":[],"length":0,"stats":{"Line":0}},{"line":2513,"address":[],"length":0,"stats":{"Line":0}},{"line":2515,"address":[],"length":0,"stats":{"Line":0}},{"line":2516,"address":[],"length":0,"stats":{"Line":0}},{"line":2518,"address":[],"length":0,"stats":{"Line":0}},{"line":2520,"address":[],"length":0,"stats":{"Line":0}},{"line":2522,"address":[],"length":0,"stats":{"Line":0}},{"line":2529,"address":[],"length":0,"stats":{"Line":0}},{"line":2531,"address":[],"length":0,"stats":{"Line":0}},{"line":2532,"address":[],"length":0,"stats":{"Line":0}},{"line":2534,"address":[],"length":0,"stats":{"Line":0}},{"line":2536,"address":[],"length":0,"stats":{"Line":0}},{"line":2538,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":58},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","socket","sockopt.rs"],"content":"//! Socket options as used by `setsockopt` and `getsockopt`.\n#[cfg(any(linux_android, target_os = \"illumos\"))]\nuse super::SetSockOpt;\nuse crate::sys::time::TimeVal;\n#[cfg(any(linux_android, target_os = \"illumos\"))]\nuse crate::{errno::Errno, Result};\nuse cfg_if::cfg_if;\nuse libc::{self, c_int, c_void, socklen_t};\n#[cfg(apple_targets)]\nuse std::ffi::CString;\nuse std::ffi::{CStr, OsStr, OsString};\nuse std::mem::{self, MaybeUninit};\nuse std::os::fd::OwnedFd;\nuse std::os::unix::ffi::OsStrExt;\n#[cfg(any(linux_android, target_os = \"illumos\"))]\nuse std::os::unix::io::{AsFd, AsRawFd};\n\n// Constants\n// TCP_CA_NAME_MAX isn't defined in user space include files\n#[cfg(any(target_os = \"freebsd\", target_os = \"linux\"))]\n#[cfg(feature = \"net\")]\nconst TCP_CA_NAME_MAX: usize = 16;\n\n/// Helper for implementing `SetSockOpt` for a given socket option. See\n/// [`::sys::socket::SetSockOpt`](sys/socket/trait.SetSockOpt.html).\n///\n/// This macro aims to help implementing `SetSockOpt` for different socket options that accept\n/// different kinds of data to be used with `setsockopt`.\n///\n/// Instead of using this macro directly consider using [`sockopt_impl!`](crate::sockopt_impl),\n/// especially if the option you are implementing represents a simple type.\n///\n/// # Arguments\n///\n/// * `$name:ident`: name of the type you want to implement `SetSockOpt` for.\n/// * `$level:expr` : socket layer, or a `protocol level`: could be *raw sockets*\n///   (`libc::SOL_SOCKET`), *ip protocol* (libc::IPPROTO_IP), *tcp protocol* (`libc::IPPROTO_TCP`),\n///   and more. Please refer to your system manual for more options. Will be passed as the second\n///   argument (`level`) to the `setsockopt` call.\n/// * `$flag:path`: a flag name to set. Some examples: `libc::SO_REUSEADDR`, `libc::TCP_NODELAY`,\n///   `libc::IP_ADD_MEMBERSHIP` and others. Will be passed as the third argument (`option_name`)\n///   to the `setsockopt` call.\n/// * Type of the value that you are going to set.\n/// * Type that implements the `Set` trait for the type from the previous item \n///   (like `SetBool` for `bool`, `SetUsize` for `usize`, etc.).\n#[macro_export]\nmacro_rules! setsockopt_impl {\n    ($name:ident, $level:expr, $flag:path, $ty:ty, $setter:ty) =\u003e {\n        #[allow(deprecated)] // to allow we have deprecated socket option\n        impl $crate::sys::socket::SetSockOpt for $name {\n            type Val = $ty;\n\n            fn set\u003cF: std::os::unix::io::AsFd\u003e(\n                \u0026self,\n                fd: \u0026F,\n                val: \u0026$ty,\n            ) -\u003e $crate::Result\u003c()\u003e {\n                use std::os::fd::AsRawFd;\n                use $crate::sys::socket::sockopt::Set;\n                let setter: $setter = Set::new(val);\n                let level = $level;\n                let flag = $flag;\n                let res = unsafe {\n                    libc::setsockopt(\n                        fd.as_fd().as_raw_fd(),\n                        level,\n                        flag,\n                        setter.ffi_ptr(),\n                        setter.ffi_len(),\n                    )\n                };\n                $crate::errno::Errno::result(res).map(drop)\n            }\n        }\n    };\n}\n\n/// Helper for implementing `GetSockOpt` for a given socket option. See\n/// [`::sys::socket::GetSockOpt`](sys/socket/trait.GetSockOpt.html).\n///\n/// This macro aims to help implementing `GetSockOpt` for different socket options that accept\n/// different kinds of data to be use with `getsockopt`.\n///\n/// Instead of using this macro directly consider using [`sockopt_impl!`](crate::sockopt_impl),\n/// especially if the option you are implementing represents a simple type.\n///\n/// # Arguments\n///\n/// * Name of the type you want to implement `GetSockOpt` for.\n/// * Socket layer, or a `protocol level`: could be *raw sockets* (`lic::SOL_SOCKET`),  *ip\n///   protocol* (libc::IPPROTO_IP), *tcp protocol* (`libc::IPPROTO_TCP`),  and more. Please refer\n///   to your system manual for more options. Will be passed as the second argument (`level`) to\n///   the `getsockopt` call.\n/// * A flag to set. Some examples: `libc::SO_REUSEADDR`, `libc::TCP_NODELAY`,\n///   `libc::SO_ORIGINAL_DST` and others. Will be passed as the third argument (`option_name`) to\n///   the `getsockopt` call.\n/// * Type of the value that you are going to get.\n/// * Type that implements the `Get` trait for the type from the previous item (`GetBool` for\n///   `bool`, `GetUsize` for `usize`, etc.).\n#[macro_export]\nmacro_rules! getsockopt_impl {\n    ($name:ident, $level:expr, $flag:path, $ty:ty, $getter:ty) =\u003e {\n        #[allow(deprecated)] // to allow we have deprecated socket option\n        impl $crate::sys::socket::GetSockOpt for $name {\n            type Val = $ty;\n\n            fn get\u003cF: std::os::unix::io::AsFd\u003e(\n                \u0026self,\n                fd: \u0026F,\n            ) -\u003e $crate::Result\u003c$ty\u003e {\n                use std::os::fd::AsRawFd;\n                use $crate::sys::socket::sockopt::Get;\n                let mut getter: $getter = Get::uninit();\n                let level = $level;\n                let flag = $flag;\n                let res = unsafe {\n                    libc::getsockopt(\n                        fd.as_fd().as_raw_fd(),\n                        level,\n                        flag,\n                        getter.ffi_ptr(),\n                        getter.ffi_len(),\n                    )\n                };\n                $crate::errno::Errno::result(res)?;\n\n                // getter is definitely initialized now\n                let gotten = unsafe { getter.assume_init() };\n                match \u003c$ty\u003e::try_from(gotten) {\n                    // In most `getsockopt_impl!` implementations, `assume_init()`\n                    // returns `$ty`, so calling `$ty`::try_from($ty) will always\n                    // succeed. which makes the following `Err(_)` branch\n                    // unreachable.\n                    //\n                    // However, there is indeed one exception, `sockopt::SockType`,\n                    // `assume_init()` returns an `i32`, but `$ty` is `super::SockType`,\n                    // this exception necessitates the use of that `try_from()`,\n                    // and we have to allow the unreachable pattern wraning.\n                    //\n                    // For the reason why we are using `i32` as the underlying\n                    // buffer type for this socket option, see issue:\n                    // https://github.com/nix-rust/nix/issues/1819\n                    #[allow(unreachable_patterns)]\n                    Err(_) =\u003e Err($crate::errno::Errno::EINVAL),\n                    Ok(r) =\u003e Ok(r),\n                }\n            }\n        }\n    };\n}\n\n/// Helper to generate the sockopt accessors. See\n/// [`::sys::socket::GetSockOpt`](sys/socket/trait.GetSockOpt.html) and\n/// [`::sys::socket::SetSockOpt`](sys/socket/trait.SetSockOpt.html).\n///\n/// This macro aims to help implementing `GetSockOpt` and `SetSockOpt` for different socket options\n/// that accept different kinds of data to be use with `getsockopt` and `setsockopt` respectively.\n///\n/// Basically this macro wraps up the [`getsockopt_impl!`](macro.getsockopt_impl.html) and\n/// [`setsockopt_impl!`](macro.setsockopt_impl.html) macros.\n///\n/// # Arguments\n///\n/// * `GetOnly`, `SetOnly` or `Both`: whether you want to implement only getter, only setter or\n///   both of them.\n/// * `$name:ident`: name of type `GetSockOpt`/`SetSockOpt` will be implemented for.\n/// * `$level:expr` : socket layer, or a `protocol level`: could be *raw sockets*\n///   (`libc::SOL_SOCKET`), *ip protocol* (libc::IPPROTO_IP), *tcp protocol* (`libc::IPPROTO_TCP`),\n///   and more. Please refer to your system manual for more options. Will be passed as the second\n///   argument (`level`) to the `getsockopt`/`setsockopt` call.\n/// * `$flag:path`: a flag name to set. Some examples: `libc::SO_REUSEADDR`, `libc::TCP_NODELAY`,\n///   `libc::IP_ADD_MEMBERSHIP` and others. Will be passed as the third argument (`option_name`)\n///   to the `setsockopt`/`getsockopt` call.\n/// * `$ty:ty`: type of the value that will be get/set.\n/// * `$getter:ty`: `Get` implementation; optional; only for `GetOnly` and `Both`.\n/// * `$setter:ty`: `Set` implementation; optional; only for `SetOnly` and `Both`.\n// Some targets don't use all rules.\n#[allow(unused_macro_rules)]\n#[macro_export]\nmacro_rules! sockopt_impl {\n    ($(#[$attr:meta])* $name:ident, GetOnly, $level:expr, $flag:path, bool) =\u003e {\n        sockopt_impl!($(#[$attr])*\n                      $name, GetOnly, $level, $flag, bool, $crate::sys::socket::sockopt::GetBool);\n    };\n\n    ($(#[$attr:meta])* $name:ident, GetOnly, $level:expr, $flag:path, u8) =\u003e {\n        sockopt_impl!($(#[$attr])* $name, GetOnly, $level, $flag, u8, $crate::sys::socket::sockopt::GetU8);\n    };\n\n    ($(#[$attr:meta])* $name:ident, GetOnly, $level:expr, $flag:path, usize) =\u003e\n    {\n        sockopt_impl!($(#[$attr])*\n                      $name, GetOnly, $level, $flag, usize, $crate::sys::socket::sockopt::GetUsize);\n    };\n\n    ($(#[$attr:meta])* $name:ident, GetOnly, $level:expr, $flag:path, OwnedFd) =\u003e\n    {\n        sockopt_impl!($(#[$attr])*\n                      $name, GetOnly, $level, $flag, OwnedFd, $crate::sys::socket::sockopt::GetOwnedFd);\n    };\n\n    ($(#[$attr:meta])* $name:ident, SetOnly, $level:expr, $flag:path, bool) =\u003e {\n        sockopt_impl!($(#[$attr])*\n                      $name, SetOnly, $level, $flag, bool, $crate::sys::socket::sockopt::SetBool);\n    };\n\n    ($(#[$attr:meta])* $name:ident, SetOnly, $level:expr, $flag:path, u8) =\u003e {\n        sockopt_impl!($(#[$attr])* $name, SetOnly, $level, $flag, u8, $crate::sys::socket::sockopt::SetU8);\n    };\n\n    ($(#[$attr:meta])* $name:ident, SetOnly, $level:expr, $flag:path, usize) =\u003e\n    {\n        sockopt_impl!($(#[$attr])*\n                      $name, SetOnly, $level, $flag, usize, $crate::sys::socket::sockopt::SetUsize);\n    };\n\n    ($(#[$attr:meta])* $name:ident, SetOnly, $level:expr, $flag:path, OwnedFd) =\u003e\n    {\n        sockopt_impl!($(#[$attr])*\n                      $name, SetOnly, $level, $flag, OwnedFd, $crate::sys::socket::sockopt::SetOwnedFd);\n    };\n\n    ($(#[$attr:meta])* $name:ident, Both, $level:expr, $flag:path, bool) =\u003e {\n        sockopt_impl!($(#[$attr])*\n                      $name, Both, $level, $flag, bool, $crate::sys::socket::sockopt::GetBool, $crate::sys::socket::sockopt::SetBool);\n    };\n\n    ($(#[$attr:meta])* $name:ident, Both, $level:expr, $flag:path, u8) =\u003e {\n        sockopt_impl!($(#[$attr])*\n                      $name, Both, $level, $flag, u8, $crate::sys::socket::sockopt::GetU8, $crate::sys::socket::sockopt::SetU8);\n    };\n\n    ($(#[$attr:meta])* $name:ident, Both, $level:expr, $flag:path, usize) =\u003e {\n        sockopt_impl!($(#[$attr])*\n                      $name, Both, $level, $flag, usize, $crate::sys::socket::sockopt::GetUsize, $crate::sys::socket::sockopt::SetUsize);\n    };\n\n    ($(#[$attr:meta])* $name:ident, Both, $level:expr, $flag:path, OwnedFd) =\u003e {\n        sockopt_impl!($(#[$attr])*\n                      $name, Both, $level, $flag, OwnedFd, $crate::sys::socket::sockopt::GetOwnedFd, $crate::sys::socket::sockopt::SetOwnedFd);\n    };\n\n    ($(#[$attr:meta])* $name:ident, Both, $level:expr, $flag:path,\n     OsString\u003c$array:ty\u003e) =\u003e\n    {\n        sockopt_impl!($(#[$attr])*\n                      $name, Both, $level, $flag, std::ffi::OsString, $crate::sys::socket::sockopt::GetOsString\u003c$array\u003e,\n                      $crate::sys::socket::sockopt::SetOsString);\n    };\n\n    /*\n     * Matchers with generic getter types must be placed at the end, so\n     * they'll only match _after_ specialized matchers fail\n     */\n    ($(#[$attr:meta])* $name:ident, GetOnly, $level:expr, $flag:path, $ty:ty) =\u003e\n    {\n        sockopt_impl!($(#[$attr])*\n                      $name, GetOnly, $level, $flag, $ty, $crate::sys::socket::sockopt::GetStruct\u003c$ty\u003e);\n    };\n\n    ($(#[$attr:meta])* $name:ident, GetOnly, $level:expr, $flag:path, $ty:ty,\n     $getter:ty) =\u003e\n    {\n        $(#[$attr])*\n        #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\n        pub struct $name;\n\n        getsockopt_impl!($name, $level, $flag, $ty, $getter);\n    };\n\n    ($(#[$attr:meta])* $name:ident, SetOnly, $level:expr, $flag:path, $ty:ty) =\u003e\n    {\n        sockopt_impl!($(#[$attr])*\n                      $name, SetOnly, $level, $flag, $ty, $crate::sys::socket::sockopt::SetStruct\u003c$ty\u003e);\n    };\n\n    ($(#[$attr:meta])* $name:ident, SetOnly, $level:expr, $flag:path, $ty:ty,\n     $setter:ty) =\u003e\n    {\n        $(#[$attr])*\n        #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\n        pub struct $name;\n\n        setsockopt_impl!($name, $level, $flag, $ty, $setter);\n    };\n\n    ($(#[$attr:meta])* $name:ident, Both, $level:expr, $flag:path, $ty:ty,\n     $getter:ty, $setter:ty) =\u003e\n    {\n        $(#[$attr])*\n        #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\n        pub struct $name;\n\n        setsockopt_impl!($name, $level, $flag, $ty, $setter);\n        getsockopt_impl!($name, $level, $flag, $ty, $getter);\n    };\n\n    ($(#[$attr:meta])* $name:ident, Both, $level:expr, $flag:path, $ty:ty) =\u003e {\n        sockopt_impl!($(#[$attr])*\n                      $name, Both, $level, $flag, $ty, $crate::sys::socket::sockopt::GetStruct\u003c$ty\u003e,\n                      $crate::sys::socket::sockopt::SetStruct\u003c$ty\u003e);\n    };\n}\n\n/*\n *\n * ===== Define sockopts =====\n *\n */\n\nsockopt_impl!(\n    /// Enables local address reuse\n    ReuseAddr,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_REUSEADDR,\n    bool\n);\n#[cfg(not(any(solarish, target_os = \"cygwin\")))]\nsockopt_impl!(\n    /// Permits multiple AF_INET or AF_INET6 sockets to be bound to an\n    /// identical socket address.\n    ReusePort,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_REUSEPORT,\n    bool\n);\n#[cfg(target_os = \"freebsd\")]\nsockopt_impl!(\n    /// Enables incoming connections to be distributed among N sockets (up to 256)\n    /// via a Load-Balancing hash based algorithm.\n    ReusePortLb,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_REUSEPORT_LB,\n    bool\n);\n#[cfg(target_os = \"freebsd\")]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Select or query the set of functions that TCP will use for this connection.  This allows a\n    /// user to select an alternate TCP stack.\n    TcpFunctionBlk,\n    Both,\n    libc::IPPROTO_TCP,\n    libc::TCP_FUNCTION_BLK,\n    libc::tcp_function_set\n);\n#[cfg(target_os = \"freebsd\")]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Query the alias name of the set of function of the socket's TCP stack.\n    /// Uses the same field for the main name when getting from TCP_FUNCTION_BLK.\n    /// Empty if no alias.\n    TcpFunctionAlias,\n    GetOnly,\n    libc::IPPROTO_TCP,\n    libc::TCP_FUNCTION_ALIAS,\n    libc::tcp_function_set\n);\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Used to disable Nagle's algorithm.\n    /// \n    /// Nagle's algorithm:\n    /// \n    /// Under most circumstances, TCP sends data when it is presented; when\n    /// outstanding data has not yet been acknowledged, it gathers small amounts\n    /// of output to be sent in a single packet once an acknowledgement is\n    /// received.  For a small number of clients, such as window systems that\n    /// send a stream of mouse events which receive no replies, this\n    /// packetization may cause significant delays.  The boolean option, when\n    /// enabled, defeats this algorithm.\n    TcpNoDelay,\n    Both,\n    libc::IPPROTO_TCP,\n    libc::TCP_NODELAY,\n    bool\n);\nsockopt_impl!(\n    /// When enabled, a close(2) or shutdown(2) will not return until all\n    /// queued messages for the socket have been successfully sent or the\n    /// linger timeout has been reached.\n    Linger,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_LINGER,\n    libc::linger\n);\n#[cfg(apple_targets)]\nsockopt_impl!(\n    /// Same as `SO_LINGER`, but the duration is in seconds rather than kernel ticks.\n    LingerSec,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_LINGER_SEC,\n    libc::linger\n);\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Join a multicast group\n    IpAddMembership,\n    SetOnly,\n    libc::IPPROTO_IP,\n    libc::IP_ADD_MEMBERSHIP,\n    super::IpMembershipRequest\n);\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Leave a multicast group.\n    IpDropMembership,\n    SetOnly,\n    libc::IPPROTO_IP,\n    libc::IP_DROP_MEMBERSHIP,\n    super::IpMembershipRequest\n);\ncfg_if! {\n    if #[cfg(linux_android)] {\n        #[cfg(feature = \"net\")]\n        sockopt_impl!(\n            #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n            /// Join an IPv6 multicast group.\n            Ipv6AddMembership, SetOnly, libc::IPPROTO_IPV6, libc::IPV6_ADD_MEMBERSHIP, super::Ipv6MembershipRequest);\n        #[cfg(feature = \"net\")]\n        sockopt_impl!(\n            #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n            /// Leave an IPv6 multicast group.\n            Ipv6DropMembership, SetOnly, libc::IPPROTO_IPV6, libc::IPV6_DROP_MEMBERSHIP, super::Ipv6MembershipRequest);\n    } else if #[cfg(any(bsd, solarish))] {\n        #[cfg(feature = \"net\")]\n        sockopt_impl!(\n            #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n            /// Join an IPv6 multicast group.\n            Ipv6AddMembership, SetOnly, libc::IPPROTO_IPV6,\n            libc::IPV6_JOIN_GROUP, super::Ipv6MembershipRequest);\n        #[cfg(feature = \"net\")]\n        sockopt_impl!(\n            #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n            /// Leave an IPv6 multicast group.\n            Ipv6DropMembership, SetOnly, libc::IPPROTO_IPV6,\n            libc::IPV6_LEAVE_GROUP, super::Ipv6MembershipRequest);\n    }\n}\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Set or read the time-to-live value of outgoing multicast packets for\n    /// this socket.\n    IpMulticastTtl,\n    Both,\n    libc::IPPROTO_IP,\n    libc::IP_MULTICAST_TTL,\n    u8\n);\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Set or read the hop limit value of outgoing IPv6 multicast packets for\n    /// this socket.\n    Ipv6MulticastHops,\n    Both,\n    libc::IPPROTO_IPV6,\n    libc::IPV6_MULTICAST_HOPS,\n    libc::c_int\n);\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Set or read a boolean integer argument that determines whether sent\n    /// multicast packets should be looped back to the local sockets.\n    IpMulticastLoop,\n    Both,\n    libc::IPPROTO_IP,\n    libc::IP_MULTICAST_LOOP,\n    bool\n);\n#[cfg(target_os = \"linux\")]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Set the protocol-defined priority for all packets to be\n    /// sent on this socket\n    Priority,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_PRIORITY,\n    libc::c_int\n);\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[deprecated(since = \"0.30.0\", note = \"Use Ipv4Tos instead\")]\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Set or receive the Type-Of-Service (TOS) field that is\n    /// sent with every IP packet originating from this socket\n    IpTos,\n    Both,\n    libc::IPPROTO_IP,\n    libc::IP_TOS,\n    libc::c_int\n);\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Set or receive the Type-Of-Service (TOS) field that is\n    /// sent with every IP packet originating from this socket\n    Ipv4Tos,\n    Both,\n    libc::IPPROTO_IP,\n    libc::IP_TOS,\n    libc::c_int\n);\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// If enabled, the IP_TOS ancillary message is passed with incoming packets.\n    IpRecvTos,\n    Both,\n    libc::IPPROTO_IP,\n    libc::IP_RECVTOS,\n    bool\n);\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Set the traffic class associated with outgoing packets.\n    Ipv6TClass,\n    Both,\n    libc::IPPROTO_IPV6,\n    libc::IPV6_TCLASS,\n    libc::c_int\n);\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// If enabled, the IPV6_TCLASS ancillary message is passed with incoming packets.\n    Ipv6RecvTClass,\n    Both,\n    libc::IPPROTO_IPV6,\n    libc::IPV6_RECVTCLASS,\n    bool\n);\n#[cfg(any(linux_android, target_os = \"fuchsia\"))]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// If enabled, this boolean option allows binding to an IP address that\n    /// is nonlocal or does not (yet) exist.\n    IpFreebind,\n    Both,\n    libc::IPPROTO_IP,\n    libc::IP_FREEBIND,\n    bool\n);\n#[cfg(linux_android)]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// If enabled, the kernel will not reserve an ephemeral port when binding\n    /// socket with a port number of 0. The port will later be automatically\n    /// chosen at connect time, in a way that allows sharing a source port as\n    /// long as the 4-tuple is unique.\n    IpBindAddressNoPort,\n    Both,\n    libc::IPPROTO_IP,\n    libc::IP_BIND_ADDRESS_NO_PORT,\n    bool\n);\nsockopt_impl!(\n    /// Specify the receiving timeout until reporting an error.\n    ReceiveTimeout,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_RCVTIMEO,\n    TimeVal\n);\nsockopt_impl!(\n    /// Specify the sending timeout until reporting an error.\n    SendTimeout,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_SNDTIMEO,\n    TimeVal\n);\nsockopt_impl!(\n    /// Set or get the broadcast flag.\n    Broadcast,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_BROADCAST,\n    bool\n);\nsockopt_impl!(\n    /// If this option is enabled, out-of-band data is directly placed into\n    /// the receive data stream.\n    OobInline,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_OOBINLINE,\n    bool\n);\nsockopt_impl!(\n    /// Get and clear the pending socket error.\n    SocketError,\n    GetOnly,\n    libc::SOL_SOCKET,\n    libc::SO_ERROR,\n    i32\n);\nsockopt_impl!(\n    /// Set or get the don't route flag.\n    DontRoute,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_DONTROUTE,\n    bool\n);\nsockopt_impl!(\n    /// Enable sending of keep-alive messages on connection-oriented sockets.\n    KeepAlive,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_KEEPALIVE,\n    bool\n);\n#[cfg(freebsdlike)]\nsockopt_impl!(\n    /// Get the credentials of the peer process of a connected unix domain\n    /// socket.\n    LocalPeerCred,\n    GetOnly,\n    0,\n    libc::LOCAL_PEERCRED,\n    super::XuCred\n);\n#[cfg(apple_targets)]\nsockopt_impl!(\n    /// Get the credentials of the peer process of a connected unix domain\n    /// socket.\n    LocalPeerCred,\n    GetOnly,\n    libc::SOL_LOCAL,\n    libc::LOCAL_PEERCRED,\n    super::XuCred\n);\n#[cfg(apple_targets)]\nsockopt_impl!(\n    /// Get the PID of the peer process of a connected unix domain socket.\n    LocalPeerPid,\n    GetOnly,\n    libc::SOL_LOCAL,\n    libc::LOCAL_PEERPID,\n    libc::c_int\n);\n#[cfg(apple_targets)]\nsockopt_impl!(\n    /// Get the audit token of the peer process of a connected unix domain\n    /// socket.\n    LocalPeerToken,\n    GetOnly,\n    libc::SOL_LOCAL,\n    libc::LOCAL_PEERTOKEN,\n    super::audit_token_t\n);\n#[cfg(linux_android)]\nsockopt_impl!(\n    /// Return the credentials of the foreign process connected to this socket.\n    PeerCredentials,\n    GetOnly,\n    libc::SOL_SOCKET,\n    libc::SO_PEERCRED,\n    super::UnixCredentials\n);\n#[cfg(target_os = \"linux\")]\nsockopt_impl!(\n    /// Return the pidfd of the foreign process connected to this socket.\n    PeerPidfd,\n    GetOnly,\n    libc::SOL_SOCKET,\n    libc::SO_PEERPIDFD,\n    OwnedFd\n);\n#[cfg(target_os = \"freebsd\")]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Get backlog limit of the socket\n    ListenQLimit,\n    GetOnly,\n    libc::SOL_SOCKET,\n    libc::SO_LISTENQLIMIT,\n    u32\n);\n#[cfg(apple_targets)]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Specify the amount of time, in seconds, that the connection must be idle\n    /// before keepalive probes (if enabled) are sent.\n    TcpKeepAlive,\n    Both,\n    libc::IPPROTO_TCP,\n    libc::TCP_KEEPALIVE,\n    u32\n);\n#[cfg(any(freebsdlike, linux_android))]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// The time (in seconds) the connection needs to remain idle before TCP\n    /// starts sending keepalive probes\n    TcpKeepIdle,\n    Both,\n    libc::IPPROTO_TCP,\n    libc::TCP_KEEPIDLE,\n    u32\n);\ncfg_if! {\n    if #[cfg(any(linux_android, apple_targets))] {\n        sockopt_impl!(\n            /// The maximum segment size for outgoing TCP packets.\n            TcpMaxSeg, Both, libc::IPPROTO_TCP, libc::TCP_MAXSEG, u32);\n    } else if #[cfg(not(target_os = \"redox\"))] {\n        sockopt_impl!(\n            /// The maximum segment size for outgoing TCP packets.\n            TcpMaxSeg, GetOnly, libc::IPPROTO_TCP, libc::TCP_MAXSEG, u32);\n    }\n}\n#[cfg(not(any(\n    target_os = \"openbsd\",\n    target_os = \"haiku\",\n    target_os = \"redox\"\n)))]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// The maximum number of keepalive probes TCP should send before\n    /// dropping the connection.\n    TcpKeepCount,\n    Both,\n    libc::IPPROTO_TCP,\n    libc::TCP_KEEPCNT,\n    u32\n);\n#[cfg(any(linux_android, target_os = \"fuchsia\"))]\nsockopt_impl!(\n    #[allow(missing_docs)]\n    // Not documented by Linux!\n    TcpRepair,\n    Both,\n    libc::IPPROTO_TCP,\n    libc::TCP_REPAIR,\n    u32\n);\n#[cfg(not(any(\n    target_os = \"openbsd\",\n    target_os = \"haiku\",\n    target_os = \"redox\"\n)))]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// The time (in seconds) between individual keepalive probes.\n    TcpKeepInterval,\n    Both,\n    libc::IPPROTO_TCP,\n    libc::TCP_KEEPINTVL,\n    u32\n);\n#[cfg(any(target_os = \"fuchsia\", target_os = \"linux\"))]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Specifies the maximum amount of time in milliseconds that transmitted\n    /// data may remain unacknowledged before TCP will forcibly close the\n    /// corresponding connection\n    TcpUserTimeout,\n    Both,\n    libc::IPPROTO_TCP,\n    libc::TCP_USER_TIMEOUT,\n    u32\n);\n#[cfg(linux_android)]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Enables TCP Fast Open (RFC 7413) on a connecting socket. If a fast open\n    /// cookie is not available (first attempt to connect), `connect` syscall\n    /// will behave as usual, except for internally trying to solicit a cookie\n    /// from remote peer. When cookie is available, the next `connect` syscall\n    /// will immediately succeed without actually establishing TCP connection.\n    /// The connection establishment will be defered till the next `write` or\n    /// `sendmsg` syscalls on the socket, allowing TCP prtocol to establish\n    /// connection and send data in the same packets. Note: calling `read` right\n    /// after `connect` without `write` on the socket will cause the blocking\n    /// socket to be blocked forever.\n    TcpFastOpenConnect,\n    Both,\n    libc::IPPROTO_TCP,\n    libc::TCP_FASTOPEN_CONNECT,\n    bool\n);\nsockopt_impl!(\n    /// Sets or gets the maximum socket receive buffer in bytes.\n    RcvBuf,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_RCVBUF,\n    usize\n);\nsockopt_impl!(\n    /// Sets or gets the maximum socket send buffer in bytes.\n    SndBuf,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_SNDBUF,\n    usize\n);\n#[cfg(linux_android)]\nsockopt_impl!(\n    /// Using this socket option, a privileged (`CAP_NET_ADMIN`) process can\n    /// perform the same task as `SO_RCVBUF`, but the `rmem_max limit` can be\n    /// overridden.\n    RcvBufForce,\n    SetOnly,\n    libc::SOL_SOCKET,\n    libc::SO_RCVBUFFORCE,\n    usize\n);\n#[cfg(linux_android)]\nsockopt_impl!(\n    /// Using this socket option, a privileged (`CAP_NET_ADMIN`)  process can\n    /// perform the same task as `SO_SNDBUF`, but the `wmem_max` limit can be\n    /// overridden.\n    SndBufForce,\n    SetOnly,\n    libc::SOL_SOCKET,\n    libc::SO_SNDBUFFORCE,\n    usize\n);\nsockopt_impl!(\n    /// Gets the socket type as an integer.\n    SockType,\n    GetOnly,\n    libc::SOL_SOCKET,\n    libc::SO_TYPE,\n    super::SockType,\n    GetStruct\u003ci32\u003e\n);\nsockopt_impl!(\n    /// Returns a value indicating whether or not this socket has been marked to\n    /// accept connections with `listen(2)`.\n    AcceptConn,\n    GetOnly,\n    libc::SOL_SOCKET,\n    libc::SO_ACCEPTCONN,\n    bool\n);\n#[cfg(linux_android)]\nsockopt_impl!(\n    /// Bind this socket to a particular device like eth0.\n    BindToDevice,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_BINDTODEVICE,\n    OsString\u003c[u8; libc::IFNAMSIZ]\u003e\n);\n#[cfg(linux_android)]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    #[allow(missing_docs)]\n    // Not documented by Linux!\n    OriginalDst,\n    GetOnly,\n    libc::SOL_IP,\n    libc::SO_ORIGINAL_DST,\n    libc::sockaddr_in\n);\n#[cfg(linux_android)]\nsockopt_impl!(\n    #[allow(missing_docs)]\n    // Not documented by Linux!\n    Ip6tOriginalDst,\n    GetOnly,\n    libc::SOL_IPV6,\n    libc::IP6T_SO_ORIGINAL_DST,\n    libc::sockaddr_in6\n);\n#[cfg(linux_android)]\nsockopt_impl!(\n    /// Specifies exact type of timestamping information collected by the kernel\n    /// [Further reading](https://www.kernel.org/doc/html/latest/networking/timestamping.html)\n    Timestamping,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_TIMESTAMPING,\n    super::TimestampingFlag\n);\n#[cfg(not(any(\n    target_os = \"aix\",\n    target_os = \"haiku\",\n    target_os = \"hurd\",\n    target_os = \"redox\",\n    target_os = \"cygwin\"\n)))]\nsockopt_impl!(\n    /// Enable or disable the receiving of the `SO_TIMESTAMP` control message.\n    ReceiveTimestamp,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_TIMESTAMP,\n    bool\n);\n#[cfg(linux_android)]\nsockopt_impl!(\n    /// Enable or disable the receiving of the `SO_TIMESTAMPNS` control message.\n    ReceiveTimestampns,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_TIMESTAMPNS,\n    bool\n);\n#[cfg(target_os = \"freebsd\")]\nsockopt_impl!(\n    /// Sets a specific timestamp format instead of the classic `SCM_TIMESTAMP`,\n    /// to follow up after `SO_TIMESTAMP` is set.\n    TsClock,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_TS_CLOCK,\n    super::SocketTimestamp\n);\n#[cfg(linux_android)]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Setting this boolean option enables transparent proxying on this socket.\n    IpTransparent,\n    Both,\n    libc::SOL_IP,\n    libc::IP_TRANSPARENT,\n    bool\n);\n#[cfg(target_os = \"openbsd\")]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Allows the socket to be bound to addresses which are not local to the\n    /// machine, so it can be used to make a transparent proxy.\n    BindAny,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_BINDANY,\n    bool\n);\n#[cfg(target_os = \"freebsd\")]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Can `bind(2)` to any address, even one not bound to any available\n    /// network interface in the system.\n    BindAny,\n    Both,\n    libc::IPPROTO_IP,\n    libc::IP_BINDANY,\n    bool\n);\n#[cfg(target_os = \"freebsd\")]\nsockopt_impl!(\n    /// Set the route table (FIB) for this socket up to the `net.fibs` OID limit\n    /// (more specific than the setfib command line/call which are process based).\n    Fib,\n    SetOnly,\n    libc::SOL_SOCKET,\n    libc::SO_SETFIB,\n    i32\n);\n#[cfg(target_os = \"freebsd\")]\nsockopt_impl!(\n    /// Set `so_user_cookie` for this socket allowing network traffic based\n    /// upon it, similar to Linux's netfilter MARK.\n    UserCookie,\n    SetOnly,\n    libc::SOL_SOCKET,\n    libc::SO_USER_COOKIE,\n    u32\n);\n#[cfg(target_os = \"openbsd\")]\nsockopt_impl!(\n    /// Set the route table for this socket, needs a privileged user if\n    /// the process/socket had been set to the non default route.\n    Rtable,\n    SetOnly,\n    libc::SOL_SOCKET,\n    libc::SO_RTABLE,\n    i32\n);\n#[cfg(any(target_os = \"freebsd\", target_os = \"netbsd\"))]\nsockopt_impl!(\n    /// Get/set a filter on this socket before accepting connections similarly\n    /// to Linux's TCP_DEFER_ACCEPT but after the listen's call.\n    AcceptFilter,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_ACCEPTFILTER,\n    libc::accept_filter_arg\n);\n#[cfg(target_os = \"linux\")]\nsockopt_impl!(\n    /// Set the mark for each packet sent through this socket (similar to the\n    /// netfilter MARK target but socket-based).\n    Mark,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_MARK,\n    u32\n);\n#[cfg(linux_android)]\nsockopt_impl!(\n    /// Enable or disable the receiving of the `SCM_CREDENTIALS` control\n    /// message.\n    PassCred,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_PASSCRED,\n    bool\n);\n#[cfg(any(target_os = \"freebsd\", target_os = \"linux\"))]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// This option allows the caller to set the TCP congestion control\n    /// algorithm to be used,  on a per-socket basis.\n    TcpCongestion,\n    Both,\n    libc::IPPROTO_TCP,\n    libc::TCP_CONGESTION,\n    OsString\u003c[u8; TCP_CA_NAME_MAX]\u003e\n);\n#[cfg(any(linux_android, apple_targets, target_os = \"netbsd\"))]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Pass an `IP_PKTINFO` ancillary message that contains a pktinfo\n    /// structure that supplies some information about the incoming packet.\n    Ipv4PacketInfo,\n    Both,\n    libc::IPPROTO_IP,\n    libc::IP_PKTINFO,\n    bool\n);\n#[cfg(any(linux_android, bsd))]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Set delivery of the `IPV6_PKTINFO` control message on incoming\n    /// datagrams.\n    Ipv6RecvPacketInfo,\n    Both,\n    libc::IPPROTO_IPV6,\n    libc::IPV6_RECVPKTINFO,\n    bool\n);\n\n#[cfg(any(linux_android, bsd))]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// Pass an `IPV6_PKTINFO` ancillary message that contains a in6_pktinfo\n    /// structure that supplies some information about the incoming packet.\n    Ipv6PacketInfo,\n    Both,\n    libc::IPPROTO_IPV6,\n    libc::IPV6_PKTINFO,\n    bool\n);\n#[cfg(bsd)]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// The `recvmsg(2)` call returns a `struct sockaddr_dl` corresponding to\n    /// the interface on which the packet was received.\n    Ipv4RecvIf,\n    Both,\n    libc::IPPROTO_IP,\n    libc::IP_RECVIF,\n    bool\n);\n#[cfg(bsd)]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// The `recvmsg(2)` call will return the destination IP address for a UDP\n    /// datagram.\n    Ipv4RecvDstAddr,\n    Both,\n    libc::IPPROTO_IP,\n    libc::IP_RECVDSTADDR,\n    bool\n);\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// The `recvmsg(2)` call will return the destination IP address for a UDP\n    /// datagram.\n    Ipv4OrigDstAddr,\n    Both,\n    libc::IPPROTO_IP,\n    libc::IP_ORIGDSTADDR,\n    bool\n);\n#[cfg(target_os = \"linux\")]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    #[allow(missing_docs)]\n    // Not documented by Linux!\n    UdpGsoSegment,\n    Both,\n    libc::SOL_UDP,\n    libc::UDP_SEGMENT,\n    libc::c_int\n);\n#[cfg(target_os = \"linux\")]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    #[allow(missing_docs)]\n    // Not documented by Linux!\n    UdpGroSegment,\n    Both,\n    libc::IPPROTO_UDP,\n    libc::UDP_GRO,\n    bool\n);\n#[cfg(target_os = \"linux\")]\nsockopt_impl!(\n    /// Configures the behavior of time-based transmission of packets, for use\n    /// with the `TxTime` control message.\n    TxTime,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_TXTIME,\n    libc::sock_txtime\n);\n#[cfg(any(linux_android, target_os = \"fuchsia\"))]\nsockopt_impl!(\n    /// Indicates that an unsigned 32-bit value ancillary message (cmsg) should\n    /// be attached to received skbs indicating the number of packets dropped by\n    /// the socket since its creation.\n    RxqOvfl,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_RXQ_OVFL,\n    libc::c_int\n);\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// The socket is restricted to sending and receiving IPv6 packets only.\n    Ipv6V6Only,\n    Both,\n    libc::IPPROTO_IPV6,\n    libc::IPV6_V6ONLY,\n    bool\n);\n#[cfg(linux_android)]\nsockopt_impl!(\n    /// Enable extended reliable error message passing.\n    Ipv4RecvErr,\n    Both,\n    libc::IPPROTO_IP,\n    libc::IP_RECVERR,\n    bool\n);\n#[cfg(linux_android)]\nsockopt_impl!(\n    /// Control receiving of asynchronous error options.\n    Ipv6RecvErr,\n    Both,\n    libc::IPPROTO_IPV6,\n    libc::IPV6_RECVERR,\n    bool\n);\n#[cfg(linux_android)]\nsockopt_impl!(\n    /// Fetch the current system-estimated Path MTU.\n    IpMtu,\n    GetOnly,\n    libc::IPPROTO_IP,\n    libc::IP_MTU,\n    libc::c_int\n);\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\nsockopt_impl!(\n    /// Set or retrieve the current time-to-live field that is used in every\n    /// packet sent from this socket.\n    Ipv4Ttl,\n    Both,\n    libc::IPPROTO_IP,\n    libc::IP_TTL,\n    libc::c_int\n);\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    /// Enables a receiving socket to retrieve the Time-to-Live (TTL) field \n    /// from incoming IPv4 packets.\n    Ipv4RecvTtl,\n    Both,\n    libc::IPPROTO_IP,\n    libc::IP_RECVTTL,\n    bool\n);\n#[cfg(any(apple_targets, linux_android, target_os = \"freebsd\"))]\nsockopt_impl!(\n    /// Set the unicast hop limit for the socket.\n    Ipv6Ttl,\n    Both,\n    libc::IPPROTO_IPV6,\n    libc::IPV6_UNICAST_HOPS,\n    libc::c_int\n);\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    /// Enables a receiving socket to retrieve the Hop Limit field \n    /// (similar to TTL in IPv4) from incoming IPv6 packets.\n    Ipv6RecvHopLimit,\n    Both,\n    libc::IPPROTO_IPV6,\n    libc::IPV6_RECVHOPLIMIT,\n    bool\n);\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    #[cfg_attr(docsrs, doc(cfg(feature = \"net\")))]\n    /// The `recvmsg(2)` call will return the destination IP address for a UDP\n    /// datagram.\n    Ipv6OrigDstAddr,\n    Both,\n    libc::IPPROTO_IPV6,\n    libc::IPV6_ORIGDSTADDR,\n    bool\n);\n#[cfg(apple_targets)]\nsockopt_impl!(\n    /// Set \"don't fragment packet\" flag on the IP packet.\n    IpDontFrag,\n    Both,\n    libc::IPPROTO_IP,\n    libc::IP_DONTFRAG,\n    bool\n);\n#[cfg(any(linux_android, apple_targets))]\nsockopt_impl!(\n    /// Set \"don't fragment packet\" flag on the IPv6 packet.\n    Ipv6DontFrag,\n    Both,\n    libc::IPPROTO_IPV6,\n    libc::IPV6_DONTFRAG,\n    bool\n);\n#[cfg(apple_targets)]\n#[cfg(feature = \"net\")]\nsockopt_impl!(\n    /// Get the utun interface name.\n    UtunIfname,\n    GetOnly,\n    libc::SYSPROTO_CONTROL,\n    libc::UTUN_OPT_IFNAME,\n    CString,\n    GetCString\u003c[u8; libc::IFNAMSIZ]\u003e\n);\n\n#[cfg(solarish)]\nsockopt_impl!(\n    /// Enable/disable exclusive binding.\n    /// Prevent multiple sockets to bind to the same\n    /// address:port, neutralizing `SO_REUSEADDR` effect.\n    ExclBind,\n    Both,\n    libc::SOL_SOCKET,\n    libc::SO_EXCLBIND,\n    bool\n);\n#[cfg(target_os = \"linux\")]\nsockopt_impl!(\n    /// To be used with `ReusePort`,\n    /// we can then attach a BPF (classic)\n    /// to set how the packets are assigned\n    /// to the socket (e.g. cpu distribution).\n    AttachReusePortCbpf,\n    SetOnly,\n    libc::SOL_SOCKET,\n    libc::SO_ATTACH_REUSEPORT_CBPF,\n    libc::sock_fprog\n);\n\n#[allow(missing_docs)]\n// Not documented by Linux!\n#[cfg(linux_android)]\n#[derive(Copy, Clone, Debug)]\npub struct AlgSetAeadAuthSize;\n\n// ALG_SET_AEAD_AUTH_SIZE read the length from passed `option_len`\n// See https://elixir.bootlin.com/linux/v4.4/source/crypto/af_alg.c#L222\n#[cfg(linux_android)]\nimpl SetSockOpt for AlgSetAeadAuthSize {\n    type Val = usize;\n\n    fn set\u003cF: AsFd\u003e(\u0026self, fd: \u0026F, val: \u0026usize) -\u003e Result\u003c()\u003e {\n        unsafe {\n            let res = libc::setsockopt(\n                fd.as_fd().as_raw_fd(),\n                libc::SOL_ALG,\n                libc::ALG_SET_AEAD_AUTHSIZE,\n                ::std::ptr::null(),\n                *val as libc::socklen_t,\n            );\n            Errno::result(res).map(drop)\n        }\n    }\n}\n\n#[allow(missing_docs)]\n// Not documented by Linux!\n#[cfg(linux_android)]\n#[derive(Clone, Debug)]\npub struct AlgSetKey\u003cT\u003e(::std::marker::PhantomData\u003cT\u003e);\n\n#[cfg(linux_android)]\nimpl\u003cT\u003e Default for AlgSetKey\u003cT\u003e {\n    fn default() -\u003e Self {\n        AlgSetKey(Default::default())\n    }\n}\n\n#[cfg(linux_android)]\nimpl\u003cT\u003e SetSockOpt for AlgSetKey\u003cT\u003e\nwhere\n    T: AsRef\u003c[u8]\u003e + Clone,\n{\n    type Val = T;\n\n    fn set\u003cF: AsFd\u003e(\u0026self, fd: \u0026F, val: \u0026T) -\u003e Result\u003c()\u003e {\n        unsafe {\n            let res = libc::setsockopt(\n                fd.as_fd().as_raw_fd(),\n                libc::SOL_ALG,\n                libc::ALG_SET_KEY,\n                val.as_ref().as_ptr().cast(),\n                val.as_ref().len() as libc::socklen_t,\n            );\n            Errno::result(res).map(drop)\n        }\n    }\n}\n\n/// Set the Upper Layer Protocol (ULP) on the TCP socket.\n///\n/// For example, to enable the TLS ULP on a socket, the C function call would be:\n///\n/// ```c\n/// setsockopt(sock, SOL_TCP, TCP_ULP, \"tls\", sizeof(\"tls\"));\n/// ```\n///\n/// ... and the `nix` equivalent is:\n///\n/// ```ignore,rust\n/// setsockopt(sock, TcpUlp::default(), b\"tls\");\n/// ```\n///\n/// Note that the ULP name does not need a trailing NUL terminator (`\\0`).\n#[cfg(linux_android)]\n#[derive(Clone, Debug)]\npub struct TcpUlp\u003cT\u003e(::std::marker::PhantomData\u003cT\u003e);\n\n#[cfg(linux_android)]\nimpl\u003cT\u003e Default for TcpUlp\u003cT\u003e {\n    fn default() -\u003e Self {\n        TcpUlp(Default::default())\n    }\n}\n\n#[cfg(linux_android)]\nimpl\u003cT\u003e SetSockOpt for TcpUlp\u003cT\u003e\nwhere\n    T: AsRef\u003c[u8]\u003e + Clone,\n{\n    type Val = T;\n\n    fn set\u003cF: AsFd\u003e(\u0026self, fd: \u0026F, val: \u0026Self::Val) -\u003e Result\u003c()\u003e {\n        unsafe {\n            let res = libc::setsockopt(\n                fd.as_fd().as_raw_fd(),\n                libc::SOL_TCP,\n                libc::TCP_ULP,\n                val.as_ref().as_ptr().cast(),\n                val.as_ref().len() as libc::socklen_t,\n            );\n            Errno::result(res).map(drop)\n        }\n    }\n}\n\n/// Value used with the [`TcpTlsTx`] and [`TcpTlsRx`] socket options.\n#[cfg(target_os = \"linux\")]\n#[derive(Copy, Clone, Debug)]\npub enum TlsCryptoInfo {\n    /// AES-128-GCM\n    Aes128Gcm(libc::tls12_crypto_info_aes_gcm_128),\n\n    /// AES-256-GCM\n    Aes256Gcm(libc::tls12_crypto_info_aes_gcm_256),\n\n    /// CHACHA20-POLY1305\n    Chacha20Poly1305(libc::tls12_crypto_info_chacha20_poly1305),\n}\n\n/// Set the Kernel TLS write parameters on the TCP socket.\n///\n/// For example, the C function call would be:\n///\n/// ```c\n/// setsockopt(sock, SOL_TLS, TLS_TX, \u0026crypto_info, sizeof(crypto_info));\n/// ```\n///\n/// ... and the `nix` equivalent is:\n///\n/// ```ignore,rust\n/// setsockopt(sock, TcpTlsTx, \u0026crypto_info);\n/// ```\n#[cfg(target_os = \"linux\")]\n#[derive(Copy, Clone, Debug)]\npub struct TcpTlsTx;\n\n#[cfg(target_os = \"linux\")]\nimpl SetSockOpt for TcpTlsTx {\n    type Val = TlsCryptoInfo;\n\n    fn set\u003cF: AsFd\u003e(\u0026self, fd: \u0026F, val: \u0026Self::Val) -\u003e Result\u003c()\u003e {\n        let (ffi_ptr, ffi_len) = match val {\n            TlsCryptoInfo::Aes128Gcm(crypto_info) =\u003e {\n                (\u003c*const _\u003e::cast(crypto_info), mem::size_of_val(crypto_info))\n            }\n            TlsCryptoInfo::Aes256Gcm(crypto_info) =\u003e {\n                (\u003c*const _\u003e::cast(crypto_info), mem::size_of_val(crypto_info))\n            }\n            TlsCryptoInfo::Chacha20Poly1305(crypto_info) =\u003e {\n                (\u003c*const _\u003e::cast(crypto_info), mem::size_of_val(crypto_info))\n            }\n        };\n        unsafe {\n            let res = libc::setsockopt(\n                fd.as_fd().as_raw_fd(),\n                libc::SOL_TLS,\n                libc::TLS_TX,\n                ffi_ptr,\n                ffi_len as libc::socklen_t,\n            );\n            Errno::result(res).map(drop)\n        }\n    }\n}\n\n/// Set the Kernel TLS read parameters on the TCP socket.\n///\n/// For example, the C function call would be:\n///\n/// ```c\n/// setsockopt(sock, SOL_TLS, TLS_RX, \u0026crypto_info, sizeof(crypto_info));\n/// ```\n///\n/// ... and the `nix` equivalent is:\n///\n/// ```ignore,rust\n/// setsockopt(sock, TcpTlsRx, \u0026crypto_info);\n/// ```\n#[cfg(target_os = \"linux\")]\n#[derive(Copy, Clone, Debug)]\npub struct TcpTlsRx;\n\n#[cfg(target_os = \"linux\")]\nimpl SetSockOpt for TcpTlsRx {\n    type Val = TlsCryptoInfo;\n\n    fn set\u003cF: AsFd\u003e(\u0026self, fd: \u0026F, val: \u0026Self::Val) -\u003e Result\u003c()\u003e {\n        let (ffi_ptr, ffi_len) = match val {\n            TlsCryptoInfo::Aes128Gcm(crypto_info) =\u003e {\n                (\u003c*const _\u003e::cast(crypto_info), mem::size_of_val(crypto_info))\n            }\n            TlsCryptoInfo::Aes256Gcm(crypto_info) =\u003e {\n                (\u003c*const _\u003e::cast(crypto_info), mem::size_of_val(crypto_info))\n            }\n            TlsCryptoInfo::Chacha20Poly1305(crypto_info) =\u003e {\n                (\u003c*const _\u003e::cast(crypto_info), mem::size_of_val(crypto_info))\n            }\n        };\n        unsafe {\n            let res = libc::setsockopt(\n                fd.as_fd().as_raw_fd(),\n                libc::SOL_TLS,\n                libc::TLS_RX,\n                ffi_ptr,\n                ffi_len as libc::socklen_t,\n            );\n            Errno::result(res).map(drop)\n        }\n    }\n}\n\n#[cfg(target_os = \"illumos\")]\n#[derive(Copy, Clone, Debug)]\n/// Attach a named filter to this socket to be able to\n/// defer when anough byte had been buffered by the kernel\npub struct FilterAttach;\n\n#[cfg(target_os = \"illumos\")]\nimpl SetSockOpt for FilterAttach {\n    type Val = OsStr;\n\n    fn set\u003cF: AsFd\u003e(\u0026self, fd: \u0026F, val: \u0026Self::Val) -\u003e Result\u003c()\u003e {\n        if val.len() \u003e libc::FILNAME_MAX as usize {\n            return Err(Errno::EINVAL);\n        }\n        unsafe {\n            let res = libc::setsockopt(\n                fd.as_fd().as_raw_fd(),\n                libc::SOL_FILTER,\n                libc::FIL_ATTACH,\n                val.as_bytes().as_ptr().cast(),\n                val.len() as libc::socklen_t,\n            );\n            Errno::result(res).map(drop)\n        }\n    }\n}\n\n#[cfg(target_os = \"illumos\")]\n#[derive(Copy, Clone, Debug)]\n/// Detach a socket filter previously attached with FIL_ATTACH\npub struct FilterDetach;\n\n#[cfg(target_os = \"illumos\")]\nimpl SetSockOpt for FilterDetach {\n    type Val = OsStr;\n\n    fn set\u003cF: AsFd\u003e(\u0026self, fd: \u0026F, val: \u0026Self::Val) -\u003e Result\u003c()\u003e {\n        if val.len() \u003e libc::FILNAME_MAX as usize {\n            return Err(Errno::EINVAL);\n        }\n        unsafe {\n            let res = libc::setsockopt(\n                fd.as_fd().as_raw_fd(),\n                libc::SOL_FILTER,\n                libc::FIL_DETACH,\n                val.as_bytes().as_ptr().cast(),\n                val.len() as libc::socklen_t,\n            );\n            Errno::result(res).map(drop)\n        }\n    }\n}\n/*\n *\n * ===== Accessor helpers =====\n *\n */\n\n/// Helper trait that describes what is expected from a `GetSockOpt` getter.\n// Hide the docs, because it's an implementation detail of `sockopt_impl!`\n#[doc(hidden)]\npub trait Get\u003cT\u003e {\n    /// Returns an uninitialized value.\n    fn uninit() -\u003e Self;\n    /// Returns a pointer to the stored value. This pointer will be passed to the system's\n    /// `getsockopt` call (`man 3p getsockopt`, argument `option_value`).\n    fn ffi_ptr(\u0026mut self) -\u003e *mut c_void;\n    /// Returns length of the stored value. This pointer will be passed to the system's\n    /// `getsockopt` call (`man 3p getsockopt`, argument `option_len`).\n    fn ffi_len(\u0026mut self) -\u003e *mut socklen_t;\n    /// Returns the hopefully initialized inner value.\n    unsafe fn assume_init(self) -\u003e T;\n}\n\n/// Helper trait that describes what is expected from a `SetSockOpt` setter.\n// Hide the docs, because it's an implementation detail of `sockopt_impl!`\n#[doc(hidden)]\npub trait Set\u003c'a, T\u003e {\n    /// Initialize the setter with a given value.\n    fn new(val: \u0026'a T) -\u003e Self;\n    /// Returns a pointer to the stored value. This pointer will be passed to the system's\n    /// `setsockopt` call (`man 3p setsockopt`, argument `option_value`).\n    fn ffi_ptr(\u0026self) -\u003e *const c_void;\n    /// Returns length of the stored value. This pointer will be passed to the system's\n    /// `setsockopt` call (`man 3p setsockopt`, argument `option_len`).\n    fn ffi_len(\u0026self) -\u003e socklen_t;\n}\n\n/// Getter for an arbitrary `struct`.\n// Hide the docs, because it's an implementation detail of `sockopt_impl!`\n#[doc(hidden)]\n#[derive(Debug)]\npub struct GetStruct\u003cT\u003e {\n    len: socklen_t,\n    val: MaybeUninit\u003cT\u003e,\n}\n\nimpl\u003cT\u003e Get\u003cT\u003e for GetStruct\u003cT\u003e {\n    fn uninit() -\u003e Self {\n        GetStruct {\n            len: mem::size_of::\u003cT\u003e() as socklen_t,\n            val: MaybeUninit::uninit(),\n        }\n    }\n\n    fn ffi_ptr(\u0026mut self) -\u003e *mut c_void {\n        self.val.as_mut_ptr().cast()\n    }\n\n    fn ffi_len(\u0026mut self) -\u003e *mut socklen_t {\n        \u0026mut self.len\n    }\n\n    unsafe fn assume_init(self) -\u003e T {\n        assert_eq!(\n            self.len as usize,\n            mem::size_of::\u003cT\u003e(),\n            \"invalid getsockopt implementation\"\n        );\n        unsafe { self.val.assume_init() }\n    }\n}\n\n/// Setter for an arbitrary `struct`.\n// Hide the docs, because it's an implementation detail of `sockopt_impl!`\n#[doc(hidden)]\n#[derive(Debug)]\npub struct SetStruct\u003c'a, T: 'static\u003e {\n    ptr: \u0026'a T,\n}\n\nimpl\u003c'a, T\u003e Set\u003c'a, T\u003e for SetStruct\u003c'a, T\u003e {\n    fn new(ptr: \u0026'a T) -\u003e SetStruct\u003c'a, T\u003e {\n        SetStruct { ptr }\n    }\n\n    fn ffi_ptr(\u0026self) -\u003e *const c_void {\n        self.ptr as *const T as *const c_void\n    }\n\n    fn ffi_len(\u0026self) -\u003e socklen_t {\n        mem::size_of::\u003cT\u003e() as socklen_t\n    }\n}\n\n/// Getter for a boolean value.\n// Hide the docs, because it's an implementation detail of `sockopt_impl!`\n#[doc(hidden)]\n#[derive(Clone, Copy, Debug)]\npub struct GetBool {\n    len: socklen_t,\n    val: MaybeUninit\u003cc_int\u003e,\n}\n\nimpl Get\u003cbool\u003e for GetBool {\n    fn uninit() -\u003e Self {\n        GetBool {\n            len: mem::size_of::\u003cc_int\u003e() as socklen_t,\n            val: MaybeUninit::uninit(),\n        }\n    }\n\n    fn ffi_ptr(\u0026mut self) -\u003e *mut c_void {\n        self.val.as_mut_ptr().cast()\n    }\n\n    fn ffi_len(\u0026mut self) -\u003e *mut socklen_t {\n        \u0026mut self.len\n    }\n\n    unsafe fn assume_init(self) -\u003e bool {\n        assert_eq!(\n            self.len as usize,\n            mem::size_of::\u003cc_int\u003e(),\n            \"invalid getsockopt implementation\"\n        );\n        unsafe { self.val.assume_init() != 0 }\n    }\n}\n\n/// Setter for a boolean value.\n// Hide the docs, because it's an implementation detail of `sockopt_impl!`\n#[doc(hidden)]\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub struct SetBool {\n    val: c_int,\n}\n\nimpl\u003c'a\u003e Set\u003c'a, bool\u003e for SetBool {\n    fn new(val: \u0026'a bool) -\u003e SetBool {\n        SetBool {\n            val: i32::from(*val),\n        }\n    }\n\n    fn ffi_ptr(\u0026self) -\u003e *const c_void {\n        \u0026self.val as *const c_int as *const c_void\n    }\n\n    fn ffi_len(\u0026self) -\u003e socklen_t {\n        mem::size_of_val(\u0026self.val) as socklen_t\n    }\n}\n\n/// Getter for an `u8` value.\n#[cfg(feature = \"net\")]\n// Hide the docs, because it's an implementation detail of `sockopt_impl!`\n#[doc(hidden)]\n#[derive(Clone, Copy, Debug)]\npub struct GetU8 {\n    len: socklen_t,\n    val: MaybeUninit\u003cu8\u003e,\n}\n\n#[cfg(feature = \"net\")]\nimpl Get\u003cu8\u003e for GetU8 {\n    fn uninit() -\u003e Self {\n        GetU8 {\n            len: mem::size_of::\u003cu8\u003e() as socklen_t,\n            val: MaybeUninit::uninit(),\n        }\n    }\n\n    fn ffi_ptr(\u0026mut self) -\u003e *mut c_void {\n        self.val.as_mut_ptr().cast()\n    }\n\n    fn ffi_len(\u0026mut self) -\u003e *mut socklen_t {\n        \u0026mut self.len\n    }\n\n    unsafe fn assume_init(self) -\u003e u8 {\n        assert_eq!(\n            self.len as usize,\n            mem::size_of::\u003cu8\u003e(),\n            \"invalid getsockopt implementation\"\n        );\n        unsafe { self.val.assume_init() }\n    }\n}\n\n/// Setter for an `u8` value.\n// Hide the docs, because it's an implementation detail of `sockopt_impl!`\n#[doc(hidden)]\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub struct SetU8 {\n    val: u8,\n}\n\n#[cfg(feature = \"net\")]\nimpl\u003c'a\u003e Set\u003c'a, u8\u003e for SetU8 {\n    fn new(val: \u0026'a u8) -\u003e SetU8 {\n        SetU8 { val: *val }\n    }\n\n    fn ffi_ptr(\u0026self) -\u003e *const c_void {\n        \u0026self.val as *const u8 as *const c_void\n    }\n\n    fn ffi_len(\u0026self) -\u003e socklen_t {\n        mem::size_of_val(\u0026self.val) as socklen_t\n    }\n}\n\n/// Getter for an `usize` value.\n// Hide the docs, because it's an implementation detail of `sockopt_impl!`\n#[doc(hidden)]\n#[derive(Clone, Copy, Debug)]\npub struct GetUsize {\n    len: socklen_t,\n    val: MaybeUninit\u003cc_int\u003e,\n}\n\nimpl Get\u003cusize\u003e for GetUsize {\n    fn uninit() -\u003e Self {\n        GetUsize {\n            len: mem::size_of::\u003cc_int\u003e() as socklen_t,\n            val: MaybeUninit::uninit(),\n        }\n    }\n\n    fn ffi_ptr(\u0026mut self) -\u003e *mut c_void {\n        self.val.as_mut_ptr().cast()\n    }\n\n    fn ffi_len(\u0026mut self) -\u003e *mut socklen_t {\n        \u0026mut self.len\n    }\n\n    unsafe fn assume_init(self) -\u003e usize {\n        assert_eq!(\n            self.len as usize,\n            mem::size_of::\u003cc_int\u003e(),\n            \"invalid getsockopt implementation\"\n        );\n        unsafe { self.val.assume_init() as usize }\n    }\n}\n\n/// Setter for an `usize` value.\n// Hide the docs, because it's an implementation detail of `sockopt_impl!`\n#[doc(hidden)]\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub struct SetUsize {\n    val: c_int,\n}\n\nimpl\u003c'a\u003e Set\u003c'a, usize\u003e for SetUsize {\n    fn new(val: \u0026'a usize) -\u003e SetUsize {\n        SetUsize { val: *val as c_int }\n    }\n\n    fn ffi_ptr(\u0026self) -\u003e *const c_void {\n        \u0026self.val as *const c_int as *const c_void\n    }\n\n    fn ffi_len(\u0026self) -\u003e socklen_t {\n        mem::size_of_val(\u0026self.val) as socklen_t\n    }\n}\n\n\n/// Getter for a `OwnedFd` value.\n// Hide the docs, because it's an implementation detail of `sockopt_impl!`\n#[doc(hidden)]\n#[derive(Clone, Copy, Debug)]\npub struct GetOwnedFd {\n    len: socklen_t,\n    val: MaybeUninit\u003cc_int\u003e,\n}\n\nimpl Get\u003cOwnedFd\u003e for GetOwnedFd {\n    fn uninit() -\u003e Self {\n        GetOwnedFd {\n            len: mem::size_of::\u003cc_int\u003e() as socklen_t,\n            val: MaybeUninit::uninit(),\n        }\n    }\n\n    fn ffi_ptr(\u0026mut self) -\u003e *mut c_void {\n        self.val.as_mut_ptr().cast()\n    }\n\n    fn ffi_len(\u0026mut self) -\u003e *mut socklen_t {\n        \u0026mut self.len\n    }\n\n    unsafe fn assume_init(self) -\u003e OwnedFd {\n        use std::os::fd::{FromRawFd, RawFd};\n\n        assert_eq!(\n            self.len as usize,\n            mem::size_of::\u003cc_int\u003e(),\n            \"invalid getsockopt implementation\"\n        );\n        unsafe { OwnedFd::from_raw_fd(self.val.assume_init() as RawFd) }\n    }\n}\n\n/// Setter for an `OwnedFd` value.\n// Hide the docs, because it's an implementation detail of `sockopt_impl!`\n#[doc(hidden)]\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub struct SetOwnedFd {\n    val: c_int,\n}\n\nimpl\u003c'a\u003e Set\u003c'a, OwnedFd\u003e for SetOwnedFd {\n    fn new(val: \u0026'a OwnedFd) -\u003e SetOwnedFd {\n        use std::os::fd::AsRawFd;\n\n        SetOwnedFd { val: val.as_raw_fd() as c_int }\n    }\n\n    fn ffi_ptr(\u0026self) -\u003e *const c_void {\n        \u0026self.val as *const c_int as *const c_void\n    }\n\n    fn ffi_len(\u0026self) -\u003e socklen_t {\n        mem::size_of_val(\u0026self.val) as socklen_t\n    }\n}\n\n/// Getter for a `OsString` value.\n// Hide the docs, because it's an implementation detail of `sockopt_impl!`\n#[doc(hidden)]\n#[derive(Debug)]\npub struct GetOsString\u003cT: AsMut\u003c[u8]\u003e\u003e {\n    len: socklen_t,\n    val: MaybeUninit\u003cT\u003e,\n}\n\nimpl\u003cT: AsMut\u003c[u8]\u003e\u003e Get\u003cOsString\u003e for GetOsString\u003cT\u003e {\n    fn uninit() -\u003e Self {\n        GetOsString {\n            len: mem::size_of::\u003cT\u003e() as socklen_t,\n            val: MaybeUninit::uninit(),\n        }\n    }\n\n    fn ffi_ptr(\u0026mut self) -\u003e *mut c_void {\n        self.val.as_mut_ptr().cast()\n    }\n\n    fn ffi_len(\u0026mut self) -\u003e *mut socklen_t {\n        \u0026mut self.len\n    }\n\n    unsafe fn assume_init(self) -\u003e OsString {\n        let len = self.len as usize;\n        let mut v = unsafe { self.val.assume_init() };\n        if let Ok(cs) = CStr::from_bytes_until_nul(\u0026v.as_mut()[0..len]) {\n            // It's legal for the kernel to return any number of NULs at the\n            // end of the string.  C applications don't care, after all.\n            OsStr::from_bytes(cs.to_bytes())\n        } else {\n            // Even zero NULs is possible.\n            OsStr::from_bytes(\u0026v.as_mut()[0..len])\n        }\n        .to_owned()\n    }\n}\n\n/// Setter for a `OsString` value.\n// Hide the docs, because it's an implementation detail of `sockopt_impl!`\n#[doc(hidden)]\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\npub struct SetOsString\u003c'a\u003e {\n    val: \u0026'a OsStr,\n}\n\n#[cfg(any(target_os = \"freebsd\", linux_android, target_os = \"illumos\"))]\nimpl\u003c'a\u003e Set\u003c'a, OsString\u003e for SetOsString\u003c'a\u003e {\n    fn new(val: \u0026OsString) -\u003e SetOsString {\n        SetOsString {\n            val: val.as_os_str(),\n        }\n    }\n\n    fn ffi_ptr(\u0026self) -\u003e *const c_void {\n        self.val.as_bytes().as_ptr().cast()\n    }\n\n    fn ffi_len(\u0026self) -\u003e socklen_t {\n        self.val.len() as socklen_t\n    }\n}\n\n/// Getter for a `CString` value.\n#[cfg(apple_targets)]\nstruct GetCString\u003cT: AsMut\u003c[u8]\u003e\u003e {\n    len: socklen_t,\n    val: MaybeUninit\u003cT\u003e,\n}\n\n#[cfg(apple_targets)]\nimpl\u003cT: AsMut\u003c[u8]\u003e\u003e Get\u003cCString\u003e for GetCString\u003cT\u003e {\n    fn uninit() -\u003e Self {\n        GetCString {\n            len: mem::size_of::\u003cT\u003e() as socklen_t,\n            val: MaybeUninit::uninit(),\n        }\n    }\n\n    fn ffi_ptr(\u0026mut self) -\u003e *mut c_void {\n        self.val.as_mut_ptr().cast()\n    }\n\n    fn ffi_len(\u0026mut self) -\u003e *mut socklen_t {\n        \u0026mut self.len\n    }\n\n    unsafe fn assume_init(self) -\u003e CString {\n        let mut v = unsafe { self.val.assume_init() };\n        CStr::from_bytes_until_nul(v.as_mut())\n            .expect(\"string should be null-terminated\")\n            .to_owned()\n    }\n}\n","traces":[{"line":1324,"address":[],"length":0,"stats":{"Line":0}},{"line":1327,"address":[],"length":0,"stats":{"Line":0}},{"line":1328,"address":[],"length":0,"stats":{"Line":0}},{"line":1329,"address":[],"length":0,"stats":{"Line":0}},{"line":1330,"address":[],"length":0,"stats":{"Line":0}},{"line":1331,"address":[],"length":0,"stats":{"Line":0}},{"line":1333,"address":[],"length":0,"stats":{"Line":0}},{"line":1346,"address":[],"length":0,"stats":{"Line":0}},{"line":1347,"address":[],"length":0,"stats":{"Line":0}},{"line":1358,"address":[],"length":0,"stats":{"Line":0}},{"line":1361,"address":[],"length":0,"stats":{"Line":0}},{"line":1362,"address":[],"length":0,"stats":{"Line":0}},{"line":1363,"address":[],"length":0,"stats":{"Line":0}},{"line":1364,"address":[],"length":0,"stats":{"Line":0}},{"line":1365,"address":[],"length":0,"stats":{"Line":0}},{"line":1367,"address":[],"length":0,"stats":{"Line":0}},{"line":1393,"address":[],"length":0,"stats":{"Line":0}},{"line":1394,"address":[],"length":0,"stats":{"Line":0}},{"line":1405,"address":[],"length":0,"stats":{"Line":0}},{"line":1408,"address":[],"length":0,"stats":{"Line":0}},{"line":1409,"address":[],"length":0,"stats":{"Line":0}},{"line":1410,"address":[],"length":0,"stats":{"Line":0}},{"line":1411,"address":[],"length":0,"stats":{"Line":0}},{"line":1412,"address":[],"length":0,"stats":{"Line":0}},{"line":1414,"address":[],"length":0,"stats":{"Line":0}},{"line":1454,"address":[],"length":0,"stats":{"Line":0}},{"line":1455,"address":[],"length":0,"stats":{"Line":0}},{"line":1456,"address":[],"length":0,"stats":{"Line":0}},{"line":1457,"address":[],"length":0,"stats":{"Line":0}},{"line":1459,"address":[],"length":0,"stats":{"Line":0}},{"line":1460,"address":[],"length":0,"stats":{"Line":0}},{"line":1462,"address":[],"length":0,"stats":{"Line":0}},{"line":1463,"address":[],"length":0,"stats":{"Line":0}},{"line":1468,"address":[],"length":0,"stats":{"Line":0}},{"line":1469,"address":[],"length":0,"stats":{"Line":0}},{"line":1470,"address":[],"length":0,"stats":{"Line":0}},{"line":1471,"address":[],"length":0,"stats":{"Line":0}},{"line":1472,"address":[],"length":0,"stats":{"Line":0}},{"line":1474,"address":[],"length":0,"stats":{"Line":0}},{"line":1500,"address":[],"length":0,"stats":{"Line":0}},{"line":1501,"address":[],"length":0,"stats":{"Line":0}},{"line":1502,"address":[],"length":0,"stats":{"Line":0}},{"line":1503,"address":[],"length":0,"stats":{"Line":0}},{"line":1505,"address":[],"length":0,"stats":{"Line":0}},{"line":1506,"address":[],"length":0,"stats":{"Line":0}},{"line":1508,"address":[],"length":0,"stats":{"Line":0}},{"line":1509,"address":[],"length":0,"stats":{"Line":0}},{"line":1514,"address":[],"length":0,"stats":{"Line":0}},{"line":1515,"address":[],"length":0,"stats":{"Line":0}},{"line":1516,"address":[],"length":0,"stats":{"Line":0}},{"line":1517,"address":[],"length":0,"stats":{"Line":0}},{"line":1518,"address":[],"length":0,"stats":{"Line":0}},{"line":1520,"address":[],"length":0,"stats":{"Line":0}},{"line":1535,"address":[],"length":0,"stats":{"Line":0}},{"line":1536,"address":[],"length":0,"stats":{"Line":0}},{"line":1537,"address":[],"length":0,"stats":{"Line":0}},{"line":1541,"address":[],"length":0,"stats":{"Line":0}},{"line":1542,"address":[],"length":0,"stats":{"Line":0}},{"line":1543,"address":[],"length":0,"stats":{"Line":0}},{"line":1544,"address":[],"length":0,"stats":{"Line":0}},{"line":1545,"address":[],"length":0,"stats":{"Line":0}},{"line":1547,"address":[],"length":0,"stats":{"Line":0}},{"line":1561,"address":[],"length":0,"stats":{"Line":0}},{"line":1562,"address":[],"length":0,"stats":{"Line":0}},{"line":1563,"address":[],"length":0,"stats":{"Line":0}},{"line":1567,"address":[],"length":0,"stats":{"Line":0}},{"line":1568,"address":[],"length":0,"stats":{"Line":0}},{"line":1569,"address":[],"length":0,"stats":{"Line":0}},{"line":1570,"address":[],"length":0,"stats":{"Line":0}},{"line":1571,"address":[],"length":0,"stats":{"Line":0}},{"line":1573,"address":[],"length":0,"stats":{"Line":0}},{"line":1623,"address":[],"length":0,"stats":{"Line":0}},{"line":1625,"address":[],"length":0,"stats":{"Line":0}},{"line":1626,"address":[],"length":0,"stats":{"Line":0}},{"line":1630,"address":[],"length":0,"stats":{"Line":0}},{"line":1631,"address":[],"length":0,"stats":{"Line":0}},{"line":1634,"address":[],"length":0,"stats":{"Line":0}},{"line":1635,"address":[],"length":0,"stats":{"Line":0}},{"line":1638,"address":[],"length":0,"stats":{"Line":0}},{"line":1639,"address":[],"length":0,"stats":{"Line":0}},{"line":1640,"address":[],"length":0,"stats":{"Line":0}},{"line":1641,"address":[],"length":0,"stats":{"Line":0}},{"line":1642,"address":[],"length":0,"stats":{"Line":0}},{"line":1644,"address":[],"length":0,"stats":{"Line":0}},{"line":1657,"address":[],"length":0,"stats":{"Line":0}},{"line":1661,"address":[],"length":0,"stats":{"Line":0}},{"line":1662,"address":[],"length":0,"stats":{"Line":0}},{"line":1665,"address":[],"length":0,"stats":{"Line":0}},{"line":1666,"address":[],"length":0,"stats":{"Line":0}},{"line":1714,"address":[],"length":0,"stats":{"Line":0}},{"line":1716,"address":[],"length":0,"stats":{"Line":0}},{"line":1720,"address":[],"length":0,"stats":{"Line":0}},{"line":1721,"address":[],"length":0,"stats":{"Line":0}},{"line":1724,"address":[],"length":0,"stats":{"Line":0}},{"line":1725,"address":[],"length":0,"stats":{"Line":0}},{"line":1776,"address":[],"length":0,"stats":{"Line":0}},{"line":1777,"address":[],"length":0,"stats":{"Line":0}},{"line":1780,"address":[],"length":0,"stats":{"Line":0}},{"line":1781,"address":[],"length":0,"stats":{"Line":0}},{"line":1784,"address":[],"length":0,"stats":{"Line":0}},{"line":1785,"address":[],"length":0,"stats":{"Line":0}},{"line":1833,"address":[],"length":0,"stats":{"Line":0}},{"line":1834,"address":[],"length":0,"stats":{"Line":0}},{"line":1837,"address":[],"length":0,"stats":{"Line":0}},{"line":1838,"address":[],"length":0,"stats":{"Line":0}},{"line":1841,"address":[],"length":0,"stats":{"Line":0}},{"line":1842,"address":[],"length":0,"stats":{"Line":0}},{"line":1893,"address":[],"length":0,"stats":{"Line":0}},{"line":1896,"address":[],"length":0,"stats":{"Line":0}},{"line":1899,"address":[],"length":0,"stats":{"Line":0}},{"line":1900,"address":[],"length":0,"stats":{"Line":0}},{"line":1903,"address":[],"length":0,"stats":{"Line":0}},{"line":1904,"address":[],"length":0,"stats":{"Line":0}},{"line":1918,"address":[],"length":0,"stats":{"Line":0}},{"line":1920,"address":[],"length":0,"stats":{"Line":0}},{"line":1921,"address":[],"length":0,"stats":{"Line":0}},{"line":1925,"address":[],"length":0,"stats":{"Line":0}},{"line":1926,"address":[],"length":0,"stats":{"Line":0}},{"line":1929,"address":[],"length":0,"stats":{"Line":0}},{"line":1930,"address":[],"length":0,"stats":{"Line":0}},{"line":1933,"address":[],"length":0,"stats":{"Line":0}},{"line":1934,"address":[],"length":0,"stats":{"Line":0}},{"line":1935,"address":[],"length":0,"stats":{"Line":0}},{"line":1936,"address":[],"length":0,"stats":{"Line":0}},{"line":1939,"address":[],"length":0,"stats":{"Line":0}},{"line":1942,"address":[],"length":0,"stats":{"Line":0}},{"line":1958,"address":[],"length":0,"stats":{"Line":0}},{"line":1960,"address":[],"length":0,"stats":{"Line":0}},{"line":1964,"address":[],"length":0,"stats":{"Line":0}},{"line":1965,"address":[],"length":0,"stats":{"Line":0}},{"line":1968,"address":[],"length":0,"stats":{"Line":0}},{"line":1969,"address":[],"length":0,"stats":{"Line":0}},{"line":1982,"address":[],"length":0,"stats":{"Line":0}},{"line":1984,"address":[],"length":0,"stats":{"Line":0}},{"line":1985,"address":[],"length":0,"stats":{"Line":0}},{"line":1989,"address":[],"length":0,"stats":{"Line":0}},{"line":1990,"address":[],"length":0,"stats":{"Line":0}},{"line":1993,"address":[],"length":0,"stats":{"Line":0}},{"line":1994,"address":[],"length":0,"stats":{"Line":0}},{"line":1997,"address":[],"length":0,"stats":{"Line":0}},{"line":1998,"address":[],"length":0,"stats":{"Line":0}},{"line":1999,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":142},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","stat.rs"],"content":"#[cfg(any(apple_targets, target_os = \"openbsd\"))]\npub use libc::c_uint;\n#[cfg(any(target_os = \"netbsd\", freebsdlike))]\npub use libc::c_ulong;\npub use libc::stat as FileStat;\npub use libc::{dev_t, mode_t};\n\n#[cfg(not(target_os = \"redox\"))]\nuse crate::fcntl::AtFlags;\nuse crate::sys::time::{TimeSpec, TimeVal};\nuse crate::{errno::Errno, NixPath, Result};\nuse std::mem;\n\nlibc_bitflags!(\n    /// \"File type\" flags for `mknod` and related functions.\n    pub struct SFlag: mode_t {\n        S_IFIFO;\n        S_IFCHR;\n        S_IFDIR;\n        S_IFBLK;\n        S_IFREG;\n        S_IFLNK;\n        S_IFSOCK;\n        S_IFMT;\n    }\n);\n\nlibc_bitflags! {\n    /// \"File mode / permissions\" flags.\n    pub struct Mode: mode_t {\n        /// Read, write and execute for owner.\n        S_IRWXU;\n        /// Read for owner.\n        S_IRUSR;\n        /// Write for owner.\n        S_IWUSR;\n        /// Execute for owner.\n        S_IXUSR;\n        /// Read write and execute for group.\n        S_IRWXG;\n        /// Read for group.\n        S_IRGRP;\n        /// Write for group.\n        S_IWGRP;\n        /// Execute for group.\n        S_IXGRP;\n        /// Read, write and execute for other.\n        S_IRWXO;\n        /// Read for other.\n        S_IROTH;\n        /// Write for other.\n        S_IWOTH;\n        /// Execute for other.\n        S_IXOTH;\n        /// Set user id on execution.\n        S_ISUID as mode_t;\n        /// Set group id on execution.\n        S_ISGID as mode_t;\n        S_ISVTX as mode_t;\n    }\n}\n\n#[cfg(any(apple_targets, target_os = \"openbsd\"))]\npub type type_of_file_flag = c_uint;\n#[cfg(any(freebsdlike, target_os = \"netbsd\"))]\npub type type_of_file_flag = c_ulong;\n\n#[cfg(bsd)]\nlibc_bitflags! {\n    /// File flags.\n    pub struct FileFlag: type_of_file_flag {\n        /// The file may only be appended to.\n        SF_APPEND;\n        /// The file has been archived.\n        SF_ARCHIVED;\n        #[cfg(any(target_os = \"dragonfly\"))]\n        SF_CACHE;\n        /// The file may not be changed.\n        SF_IMMUTABLE;\n        /// Indicates a WAPBL journal file.\n        #[cfg(any(target_os = \"netbsd\"))]\n        SF_LOG;\n        /// Do not retain history for file\n        #[cfg(any(target_os = \"dragonfly\"))]\n        SF_NOHISTORY;\n        /// The file may not be renamed or deleted.\n        #[cfg(freebsdlike)]\n        SF_NOUNLINK;\n        /// Mask of superuser changeable flags\n        SF_SETTABLE;\n        /// Snapshot is invalid.\n        #[cfg(any(target_os = \"netbsd\"))]\n        SF_SNAPINVAL;\n        /// The file is a snapshot file.\n        #[cfg(any(target_os = \"netbsd\", target_os = \"freebsd\"))]\n        SF_SNAPSHOT;\n        #[cfg(any(target_os = \"dragonfly\"))]\n        SF_XLINK;\n        /// The file may only be appended to.\n        UF_APPEND;\n        /// The file needs to be archived.\n        #[cfg(any(target_os = \"freebsd\"))]\n        UF_ARCHIVE;\n        #[cfg(any(target_os = \"dragonfly\"))]\n        UF_CACHE;\n        /// File is compressed at the file system level.\n        #[cfg(apple_targets)]\n        UF_COMPRESSED;\n        /// The file may be hidden from directory listings at the application's\n        /// discretion.\n        #[cfg(any(\n            target_os = \"freebsd\",\n            apple_targets,\n        ))]\n        UF_HIDDEN;\n        /// The file may not be changed.\n        UF_IMMUTABLE;\n        /// Do not dump the file.\n        UF_NODUMP;\n        #[cfg(any(target_os = \"dragonfly\"))]\n        UF_NOHISTORY;\n        /// The file may not be renamed or deleted.\n        #[cfg(freebsdlike)]\n        UF_NOUNLINK;\n        /// The file is offline, or has the Windows and CIFS\n        /// `FILE_ATTRIBUTE_OFFLINE` attribute.\n        #[cfg(any(target_os = \"freebsd\"))]\n        UF_OFFLINE;\n        /// The directory is opaque when viewed through a union stack.\n        UF_OPAQUE;\n        /// The file is read only, and may not be written or appended.\n        #[cfg(any(target_os = \"freebsd\"))]\n        UF_READONLY;\n        /// The file contains a Windows reparse point.\n        #[cfg(any(target_os = \"freebsd\"))]\n        UF_REPARSE;\n        /// Mask of owner changeable flags.\n        UF_SETTABLE;\n        /// The file has the Windows `FILE_ATTRIBUTE_SPARSE_FILE` attribute.\n        #[cfg(any(target_os = \"freebsd\"))]\n        UF_SPARSE;\n        /// The file has the DOS, Windows and CIFS `FILE_ATTRIBUTE_SYSTEM`\n        /// attribute.\n        #[cfg(any(target_os = \"freebsd\"))]\n        UF_SYSTEM;\n        /// File renames and deletes are tracked.\n        #[cfg(apple_targets)]\n        UF_TRACKED;\n        #[cfg(any(target_os = \"dragonfly\"))]\n        UF_XLINK;\n    }\n}\n\n/// Create a special or ordinary file, by pathname.\npub fn mknod\u003cP: ?Sized + NixPath\u003e(\n    path: \u0026P,\n    kind: SFlag,\n    perm: Mode,\n    dev: dev_t,\n) -\u003e Result\u003c()\u003e {\n    let res = path.with_nix_path(|cstr| unsafe {\n        libc::mknod(cstr.as_ptr(), kind.bits() | perm.bits() as mode_t, dev)\n    })?;\n\n    Errno::result(res).map(drop)\n}\n\n/// Create a special or ordinary file, relative to a given directory.\n#[cfg(not(any(apple_targets, target_os = \"redox\", target_os = \"haiku\")))]\npub fn mknodat\u003cFd: std::os::fd::AsFd, P: ?Sized + NixPath\u003e(\n    dirfd: Fd,\n    path: \u0026P,\n    kind: SFlag,\n    perm: Mode,\n    dev: dev_t,\n) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = path.with_nix_path(|cstr| unsafe {\n        libc::mknodat(\n            dirfd.as_fd().as_raw_fd(),\n            cstr.as_ptr(),\n            kind.bits() | perm.bits() as mode_t,\n            dev,\n        )\n    })?;\n\n    Errno::result(res).map(drop)\n}\n\n#[cfg(target_os = \"linux\")]\npub const fn major(dev: dev_t) -\u003e u64 {\n    ((dev \u003e\u003e 32) \u0026 0xffff_f000) | ((dev \u003e\u003e 8) \u0026 0x0000_0fff)\n}\n\n#[cfg(target_os = \"linux\")]\npub const fn minor(dev: dev_t) -\u003e u64 {\n    ((dev \u003e\u003e 12) \u0026 0xffff_ff00) | ((dev) \u0026 0x0000_00ff)\n}\n\n#[cfg(target_os = \"linux\")]\npub const fn makedev(major: u64, minor: u64) -\u003e dev_t {\n    ((major \u0026 0xffff_f000) \u003c\u003c 32)\n        | ((major \u0026 0x0000_0fff) \u003c\u003c 8)\n        | ((minor \u0026 0xffff_ff00) \u003c\u003c 12)\n        | (minor \u0026 0x0000_00ff)\n}\n\npub fn umask(mode: Mode) -\u003e Mode {\n    let prev = unsafe { libc::umask(mode.bits() as mode_t) };\n    Mode::from_bits(prev).expect(\"[BUG] umask returned invalid Mode\")\n}\n\npub fn stat\u003cP: ?Sized + NixPath\u003e(path: \u0026P) -\u003e Result\u003cFileStat\u003e {\n    let mut dst = mem::MaybeUninit::uninit();\n    let res = path.with_nix_path(|cstr| unsafe {\n        libc::stat(cstr.as_ptr(), dst.as_mut_ptr())\n    })?;\n\n    Errno::result(res)?;\n\n    Ok(unsafe { dst.assume_init() })\n}\n\npub fn lstat\u003cP: ?Sized + NixPath\u003e(path: \u0026P) -\u003e Result\u003cFileStat\u003e {\n    let mut dst = mem::MaybeUninit::uninit();\n    let res = path.with_nix_path(|cstr| unsafe {\n        libc::lstat(cstr.as_ptr(), dst.as_mut_ptr())\n    })?;\n\n    Errno::result(res)?;\n\n    Ok(unsafe { dst.assume_init() })\n}\n\npub fn fstat\u003cFd: std::os::fd::AsFd\u003e(fd: Fd) -\u003e Result\u003cFileStat\u003e {\n    use std::os::fd::AsRawFd;\n\n    let mut dst = mem::MaybeUninit::uninit();\n    let res = unsafe { libc::fstat(fd.as_fd().as_raw_fd(), dst.as_mut_ptr()) };\n\n    Errno::result(res)?;\n\n    Ok(unsafe { dst.assume_init() })\n}\n\n#[cfg(not(target_os = \"redox\"))]\npub fn fstatat\u003cFd: std::os::fd::AsFd, P: ?Sized + NixPath\u003e(\n    dirfd: Fd,\n    pathname: \u0026P,\n    f: AtFlags,\n) -\u003e Result\u003cFileStat\u003e {\n    use std::os::fd::AsRawFd;\n\n    let mut dst = mem::MaybeUninit::uninit();\n    let res = pathname.with_nix_path(|cstr| unsafe {\n        libc::fstatat(\n            dirfd.as_fd().as_raw_fd(),\n            cstr.as_ptr(),\n            dst.as_mut_ptr(),\n            f.bits() as libc::c_int,\n        )\n    })?;\n\n    Errno::result(res)?;\n\n    Ok(unsafe { dst.assume_init() })\n}\n\n/// Change the file permission bits of the file specified by a file descriptor.\n///\n/// # References\n///\n/// [fchmod(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fchmod.html).\npub fn fchmod\u003cFd: std::os::fd::AsFd\u003e(fd: Fd, mode: Mode) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res =\n        unsafe { libc::fchmod(fd.as_fd().as_raw_fd(), mode.bits() as mode_t) };\n\n    Errno::result(res).map(drop)\n}\n\n/// Flags for `fchmodat` function.\n#[derive(Clone, Copy, Debug)]\npub enum FchmodatFlags {\n    FollowSymlink,\n    NoFollowSymlink,\n}\n\n/// Change the file permission bits.\n///\n/// The file to be changed is determined relative to the directory associated\n/// with the file descriptor `dirfd` or the current working directory\n/// if `dirfd` is [`AT_FDCWD`](crate::fcntl::AT_FDCWD).\n///\n/// If `flag` is `FchmodatFlags::NoFollowSymlink` and `path` names a symbolic link,\n/// then the mode of the symbolic link is changed.\n///\n/// `fchmodat(AT_FDCWD, path, mode, FchmodatFlags::FollowSymlink)` is identical to\n/// a call `libc::chmod(path, mode)`. That's why `chmod` is unimplemented\n/// in the `nix` crate.\n///\n/// # References\n///\n/// [fchmodat(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fchmodat.html).\n#[cfg(not(target_os = \"redox\"))]\npub fn fchmodat\u003cFd: std::os::fd::AsFd, P: ?Sized + NixPath\u003e(\n    dirfd: Fd,\n    path: \u0026P,\n    mode: Mode,\n    flag: FchmodatFlags,\n) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let atflag = match flag {\n        FchmodatFlags::FollowSymlink =\u003e AtFlags::empty(),\n        FchmodatFlags::NoFollowSymlink =\u003e AtFlags::AT_SYMLINK_NOFOLLOW,\n    };\n    let res = path.with_nix_path(|cstr| unsafe {\n        libc::fchmodat(\n            dirfd.as_fd().as_raw_fd(),\n            cstr.as_ptr(),\n            mode.bits() as mode_t,\n            atflag.bits() as libc::c_int,\n        )\n    })?;\n\n    Errno::result(res).map(drop)\n}\n\n/// Change the access and modification times of a file.\n///\n/// `utimes(path, times)` is identical to\n/// `utimensat(None, path, times, UtimensatFlags::FollowSymlink)`. The former\n/// is a deprecated API so prefer using the latter if the platforms you care\n/// about support it.\n///\n/// # References\n///\n/// [utimes(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/utimes.html).\npub fn utimes\u003cP: ?Sized + NixPath\u003e(\n    path: \u0026P,\n    atime: \u0026TimeVal,\n    mtime: \u0026TimeVal,\n) -\u003e Result\u003c()\u003e {\n    let times: [libc::timeval; 2] = [*atime.as_ref(), *mtime.as_ref()];\n    let res = path.with_nix_path(|cstr| unsafe {\n        libc::utimes(cstr.as_ptr(), \u0026times[0])\n    })?;\n\n    Errno::result(res).map(drop)\n}\n\n/// Change the access and modification times of a file without following symlinks.\n///\n/// `lutimes(path, times)` is identical to\n/// `utimensat(None, path, times, UtimensatFlags::NoFollowSymlink)`. The former\n/// is a deprecated API so prefer using the latter if the platforms you care\n/// about support it.\n///\n/// # References\n///\n/// [lutimes(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/lutimes.html).\n#[cfg(any(\n    target_os = \"linux\",\n    target_os = \"haiku\",\n    apple_targets,\n    target_os = \"freebsd\",\n    target_os = \"netbsd\"\n))]\npub fn lutimes\u003cP: ?Sized + NixPath\u003e(\n    path: \u0026P,\n    atime: \u0026TimeVal,\n    mtime: \u0026TimeVal,\n) -\u003e Result\u003c()\u003e {\n    let times: [libc::timeval; 2] = [*atime.as_ref(), *mtime.as_ref()];\n    let res = path.with_nix_path(|cstr| unsafe {\n        libc::lutimes(cstr.as_ptr(), \u0026times[0])\n    })?;\n\n    Errno::result(res).map(drop)\n}\n\n/// Change the access and modification times of the file specified by a file descriptor.\n///\n/// If you want to set the timestamp to now, use `TimeSpec::UTIME_NOW`. Use\n/// `TimeSpec::UTIME_OMIT` if you don't want to change it.\n///\n/// # References\n///\n/// [futimens(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/futimens.html).\n#[inline]\npub fn futimens\u003cFd: std::os::fd::AsFd\u003e(\n    fd: Fd,\n    atime: \u0026TimeSpec,\n    mtime: \u0026TimeSpec,\n) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let times: [libc::timespec; 2] = [*atime.as_ref(), *mtime.as_ref()];\n    let res = unsafe { libc::futimens(fd.as_fd().as_raw_fd(), \u0026times[0]) };\n\n    Errno::result(res).map(drop)\n}\n\n/// Flags for `utimensat` function.\n// TODO: replace with fcntl::AtFlags\n#[derive(Clone, Copy, Debug)]\npub enum UtimensatFlags {\n    FollowSymlink,\n    NoFollowSymlink,\n}\n\n/// Change the access and modification times of a file.\n///\n/// The file to be changed is determined relative to the directory associated\n/// with the file descriptor `dirfd` or the current working directory\n/// if `dirfd` is [`AT_FDCWD`](crate::fcntl::AT_FDCWD).\n///\n/// If `flag` is `UtimensatFlags::NoFollowSymlink` and `path` names a symbolic link,\n/// then the mode of the symbolic link is changed.\n///\n/// `utimensat(AT_FDCWD, path, times, UtimensatFlags::FollowSymlink)` is identical to\n/// `utimes(path, times)`. The latter is a deprecated API so prefer using the\n/// former if the platforms you care about support it.\n///\n/// If you want to set the timestamp to now, use `TimeSpec::UTIME_NOW`. Use\n/// `TimeSpec::UTIME_OMIT` if you don't want to change it.\n///\n/// # References\n///\n/// [utimensat(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/utimens.html).\n#[cfg(not(target_os = \"redox\"))]\npub fn utimensat\u003cFd: std::os::fd::AsFd, P: ?Sized + NixPath\u003e(\n    dirfd: Fd,\n    path: \u0026P,\n    atime: \u0026TimeSpec,\n    mtime: \u0026TimeSpec,\n    flag: UtimensatFlags,\n) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let atflag = match flag {\n        UtimensatFlags::FollowSymlink =\u003e AtFlags::empty(),\n        UtimensatFlags::NoFollowSymlink =\u003e AtFlags::AT_SYMLINK_NOFOLLOW,\n    };\n    let times: [libc::timespec; 2] = [*atime.as_ref(), *mtime.as_ref()];\n    let res = path.with_nix_path(|cstr| unsafe {\n        libc::utimensat(\n            dirfd.as_fd().as_raw_fd(),\n            cstr.as_ptr(),\n            \u0026times[0],\n            atflag.bits() as libc::c_int,\n        )\n    })?;\n\n    Errno::result(res).map(drop)\n}\n\n/// Create a directory at the path specified by `dirfd` and `path`.\n///\n/// If `path` is a relative path, then it is interpreted relative to the directory\n/// referred to by the file descriptor `dirfd`. (One can use [`AT_FDCWD`][link] to\n/// specify the current working directory in `dirfd`). If `path` is absolute,\n/// then `dirfd` is ignored.\n///\n/// [link]: crate::fcntl::AT_FDCWD\n#[cfg(not(target_os = \"redox\"))]\npub fn mkdirat\u003cFd: std::os::fd::AsFd, P: ?Sized + NixPath\u003e(\n    dirfd: Fd,\n    path: \u0026P,\n    mode: Mode,\n) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = path.with_nix_path(|cstr| unsafe {\n        libc::mkdirat(\n            dirfd.as_fd().as_raw_fd(),\n            cstr.as_ptr(),\n            mode.bits() as mode_t,\n        )\n    })?;\n\n    Errno::result(res).map(drop)\n}\n","traces":[{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":78},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","statfs.rs"],"content":"//! Get filesystem statistics, non-portably\n//!\n//! See [`statvfs`](crate::sys::statvfs) for a portable alternative.\n#[cfg(not(any(linux_android, target_os = \"cygwin\")))]\nuse std::ffi::CStr;\nuse std::fmt::{self, Debug};\nuse std::mem;\nuse std::os::unix::io::{AsFd, AsRawFd};\n\nuse cfg_if::cfg_if;\n\n#[cfg(all(feature = \"mount\", bsd))]\nuse crate::mount::MntFlags;\n#[cfg(target_os = \"linux\")]\nuse crate::sys::statvfs::FsFlags;\nuse crate::{errno::Errno, NixPath, Result};\n\n/// Identifies a mounted file system\n#[cfg(target_os = \"android\")]\npub type fsid_t = libc::__fsid_t;\n/// Identifies a mounted file system\n#[cfg(not(any(target_os = \"android\", target_os = \"cygwin\")))]\npub type fsid_t = libc::fsid_t;\n/// Identifies a mounted file system\n#[cfg(target_os = \"cygwin\")]\npub type fsid_t = libc::c_long;\n\ncfg_if! {\n    if #[cfg(any(linux_android, target_os = \"fuchsia\"))] {\n        type type_of_statfs = libc::statfs64;\n        const LIBC_FSTATFS: unsafe extern \"C\" fn\n            (fd: libc::c_int, buf: *mut type_of_statfs) -\u003e libc::c_int\n            = libc::fstatfs64;\n        const LIBC_STATFS: unsafe extern \"C\" fn\n            (path: *const libc::c_char, buf: *mut type_of_statfs) -\u003e libc::c_int\n            = libc::statfs64;\n    } else {\n        type type_of_statfs = libc::statfs;\n        const LIBC_FSTATFS: unsafe extern \"C\" fn\n            (fd: libc::c_int, buf: *mut type_of_statfs) -\u003e libc::c_int\n            = libc::fstatfs;\n        const LIBC_STATFS: unsafe extern \"C\" fn\n            (path: *const libc::c_char, buf: *mut type_of_statfs) -\u003e libc::c_int\n            = libc::statfs;\n    }\n}\n\n/// Describes a mounted file system\n#[derive(Clone, Copy)]\n#[repr(transparent)]\npub struct Statfs(type_of_statfs);\n\n#[cfg(target_os = \"freebsd\")]\ntype fs_type_t = u32;\n#[cfg(target_os = \"android\")]\ntype fs_type_t = libc::c_ulong;\n#[cfg(all(\n    target_os = \"linux\",\n    target_arch = \"s390x\",\n    not(target_env = \"musl\")\n))]\ntype fs_type_t = libc::c_uint;\n#[cfg(all(target_os = \"linux\", any(target_env = \"musl\", target_env = \"ohos\")))]\ntype fs_type_t = libc::c_ulong;\n#[cfg(all(target_os = \"linux\", target_env = \"uclibc\"))]\ntype fs_type_t = libc::c_int;\n#[cfg(all(\n    target_os = \"linux\",\n    not(any(\n        target_arch = \"s390x\",\n        target_env = \"musl\",\n        target_env = \"ohos\",\n        target_env = \"uclibc\"\n    ))\n))]\ntype fs_type_t = libc::__fsword_t;\n#[cfg(target_os = \"cygwin\")]\ntype fs_type_t = libc::c_long;\n\n/// Describes the file system type as known by the operating system.\n#[cfg(any(\n    target_os = \"freebsd\",\n    target_os = \"android\",\n    all(target_os = \"linux\", target_arch = \"s390x\"),\n    all(target_os = \"linux\", target_env = \"musl\"),\n    all(target_os = \"linux\", target_env = \"ohos\"),\n    all(\n        target_os = \"linux\",\n        not(any(target_arch = \"s390x\", target_env = \"musl\"))\n    ),\n    target_os = \"cygwin\",\n))]\n#[derive(Eq, Copy, Clone, PartialEq, Debug)]\npub struct FsType(pub fs_type_t);\n\n// These constants are defined without documentation in the Linux headers, so we\n// can't very well document them here.\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const ADFS_SUPER_MAGIC: FsType =\n    FsType(libc::ADFS_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const AFFS_SUPER_MAGIC: FsType =\n    FsType(libc::AFFS_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const AFS_SUPER_MAGIC: FsType = FsType(libc::AFS_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const AUTOFS_SUPER_MAGIC: FsType =\n    FsType(libc::AUTOFS_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const BPF_FS_MAGIC: FsType = FsType(libc::BPF_FS_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const BTRFS_SUPER_MAGIC: FsType =\n    FsType(libc::BTRFS_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const CGROUP2_SUPER_MAGIC: FsType =\n    FsType(libc::CGROUP2_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const CGROUP_SUPER_MAGIC: FsType =\n    FsType(libc::CGROUP_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const CODA_SUPER_MAGIC: FsType =\n    FsType(libc::CODA_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const CRAMFS_MAGIC: FsType = FsType(libc::CRAMFS_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const DEBUGFS_MAGIC: FsType = FsType(libc::DEBUGFS_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const DEVPTS_SUPER_MAGIC: FsType =\n    FsType(libc::DEVPTS_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const ECRYPTFS_SUPER_MAGIC: FsType =\n    FsType(libc::ECRYPTFS_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const EFS_SUPER_MAGIC: FsType = FsType(libc::EFS_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const EXT2_SUPER_MAGIC: FsType =\n    FsType(libc::EXT2_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const EXT3_SUPER_MAGIC: FsType =\n    FsType(libc::EXT3_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const EXT4_SUPER_MAGIC: FsType =\n    FsType(libc::EXT4_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const F2FS_SUPER_MAGIC: FsType =\n    FsType(libc::F2FS_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const FUSE_SUPER_MAGIC: FsType =\n    FsType(libc::FUSE_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const FUTEXFS_SUPER_MAGIC: FsType =\n    FsType(libc::FUTEXFS_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const HOSTFS_SUPER_MAGIC: FsType =\n    FsType(libc::HOSTFS_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const HPFS_SUPER_MAGIC: FsType =\n    FsType(libc::HPFS_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const HUGETLBFS_MAGIC: FsType = FsType(libc::HUGETLBFS_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const ISOFS_SUPER_MAGIC: FsType =\n    FsType(libc::ISOFS_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const JFFS2_SUPER_MAGIC: FsType =\n    FsType(libc::JFFS2_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const MINIX2_SUPER_MAGIC2: FsType =\n    FsType(libc::MINIX2_SUPER_MAGIC2 as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const MINIX2_SUPER_MAGIC: FsType =\n    FsType(libc::MINIX2_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const MINIX3_SUPER_MAGIC: FsType =\n    FsType(libc::MINIX3_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const MINIX_SUPER_MAGIC2: FsType =\n    FsType(libc::MINIX_SUPER_MAGIC2 as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const MINIX_SUPER_MAGIC: FsType =\n    FsType(libc::MINIX_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const MSDOS_SUPER_MAGIC: FsType =\n    FsType(libc::MSDOS_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const NCP_SUPER_MAGIC: FsType = FsType(libc::NCP_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const NFS_SUPER_MAGIC: FsType = FsType(libc::NFS_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const NILFS_SUPER_MAGIC: FsType =\n    FsType(libc::NILFS_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const OCFS2_SUPER_MAGIC: FsType =\n    FsType(libc::OCFS2_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const OPENPROM_SUPER_MAGIC: FsType =\n    FsType(libc::OPENPROM_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const OVERLAYFS_SUPER_MAGIC: FsType =\n    FsType(libc::OVERLAYFS_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const PROC_SUPER_MAGIC: FsType =\n    FsType(libc::PROC_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const QNX4_SUPER_MAGIC: FsType =\n    FsType(libc::QNX4_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const QNX6_SUPER_MAGIC: FsType =\n    FsType(libc::QNX6_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const RDTGROUP_SUPER_MAGIC: FsType =\n    FsType(libc::RDTGROUP_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const REISERFS_SUPER_MAGIC: FsType =\n    FsType(libc::REISERFS_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const SECURITYFS_MAGIC: FsType =\n    FsType(libc::SECURITYFS_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const SELINUX_MAGIC: FsType = FsType(libc::SELINUX_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const SMACK_MAGIC: FsType = FsType(libc::SMACK_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const SMB_SUPER_MAGIC: FsType = FsType(libc::SMB_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const SYSFS_MAGIC: FsType = FsType(libc::SYSFS_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const TMPFS_MAGIC: FsType = FsType(libc::TMPFS_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const TRACEFS_MAGIC: FsType = FsType(libc::TRACEFS_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const UDF_SUPER_MAGIC: FsType = FsType(libc::UDF_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const USBDEVICE_SUPER_MAGIC: FsType =\n    FsType(libc::USBDEVICE_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const XENFS_SUPER_MAGIC: FsType =\n    FsType(libc::XENFS_SUPER_MAGIC as fs_type_t);\n#[cfg(linux_android)]\n#[allow(missing_docs)]\npub const NSFS_MAGIC: FsType = FsType(libc::NSFS_MAGIC as fs_type_t);\n#[cfg(all(linux_android, not(target_env = \"musl\"), not(target_env = \"ohos\")))]\n#[allow(missing_docs)]\npub const XFS_SUPER_MAGIC: FsType = FsType(libc::XFS_SUPER_MAGIC as fs_type_t);\n\nimpl Statfs {\n    /// Magic code defining system type\n    #[cfg(not(any(\n        target_os = \"openbsd\",\n        target_os = \"dragonfly\",\n        apple_targets,\n    )))]\n    pub fn filesystem_type(\u0026self) -\u003e FsType {\n        FsType(self.0.f_type)\n    }\n\n    /// Magic code defining system type\n    #[cfg(not(any(linux_android, target_os = \"cygwin\")))]\n    pub fn filesystem_type_name(\u0026self) -\u003e \u0026str {\n        let c_str = unsafe { CStr::from_ptr(self.0.f_fstypename.as_ptr()) };\n        c_str.to_str().unwrap()\n    }\n\n    /// Optimal transfer block size\n    #[cfg(apple_targets)]\n    pub fn optimal_transfer_size(\u0026self) -\u003e i32 {\n        self.0.f_iosize\n    }\n\n    /// Optimal transfer block size\n    #[cfg(target_os = \"openbsd\")]\n    pub fn optimal_transfer_size(\u0026self) -\u003e u32 {\n        self.0.f_iosize\n    }\n\n    /// Optimal transfer block size\n    #[cfg(all(\n        target_os = \"linux\",\n        target_arch = \"s390x\",\n        not(target_env = \"musl\")\n    ))]\n    pub fn optimal_transfer_size(\u0026self) -\u003e u32 {\n        self.0.f_bsize\n    }\n\n    /// Optimal transfer block size\n    #[cfg(any(\n        target_os = \"android\",\n        all(target_os = \"linux\", target_env = \"musl\"),\n        all(target_os = \"linux\", target_env = \"ohos\")\n    ))]\n    pub fn optimal_transfer_size(\u0026self) -\u003e libc::c_ulong {\n        self.0.f_bsize\n    }\n\n    /// Optimal transfer block size\n    #[cfg(all(\n        target_os = \"linux\",\n        not(any(\n            target_arch = \"s390x\",\n            target_env = \"musl\",\n            target_env = \"ohos\",\n            target_env = \"uclibc\"\n        ))\n    ))]\n    pub fn optimal_transfer_size(\u0026self) -\u003e libc::__fsword_t {\n        self.0.f_bsize\n    }\n\n    /// Optimal transfer block size\n    #[cfg(all(target_os = \"linux\", target_env = \"uclibc\"))]\n    pub fn optimal_transfer_size(\u0026self) -\u003e libc::c_int {\n        self.0.f_bsize\n    }\n\n    /// Optimal transfer block size\n    #[cfg(target_os = \"dragonfly\")]\n    pub fn optimal_transfer_size(\u0026self) -\u003e libc::c_long {\n        self.0.f_iosize\n    }\n\n    /// Optimal transfer block size\n    #[cfg(target_os = \"freebsd\")]\n    pub fn optimal_transfer_size(\u0026self) -\u003e u64 {\n        self.0.f_iosize\n    }\n\n    /// Size of a block\n    #[cfg(any(apple_targets, target_os = \"openbsd\"))]\n    pub fn block_size(\u0026self) -\u003e u32 {\n        self.0.f_bsize\n    }\n\n    /// Size of a block\n    // f_bsize on linux: https://github.com/torvalds/linux/blob/master/fs/nfs/super.c#L471\n    #[cfg(all(\n        target_os = \"linux\",\n        target_arch = \"s390x\",\n        not(target_env = \"musl\")\n    ))]\n    pub fn block_size(\u0026self) -\u003e u32 {\n        self.0.f_bsize\n    }\n\n    /// Size of a block\n    // f_bsize on linux: https://github.com/torvalds/linux/blob/master/fs/nfs/super.c#L471\n    #[cfg(all(target_os = \"linux\", target_env = \"musl\"))]\n    pub fn block_size(\u0026self) -\u003e libc::c_ulong {\n        self.0.f_bsize\n    }\n\n    /// Size of a block\n    // f_bsize on linux: https://github.com/torvalds/linux/blob/master/fs/nfs/super.c#L471\n    #[cfg(all(target_os = \"linux\", target_env = \"ohos\"))]\n    pub fn block_size(\u0026self) -\u003e libc::c_ulong {\n        self.0.f_bsize\n    }\n\n    /// Size of a block\n    // f_bsize on linux: https://github.com/torvalds/linux/blob/master/fs/nfs/super.c#L471\n    #[cfg(all(target_os = \"linux\", target_env = \"uclibc\"))]\n    pub fn block_size(\u0026self) -\u003e libc::c_int {\n        self.0.f_bsize\n    }\n\n    /// Size of a block\n    // f_bsize on linux: https://github.com/torvalds/linux/blob/master/fs/nfs/super.c#L471\n    #[cfg(all(\n        target_os = \"linux\",\n        not(any(\n            target_arch = \"s390x\",\n            target_env = \"musl\",\n            target_env = \"ohos\",\n            target_env = \"uclibc\"\n        ))\n    ))]\n    pub fn block_size(\u0026self) -\u003e libc::__fsword_t {\n        self.0.f_bsize\n    }\n\n    /// Size of a block\n    #[cfg(target_os = \"freebsd\")]\n    pub fn block_size(\u0026self) -\u003e u64 {\n        self.0.f_bsize\n    }\n\n    /// Size of a block\n    #[cfg(target_os = \"android\")]\n    pub fn block_size(\u0026self) -\u003e libc::c_ulong {\n        self.0.f_bsize\n    }\n\n    /// Size of a block\n    #[cfg(any(target_os = \"dragonfly\", target_os = \"cygwin\"))]\n    pub fn block_size(\u0026self) -\u003e libc::c_long {\n        self.0.f_bsize\n    }\n\n    /// Get the mount flags\n    #[cfg(all(feature = \"mount\", bsd))]\n    #[allow(clippy::unnecessary_cast)] // Not unnecessary on all arches\n    pub fn flags(\u0026self) -\u003e MntFlags {\n        MntFlags::from_bits_truncate(self.0.f_flags as i32)\n    }\n\n    /// Get the mount flags\n    // The f_flags field exists on Android and Fuchsia too, but without man\n    // pages I can't tell if it can be cast to FsFlags.\n    #[cfg(target_os = \"linux\")]\n    pub fn flags(\u0026self) -\u003e FsFlags {\n        FsFlags::from_bits_truncate(self.0.f_flags as libc::c_ulong)\n    }\n\n    /// Maximum length of filenames\n    #[cfg(any(target_os = \"freebsd\", target_os = \"openbsd\"))]\n    pub fn maximum_name_length(\u0026self) -\u003e u32 {\n        self.0.f_namemax\n    }\n\n    /// Maximum length of filenames\n    #[cfg(all(\n        target_os = \"linux\",\n        target_arch = \"s390x\",\n        not(target_env = \"musl\")\n    ))]\n    pub fn maximum_name_length(\u0026self) -\u003e u32 {\n        self.0.f_namelen\n    }\n\n    /// Maximum length of filenames\n    #[cfg(all(target_os = \"linux\", target_env = \"musl\"))]\n    pub fn maximum_name_length(\u0026self) -\u003e libc::c_ulong {\n        self.0.f_namelen\n    }\n\n    /// Maximum length of filenames\n    #[cfg(all(target_os = \"linux\", target_env = \"uclibc\"))]\n    pub fn maximum_name_length(\u0026self) -\u003e libc::c_int {\n        self.0.f_namelen\n    }\n\n    /// Maximum length of filenames\n    #[cfg(all(\n        target_os = \"linux\",\n        not(any(\n            target_arch = \"s390x\",\n            target_env = \"musl\",\n            target_env = \"ohos\",\n            target_env = \"uclibc\"\n        ))\n    ))]\n    pub fn maximum_name_length(\u0026self) -\u003e libc::__fsword_t {\n        self.0.f_namelen\n    }\n\n    /// Maximum length of filenames\n    #[cfg(target_os = \"android\")]\n    pub fn maximum_name_length(\u0026self) -\u003e libc::c_ulong {\n        self.0.f_namelen\n    }\n\n    /// Total data blocks in filesystem\n    #[cfg(any(\n        apple_targets,\n        linux_android,\n        target_os = \"freebsd\",\n        target_os = \"fuchsia\",\n        target_os = \"openbsd\",\n    ))]\n    pub fn blocks(\u0026self) -\u003e u64 {\n        self.0.f_blocks\n    }\n\n    /// Total data blocks in filesystem\n    #[cfg(any(target_os = \"dragonfly\", target_os = \"cygwin\"))]\n    pub fn blocks(\u0026self) -\u003e libc::c_long {\n        self.0.f_blocks\n    }\n\n    /// Total data blocks in filesystem\n    #[cfg(target_os = \"emscripten\")]\n    pub fn blocks(\u0026self) -\u003e u32 {\n        self.0.f_blocks\n    }\n\n    /// Free blocks in filesystem\n    #[cfg(any(\n        apple_targets,\n        linux_android,\n        target_os = \"freebsd\",\n        target_os = \"fuchsia\",\n        target_os = \"openbsd\",\n    ))]\n    pub fn blocks_free(\u0026self) -\u003e u64 {\n        self.0.f_bfree\n    }\n\n    /// Free blocks in filesystem\n    #[cfg(any(target_os = \"dragonfly\", target_os = \"cygwin\"))]\n    pub fn blocks_free(\u0026self) -\u003e libc::c_long {\n        self.0.f_bfree\n    }\n\n    /// Free blocks in filesystem\n    #[cfg(target_os = \"emscripten\")]\n    pub fn blocks_free(\u0026self) -\u003e u32 {\n        self.0.f_bfree\n    }\n\n    /// Free blocks available to unprivileged user\n    #[cfg(any(apple_targets, linux_android, target_os = \"fuchsia\"))]\n    pub fn blocks_available(\u0026self) -\u003e u64 {\n        self.0.f_bavail\n    }\n\n    /// Free blocks available to unprivileged user\n    #[cfg(any(target_os = \"dragonfly\", target_os = \"cygwin\"))]\n    pub fn blocks_available(\u0026self) -\u003e libc::c_long {\n        self.0.f_bavail\n    }\n\n    /// Free blocks available to unprivileged user\n    #[cfg(any(target_os = \"freebsd\", target_os = \"openbsd\"))]\n    pub fn blocks_available(\u0026self) -\u003e i64 {\n        self.0.f_bavail\n    }\n\n    /// Free blocks available to unprivileged user\n    #[cfg(target_os = \"emscripten\")]\n    pub fn blocks_available(\u0026self) -\u003e u32 {\n        self.0.f_bavail\n    }\n\n    /// Total file nodes in filesystem\n    #[cfg(any(\n        apple_targets,\n        linux_android,\n        target_os = \"freebsd\",\n        target_os = \"fuchsia\",\n        target_os = \"openbsd\",\n    ))]\n    pub fn files(\u0026self) -\u003e u64 {\n        self.0.f_files\n    }\n\n    /// Total file nodes in filesystem\n    #[cfg(any(target_os = \"dragonfly\", target_os = \"cygwin\"))]\n    pub fn files(\u0026self) -\u003e libc::c_long {\n        self.0.f_files\n    }\n\n    /// Total file nodes in filesystem\n    #[cfg(target_os = \"emscripten\")]\n    pub fn files(\u0026self) -\u003e u32 {\n        self.0.f_files\n    }\n\n    /// Free file nodes in filesystem\n    #[cfg(any(\n        apple_targets,\n        linux_android,\n        target_os = \"fuchsia\",\n        target_os = \"openbsd\",\n    ))]\n    pub fn files_free(\u0026self) -\u003e u64 {\n        self.0.f_ffree\n    }\n\n    /// Free file nodes in filesystem\n    #[cfg(any(target_os = \"dragonfly\", target_os = \"cygwin\"))]\n    pub fn files_free(\u0026self) -\u003e libc::c_long {\n        self.0.f_ffree\n    }\n\n    /// Free file nodes in filesystem\n    #[cfg(target_os = \"freebsd\")]\n    pub fn files_free(\u0026self) -\u003e i64 {\n        self.0.f_ffree\n    }\n\n    /// Free file nodes in filesystem\n    #[cfg(target_os = \"emscripten\")]\n    pub fn files_free(\u0026self) -\u003e u32 {\n        self.0.f_ffree\n    }\n\n    /// Filesystem ID\n    pub fn filesystem_id(\u0026self) -\u003e fsid_t {\n        self.0.f_fsid\n    }\n}\n\nimpl Debug for Statfs {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        let mut ds = f.debug_struct(\"Statfs\");\n        #[cfg(not(target_os = \"cygwin\"))]\n        ds.field(\"optimal_transfer_size\", \u0026self.optimal_transfer_size());\n        ds.field(\"block_size\", \u0026self.block_size());\n        ds.field(\"blocks\", \u0026self.blocks());\n        ds.field(\"blocks_free\", \u0026self.blocks_free());\n        ds.field(\"blocks_available\", \u0026self.blocks_available());\n        ds.field(\"files\", \u0026self.files());\n        ds.field(\"files_free\", \u0026self.files_free());\n        ds.field(\"filesystem_id\", \u0026self.filesystem_id());\n        #[cfg(all(feature = \"mount\", bsd))]\n        ds.field(\"flags\", \u0026self.flags());\n        ds.finish()\n    }\n}\n\n/// Describes a mounted file system.\n///\n/// The result is OS-dependent.  For a portable alternative, see\n/// [`statvfs`](crate::sys::statvfs::statvfs).\n///\n/// # Arguments\n///\n/// `path` - Path to any file within the file system to describe\npub fn statfs\u003cP: ?Sized + NixPath\u003e(path: \u0026P) -\u003e Result\u003cStatfs\u003e {\n    unsafe {\n        let mut stat = mem::MaybeUninit::\u003ctype_of_statfs\u003e::uninit();\n        let res = path.with_nix_path(|path| {\n            LIBC_STATFS(path.as_ptr(), stat.as_mut_ptr())\n        })?;\n        Errno::result(res).map(|_| Statfs(stat.assume_init()))\n    }\n}\n\n/// Describes a mounted file system.\n///\n/// The result is OS-dependent.  For a portable alternative, see\n/// [`fstatvfs`](crate::sys::statvfs::fstatvfs).\n///\n/// # Arguments\n///\n/// `fd` - File descriptor of any open file within the file system to describe\npub fn fstatfs\u003cFd: AsFd\u003e(fd: Fd) -\u003e Result\u003cStatfs\u003e {\n    unsafe {\n        let mut stat = mem::MaybeUninit::\u003ctype_of_statfs\u003e::uninit();\n        Errno::result(LIBC_FSTATFS(fd.as_fd().as_raw_fd(), stat.as_mut_ptr()))\n            .map(|_| Statfs(stat.assume_init()))\n    }\n}\n","traces":[{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","statvfs.rs"],"content":"//! Get filesystem statistics\n//!\n//! See [the man pages](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fstatvfs.html)\n//! for more details.\nuse std::mem;\nuse std::os::unix::io::{AsFd, AsRawFd};\n\nuse libc::{self, c_ulong};\n\nuse crate::{errno::Errno, NixPath, Result};\n\n#[cfg(not(target_os = \"redox\"))]\nlibc_bitflags!(\n    /// File system mount Flags\n    #[derive(Default)]\n    pub struct FsFlags: c_ulong {\n        /// Read Only\n        #[cfg(not(target_os = \"haiku\"))]\n        ST_RDONLY;\n        /// Do not allow the set-uid bits to have an effect\n        #[cfg(not(target_os = \"haiku\"))]\n        ST_NOSUID;\n        /// Do not interpret character or block-special devices\n        #[cfg(linux_android)]\n        ST_NODEV;\n        /// Do not allow execution of binaries on the filesystem\n        #[cfg(linux_android)]\n        ST_NOEXEC;\n        /// All IO should be done synchronously\n        #[cfg(linux_android)]\n        ST_SYNCHRONOUS;\n        /// Allow mandatory locks on the filesystem\n        #[cfg(linux_android)]\n        ST_MANDLOCK;\n        /// Write on file/directory/symlink\n        #[cfg(target_os = \"linux\")]\n        ST_WRITE;\n        /// Append-only file\n        #[cfg(target_os = \"linux\")]\n        ST_APPEND;\n        /// Immutable file\n        #[cfg(target_os = \"linux\")]\n        ST_IMMUTABLE;\n        /// Do not update access times on files\n        #[cfg(linux_android)]\n        ST_NOATIME;\n        /// Do not update access times on files\n        #[cfg(linux_android)]\n        ST_NODIRATIME;\n        /// Update access time relative to modify/change time\n        #[cfg(any(target_os = \"android\", all(target_os = \"linux\", not(target_env = \"musl\"), not(target_env = \"ohos\"))))]\n        ST_RELATIME;\n    }\n);\n\n/// Wrapper around the POSIX `statvfs` struct\n///\n/// For more information see the [`statvfs(3)` man pages](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_statvfs.h.html).\n#[repr(transparent)]\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct Statvfs(libc::statvfs);\n\nimpl Statvfs {\n    /// get the file system block size\n    pub fn block_size(\u0026self) -\u003e c_ulong {\n        self.0.f_bsize\n    }\n\n    /// Get the fundamental file system block size\n    pub fn fragment_size(\u0026self) -\u003e c_ulong {\n        self.0.f_frsize\n    }\n\n    /// Get the number of blocks.\n    ///\n    /// Units are in units of `fragment_size()`\n    pub fn blocks(\u0026self) -\u003e libc::fsblkcnt_t {\n        self.0.f_blocks\n    }\n\n    /// Get the number of free blocks in the file system\n    pub fn blocks_free(\u0026self) -\u003e libc::fsblkcnt_t {\n        self.0.f_bfree\n    }\n\n    /// Get the number of free blocks for unprivileged users\n    pub fn blocks_available(\u0026self) -\u003e libc::fsblkcnt_t {\n        self.0.f_bavail\n    }\n\n    /// Get the total number of file inodes\n    pub fn files(\u0026self) -\u003e libc::fsfilcnt_t {\n        self.0.f_files\n    }\n\n    /// Get the number of free file inodes\n    pub fn files_free(\u0026self) -\u003e libc::fsfilcnt_t {\n        self.0.f_ffree\n    }\n\n    /// Get the number of free file inodes for unprivileged users\n    pub fn files_available(\u0026self) -\u003e libc::fsfilcnt_t {\n        self.0.f_favail\n    }\n\n    /// Get the file system id\n    #[cfg(not(target_os = \"hurd\"))]\n    pub fn filesystem_id(\u0026self) -\u003e c_ulong {\n        self.0.f_fsid\n    }\n    /// Get the file system id\n    #[cfg(target_os = \"hurd\")]\n    pub fn filesystem_id(\u0026self) -\u003e u64 {\n        self.0.f_fsid\n    }\n\n    /// Get the mount flags\n    #[cfg(not(target_os = \"redox\"))]\n    pub fn flags(\u0026self) -\u003e FsFlags {\n        FsFlags::from_bits_truncate(self.0.f_flag)\n    }\n\n    /// Get the maximum filename length\n    pub fn name_max(\u0026self) -\u003e c_ulong {\n        self.0.f_namemax\n    }\n}\n\n/// Return a `Statvfs` object with information about the `path`\npub fn statvfs\u003cP: ?Sized + NixPath\u003e(path: \u0026P) -\u003e Result\u003cStatvfs\u003e {\n    unsafe {\n        Errno::clear();\n        let mut stat = mem::MaybeUninit::\u003clibc::statvfs\u003e::uninit();\n        let res = path.with_nix_path(|path| {\n            libc::statvfs(path.as_ptr(), stat.as_mut_ptr())\n        })?;\n\n        Errno::result(res).map(|_| Statvfs(stat.assume_init()))\n    }\n}\n\n/// Return a `Statvfs` object with information about `fd`\npub fn fstatvfs\u003cFd: AsFd\u003e(fd: Fd) -\u003e Result\u003cStatvfs\u003e {\n    unsafe {\n        Errno::clear();\n        let mut stat = mem::MaybeUninit::\u003clibc::statvfs\u003e::uninit();\n        Errno::result(libc::fstatvfs(fd.as_fd().as_raw_fd(), stat.as_mut_ptr()))\n            .map(|_| Statvfs(stat.assume_init()))\n    }\n}\n","traces":[{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","sysinfo.rs"],"content":"use libc::SI_LOAD_SHIFT;\nuse std::time::Duration;\nuse std::{cmp, mem};\n\nuse crate::errno::Errno;\nuse crate::Result;\n\n/// System info structure returned by `sysinfo`.\n#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]\n#[repr(transparent)]\npub struct SysInfo(libc::sysinfo);\n\n// The fields are c_ulong on 32-bit linux, u64 on 64-bit linux; x32's ulong is u32\n#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\ntype mem_blocks_t = u64;\n#[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\ntype mem_blocks_t = libc::c_ulong;\n\nimpl SysInfo {\n    /// Returns the load average tuple.\n    ///\n    /// The returned values represent the load average over time intervals of\n    /// 1, 5, and 15 minutes, respectively.\n    pub fn load_average(\u0026self) -\u003e (f64, f64, f64) {\n        (\n            self.0.loads[0] as f64 / (1 \u003c\u003c SI_LOAD_SHIFT) as f64,\n            self.0.loads[1] as f64 / (1 \u003c\u003c SI_LOAD_SHIFT) as f64,\n            self.0.loads[2] as f64 / (1 \u003c\u003c SI_LOAD_SHIFT) as f64,\n        )\n    }\n\n    /// Returns the time since system boot.\n    // The cast is not unnecessary on all platforms.\n    #[allow(clippy::unnecessary_cast)]\n    pub fn uptime(\u0026self) -\u003e Duration {\n        // Truncate negative values to 0\n        Duration::from_secs(cmp::max(self.0.uptime, 0) as u64)\n    }\n\n    /// Current number of processes.\n    pub fn process_count(\u0026self) -\u003e u16 {\n        self.0.procs\n    }\n\n    /// Returns the amount of swap memory in Bytes.\n    pub fn swap_total(\u0026self) -\u003e u64 {\n        self.scale_mem(self.0.totalswap)\n    }\n\n    /// Returns the amount of unused swap memory in Bytes.\n    pub fn swap_free(\u0026self) -\u003e u64 {\n        self.scale_mem(self.0.freeswap)\n    }\n\n    /// Returns the total amount of installed RAM in Bytes.\n    pub fn ram_total(\u0026self) -\u003e u64 {\n        self.scale_mem(self.0.totalram)\n    }\n\n    /// Returns the amount of completely unused RAM in Bytes.\n    ///\n    /// \"Unused\" in this context means that the RAM in neither actively used by\n    /// programs, nor by the operating system as disk cache or buffer. It is\n    /// \"wasted\" RAM since it currently serves no purpose.\n    pub fn ram_unused(\u0026self) -\u003e u64 {\n        self.scale_mem(self.0.freeram)\n    }\n\n    // The cast is not unnecessary on all platforms.\n    #[allow(clippy::unnecessary_cast)]\n    fn scale_mem(\u0026self, units: mem_blocks_t) -\u003e u64 {\n        units as u64 * self.0.mem_unit as u64\n    }\n}\n\n/// Returns system information.\n///\n/// [See `sysinfo(2)`](https://man7.org/linux/man-pages/man2/sysinfo.2.html).\npub fn sysinfo() -\u003e Result\u003cSysInfo\u003e {\n    let mut info = mem::MaybeUninit::uninit();\n    let res = unsafe { libc::sysinfo(info.as_mut_ptr()) };\n    Errno::result(res).map(|_| unsafe { SysInfo(info.assume_init()) })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","termios.rs"],"content":"//! An interface for controlling asynchronous communication ports\n//!\n//! This interface provides a safe wrapper around the termios subsystem defined by POSIX. The\n//! underlying types are all implemented in libc for most platforms and either wrapped in safer\n//! types here or exported directly.\n//!\n//! If you are unfamiliar with the `termios` API, you should first read the\n//! [API documentation](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/termios.h.html) and\n//! then come back to understand how `nix` safely wraps it.\n//!\n//! It should be noted that this API incurs some runtime overhead above the base `libc` definitions.\n//! As this interface is not used with high-bandwidth information, this should be fine in most\n//! cases. The primary cost when using this API is that the `Termios` datatype here duplicates the\n//! standard fields of the underlying `termios` struct and uses safe type wrappers for those fields.\n//! This means that when crossing the FFI interface to the underlying C library, data is first\n//! copied into the underlying `termios` struct, then the operation is done, and the data is copied\n//! back (with additional sanity checking) into the safe wrapper types. The `termios` struct is\n//! relatively small across all platforms (on the order of 32-64 bytes).\n//!\n//! The following examples highlight some of the API use cases such that users coming from using C\n//! or reading the standard documentation will understand how to use the safe API exposed here.\n//!\n//! Example disabling processing of the end-of-file control character:\n//!\n//! ```\n//! # use self::nix::sys::termios::SpecialCharacterIndices::VEOF;\n//! # use self::nix::sys::termios::{_POSIX_VDISABLE, Termios};\n//! # let mut termios: Termios = unsafe { std::mem::zeroed() };\n//! termios.control_chars[VEOF as usize] = _POSIX_VDISABLE;\n//! ```\n//!\n//! The flags within `Termios` are defined as bitfields using the `bitflags` crate. This provides\n//! an interface for working with bitfields that is similar to working with the raw unsigned\n//! integer types but offers type safety because of the internal checking that values will always\n//! be a valid combination of the defined flags.\n//!\n//! An example showing some of the basic operations for interacting with the control flags:\n//!\n//! ```\n//! # use self::nix::sys::termios::{ControlFlags, Termios};\n//! # let mut termios: Termios = unsafe { std::mem::zeroed() };\n//! termios.control_flags \u0026 ControlFlags::CSIZE == ControlFlags::CS5;\n//! termios.control_flags |= ControlFlags::CS5;\n//! ```\n//!\n//! # Baud rates\n//!\n//! This API is not consistent across platforms when it comes to `BaudRate`: Android and Linux both\n//! only support the rates specified by the `BaudRate` enum through their termios API while the BSDs\n//! support arbitrary baud rates as the values of the `BaudRate` enum constants are the same integer\n//! value of the constant (`B9600` == `9600`). Therefore the `nix::termios` API uses the following\n//! conventions:\n//!\n//! * `cfgetispeed()` - Returns `u32` on BSDs, `BaudRate` on Android/Linux\n//! * `cfgetospeed()` - Returns `u32` on BSDs, `BaudRate` on Android/Linux\n//! * `cfsetispeed()` - Takes `u32` or `BaudRate` on BSDs, `BaudRate` on Android/Linux\n//! * `cfsetospeed()` - Takes `u32` or `BaudRate` on BSDs, `BaudRate` on Android/Linux\n//! * `cfsetspeed()` - Takes `u32` or `BaudRate` on BSDs, `BaudRate` on Android/Linux\n//!\n//! The most common use case of specifying a baud rate using the enum will work the same across\n//! platforms:\n//!\n//! ```rust\n//! # use nix::sys::termios::{BaudRate, cfsetispeed, cfsetospeed, cfsetspeed, Termios};\n//! # fn main() {\n//! # let mut t: Termios = unsafe { std::mem::zeroed() };\n//! cfsetispeed(\u0026mut t, BaudRate::B9600).unwrap();\n//! cfsetospeed(\u0026mut t, BaudRate::B9600).unwrap();\n//! cfsetspeed(\u0026mut t, BaudRate::B9600).unwrap();\n//! # }\n//! ```\n//!\n//! Additionally round-tripping baud rates is consistent across platforms:\n//!\n//! ```rust\n//! # use nix::sys::termios::{BaudRate, cfgetispeed, cfgetospeed, cfsetispeed, cfsetspeed, Termios};\n//! # fn main() {\n//! # let mut t: Termios = unsafe { std::mem::zeroed() };\n//! # cfsetspeed(\u0026mut t, BaudRate::B9600).unwrap();\n//! let speed = cfgetispeed(\u0026t);\n//! assert_eq!(speed, cfgetospeed(\u0026t));\n//! cfsetispeed(\u0026mut t, speed).unwrap();\n//! # }\n//! ```\n//!\n//! On non-BSDs, `cfgetispeed()` and `cfgetospeed()` both return a `BaudRate`:\n//!\n#![cfg_attr(bsd, doc = \" ```rust,ignore\")]\n#![cfg_attr(not(bsd), doc = \" ```rust\")]\n//! # use nix::sys::termios::{BaudRate, cfgetispeed, cfgetospeed, cfsetspeed, Termios};\n//! # fn main() {\n//! # let mut t: Termios = unsafe { std::mem::zeroed() };\n//! # cfsetspeed(\u0026mut t, BaudRate::B9600);\n//! assert_eq!(cfgetispeed(\u0026t), BaudRate::B9600);\n//! assert_eq!(cfgetospeed(\u0026t), BaudRate::B9600);\n//! # }\n//! ```\n//!\n//! But on the BSDs, `cfgetispeed()` and `cfgetospeed()` both return `u32`s:\n//!\n#![cfg_attr(bsd, doc = \" ```rust\")]\n#![cfg_attr(not(bsd), doc = \" ```rust,ignore\")]\n//! # use nix::sys::termios::{BaudRate, cfgetispeed, cfgetospeed, cfsetspeed, Termios};\n//! # fn main() {\n//! # let mut t: Termios = unsafe { std::mem::zeroed() };\n//! # cfsetspeed(\u0026mut t, 9600u32);\n//! assert_eq!(cfgetispeed(\u0026t), 9600u32);\n//! assert_eq!(cfgetospeed(\u0026t), 9600u32);\n//! # }\n//! ```\n//!\n//! It's trivial to convert from a `BaudRate` to a `u32` on BSDs:\n//!\n#![cfg_attr(bsd, doc = \" ```rust\")]\n#![cfg_attr(not(bsd), doc = \" ```rust,ignore\")]\n//! # use nix::sys::termios::{BaudRate, cfgetispeed, cfsetspeed, Termios};\n//! # fn main() {\n//! # let mut t: Termios = unsafe { std::mem::zeroed() };\n//! # cfsetspeed(\u0026mut t, 9600u32);\n//! assert_eq!(cfgetispeed(\u0026t), BaudRate::B9600.into());\n//! assert_eq!(u32::from(BaudRate::B9600), 9600u32);\n//! # }\n//! ```\n//!\n//! And on BSDs you can specify arbitrary baud rates (**note** this depends on hardware support)\n//! by specifying baud rates directly using `u32`s:\n//!\n#![cfg_attr(bsd, doc = \" ```rust\")]\n#![cfg_attr(not(bsd), doc = \" ```rust,ignore\")]\n//! # use nix::sys::termios::{cfsetispeed, cfsetospeed, cfsetspeed, Termios};\n//! # fn main() {\n//! # let mut t: Termios = unsafe { std::mem::zeroed() };\n//! cfsetispeed(\u0026mut t, 9600u32);\n//! cfsetospeed(\u0026mut t, 9600u32);\n//! cfsetspeed(\u0026mut t, 9600u32);\n//! # }\n//! ```\nuse crate::errno::Errno;\nuse crate::Result;\nuse cfg_if::cfg_if;\nuse libc::{self, c_int, tcflag_t};\nuse std::cell::{Ref, RefCell};\nuse std::convert::From;\nuse std::mem;\nuse std::os::unix::io::{AsFd, AsRawFd};\n\n#[cfg(feature = \"process\")]\nuse crate::unistd::Pid;\n\n/// Stores settings for the termios API\n///\n/// This is a wrapper around the `libc::termios` struct that provides a safe interface for the\n/// standard fields. The only safe way to obtain an instance of this struct is to extract it from\n/// an open port using `tcgetattr()`.\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Termios {\n    inner: RefCell\u003clibc::termios\u003e,\n    /// Input mode flags (see `termios.c_iflag` documentation)\n    pub input_flags: InputFlags,\n    /// Output mode flags (see `termios.c_oflag` documentation)\n    pub output_flags: OutputFlags,\n    /// Control mode flags (see `termios.c_cflag` documentation)\n    pub control_flags: ControlFlags,\n    /// Local mode flags (see `termios.c_lflag` documentation)\n    pub local_flags: LocalFlags,\n    /// Control characters (see `termios.c_cc` documentation)\n    pub control_chars: [libc::cc_t; NCCS],\n    /// Line discipline (see `termios.c_line` documentation)\n    #[cfg(linux_android)]\n    pub line_discipline: libc::cc_t,\n    /// Line discipline (see `termios.c_line` documentation)\n    #[cfg(target_os = \"haiku\")]\n    pub line_discipline: libc::c_char,\n}\n\nimpl Termios {\n    /// Exposes an immutable reference to the underlying `libc::termios` data structure.\n    ///\n    /// This is not part of `nix`'s public API because it requires additional work to maintain type\n    /// safety.\n    pub(crate) fn get_libc_termios(\u0026self) -\u003e Ref\u003clibc::termios\u003e {\n        {\n            let mut termios = self.inner.borrow_mut();\n            termios.c_iflag = self.input_flags.bits();\n            termios.c_oflag = self.output_flags.bits();\n            termios.c_cflag = self.control_flags.bits();\n            termios.c_lflag = self.local_flags.bits();\n            termios.c_cc = self.control_chars;\n            #[cfg(any(linux_android, target_os = \"haiku\"))]\n            {\n                termios.c_line = self.line_discipline;\n            }\n        }\n        self.inner.borrow()\n    }\n\n    /// Exposes the inner `libc::termios` datastore within `Termios`.\n    ///\n    /// This is unsafe because if this is used to modify the inner `libc::termios` struct, it will\n    /// not automatically update the safe wrapper type around it. In this case it should also be\n    /// paired with a call to `update_wrapper()` so that the wrapper-type and internal\n    /// representation stay consistent.\n    pub(crate) unsafe fn get_libc_termios_mut(\u0026mut self) -\u003e *mut libc::termios {\n        {\n            let mut termios = self.inner.borrow_mut();\n            termios.c_iflag = self.input_flags.bits();\n            termios.c_oflag = self.output_flags.bits();\n            termios.c_cflag = self.control_flags.bits();\n            termios.c_lflag = self.local_flags.bits();\n            termios.c_cc = self.control_chars;\n            #[cfg(any(linux_android, target_os = \"haiku\"))]\n            {\n                termios.c_line = self.line_discipline;\n            }\n        }\n        self.inner.as_ptr()\n    }\n\n    /// Updates the wrapper values from the internal `libc::termios` data structure.\n    pub(crate) fn update_wrapper(\u0026mut self) {\n        let termios = *self.inner.borrow_mut();\n        self.input_flags = InputFlags::from_bits_truncate(termios.c_iflag);\n        self.output_flags = OutputFlags::from_bits_truncate(termios.c_oflag);\n        self.control_flags = ControlFlags::from_bits_retain(termios.c_cflag);\n        self.local_flags = LocalFlags::from_bits_truncate(termios.c_lflag);\n        self.control_chars = termios.c_cc;\n        #[cfg(any(linux_android, target_os = \"haiku\"))]\n        {\n            self.line_discipline = termios.c_line;\n        }\n    }\n}\n\nimpl From\u003clibc::termios\u003e for Termios {\n    fn from(termios: libc::termios) -\u003e Self {\n        Termios {\n            inner: RefCell::new(termios),\n            input_flags: InputFlags::from_bits_truncate(termios.c_iflag),\n            output_flags: OutputFlags::from_bits_truncate(termios.c_oflag),\n            control_flags: ControlFlags::from_bits_truncate(termios.c_cflag),\n            local_flags: LocalFlags::from_bits_truncate(termios.c_lflag),\n            control_chars: termios.c_cc,\n            #[cfg(any(linux_android, target_os = \"haiku\"))]\n            line_discipline: termios.c_line,\n        }\n    }\n}\n\nimpl From\u003cTermios\u003e for libc::termios {\n    fn from(termios: Termios) -\u003e Self {\n        termios.inner.into_inner()\n    }\n}\n\nlibc_enum! {\n    /// Baud rates supported by the system.\n    ///\n    /// For the BSDs, arbitrary baud rates can be specified by using `u32`s directly instead of this\n    /// enum.\n    ///\n    /// B0 is special and will disable the port.\n    #[cfg_attr(target_os = \"haiku\", repr(u8))]\n    #[cfg_attr(target_os = \"hurd\", repr(i32))]\n    #[cfg_attr(all(apple_targets, target_pointer_width = \"64\"), repr(u64))]\n    #[cfg_attr(all(\n        not(all(apple_targets, target_pointer_width = \"64\")),\n        not(target_os = \"haiku\"),\n        not(target_os = \"hurd\")\n        ), repr(u32))]\n    #[non_exhaustive]\n    pub enum BaudRate {\n        B0,\n        B50,\n        B75,\n        B110,\n        B134,\n        B150,\n        B200,\n        B300,\n        B600,\n        B1200,\n        B1800,\n        B2400,\n        B4800,\n        #[cfg(bsd)]\n        B7200,\n        B9600,\n        #[cfg(bsd)]\n        B14400,\n        B19200,\n        #[cfg(bsd)]\n        B28800,\n        B38400,\n        #[cfg(not(target_os = \"aix\"))]\n        B57600,\n        #[cfg(bsd)]\n        B76800,\n        #[cfg(not(target_os = \"aix\"))]\n        B115200,\n        #[cfg(solarish)]\n        B153600,\n        #[cfg(not(target_os = \"aix\"))]\n        B230400,\n        #[cfg(solarish)]\n        B307200,\n        #[cfg(any(linux_android,\n                  solarish,\n                  target_os = \"freebsd\",\n                  target_os = \"netbsd\"))]\n        B460800,\n        #[cfg(linux_android)]\n        B500000,\n        #[cfg(linux_android)]\n        B576000,\n        #[cfg(any(linux_android,\n                  solarish,\n                  target_os = \"freebsd\",\n                  target_os = \"netbsd\"))]\n        B921600,\n        #[cfg(linux_android)]\n        B1000000,\n        #[cfg(linux_android)]\n        B1152000,\n        #[cfg(linux_android)]\n        B1500000,\n        #[cfg(linux_android)]\n        B2000000,\n        #[cfg(any(target_os = \"android\", all(target_os = \"linux\", not(target_arch = \"sparc64\"))))]\n        B2500000,\n        #[cfg(any(target_os = \"android\", all(target_os = \"linux\", not(target_arch = \"sparc64\"))))]\n        B3000000,\n        #[cfg(any(target_os = \"android\", all(target_os = \"linux\", not(target_arch = \"sparc64\"))))]\n        B3500000,\n        #[cfg(any(target_os = \"android\", all(target_os = \"linux\", not(target_arch = \"sparc64\"))))]\n        B4000000,\n    }\n    impl TryFrom\u003clibc::speed_t\u003e\n}\n\n#[cfg(bsd)]\nimpl From\u003cBaudRate\u003e for u32 {\n    fn from(b: BaudRate) -\u003e u32 {\n        b as u32\n    }\n}\n\n#[cfg(target_os = \"haiku\")]\nimpl From\u003cBaudRate\u003e for u8 {\n    fn from(b: BaudRate) -\u003e u8 {\n        b as u8\n    }\n}\n\n// TODO: Add TCSASOFT, which will require treating this as a bitfield.\nlibc_enum! {\n    /// Specify when a port configuration change should occur.\n    ///\n    /// Used as an argument to `tcsetattr()`\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum SetArg {\n        /// The change will occur immediately\n        TCSANOW,\n        /// The change occurs after all output has been written\n        TCSADRAIN,\n        /// Same as `TCSADRAIN`, but will also flush the input buffer\n        TCSAFLUSH,\n    }\n}\n\nlibc_enum! {\n    /// Specify a combination of the input and output buffers to flush\n    ///\n    /// Used as an argument to `tcflush()`.\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum FlushArg {\n        /// Flush data that was received but not read\n        TCIFLUSH,\n        /// Flush data written but not transmitted\n        TCOFLUSH,\n        /// Flush both received data not read and written data not transmitted\n        TCIOFLUSH,\n    }\n}\n\nlibc_enum! {\n    /// Specify how transmission flow should be altered\n    ///\n    /// Used as an argument to `tcflow()`.\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum FlowArg {\n        /// Suspend transmission\n        TCOOFF,\n        /// Resume transmission\n        TCOON,\n        /// Transmit a STOP character, which should disable a connected terminal device\n        TCIOFF,\n        /// Transmit a START character, which should re-enable a connected terminal device\n        TCION,\n    }\n}\n\n// TODO: Make this usable directly as a slice index.\nlibc_enum! {\n    /// Indices into the `termios.c_cc` array for special characters.\n    #[repr(usize)]\n    #[non_exhaustive]\n    pub enum SpecialCharacterIndices {\n        #[cfg(not(any(target_os = \"aix\", target_os = \"haiku\")))]\n        VDISCARD,\n        #[cfg(any(bsd,\n                solarish,\n                target_os = \"aix\"))]\n        VDSUSP,\n        VEOF,\n        VEOL,\n        VEOL2,\n        VERASE,\n        #[cfg(any(freebsdlike, target_os = \"illumos\"))]\n        VERASE2,\n        VINTR,\n        VKILL,\n        #[cfg(not(target_os = \"haiku\"))]\n        VLNEXT,\n        #[cfg(not(any(all(target_os = \"linux\", target_arch = \"sparc64\"),\n                solarish, target_os = \"aix\", target_os = \"haiku\")))]\n        VMIN,\n        VQUIT,\n        #[cfg(not(target_os = \"haiku\"))]\n        VREPRINT,\n        VSTART,\n        #[cfg(any(bsd, target_os = \"illumos\"))]\n        VSTATUS,\n        VSTOP,\n        VSUSP,\n        #[cfg(target_os = \"linux\")]\n        VSWTC,\n        #[cfg(any(solarish, target_os = \"haiku\"))]\n        VSWTCH,\n        #[cfg(not(any(all(target_os = \"linux\", target_arch = \"sparc64\"),\n                solarish, target_os = \"aix\", target_os = \"haiku\")))]\n        VTIME,\n        #[cfg(not(any(target_os = \"aix\", target_os = \"haiku\")))]\n        VWERASE,\n        #[cfg(target_os = \"dragonfly\")]\n        VCHECKPT,\n    }\n}\n\n#[cfg(any(\n    all(target_os = \"linux\", target_arch = \"sparc64\"),\n    solarish,\n    target_os = \"aix\",\n    target_os = \"haiku\",\n))]\nimpl SpecialCharacterIndices {\n    pub const VMIN: SpecialCharacterIndices = SpecialCharacterIndices::VEOF;\n    pub const VTIME: SpecialCharacterIndices = SpecialCharacterIndices::VEOL;\n}\n\npub use libc::NCCS;\n#[cfg(any(bsd, linux_android, target_os = \"aix\", target_os = \"solaris\"))]\npub use libc::_POSIX_VDISABLE;\n\nlibc_bitflags! {\n    /// Flags for configuring the input mode of a terminal\n    pub struct InputFlags: tcflag_t {\n        IGNBRK;\n        BRKINT;\n        IGNPAR;\n        PARMRK;\n        INPCK;\n        ISTRIP;\n        INLCR;\n        IGNCR;\n        ICRNL;\n        IXON;\n        IXOFF;\n        #[cfg(not(target_os = \"redox\"))]\n        IXANY;\n        #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n        IMAXBEL;\n        #[cfg(any(linux_android, apple_targets))]\n        IUTF8;\n    }\n}\n\nlibc_bitflags! {\n    /// Flags for configuring the output mode of a terminal\n    pub struct OutputFlags: tcflag_t {\n        OPOST;\n        #[cfg(any(linux_android,\n                  target_os = \"haiku\",\n                  target_os = \"openbsd\"))]\n        OLCUC;\n        ONLCR;\n        OCRNL as tcflag_t;\n        ONOCR as tcflag_t;\n        ONLRET as tcflag_t;\n        #[cfg(any(linux_android,\n                  target_os = \"haiku\",\n                  apple_targets))]\n        OFDEL as tcflag_t;\n        #[cfg(any(linux_android,\n                  target_os = \"haiku\",\n                  apple_targets))]\n        NL0 as tcflag_t;\n        #[cfg(any(linux_android,\n                  target_os = \"haiku\",\n                  apple_targets))]\n        NL1 as tcflag_t;\n        #[cfg(any(linux_android,\n                  target_os = \"haiku\",\n                  apple_targets))]\n        CR0 as tcflag_t;\n        #[cfg(any(linux_android,\n                  target_os = \"haiku\",\n                  apple_targets))]\n        CR1 as tcflag_t;\n        #[cfg(any(linux_android,\n                  target_os = \"haiku\",\n                  apple_targets))]\n        CR2 as tcflag_t;\n        #[cfg(any(linux_android,\n                  target_os = \"haiku\",\n                  apple_targets))]\n        CR3 as tcflag_t;\n        #[cfg(any(linux_android,\n                  target_os = \"freebsd\",\n                  target_os = \"haiku\",\n                  apple_targets))]\n        TAB0 as tcflag_t;\n        #[cfg(any(linux_android,\n                  target_os = \"haiku\",\n                  apple_targets))]\n        TAB1 as tcflag_t;\n        #[cfg(any(linux_android,\n                  target_os = \"haiku\",\n                  apple_targets))]\n        TAB2 as tcflag_t;\n        #[cfg(any(linux_android,\n                  target_os = \"freebsd\",\n                  target_os = \"haiku\",\n                  apple_targets))]\n        TAB3 as tcflag_t;\n        #[cfg(linux_android)]\n        XTABS;\n        #[cfg(any(linux_android,\n                  target_os = \"haiku\",\n                  apple_targets))]\n        BS0 as tcflag_t;\n        #[cfg(any(linux_android,\n                  target_os = \"haiku\",\n                  apple_targets))]\n        BS1 as tcflag_t;\n        #[cfg(any(linux_android,\n                  target_os = \"haiku\",\n                  apple_targets))]\n        VT0 as tcflag_t;\n        #[cfg(any(linux_android,\n                  target_os = \"haiku\",\n                  apple_targets))]\n        VT1 as tcflag_t;\n        #[cfg(any(linux_android,\n                  target_os = \"haiku\",\n                  apple_targets))]\n        FF0 as tcflag_t;\n        #[cfg(any(linux_android,\n                  target_os = \"haiku\",\n                  apple_targets))]\n        FF1 as tcflag_t;\n        #[cfg(bsd)]\n        OXTABS;\n        #[cfg(bsd)]\n        ONOEOT as tcflag_t;\n\n        // Bitmasks for use with OutputFlags to select specific settings\n        // These should be moved to be a mask once https://github.com/rust-lang-nursery/bitflags/issues/110\n        // is resolved.\n\n        #[cfg(any(linux_android,\n                  target_os = \"haiku\",\n                  apple_targets))]\n        NLDLY as tcflag_t; // FIXME: Datatype needs to be corrected in libc for mac\n        #[cfg(any(linux_android,\n                  target_os = \"haiku\",\n                  apple_targets))]\n        CRDLY as tcflag_t;\n        #[cfg(any(linux_android,\n                  target_os = \"freebsd\",\n                  target_os = \"haiku\",\n                  apple_targets))]\n        TABDLY as tcflag_t;\n        #[cfg(any(linux_android,\n                  target_os = \"haiku\",\n                  apple_targets))]\n        BSDLY as tcflag_t;\n        #[cfg(any(linux_android,\n                  target_os = \"haiku\",\n                  apple_targets))]\n        VTDLY as tcflag_t;\n        #[cfg(any(linux_android,\n                  target_os = \"haiku\",\n                  apple_targets))]\n        FFDLY as tcflag_t;\n    }\n}\n\nlibc_bitflags! {\n    /// Flags for setting the control mode of a terminal\n    pub struct ControlFlags: tcflag_t {\n        #[cfg(bsd)]\n        CIGNORE;\n        CS5;\n        CS6;\n        CS7;\n        CS8;\n        CSTOPB;\n        CREAD;\n        PARENB;\n        PARODD;\n        HUPCL;\n        CLOCAL;\n        #[cfg(not(any(target_os = \"redox\", target_os = \"aix\")))]\n        CRTSCTS;\n        #[cfg(linux_android)]\n        CBAUD;\n        #[cfg(any(target_os = \"android\", all(target_os = \"linux\", not(target_arch = \"mips\"))))]\n        CMSPAR;\n        #[cfg(any(target_os = \"android\",\n                  all(target_os = \"linux\",\n                      not(any(target_arch = \"powerpc\", target_arch = \"powerpc64\")))))]\n        CIBAUD;\n        #[cfg(linux_android)]\n        CBAUDEX;\n        #[cfg(bsd)]\n        MDMBUF;\n        #[cfg(netbsdlike)]\n        CHWFLOW;\n        #[cfg(any(freebsdlike, netbsdlike))]\n        CCTS_OFLOW;\n        #[cfg(any(freebsdlike, netbsdlike))]\n        CRTS_IFLOW;\n        #[cfg(freebsdlike)]\n        CDTR_IFLOW;\n        #[cfg(freebsdlike)]\n        CDSR_OFLOW;\n        #[cfg(freebsdlike)]\n        CCAR_OFLOW;\n\n        // Bitmasks for use with ControlFlags to select specific settings\n        // These should be moved to be a mask once https://github.com/rust-lang-nursery/bitflags/issues/110\n        // is resolved.\n\n        CSIZE;\n    }\n}\n\nlibc_bitflags! {\n    /// Flags for setting any local modes\n    pub struct LocalFlags: tcflag_t {\n        #[cfg(not(target_os = \"redox\"))]\n        ECHOKE;\n        ECHOE;\n        ECHOK;\n        ECHO;\n        ECHONL;\n        #[cfg(not(any(target_os = \"redox\", target_os = \"cygwin\")))]\n        ECHOPRT;\n        #[cfg(not(target_os = \"redox\"))]\n        ECHOCTL;\n        ISIG;\n        ICANON;\n        #[cfg(bsd)]\n        ALTWERASE;\n        IEXTEN;\n        #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\", target_os = \"aix\", target_os = \"cygwin\")))]\n        EXTPROC;\n        TOSTOP;\n        #[cfg(not(target_os = \"redox\"))]\n        FLUSHO;\n        #[cfg(bsd)]\n        NOKERNINFO;\n        #[cfg(not(any(target_os = \"redox\", target_os = \"cygwin\")))]\n        PENDIN;\n        NOFLSH;\n    }\n}\n\ncfg_if! {\n    if #[cfg(bsd)] {\n        /// Get input baud rate (see\n        /// [cfgetispeed(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/cfgetispeed.html)).\n        ///\n        /// `cfgetispeed()` extracts the input baud rate from the given `Termios` structure.\n        // The cast is not unnecessary on all platforms.\n        #[allow(clippy::unnecessary_cast)]\n        pub fn cfgetispeed(termios: \u0026Termios) -\u003e u32 {\n            let inner_termios = termios.get_libc_termios();\n            unsafe { libc::cfgetispeed(\u0026*inner_termios) as u32 }\n        }\n\n        /// Get output baud rate (see\n        /// [cfgetospeed(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/cfgetospeed.html)).\n        ///\n        /// `cfgetospeed()` extracts the output baud rate from the given `Termios` structure.\n        // The cast is not unnecessary on all platforms.\n        #[allow(clippy::unnecessary_cast)]\n        pub fn cfgetospeed(termios: \u0026Termios) -\u003e u32 {\n            let inner_termios = termios.get_libc_termios();\n            unsafe { libc::cfgetospeed(\u0026*inner_termios) as u32 }\n        }\n\n        /// Set input baud rate (see\n        /// [cfsetispeed(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/cfsetispeed.html)).\n        ///\n        /// `cfsetispeed()` sets the intput baud rate in the given `Termios` structure.\n        pub fn cfsetispeed\u003cT: Into\u003cu32\u003e\u003e(termios: \u0026mut Termios, baud: T) -\u003e Result\u003c()\u003e {\n            let inner_termios = unsafe { termios.get_libc_termios_mut() };\n            let res = unsafe { libc::cfsetispeed(inner_termios, baud.into() as libc::speed_t) };\n            termios.update_wrapper();\n            Errno::result(res).map(drop)\n        }\n\n        /// Set output baud rate (see\n        /// [cfsetospeed(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/cfsetospeed.html)).\n        ///\n        /// `cfsetospeed()` sets the output baud rate in the given termios structure.\n        pub fn cfsetospeed\u003cT: Into\u003cu32\u003e\u003e(termios: \u0026mut Termios, baud: T) -\u003e Result\u003c()\u003e {\n            let inner_termios = unsafe { termios.get_libc_termios_mut() };\n            let res = unsafe { libc::cfsetospeed(inner_termios, baud.into() as libc::speed_t) };\n            termios.update_wrapper();\n            Errno::result(res).map(drop)\n        }\n\n        /// Set both the input and output baud rates (see\n        /// [termios(3)](https://www.freebsd.org/cgi/man.cgi?query=cfsetspeed)).\n        ///\n        /// `cfsetspeed()` sets the input and output baud rate in the given termios structure. Note that\n        /// this is part of the 4.4BSD standard and not part of POSIX.\n        pub fn cfsetspeed\u003cT: Into\u003cu32\u003e\u003e(termios: \u0026mut Termios, baud: T) -\u003e Result\u003c()\u003e {\n            let inner_termios = unsafe { termios.get_libc_termios_mut() };\n            let res = unsafe { libc::cfsetspeed(inner_termios, baud.into() as libc::speed_t) };\n            termios.update_wrapper();\n            Errno::result(res).map(drop)\n        }\n    } else {\n        use std::convert::TryInto;\n\n        /// Get input baud rate (see\n        /// [cfgetispeed(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/cfgetispeed.html)).\n        ///\n        /// `cfgetispeed()` extracts the input baud rate from the given `Termios` structure.\n        pub fn cfgetispeed(termios: \u0026Termios) -\u003e BaudRate {\n            let inner_termios = termios.get_libc_termios();\n            unsafe { libc::cfgetispeed(\u0026*inner_termios) }.try_into().unwrap()\n        }\n\n        /// Get output baud rate (see\n        /// [cfgetospeed(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/cfgetospeed.html)).\n        ///\n        /// `cfgetospeed()` extracts the output baud rate from the given `Termios` structure.\n        pub fn cfgetospeed(termios: \u0026Termios) -\u003e BaudRate {\n            let inner_termios = termios.get_libc_termios();\n            unsafe { libc::cfgetospeed(\u0026*inner_termios) }.try_into().unwrap()\n        }\n\n        /// Set input baud rate (see\n        /// [cfsetispeed(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/cfsetispeed.html)).\n        ///\n        /// `cfsetispeed()` sets the intput baud rate in the given `Termios` structure.\n        pub fn cfsetispeed(termios: \u0026mut Termios, baud: BaudRate) -\u003e Result\u003c()\u003e {\n            let inner_termios = unsafe { termios.get_libc_termios_mut() };\n            let res = unsafe { libc::cfsetispeed(inner_termios, baud as libc::speed_t) };\n            termios.update_wrapper();\n            Errno::result(res).map(drop)\n        }\n\n        /// Set output baud rate (see\n        /// [cfsetospeed(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/cfsetospeed.html)).\n        ///\n        /// `cfsetospeed()` sets the output baud rate in the given `Termios` structure.\n        pub fn cfsetospeed(termios: \u0026mut Termios, baud: BaudRate) -\u003e Result\u003c()\u003e {\n            let inner_termios = unsafe { termios.get_libc_termios_mut() };\n            let res = unsafe { libc::cfsetospeed(inner_termios, baud as libc::speed_t) };\n            termios.update_wrapper();\n            Errno::result(res).map(drop)\n        }\n\n        /// Set both the input and output baud rates (see\n        /// [termios(3)](https://www.freebsd.org/cgi/man.cgi?query=cfsetspeed)).\n        ///\n        /// `cfsetspeed()` sets the input and output baud rate in the given `Termios` structure. Note that\n        /// this is part of the 4.4BSD standard and not part of POSIX.\n        #[cfg(not(target_os = \"haiku\"))]\n        pub fn cfsetspeed(termios: \u0026mut Termios, baud: BaudRate) -\u003e Result\u003c()\u003e {\n            let inner_termios = unsafe { termios.get_libc_termios_mut() };\n            let res = unsafe { libc::cfsetspeed(inner_termios, baud as libc::speed_t) };\n            termios.update_wrapper();\n            Errno::result(res).map(drop)\n        }\n    }\n}\n\n/// Configures the port to something like the \"raw\" mode of the old Version 7 terminal driver (see\n/// [termios(3)](https://man7.org/linux/man-pages/man3/termios.3.html)).\n///\n/// `cfmakeraw()` configures the termios structure such that input is available character-by-\n/// character, echoing is disabled, and all special input and output processing is disabled. Note\n/// that this is a non-standard function, but is available on Linux and BSDs.\npub fn cfmakeraw(termios: \u0026mut Termios) {\n    let inner_termios = unsafe { termios.get_libc_termios_mut() };\n    unsafe {\n        libc::cfmakeraw(inner_termios);\n    }\n    termios.update_wrapper();\n}\n\n/// Configures the port to \"sane\" mode (like the configuration of a newly created terminal) (see\n/// [tcsetattr(3)](https://www.freebsd.org/cgi/man.cgi?query=tcsetattr)).\n///\n/// Note that this is a non-standard function, available on FreeBSD.\n#[cfg(target_os = \"freebsd\")]\npub fn cfmakesane(termios: \u0026mut Termios) {\n    let inner_termios = unsafe { termios.get_libc_termios_mut() };\n    unsafe {\n        libc::cfmakesane(inner_termios);\n    }\n    termios.update_wrapper();\n}\n\n/// Return the configuration of a port\n/// [tcgetattr(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tcgetattr.html)).\n///\n/// `tcgetattr()` returns a `Termios` structure with the current configuration for a port. Modifying\n/// this structure *will not* reconfigure the port, instead the modifications should be done to\n/// the `Termios` structure and then the port should be reconfigured using `tcsetattr()`.\npub fn tcgetattr\u003cFd: AsFd\u003e(fd: Fd) -\u003e Result\u003cTermios\u003e {\n    let mut termios = mem::MaybeUninit::uninit();\n\n    let res = unsafe {\n        libc::tcgetattr(fd.as_fd().as_raw_fd(), termios.as_mut_ptr())\n    };\n\n    Errno::result(res)?;\n\n    unsafe { Ok(termios.assume_init().into()) }\n}\n\n/// Set the configuration for a terminal (see\n/// [tcsetattr(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tcsetattr.html)).\n///\n/// `tcsetattr()` reconfigures the given port based on a given `Termios` structure. This change\n/// takes affect at a time specified by `actions`. Note that this function may return success if\n/// *any* of the parameters were successfully set, not only if all were set successfully.\npub fn tcsetattr\u003cFd: AsFd\u003e(\n    fd: Fd,\n    actions: SetArg,\n    termios: \u0026Termios,\n) -\u003e Result\u003c()\u003e {\n    let inner_termios = termios.get_libc_termios();\n    Errno::result(unsafe {\n        libc::tcsetattr(\n            fd.as_fd().as_raw_fd(),\n            actions as c_int,\n            \u0026*inner_termios,\n        )\n    })\n    .map(drop)\n}\n\n/// Block until all output data is written (see\n/// [tcdrain(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tcdrain.html)).\npub fn tcdrain\u003cFd: AsFd\u003e(fd: Fd) -\u003e Result\u003c()\u003e {\n    Errno::result(unsafe { libc::tcdrain(fd.as_fd().as_raw_fd()) }).map(drop)\n}\n\n/// Suspend or resume the transmission or reception of data (see\n/// [tcflow(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tcflow.html)).\n///\n/// `tcflow()` suspends of resumes the transmission or reception of data for the given port\n/// depending on the value of `action`.\npub fn tcflow\u003cFd: AsFd\u003e(fd: Fd, action: FlowArg) -\u003e Result\u003c()\u003e {\n    Errno::result(unsafe {\n        libc::tcflow(fd.as_fd().as_raw_fd(), action as c_int)\n    })\n    .map(drop)\n}\n\n/// Discard data in the output or input queue (see\n/// [tcflush(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tcflush.html)).\n///\n/// `tcflush()` will discard data for a terminal port in the input queue, output queue, or both\n/// depending on the value of `action`.\npub fn tcflush\u003cFd: AsFd\u003e(fd: Fd, action: FlushArg) -\u003e Result\u003c()\u003e {\n    Errno::result(unsafe {\n        libc::tcflush(fd.as_fd().as_raw_fd(), action as c_int)\n    })\n    .map(drop)\n}\n\n/// Send a break for a specific duration (see\n/// [tcsendbreak(3p)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tcsendbreak.html)).\n///\n/// When using asynchronous data transmission `tcsendbreak()` will transmit a continuous stream\n/// of zero-valued bits for an implementation-defined duration.\npub fn tcsendbreak\u003cFd: AsFd\u003e(fd: Fd, duration: c_int) -\u003e Result\u003c()\u003e {\n    Errno::result(unsafe {\n        libc::tcsendbreak(fd.as_fd().as_raw_fd(), duration)\n    })\n    .map(drop)\n}\n\nfeature! {\n#![feature = \"process\"]\n/// Get the session controlled by the given terminal (see\n/// [tcgetsid(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tcgetsid.html)).\npub fn tcgetsid\u003cFd: AsFd\u003e(fd: Fd) -\u003e Result\u003cPid\u003e {\n    let res = unsafe { libc::tcgetsid(fd.as_fd().as_raw_fd()) };\n\n    Errno::result(res).map(Pid::from_raw)\n}\n}\n","traces":[{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":866,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":876,"address":[],"length":0,"stats":{"Line":0}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":885,"address":[],"length":0,"stats":{"Line":0}},{"line":886,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":910,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":26},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","time.rs"],"content":"#[cfg_attr(\n    any(target_env = \"musl\", target_env = \"ohos\"),\n    allow(deprecated)\n)]\n// https://github.com/rust-lang/libc/issues/1848\npub use libc::{suseconds_t, time_t};\nuse libc::{timespec, timeval};\nuse std::time::Duration;\nuse std::{cmp, fmt, ops};\n\nconst fn zero_init_timespec() -\u003e timespec {\n    // `std::mem::MaybeUninit::zeroed()` is not yet a const fn\n    // (https://github.com/rust-lang/rust/issues/91850) so we will instead initialize an array of\n    // the appropriate size to zero and then transmute it to a timespec value.\n    unsafe { std::mem::transmute([0u8; std::mem::size_of::\u003ctimespec\u003e()]) }\n}\n\n#[cfg(any(\n    all(feature = \"time\", any(target_os = \"android\", target_os = \"linux\")),\n    all(\n        any(\n            target_os = \"freebsd\",\n            solarish,\n            target_os = \"linux\",\n            target_os = \"netbsd\"\n        ),\n        feature = \"time\",\n        feature = \"signal\"\n    )\n))]\npub(crate) mod timer {\n    use crate::sys::time::{zero_init_timespec, TimeSpec};\n    use bitflags::bitflags;\n\n    #[derive(Debug, Clone, Copy)]\n    pub(crate) struct TimerSpec(libc::itimerspec);\n\n    impl TimerSpec {\n        pub const fn none() -\u003e Self {\n            Self(libc::itimerspec {\n                it_interval: zero_init_timespec(),\n                it_value: zero_init_timespec(),\n            })\n        }\n    }\n\n    impl AsMut\u003clibc::itimerspec\u003e for TimerSpec {\n        fn as_mut(\u0026mut self) -\u003e \u0026mut libc::itimerspec {\n            \u0026mut self.0\n        }\n    }\n\n    impl AsRef\u003clibc::itimerspec\u003e for TimerSpec {\n        fn as_ref(\u0026self) -\u003e \u0026libc::itimerspec {\n            \u0026self.0\n        }\n    }\n\n    impl From\u003cExpiration\u003e for TimerSpec {\n        fn from(expiration: Expiration) -\u003e TimerSpec {\n            match expiration {\n                Expiration::OneShot(t) =\u003e TimerSpec(libc::itimerspec {\n                    it_interval: zero_init_timespec(),\n                    it_value: *t.as_ref(),\n                }),\n                Expiration::IntervalDelayed(start, interval) =\u003e {\n                    TimerSpec(libc::itimerspec {\n                        it_interval: *interval.as_ref(),\n                        it_value: *start.as_ref(),\n                    })\n                }\n                Expiration::Interval(t) =\u003e TimerSpec(libc::itimerspec {\n                    it_interval: *t.as_ref(),\n                    it_value: *t.as_ref(),\n                }),\n            }\n        }\n    }\n\n    /// An enumeration allowing the definition of the expiration time of an alarm,\n    /// recurring or not.\n    #[derive(Debug, Clone, Copy, Eq, PartialEq)]\n    pub enum Expiration {\n        /// Alarm will trigger once after the time given in `TimeSpec`\n        OneShot(TimeSpec),\n        /// Alarm will trigger after a specified delay and then every interval of\n        /// time.\n        IntervalDelayed(TimeSpec, TimeSpec),\n        /// Alarm will trigger every specified interval of time.\n        Interval(TimeSpec),\n    }\n\n    #[cfg(linux_android)]\n    bitflags! {\n        /// Flags that are used for arming the timer.\n        #[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n        pub struct TimerSetTimeFlags: libc::c_int {\n            const TFD_TIMER_ABSTIME = libc::TFD_TIMER_ABSTIME;\n            const TFD_TIMER_CANCEL_ON_SET = libc::TFD_TIMER_CANCEL_ON_SET;\n        }\n    }\n    #[cfg(any(freebsdlike, target_os = \"netbsd\", solarish))]\n    bitflags! {\n        /// Flags that are used for arming the timer.\n        #[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n        pub struct TimerSetTimeFlags: libc::c_int {\n            const TFD_TIMER_ABSTIME = libc::TIMER_ABSTIME;\n        }\n    }\n\n    impl From\u003cTimerSpec\u003e for Expiration {\n        fn from(timerspec: TimerSpec) -\u003e Expiration {\n            match timerspec {\n                TimerSpec(libc::itimerspec {\n                    it_interval:\n                        libc::timespec {\n                            tv_sec: 0,\n                            tv_nsec: 0,\n                            ..\n                        },\n                    it_value: ts,\n                }) =\u003e Expiration::OneShot(ts.into()),\n                TimerSpec(libc::itimerspec {\n                    it_interval: int_ts,\n                    it_value: val_ts,\n                }) =\u003e {\n                    if (int_ts.tv_sec == val_ts.tv_sec)\n                        \u0026\u0026 (int_ts.tv_nsec == val_ts.tv_nsec)\n                    {\n                        Expiration::Interval(int_ts.into())\n                    } else {\n                        Expiration::IntervalDelayed(\n                            val_ts.into(),\n                            int_ts.into(),\n                        )\n                    }\n                }\n            }\n        }\n    }\n}\n\npub trait TimeValLike: Sized {\n    #[inline]\n    fn zero() -\u003e Self {\n        Self::seconds(0)\n    }\n\n    #[inline]\n    fn hours(hours: i64) -\u003e Self {\n        let secs = hours\n            .checked_mul(SECS_PER_HOUR)\n            .expect(\"TimeValLike::hours ouf of bounds\");\n        Self::seconds(secs)\n    }\n\n    #[inline]\n    fn minutes(minutes: i64) -\u003e Self {\n        let secs = minutes\n            .checked_mul(SECS_PER_MINUTE)\n            .expect(\"TimeValLike::minutes out of bounds\");\n        Self::seconds(secs)\n    }\n\n    fn seconds(seconds: i64) -\u003e Self;\n    fn milliseconds(milliseconds: i64) -\u003e Self;\n    fn microseconds(microseconds: i64) -\u003e Self;\n    fn nanoseconds(nanoseconds: i64) -\u003e Self;\n\n    #[inline]\n    fn num_hours(\u0026self) -\u003e i64 {\n        self.num_seconds() / 3600\n    }\n\n    #[inline]\n    fn num_minutes(\u0026self) -\u003e i64 {\n        self.num_seconds() / 60\n    }\n\n    fn num_seconds(\u0026self) -\u003e i64;\n    fn num_milliseconds(\u0026self) -\u003e i64;\n    fn num_microseconds(\u0026self) -\u003e i64;\n    fn num_nanoseconds(\u0026self) -\u003e i64;\n}\n\n#[repr(C)]\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct TimeSpec(timespec);\n\nconst NANOS_PER_SEC: i64 = 1_000_000_000;\nconst SECS_PER_MINUTE: i64 = 60;\nconst SECS_PER_HOUR: i64 = 3600;\n\n#[cfg(target_pointer_width = \"64\")]\nconst TS_MAX_SECONDS: i64 = (i64::MAX / NANOS_PER_SEC) - 1;\n\n#[cfg(target_pointer_width = \"32\")]\nconst TS_MAX_SECONDS: i64 = isize::MAX as i64;\n\nconst TS_MIN_SECONDS: i64 = -TS_MAX_SECONDS;\n\n// x32 compatibility\n// See https://sourceware.org/bugzilla/show_bug.cgi?id=16437\n#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"32\"))]\ntype timespec_tv_nsec_t = i64;\n#[cfg(not(all(target_arch = \"x86_64\", target_pointer_width = \"32\")))]\ntype timespec_tv_nsec_t = libc::c_long;\n\nimpl From\u003ctimespec\u003e for TimeSpec {\n    fn from(ts: timespec) -\u003e Self {\n        Self(ts)\n    }\n}\n\nimpl From\u003cDuration\u003e for TimeSpec {\n    fn from(duration: Duration) -\u003e Self {\n        Self::from_duration(duration)\n    }\n}\n\nimpl From\u003cTimeSpec\u003e for Duration {\n    fn from(timespec: TimeSpec) -\u003e Self {\n        Duration::new(timespec.0.tv_sec as u64, timespec.0.tv_nsec as u32)\n    }\n}\n\nimpl AsRef\u003ctimespec\u003e for TimeSpec {\n    fn as_ref(\u0026self) -\u003e \u0026timespec {\n        \u0026self.0\n    }\n}\n\nimpl AsMut\u003ctimespec\u003e for TimeSpec {\n    fn as_mut(\u0026mut self) -\u003e \u0026mut timespec {\n        \u0026mut self.0\n    }\n}\n\nimpl Ord for TimeSpec {\n    // The implementation of cmp is simplified by assuming that the struct is\n    // normalized.  That is, tv_nsec must always be within [0, 1_000_000_000)\n    fn cmp(\u0026self, other: \u0026TimeSpec) -\u003e cmp::Ordering {\n        if self.tv_sec() == other.tv_sec() {\n            self.tv_nsec().cmp(\u0026other.tv_nsec())\n        } else {\n            self.tv_sec().cmp(\u0026other.tv_sec())\n        }\n    }\n}\n\nimpl PartialOrd for TimeSpec {\n    fn partial_cmp(\u0026self, other: \u0026TimeSpec) -\u003e Option\u003ccmp::Ordering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\nimpl TimeValLike for TimeSpec {\n    #[inline]\n    #[cfg_attr(\n        any(target_env = \"musl\", target_env = \"ohos\"),\n        allow(deprecated)\n    )]\n    // https://github.com/rust-lang/libc/issues/1848\n    fn seconds(seconds: i64) -\u003e TimeSpec {\n        assert!(\n            (TS_MIN_SECONDS..=TS_MAX_SECONDS).contains(\u0026seconds),\n            \"TimeSpec out of bounds; seconds={seconds}\",\n        );\n        let mut ts = zero_init_timespec();\n        ts.tv_sec = seconds as time_t;\n        TimeSpec(ts)\n    }\n\n    #[inline]\n    fn milliseconds(milliseconds: i64) -\u003e TimeSpec {\n        let nanoseconds = milliseconds\n            .checked_mul(1_000_000)\n            .expect(\"TimeSpec::milliseconds out of bounds\");\n\n        TimeSpec::nanoseconds(nanoseconds)\n    }\n\n    /// Makes a new `TimeSpec` with given number of microseconds.\n    #[inline]\n    fn microseconds(microseconds: i64) -\u003e TimeSpec {\n        let nanoseconds = microseconds\n            .checked_mul(1_000)\n            .expect(\"TimeSpec::milliseconds out of bounds\");\n\n        TimeSpec::nanoseconds(nanoseconds)\n    }\n\n    /// Makes a new `TimeSpec` with given number of nanoseconds.\n    #[inline]\n    #[cfg_attr(\n        any(target_env = \"musl\", target_env = \"ohos\"),\n        allow(deprecated)\n    )]\n    // https://github.com/rust-lang/libc/issues/1848\n    fn nanoseconds(nanoseconds: i64) -\u003e TimeSpec {\n        let (secs, nanos) = div_mod_floor_64(nanoseconds, NANOS_PER_SEC);\n        assert!(\n            (TS_MIN_SECONDS..=TS_MAX_SECONDS).contains(\u0026secs),\n            \"TimeSpec out of bounds\"\n        );\n        let mut ts = zero_init_timespec();\n        ts.tv_sec = secs as time_t;\n        ts.tv_nsec = nanos as timespec_tv_nsec_t;\n        TimeSpec(ts)\n    }\n\n    // The cast is not unnecessary on all platforms.\n    #[allow(clippy::unnecessary_cast)]\n    fn num_seconds(\u0026self) -\u003e i64 {\n        if self.tv_sec() \u003c 0 \u0026\u0026 self.tv_nsec() \u003e 0 {\n            (self.tv_sec() + 1) as i64\n        } else {\n            self.tv_sec() as i64\n        }\n    }\n\n    fn num_milliseconds(\u0026self) -\u003e i64 {\n        self.num_nanoseconds() / 1_000_000\n    }\n\n    fn num_microseconds(\u0026self) -\u003e i64 {\n        self.num_nanoseconds() / 1_000\n    }\n\n    // The cast is not unnecessary on all platforms.\n    #[allow(clippy::unnecessary_cast)]\n    fn num_nanoseconds(\u0026self) -\u003e i64 {\n        let secs = self.num_seconds() * 1_000_000_000;\n        let nsec = self.nanos_mod_sec();\n        secs + nsec as i64\n    }\n}\n\nimpl TimeSpec {\n    /// Leave the timestamp unchanged.\n    #[cfg(not(target_os = \"redox\"))]\n    // At the time of writing this PR, redox does not support this feature\n    pub const UTIME_OMIT: TimeSpec =\n        TimeSpec::new(0, libc::UTIME_OMIT as timespec_tv_nsec_t);\n    /// Update the timestamp to `Now`\n    // At the time of writing this PR, redox does not support this feature\n    #[cfg(not(target_os = \"redox\"))]\n    pub const UTIME_NOW: TimeSpec =\n        TimeSpec::new(0, libc::UTIME_NOW as timespec_tv_nsec_t);\n\n    /// Construct a new `TimeSpec` from its components\n    #[cfg_attr(\n        any(target_env = \"musl\", target_env = \"ohos\"),\n        allow(deprecated)\n    )] // https://github.com/rust-lang/libc/issues/1848\n    pub const fn new(seconds: time_t, nanoseconds: timespec_tv_nsec_t) -\u003e Self {\n        let mut ts = zero_init_timespec();\n        ts.tv_sec = seconds;\n        ts.tv_nsec = nanoseconds;\n        Self(ts)\n    }\n\n    fn nanos_mod_sec(\u0026self) -\u003e timespec_tv_nsec_t {\n        if self.tv_sec() \u003c 0 \u0026\u0026 self.tv_nsec() \u003e 0 {\n            self.tv_nsec() - NANOS_PER_SEC as timespec_tv_nsec_t\n        } else {\n            self.tv_nsec()\n        }\n    }\n\n    #[cfg_attr(\n        any(target_env = \"musl\", target_env = \"ohos\"),\n        allow(deprecated)\n    )] // https://github.com/rust-lang/libc/issues/1848\n    pub const fn tv_sec(\u0026self) -\u003e time_t {\n        self.0.tv_sec\n    }\n\n    pub const fn tv_nsec(\u0026self) -\u003e timespec_tv_nsec_t {\n        self.0.tv_nsec\n    }\n\n    #[cfg_attr(\n        any(target_env = \"musl\", target_env = \"ohos\"),\n        allow(deprecated)\n    )]\n    // https://github.com/rust-lang/libc/issues/1848\n    pub const fn from_duration(duration: Duration) -\u003e Self {\n        let mut ts = zero_init_timespec();\n        ts.tv_sec = duration.as_secs() as time_t;\n        ts.tv_nsec = duration.subsec_nanos() as timespec_tv_nsec_t;\n        TimeSpec(ts)\n    }\n\n    pub const fn from_timespec(timespec: timespec) -\u003e Self {\n        Self(timespec)\n    }\n}\n\nimpl ops::Neg for TimeSpec {\n    type Output = TimeSpec;\n\n    fn neg(self) -\u003e TimeSpec {\n        TimeSpec::nanoseconds(-self.num_nanoseconds())\n    }\n}\n\nimpl ops::Add for TimeSpec {\n    type Output = TimeSpec;\n\n    fn add(self, rhs: TimeSpec) -\u003e TimeSpec {\n        TimeSpec::nanoseconds(self.num_nanoseconds() + rhs.num_nanoseconds())\n    }\n}\n\nimpl ops::Sub for TimeSpec {\n    type Output = TimeSpec;\n\n    fn sub(self, rhs: TimeSpec) -\u003e TimeSpec {\n        TimeSpec::nanoseconds(self.num_nanoseconds() - rhs.num_nanoseconds())\n    }\n}\n\nimpl ops::Mul\u003ci32\u003e for TimeSpec {\n    type Output = TimeSpec;\n\n    fn mul(self, rhs: i32) -\u003e TimeSpec {\n        let usec = self\n            .num_nanoseconds()\n            .checked_mul(i64::from(rhs))\n            .expect(\"TimeSpec multiply out of bounds\");\n\n        TimeSpec::nanoseconds(usec)\n    }\n}\n\nimpl ops::Div\u003ci32\u003e for TimeSpec {\n    type Output = TimeSpec;\n\n    fn div(self, rhs: i32) -\u003e TimeSpec {\n        let usec = self.num_nanoseconds() / i64::from(rhs);\n        TimeSpec::nanoseconds(usec)\n    }\n}\n\nimpl fmt::Display for TimeSpec {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        let (abs, sign) = if self.tv_sec() \u003c 0 {\n            (-*self, \"-\")\n        } else {\n            (*self, \"\")\n        };\n\n        let sec = abs.tv_sec();\n\n        write!(f, \"{sign}\")?;\n\n        if abs.tv_nsec() == 0 {\n            if sec == 1 {\n                write!(f, \"1 second\")?;\n            } else {\n                write!(f, \"{sec} seconds\")?;\n            }\n        } else if abs.tv_nsec() % 1_000_000 == 0 {\n            write!(f, \"{sec}.{:03} seconds\", abs.tv_nsec() / 1_000_000)?;\n        } else if abs.tv_nsec() % 1_000 == 0 {\n            write!(f, \"{sec}.{:06} seconds\", abs.tv_nsec() / 1_000)?;\n        } else {\n            write!(f, \"{sec}.{:09} seconds\", abs.tv_nsec())?;\n        }\n\n        Ok(())\n    }\n}\n\n#[repr(transparent)]\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct TimeVal(timeval);\n\nconst MICROS_PER_SEC: i64 = 1_000_000;\n\n#[cfg(target_pointer_width = \"64\")]\nconst TV_MAX_SECONDS: i64 = (i64::MAX / MICROS_PER_SEC) - 1;\n\n#[cfg(target_pointer_width = \"32\")]\nconst TV_MAX_SECONDS: i64 = isize::MAX as i64;\n\nconst TV_MIN_SECONDS: i64 = -TV_MAX_SECONDS;\n\nimpl AsRef\u003ctimeval\u003e for TimeVal {\n    fn as_ref(\u0026self) -\u003e \u0026timeval {\n        \u0026self.0\n    }\n}\n\nimpl AsMut\u003ctimeval\u003e for TimeVal {\n    fn as_mut(\u0026mut self) -\u003e \u0026mut timeval {\n        \u0026mut self.0\n    }\n}\n\nimpl Ord for TimeVal {\n    // The implementation of cmp is simplified by assuming that the struct is\n    // normalized.  That is, tv_usec must always be within [0, 1_000_000)\n    fn cmp(\u0026self, other: \u0026TimeVal) -\u003e cmp::Ordering {\n        if self.tv_sec() == other.tv_sec() {\n            self.tv_usec().cmp(\u0026other.tv_usec())\n        } else {\n            self.tv_sec().cmp(\u0026other.tv_sec())\n        }\n    }\n}\n\nimpl PartialOrd for TimeVal {\n    fn partial_cmp(\u0026self, other: \u0026TimeVal) -\u003e Option\u003ccmp::Ordering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\nimpl TimeValLike for TimeVal {\n    #[inline]\n    fn seconds(seconds: i64) -\u003e TimeVal {\n        assert!(\n            (TV_MIN_SECONDS..=TV_MAX_SECONDS).contains(\u0026seconds),\n            \"TimeVal out of bounds; seconds={seconds}\"\n        );\n        #[cfg_attr(\n            any(target_env = \"musl\", target_env = \"ohos\"),\n            allow(deprecated)\n        )]\n        // https://github.com/rust-lang/libc/issues/1848\n        TimeVal(timeval {\n            tv_sec: seconds as time_t,\n            tv_usec: 0,\n        })\n    }\n\n    #[inline]\n    fn milliseconds(milliseconds: i64) -\u003e TimeVal {\n        let microseconds = milliseconds\n            .checked_mul(1_000)\n            .expect(\"TimeVal::milliseconds out of bounds\");\n\n        TimeVal::microseconds(microseconds)\n    }\n\n    /// Makes a new `TimeVal` with given number of microseconds.\n    #[inline]\n    fn microseconds(microseconds: i64) -\u003e TimeVal {\n        let (secs, micros) = div_mod_floor_64(microseconds, MICROS_PER_SEC);\n        assert!(\n            (TV_MIN_SECONDS..=TV_MAX_SECONDS).contains(\u0026secs),\n            \"TimeVal out of bounds\"\n        );\n        #[cfg_attr(\n            any(target_env = \"musl\", target_env = \"ohos\"),\n            allow(deprecated)\n        )]\n        // https://github.com/rust-lang/libc/issues/1848\n        TimeVal(timeval {\n            tv_sec: secs as time_t,\n            tv_usec: micros as suseconds_t,\n        })\n    }\n\n    /// Makes a new `TimeVal` with given number of nanoseconds.  Some precision\n    /// will be lost\n    #[inline]\n    fn nanoseconds(nanoseconds: i64) -\u003e TimeVal {\n        let microseconds = nanoseconds / 1000;\n        let (secs, micros) = div_mod_floor_64(microseconds, MICROS_PER_SEC);\n        assert!(\n            (TV_MIN_SECONDS..=TV_MAX_SECONDS).contains(\u0026secs),\n            \"TimeVal out of bounds\"\n        );\n        #[cfg_attr(\n            any(target_env = \"musl\", target_env = \"ohos\"),\n            allow(deprecated)\n        )]\n        // https://github.com/rust-lang/libc/issues/1848\n        TimeVal(timeval {\n            tv_sec: secs as time_t,\n            tv_usec: micros as suseconds_t,\n        })\n    }\n\n    // The cast is not unnecessary on all platforms.\n    #[allow(clippy::unnecessary_cast)]\n    fn num_seconds(\u0026self) -\u003e i64 {\n        if self.tv_sec() \u003c 0 \u0026\u0026 self.tv_usec() \u003e 0 {\n            (self.tv_sec() + 1) as i64\n        } else {\n            self.tv_sec() as i64\n        }\n    }\n\n    fn num_milliseconds(\u0026self) -\u003e i64 {\n        self.num_microseconds() / 1_000\n    }\n\n    // The cast is not unnecessary on all platforms.\n    #[allow(clippy::unnecessary_cast)]\n    fn num_microseconds(\u0026self) -\u003e i64 {\n        let secs = self.num_seconds() * 1_000_000;\n        let usec = self.micros_mod_sec();\n        secs + usec as i64\n    }\n\n    fn num_nanoseconds(\u0026self) -\u003e i64 {\n        self.num_microseconds() * 1_000\n    }\n}\n\nimpl TimeVal {\n    /// Construct a new `TimeVal` from its components\n    #[cfg_attr(\n        any(target_env = \"musl\", target_env = \"ohos\"),\n        allow(deprecated)\n    )] // https://github.com/rust-lang/libc/issues/1848\n    pub const fn new(seconds: time_t, microseconds: suseconds_t) -\u003e Self {\n        Self(timeval {\n            tv_sec: seconds,\n            tv_usec: microseconds,\n        })\n    }\n\n    fn micros_mod_sec(\u0026self) -\u003e suseconds_t {\n        if self.tv_sec() \u003c 0 \u0026\u0026 self.tv_usec() \u003e 0 {\n            self.tv_usec() - MICROS_PER_SEC as suseconds_t\n        } else {\n            self.tv_usec()\n        }\n    }\n\n    #[cfg_attr(\n        any(target_env = \"musl\", target_env = \"ohos\"),\n        allow(deprecated)\n    )] // https://github.com/rust-lang/libc/issues/1848\n    pub const fn tv_sec(\u0026self) -\u003e time_t {\n        self.0.tv_sec\n    }\n\n    pub const fn tv_usec(\u0026self) -\u003e suseconds_t {\n        self.0.tv_usec\n    }\n}\n\nimpl ops::Neg for TimeVal {\n    type Output = TimeVal;\n\n    fn neg(self) -\u003e TimeVal {\n        TimeVal::microseconds(-self.num_microseconds())\n    }\n}\n\nimpl ops::Add for TimeVal {\n    type Output = TimeVal;\n\n    fn add(self, rhs: TimeVal) -\u003e TimeVal {\n        TimeVal::microseconds(self.num_microseconds() + rhs.num_microseconds())\n    }\n}\n\nimpl ops::Sub for TimeVal {\n    type Output = TimeVal;\n\n    fn sub(self, rhs: TimeVal) -\u003e TimeVal {\n        TimeVal::microseconds(self.num_microseconds() - rhs.num_microseconds())\n    }\n}\n\nimpl ops::Mul\u003ci32\u003e for TimeVal {\n    type Output = TimeVal;\n\n    fn mul(self, rhs: i32) -\u003e TimeVal {\n        let usec = self\n            .num_microseconds()\n            .checked_mul(i64::from(rhs))\n            .expect(\"TimeVal multiply out of bounds\");\n\n        TimeVal::microseconds(usec)\n    }\n}\n\nimpl ops::Div\u003ci32\u003e for TimeVal {\n    type Output = TimeVal;\n\n    fn div(self, rhs: i32) -\u003e TimeVal {\n        let usec = self.num_microseconds() / i64::from(rhs);\n        TimeVal::microseconds(usec)\n    }\n}\n\nimpl fmt::Display for TimeVal {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        let (abs, sign) = if self.tv_sec() \u003c 0 {\n            (-*self, \"-\")\n        } else {\n            (*self, \"\")\n        };\n\n        let sec = abs.tv_sec();\n\n        write!(f, \"{sign}\")?;\n\n        if abs.tv_usec() == 0 {\n            if sec == 1 {\n                write!(f, \"1 second\")?;\n            } else {\n                write!(f, \"{sec} seconds\")?;\n            }\n        } else if abs.tv_usec() % 1000 == 0 {\n            write!(f, \"{sec}.{:03} seconds\", abs.tv_usec() / 1000)?;\n        } else {\n            write!(f, \"{sec}.{:06} seconds\", abs.tv_usec())?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl From\u003ctimeval\u003e for TimeVal {\n    fn from(tv: timeval) -\u003e Self {\n        TimeVal(tv)\n    }\n}\n\n#[inline]\nfn div_mod_floor_64(this: i64, other: i64) -\u003e (i64, i64) {\n    (div_floor_64(this, other), mod_floor_64(this, other))\n}\n\n#[inline]\nfn div_floor_64(this: i64, other: i64) -\u003e i64 {\n    match div_rem_64(this, other) {\n        (d, r) if (r \u003e 0 \u0026\u0026 other \u003c 0) || (r \u003c 0 \u0026\u0026 other \u003e 0) =\u003e d - 1,\n        (d, _) =\u003e d,\n    }\n}\n\n#[inline]\nfn mod_floor_64(this: i64, other: i64) -\u003e i64 {\n    match this % other {\n        r if (r \u003e 0 \u0026\u0026 other \u003c 0) || (r \u003c 0 \u0026\u0026 other \u003e 0) =\u003e r + other,\n        r =\u003e r,\n    }\n}\n\n#[inline]\nfn div_rem_64(this: i64, other: i64) -\u003e (i64, i64) {\n    (this / other, this % other)\n}\n","traces":[{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":75},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","timer.rs"],"content":"//! Timer API via signals.\n//!\n//! Timer is a POSIX API to create timers and get expiration notifications\n//! through queued Unix signals, for the current process. This is similar to\n//! Linux's timerfd mechanism, except that API is specific to Linux and makes\n//! use of file polling.\n//!\n//! For more documentation, please read [timer_create](https://pubs.opengroup.org/onlinepubs/9699919799/functions/timer_create.html).\n//!\n//! # Examples\n//!\n//! Create an interval timer that signals SIGALARM every 250 milliseconds.\n//!\n//! ```no_run\n//! use nix::sys::signal::{self, SigEvent, SigHandler, SigevNotify, Signal};\n//! use nix::sys::timer::{Expiration, Timer, TimerSetTimeFlags};\n//! use nix::time::ClockId;\n//! use std::convert::TryFrom;\n//! use std::sync::atomic::{AtomicU64, Ordering};\n//! use std::thread::yield_now;\n//! use std::time::Duration;\n//!\n//! const SIG: Signal = Signal::SIGALRM;\n//! static ALARMS: AtomicU64 = AtomicU64::new(0);\n//!\n//! extern \"C\" fn handle_alarm(signal: libc::c_int) {\n//!     let signal = Signal::try_from(signal).unwrap();\n//!     if signal == SIG {\n//!         ALARMS.fetch_add(1, Ordering::Relaxed);\n//!     }\n//! }\n//!\n//! fn main() {\n//!     let clockid = ClockId::CLOCK_MONOTONIC;\n//!     let sigevent = SigEvent::new(SigevNotify::SigevSignal {\n//!         signal: SIG,\n//!         si_value: 0,\n//!     });\n//!\n//!     let mut timer = Timer::new(clockid, sigevent).unwrap();\n//!     let expiration = Expiration::Interval(Duration::from_millis(250).into());\n//!     let flags = TimerSetTimeFlags::empty();\n//!     timer.set(expiration, flags).expect(\"could not set timer\");\n//!\n//!     let handler = SigHandler::Handler(handle_alarm);\n//!     unsafe { signal::signal(SIG, handler) }.unwrap();\n//!\n//!     loop {\n//!         let alarms = ALARMS.load(Ordering::Relaxed);\n//!         if alarms \u003e= 10 {\n//!             println!(\"total alarms handled: {}\", alarms);\n//!             break;\n//!         }\n//!         yield_now()\n//!     }\n//! }\n//! ```\nuse crate::sys::signal::SigEvent;\nuse crate::sys::time::timer::TimerSpec;\npub use crate::sys::time::timer::{Expiration, TimerSetTimeFlags};\nuse crate::time::ClockId;\nuse crate::{errno::Errno, Result};\nuse core::mem;\n\n/// A Unix signal per-process timer.\n#[derive(Debug)]\n#[repr(transparent)]\npub struct Timer(libc::timer_t);\n\nimpl Timer {\n    /// Creates a new timer based on the clock defined by `clockid`. The details\n    /// of the signal and its handler are defined by the passed `sigevent`.\n    #[doc(alias(\"timer_create\"))]\n    pub fn new(clockid: ClockId, mut sigevent: SigEvent) -\u003e Result\u003cSelf\u003e {\n        let mut timer_id: mem::MaybeUninit\u003clibc::timer_t\u003e =\n            mem::MaybeUninit::uninit();\n        Errno::result(unsafe {\n            libc::timer_create(\n                clockid.as_raw(),\n                sigevent.as_mut_ptr(),\n                timer_id.as_mut_ptr(),\n            )\n        })\n        .map(|_| {\n            // SAFETY: libc::timer_create is responsible for initializing\n            // timer_id.\n            unsafe { Self(timer_id.assume_init()) }\n        })\n    }\n\n    /// Set a new alarm on the timer.\n    ///\n    /// # Types of alarm\n    ///\n    /// There are 3 types of alarms you can set:\n    ///\n    ///   - one shot: the alarm will trigger once after the specified amount of\n    ///     time.\n    ///     Example: I want an alarm to go off in 60s and then disable itself.\n    ///\n    ///   - interval: the alarm will trigger every specified interval of time.\n    ///     Example: I want an alarm to go off every 60s. The alarm will first\n    ///     go off 60s after I set it and every 60s after that. The alarm will\n    ///     not disable itself.\n    ///\n    ///   - interval delayed: the alarm will trigger after a certain amount of\n    ///     time and then trigger at a specified interval.\n    ///     Example: I want an alarm to go off every 60s but only start in 1h.\n    ///     The alarm will first trigger 1h after I set it and then every 60s\n    ///     after that. The alarm will not disable itself.\n    ///\n    /// # Relative vs absolute alarm\n    ///\n    /// If you do not set any `TimerSetTimeFlags`, then the `TimeSpec` you pass\n    /// to the `Expiration` you want is relative. If however you want an alarm\n    /// to go off at a certain point in time, you can set `TFD_TIMER_ABSTIME`.\n    /// Then the one shot TimeSpec and the delay TimeSpec of the delayed\n    /// interval are going to be interpreted as absolute.\n    ///\n    /// # Disabling alarms\n    ///\n    /// Note: Only one alarm can be set for any given timer. Setting a new alarm\n    /// actually removes the previous one.\n    ///\n    /// Note: Setting a one shot alarm with a 0s TimeSpec disable the alarm\n    /// altogether.\n    #[doc(alias(\"timer_settime\"))]\n    pub fn set(\n        \u0026mut self,\n        expiration: Expiration,\n        flags: TimerSetTimeFlags,\n    ) -\u003e Result\u003c()\u003e {\n        let timerspec: TimerSpec = expiration.into();\n        Errno::result(unsafe {\n            libc::timer_settime(\n                self.0,\n                flags.bits(),\n                timerspec.as_ref(),\n                core::ptr::null_mut(),\n            )\n        })\n        .map(drop)\n    }\n\n    /// Get the parameters for the alarm currently set, if any.\n    #[doc(alias(\"timer_gettime\"))]\n    pub fn get(\u0026self) -\u003e Result\u003cOption\u003cExpiration\u003e\u003e {\n        let mut timerspec = TimerSpec::none();\n        Errno::result(unsafe {\n            libc::timer_gettime(self.0, timerspec.as_mut())\n        })\n        .map(|_| {\n            if timerspec.as_ref().it_interval.tv_sec == 0\n                \u0026\u0026 timerspec.as_ref().it_interval.tv_nsec == 0\n                \u0026\u0026 timerspec.as_ref().it_value.tv_sec == 0\n                \u0026\u0026 timerspec.as_ref().it_value.tv_nsec == 0\n            {\n                None\n            } else {\n                Some(timerspec.into())\n            }\n        })\n    }\n\n    /// Return the number of timers that have overrun\n    ///\n    /// Each timer is able to queue one signal to the process at a time, meaning\n    /// if the signal is not handled before the next expiration the timer has\n    /// 'overrun'. This function returns how many times that has happened to\n    /// this timer, up to `libc::DELAYTIMER_MAX`. If more than the maximum\n    /// number of overruns have happened the return is capped to the maximum.\n    #[doc(alias(\"timer_getoverrun\"))]\n    pub fn overruns(\u0026self) -\u003e i32 {\n        unsafe { libc::timer_getoverrun(self.0) }\n    }\n}\n\nimpl Drop for Timer {\n    fn drop(\u0026mut self) {\n        if !std::thread::panicking() {\n            let result = Errno::result(unsafe { libc::timer_delete(self.0) });\n            if let Err(Errno::EINVAL) = result {\n                panic!(\"close of Timer encountered EINVAL\");\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","timerfd.rs"],"content":"//! Timer API via file descriptors.\n//!\n//! Timer FD is a Linux-only API to create timers and get expiration\n//! notifications through file descriptors.\n//!\n//! For more documentation, please read [timerfd_create(2)](https://man7.org/linux/man-pages/man2/timerfd_create.2.html).\n//!\n//! # Examples\n//!\n//! Create a new one-shot timer that expires after 1 second.\n//! ```\n//! # use std::os::unix::io::AsRawFd;\n//! # use nix::sys::timerfd::{TimerFd, ClockId, TimerFlags, TimerSetTimeFlags,\n//! #    Expiration};\n//! # use nix::sys::time::{TimeSpec, TimeValLike};\n//! # use nix::unistd::read;\n//! #\n//! // We create a new monotonic timer.\n//! let timer = TimerFd::new(ClockId::CLOCK_MONOTONIC, TimerFlags::empty())\n//!     .unwrap();\n//!\n//! // We set a new one-shot timer in 1 seconds.\n//! timer.set(\n//!     Expiration::OneShot(TimeSpec::seconds(1)),\n//!     TimerSetTimeFlags::empty()\n//! ).unwrap();\n//!\n//! // We wait for the timer to expire.\n//! timer.wait().unwrap();\n//! ```\nuse crate::sys::time::timer::TimerSpec;\npub use crate::sys::time::timer::{Expiration, TimerSetTimeFlags};\nuse crate::unistd::read;\nuse crate::{errno::Errno, Result};\nuse libc::c_int;\nuse std::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, OwnedFd, RawFd};\n\n/// A timerfd instance. This is also a file descriptor, you can feed it to\n/// other interfaces taking file descriptors as arguments, [`epoll`] for example.\n///\n/// [`epoll`]: crate::sys::epoll\n#[derive(Debug)]\npub struct TimerFd {\n    fd: OwnedFd,\n}\n\nimpl AsFd for TimerFd {\n    fn as_fd(\u0026self) -\u003e BorrowedFd\u003c'_\u003e {\n        self.fd.as_fd()\n    }\n}\n\nimpl FromRawFd for TimerFd {\n    unsafe fn from_raw_fd(fd: RawFd) -\u003e Self {\n        TimerFd {\n            fd: unsafe { OwnedFd::from_raw_fd(fd) },\n        }\n    }\n}\n\nimpl From\u003cTimerFd\u003e for OwnedFd {\n    fn from(value: TimerFd) -\u003e Self {\n        value.fd  \n    }\n}\n\nlibc_enum! {\n    /// The type of the clock used to mark the progress of the timer. For more\n    /// details on each kind of clock, please refer to [timerfd_create(2)](https://man7.org/linux/man-pages/man2/timerfd_create.2.html).\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum ClockId {\n        /// A settable system-wide real-time clock.\n        CLOCK_REALTIME,\n        /// A non-settable monotonically increasing clock.\n        ///\n        /// Does not change after system startup.\n        /// Does not measure time while the system is suspended.\n        CLOCK_MONOTONIC,\n        /// Like `CLOCK_MONOTONIC`, except that `CLOCK_BOOTTIME` includes the time\n        /// that the system was suspended.\n        CLOCK_BOOTTIME,\n        /// Like `CLOCK_REALTIME`, but will wake the system if it is suspended.\n        CLOCK_REALTIME_ALARM,\n        /// Like `CLOCK_BOOTTIME`, but will wake the system if it is suspended.\n        CLOCK_BOOTTIME_ALARM,\n    }\n}\n\nlibc_bitflags! {\n    /// Additional flags to change the behaviour of the file descriptor at the\n    /// time of creation.\n    pub struct TimerFlags: c_int {\n        /// Set the `O_NONBLOCK` flag on the open file description referred to by the new file descriptor.\n        TFD_NONBLOCK;\n        /// Set the `FD_CLOEXEC` flag on the file descriptor.\n        TFD_CLOEXEC;\n    }\n}\n\nimpl TimerFd {\n    /// Creates a new timer based on the clock defined by `clockid`. The\n    /// underlying fd can be assigned specific flags with `flags` (CLOEXEC,\n    /// NONBLOCK). The underlying fd will be closed on drop.\n    #[doc(alias(\"timerfd_create\"))]\n    pub fn new(clockid: ClockId, flags: TimerFlags) -\u003e Result\u003cSelf\u003e {\n        Errno::result(unsafe {\n            libc::timerfd_create(clockid as i32, flags.bits())\n        })\n        .map(|fd| Self {\n            fd: unsafe { OwnedFd::from_raw_fd(fd) },\n        })\n    }\n\n    /// Sets a new alarm on the timer.\n    ///\n    /// # Types of alarm\n    ///\n    /// There are 3 types of alarms you can set:\n    ///\n    ///   - one shot: the alarm will trigger once after the specified amount of\n    ///     time.\n    ///     Example: I want an alarm to go off in 60s and then disable itself.\n    ///\n    ///   - interval: the alarm will trigger every specified interval of time.\n    ///     Example: I want an alarm to go off every 60s. The alarm will first\n    ///     go off 60s after I set it and every 60s after that. The alarm will\n    ///     not disable itself.\n    ///\n    ///   - interval delayed: the alarm will trigger after a certain amount of\n    ///     time and then trigger at a specified interval.\n    ///     Example: I want an alarm to go off every 60s but only start in 1h.\n    ///     The alarm will first trigger 1h after I set it and then every 60s\n    ///     after that. The alarm will not disable itself.\n    ///\n    /// # Relative vs absolute alarm\n    ///\n    /// If you do not set any `TimerSetTimeFlags`, then the `TimeSpec` you pass\n    /// to the `Expiration` you want is relative. If however you want an alarm\n    /// to go off at a certain point in time, you can set `TFD_TIMER_ABSTIME`.\n    /// Then the one shot TimeSpec and the delay TimeSpec of the delayed\n    /// interval are going to be interpreted as absolute.\n    ///\n    /// # Cancel on a clock change\n    ///\n    /// If you set a `TFD_TIMER_CANCEL_ON_SET` alongside `TFD_TIMER_ABSTIME`\n    /// and the clock for this timer is `CLOCK_REALTIME` or `CLOCK_REALTIME_ALARM`,\n    /// then this timer is marked as cancelable if the real-time clock undergoes\n    /// a discontinuous change.\n    ///\n    /// # Disabling alarms\n    ///\n    /// Note: Only one alarm can be set for any given timer. Setting a new alarm\n    /// actually removes the previous one.\n    ///\n    /// Note: Setting a one shot alarm with a 0s TimeSpec disables the alarm\n    /// altogether.\n    #[doc(alias(\"timerfd_settime\"))]\n    pub fn set(\n        \u0026self,\n        expiration: Expiration,\n        flags: TimerSetTimeFlags,\n    ) -\u003e Result\u003c()\u003e {\n        let timerspec: TimerSpec = expiration.into();\n        Errno::result(unsafe {\n            libc::timerfd_settime(\n                self.fd.as_fd().as_raw_fd(),\n                flags.bits(),\n                timerspec.as_ref(),\n                std::ptr::null_mut(),\n            )\n        })\n        .map(drop)\n    }\n\n    /// Get the parameters for the alarm currently set, if any.\n    #[doc(alias(\"timerfd_gettime\"))]\n    pub fn get(\u0026self) -\u003e Result\u003cOption\u003cExpiration\u003e\u003e {\n        let mut timerspec = TimerSpec::none();\n        Errno::result(unsafe {\n            libc::timerfd_gettime(\n                self.fd.as_fd().as_raw_fd(),\n                timerspec.as_mut(),\n            )\n        })\n        .map(|_| {\n            if timerspec.as_ref().it_interval.tv_sec == 0\n                \u0026\u0026 timerspec.as_ref().it_interval.tv_nsec == 0\n                \u0026\u0026 timerspec.as_ref().it_value.tv_sec == 0\n                \u0026\u0026 timerspec.as_ref().it_value.tv_nsec == 0\n            {\n                None\n            } else {\n                Some(timerspec.into())\n            }\n        })\n    }\n\n    /// Remove the alarm if any is set.\n    #[doc(alias(\"timerfd_settime\"))]\n    pub fn unset(\u0026self) -\u003e Result\u003c()\u003e {\n        Errno::result(unsafe {\n            libc::timerfd_settime(\n                self.fd.as_fd().as_raw_fd(),\n                TimerSetTimeFlags::empty().bits(),\n                TimerSpec::none().as_ref(),\n                std::ptr::null_mut(),\n            )\n        })\n        .map(drop)\n    }\n\n    /// Wait for the configured alarm to expire.\n    ///\n    /// Note: If the alarm is unset, then you will wait forever.\n    pub fn wait(\u0026self) -\u003e Result\u003c()\u003e {\n        while let Err(e) = read(\u0026self.fd, \u0026mut [0u8; 8]) {\n            if e == Errno::ECANCELED {\n                break;\n            }\n            if e != Errno::EINTR {\n                return Err(e);\n            }\n        }\n\n        Ok(())\n    }\n\n\n    /// Constructs a `TimerFd` wrapping an existing `OwnedFd`.\n    ///\n    /// # Safety\n    ///\n    /// `OwnedFd` is a valid `TimerFd`.\n    pub unsafe fn from_owned_fd(fd: OwnedFd) -\u003e Self {\n        Self {\n            fd\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","uio.rs"],"content":"//! Vectored I/O\n\nuse crate::errno::Errno;\nuse crate::Result;\nuse libc::{self, c_int, off_t, size_t};\nuse std::io::{IoSlice, IoSliceMut};\nuse std::os::unix::io::{AsFd, AsRawFd};\n\n/// Low-level vectored write to a raw file descriptor\n///\n/// See also [writev(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/writev.html)\npub fn writev\u003cFd: AsFd\u003e(fd: Fd, iov: \u0026[IoSlice\u003c'_\u003e]) -\u003e Result\u003cusize\u003e {\n    // SAFETY: to quote the documentation for `IoSlice`:\n    //\n    // [IoSlice] is semantically a wrapper around a \u0026[u8], but is\n    // guaranteed to be ABI compatible with the iovec type on Unix\n    // platforms.\n    //\n    // Because it is ABI compatible, a pointer cast here is valid\n    let res = unsafe {\n        libc::writev(\n            fd.as_fd().as_raw_fd(),\n            iov.as_ptr().cast(),\n            iov.len() as c_int,\n        )\n    };\n\n    Errno::result(res).map(|r| r as usize)\n}\n\n/// Low-level vectored read from a raw file descriptor\n///\n/// See also [readv(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/readv.html)\n// Clippy doesn't know that we need to pass iov mutably only because the\n// mutation happens after converting iov to a pointer\n#[allow(clippy::needless_pass_by_ref_mut)]\npub fn readv\u003cFd: AsFd\u003e(fd: Fd, iov: \u0026mut [IoSliceMut\u003c'_\u003e]) -\u003e Result\u003cusize\u003e {\n    // SAFETY: same as in writev(), IoSliceMut is ABI-compatible with iovec\n    let res = unsafe {\n        libc::readv(\n            fd.as_fd().as_raw_fd(),\n            iov.as_ptr().cast(),\n            iov.len() as c_int,\n        )\n    };\n\n    Errno::result(res).map(|r| r as usize)\n}\n\n/// Write to `fd` at `offset` from buffers in `iov`.\n///\n/// Buffers in `iov` will be written in order until all buffers have been written\n/// or an error occurs. The file offset is not changed.\n///\n/// See also: [`writev`](fn.writev.html) and [`pwrite`](fn.pwrite.html)\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\", target_os = \"solaris\", target_os = \"cygwin\")))]\npub fn pwritev\u003cFd: AsFd\u003e(\n    fd: Fd,\n    iov: \u0026[IoSlice\u003c'_\u003e],\n    offset: off_t,\n) -\u003e Result\u003cusize\u003e {\n    #[cfg(target_env = \"uclibc\")]\n    let offset = offset as libc::off64_t; // uclibc doesn't use off_t\n\n    // SAFETY: same as in writev()\n    let res = unsafe {\n        libc::pwritev(\n            fd.as_fd().as_raw_fd(),\n            iov.as_ptr().cast(),\n            iov.len() as c_int,\n            offset,\n        )\n    };\n\n    Errno::result(res).map(|r| r as usize)\n}\n\n/// Read from `fd` at `offset` filling buffers in `iov`.\n///\n/// Buffers in `iov` will be filled in order until all buffers have been filled,\n/// no more bytes are available, or an error occurs. The file offset is not\n/// changed.\n///\n/// See also: [`readv`](fn.readv.html) and [`pread`](fn.pread.html)\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\", target_os = \"solaris\", target_os = \"cygwin\")))]\n// Clippy doesn't know that we need to pass iov mutably only because the\n// mutation happens after converting iov to a pointer\n#[allow(clippy::needless_pass_by_ref_mut)]\npub fn preadv\u003cFd: AsFd\u003e(\n    fd: Fd,\n    iov: \u0026mut [IoSliceMut\u003c'_\u003e],\n    offset: off_t,\n) -\u003e Result\u003cusize\u003e {\n    #[cfg(target_env = \"uclibc\")]\n    let offset = offset as libc::off64_t; // uclibc doesn't use off_t\n\n    // SAFETY: same as in readv()\n    let res = unsafe {\n        libc::preadv(\n            fd.as_fd().as_raw_fd(),\n            iov.as_ptr().cast(),\n            iov.len() as c_int,\n            offset,\n        )\n    };\n\n    Errno::result(res).map(|r| r as usize)\n}\n\n/// Low-level write to a file, with specified offset.\n///\n/// See also [pwrite(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pwrite.html)\n// TODO: move to unistd\npub fn pwrite\u003cFd: AsFd\u003e(fd: Fd, buf: \u0026[u8], offset: off_t) -\u003e Result\u003cusize\u003e {\n    let res = unsafe {\n        libc::pwrite(\n            fd.as_fd().as_raw_fd(),\n            buf.as_ptr().cast(),\n            buf.len() as size_t,\n            offset,\n        )\n    };\n\n    Errno::result(res).map(|r| r as usize)\n}\n\n/// Low-level read from a file, with specified offset.\n///\n/// See also [pread(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pread.html)\n// TODO: move to unistd\npub fn pread\u003cFd: AsFd\u003e(fd: Fd, buf: \u0026mut [u8], offset: off_t) -\u003e Result\u003cusize\u003e {\n    let res = unsafe {\n        libc::pread(\n            fd.as_fd().as_raw_fd(),\n            buf.as_mut_ptr().cast(),\n            buf.len() as size_t,\n            offset,\n        )\n    };\n\n    Errno::result(res).map(|r| r as usize)\n}\n\n/// A slice of memory in a remote process, starting at address `base`\n/// and consisting of `len` bytes.\n///\n/// This is the same underlying C structure as `IoSlice`,\n/// except that it refers to memory in some other process, and is\n/// therefore not represented in Rust by an actual slice as `IoSlice` is. It\n/// is used with [`process_vm_readv`](fn.process_vm_readv.html)\n/// and [`process_vm_writev`](fn.process_vm_writev.html).\n#[cfg(linux_android)]\n#[repr(C)]\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct RemoteIoVec {\n    /// The starting address of this slice (`iov_base`).\n    pub base: usize,\n    /// The number of bytes in this slice (`iov_len`).\n    pub len: usize,\n}\n\nfeature! {\n#![feature = \"process\"]\n\n/// Write data directly to another process's virtual memory\n/// (see [`process_vm_writev`(2)]).\n///\n/// `local_iov` is a list of [`IoSlice`]s containing the data to be written,\n/// and `remote_iov` is a list of [`RemoteIoVec`]s identifying where the\n/// data should be written in the target process. On success, returns the\n/// number of bytes written, which will always be a whole\n/// number of `remote_iov` chunks.\n///\n/// This requires the same permissions as debugging the process using\n/// [ptrace]: you must either be a privileged process (with\n/// `CAP_SYS_PTRACE`), or you must be running as the same user as the\n/// target process and the OS must have unprivileged debugging enabled.\n///\n/// This function is only available on Linux and Android(SDK23+).\n///\n/// [`process_vm_writev`(2)]: https://man7.org/linux/man-pages/man2/process_vm_writev.2.html\n/// [ptrace]: ../ptrace/index.html\n/// [`IoSlice`]: https://doc.rust-lang.org/std/io/struct.IoSlice.html\n/// [`RemoteIoVec`]: struct.RemoteIoVec.html\n#[cfg(all(linux_android, not(target_env = \"uclibc\")))]\npub fn process_vm_writev(\n    pid: crate::unistd::Pid,\n    local_iov: \u0026[IoSlice\u003c'_\u003e],\n    remote_iov: \u0026[RemoteIoVec]) -\u003e Result\u003cusize\u003e\n{\n    let res = unsafe {\n        libc::process_vm_writev(pid.into(),\n                                local_iov.as_ptr().cast(), local_iov.len() as libc::c_ulong,\n                                remote_iov.as_ptr().cast(), remote_iov.len() as libc::c_ulong, 0)\n    };\n\n    Errno::result(res).map(|r| r as usize)\n}\n\n/// Read data directly from another process's virtual memory\n/// (see [`process_vm_readv`(2)]).\n///\n/// `local_iov` is a list of [`IoSliceMut`]s containing the buffer to copy\n/// data into, and `remote_iov` is a list of [`RemoteIoVec`]s identifying\n/// where the source data is in the target process. On success,\n/// returns the number of bytes written, which will always be a whole\n/// number of `remote_iov` chunks.\n///\n/// This requires the same permissions as debugging the process using\n/// [`ptrace`]: you must either be a privileged process (with\n/// `CAP_SYS_PTRACE`), or you must be running as the same user as the\n/// target process and the OS must have unprivileged debugging enabled.\n///\n/// This function is only available on Linux and Android(SDK23+).\n///\n/// [`process_vm_readv`(2)]: https://man7.org/linux/man-pages/man2/process_vm_readv.2.html\n/// [`ptrace`]: ../ptrace/index.html\n/// [`IoSliceMut`]: https://doc.rust-lang.org/std/io/struct.IoSliceMut.html\n/// [`RemoteIoVec`]: struct.RemoteIoVec.html\n#[cfg(all(linux_android, not(target_env = \"uclibc\")))]\npub fn process_vm_readv(\n    pid: crate::unistd::Pid,\n    local_iov: \u0026mut [IoSliceMut\u003c'_\u003e],\n    remote_iov: \u0026[RemoteIoVec]) -\u003e Result\u003cusize\u003e\n{\n    let res = unsafe {\n        libc::process_vm_readv(pid.into(),\n                               local_iov.as_ptr().cast(), local_iov.len() as libc::c_ulong,\n                               remote_iov.as_ptr().cast(), remote_iov.len() as libc::c_ulong, 0)\n    };\n\n    Errno::result(res).map(|r| r as usize)\n}\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":32},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","utsname.rs"],"content":"//! Get system identification\nuse crate::{Errno, Result};\nuse libc::c_char;\nuse std::ffi::OsStr;\nuse std::mem;\nuse std::os::unix::ffi::OsStrExt;\n\n/// Describes the running system.  Return type of [`uname`].\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\n#[repr(transparent)]\npub struct UtsName(libc::utsname);\n\nimpl UtsName {\n    /// Name of the operating system implementation.\n    pub fn sysname(\u0026self) -\u003e \u0026OsStr {\n        cast_and_trim(\u0026self.0.sysname)\n    }\n\n    /// Network name of this machine.\n    pub fn nodename(\u0026self) -\u003e \u0026OsStr {\n        cast_and_trim(\u0026self.0.nodename)\n    }\n\n    /// Release level of the operating system.\n    pub fn release(\u0026self) -\u003e \u0026OsStr {\n        cast_and_trim(\u0026self.0.release)\n    }\n\n    /// Version level of the operating system.\n    pub fn version(\u0026self) -\u003e \u0026OsStr {\n        cast_and_trim(\u0026self.0.version)\n    }\n\n    /// Machine hardware platform.\n    pub fn machine(\u0026self) -\u003e \u0026OsStr {\n        cast_and_trim(\u0026self.0.machine)\n    }\n\n    /// NIS or YP domain name of this machine.\n    #[cfg(linux_android)]\n    pub fn domainname(\u0026self) -\u003e \u0026OsStr {\n        cast_and_trim(\u0026self.0.domainname)\n    }\n}\n\n/// Get system identification\npub fn uname() -\u003e Result\u003cUtsName\u003e {\n    unsafe {\n        let mut ret = mem::MaybeUninit::zeroed();\n        Errno::result(libc::uname(ret.as_mut_ptr()))?;\n        Ok(UtsName(ret.assume_init()))\n    }\n}\n\nfn cast_and_trim(slice: \u0026[c_char]) -\u003e \u0026OsStr {\n    let length = slice\n        .iter()\n        .position(|\u0026byte| byte == 0)\n        .unwrap_or(slice.len());\n    let bytes =\n        unsafe { std::slice::from_raw_parts(slice.as_ptr().cast(), length) };\n\n    OsStr::from_bytes(bytes)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","sys","wait.rs"],"content":"//! Wait for a process to change status\nuse crate::errno::Errno;\nuse crate::sys::signal::Signal;\nuse crate::unistd::Pid;\nuse crate::Result;\nuse cfg_if::cfg_if;\nuse libc::{self, c_int};\nuse std::convert::TryFrom;\n#[cfg(any(\n    target_os = \"android\",\n    all(target_os = \"linux\", not(target_env = \"uclibc\")),\n))]\nuse std::os::unix::io::{AsRawFd, BorrowedFd};\n\nlibc_bitflags!(\n    /// Controls the behavior of [`waitpid`].\n    pub struct WaitPidFlag: c_int {\n        /// Do not block when there are no processes wishing to report status.\n        WNOHANG;\n        /// Report the status of selected processes which are stopped due to a\n        /// [`SIGTTIN`](crate::sys::signal::Signal::SIGTTIN),\n        /// [`SIGTTOU`](crate::sys::signal::Signal::SIGTTOU),\n        /// [`SIGTSTP`](crate::sys::signal::Signal::SIGTSTP), or\n        /// [`SIGSTOP`](crate::sys::signal::Signal::SIGSTOP) signal.\n        WUNTRACED;\n        /// Report the status of selected processes which have terminated.\n        #[cfg(any(linux_android,\n                  apple_targets,\n                  target_os = \"freebsd\",\n                  target_os = \"haiku\",\n                  target_os = \"redox\",\n                  target_os = \"netbsd\"))]\n        WEXITED;\n        /// Report the status of selected processes that have continued from a\n        /// job control stop by receiving a\n        /// [`SIGCONT`](crate::sys::signal::Signal::SIGCONT) signal.\n        WCONTINUED;\n        /// An alias for WUNTRACED.\n        #[cfg(any(linux_android,\n                  apple_targets,\n                  target_os = \"freebsd\",\n                  target_os = \"haiku\",\n                  target_os = \"redox\",\n                  target_os = \"netbsd\"))]\n        WSTOPPED;\n        /// Don't reap, just poll status.\n        #[cfg(any(linux_android,\n                  apple_targets,\n                  target_os = \"freebsd\",\n                  target_os = \"haiku\",\n                  target_os = \"redox\",\n                  target_os = \"netbsd\"))]\n        WNOWAIT;\n        /// Don't wait on children of other threads in this group\n        #[cfg(any(linux_android, target_os = \"redox\"))]\n        __WNOTHREAD;\n        /// Wait on all children, regardless of type\n        #[cfg(any(linux_android, target_os = \"redox\"))]\n        __WALL;\n        /// Wait for \"clone\" children only.\n        #[cfg(any(linux_android, target_os = \"redox\"))]\n        __WCLONE;\n    }\n);\n\n/// Possible return values from `wait()` or `waitpid()`.\n///\n/// Each status (other than `StillAlive`) describes a state transition\n/// in a child process `Pid`, such as the process exiting or stopping,\n/// plus additional data about the transition if any.\n///\n/// Note that there are two Linux-specific enum variants, `PtraceEvent`\n/// and `PtraceSyscall`. Portable code should avoid exhaustively\n/// matching on `WaitStatus`.\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub enum WaitStatus {\n    /// The process exited normally (as with `exit()` or returning from\n    /// `main`) with the given exit code. This case matches the C macro\n    /// `WIFEXITED(status)`; the second field is `WEXITSTATUS(status)`.\n    Exited(Pid, i32),\n    /// The process was killed by the given signal. The third field\n    /// indicates whether the signal generated a core dump. This case\n    /// matches the C macro `WIFSIGNALED(status)`; the last two fields\n    /// correspond to `WTERMSIG(status)` and `WCOREDUMP(status)`.\n    Signaled(Pid, Signal, bool),\n    /// The process is alive, but was stopped by the given signal. This\n    /// is only reported if `WaitPidFlag::WUNTRACED` was passed. This\n    /// case matches the C macro `WIFSTOPPED(status)`; the second field\n    /// is `WSTOPSIG(status)`.\n    Stopped(Pid, Signal),\n    /// The traced process was stopped by a `PTRACE_EVENT_*` event. See\n    /// [`nix::sys::ptrace`] and [`ptrace`(2)] for more information. All\n    /// currently-defined events use `SIGTRAP` as the signal; the third\n    /// field is the `PTRACE_EVENT_*` value of the event.\n    ///\n    /// [`nix::sys::ptrace`]: ../ptrace/index.html\n    /// [`ptrace`(2)]: https://man7.org/linux/man-pages/man2/ptrace.2.html\n    #[cfg(linux_android)]\n    PtraceEvent(Pid, Signal, c_int),\n    /// The traced process was stopped by execution of a system call,\n    /// and `PTRACE_O_TRACESYSGOOD` is in effect. See [`ptrace`(2)] for\n    /// more information.\n    ///\n    /// [`ptrace`(2)]: https://man7.org/linux/man-pages/man2/ptrace.2.html\n    #[cfg(linux_android)]\n    PtraceSyscall(Pid),\n    /// The process was previously stopped but has resumed execution\n    /// after receiving a `SIGCONT` signal. This is only reported if\n    /// `WaitPidFlag::WCONTINUED` was passed. This case matches the C\n    /// macro `WIFCONTINUED(status)`.\n    Continued(Pid),\n    /// There are currently no state changes to report in any awaited\n    /// child process. This is only returned if `WaitPidFlag::WNOHANG`\n    /// was used (otherwise `wait()` or `waitpid()` would block until\n    /// there was something to report).\n    StillAlive,\n}\n\nimpl WaitStatus {\n    /// Extracts the PID from the WaitStatus unless it equals StillAlive.\n    pub fn pid(\u0026self) -\u003e Option\u003cPid\u003e {\n        use self::WaitStatus::*;\n        match *self {\n            Exited(p, _) | Signaled(p, _, _) | Stopped(p, _) | Continued(p) =\u003e {\n                Some(p)\n            }\n            StillAlive =\u003e None,\n            #[cfg(linux_android)]\n            PtraceEvent(p, _, _) | PtraceSyscall(p) =\u003e Some(p),\n        }\n    }\n}\n\nfn exited(status: i32) -\u003e bool {\n    libc::WIFEXITED(status)\n}\n\nfn exit_status(status: i32) -\u003e i32 {\n    libc::WEXITSTATUS(status)\n}\n\nfn signaled(status: i32) -\u003e bool {\n    libc::WIFSIGNALED(status)\n}\n\nfn term_signal(status: i32) -\u003e Result\u003cSignal\u003e {\n    Signal::try_from(libc::WTERMSIG(status))\n}\n\nfn dumped_core(status: i32) -\u003e bool {\n    libc::WCOREDUMP(status)\n}\n\nfn stopped(status: i32) -\u003e bool {\n    libc::WIFSTOPPED(status)\n}\n\nfn stop_signal(status: i32) -\u003e Result\u003cSignal\u003e {\n    Signal::try_from(libc::WSTOPSIG(status))\n}\n\n#[cfg(linux_android)]\nfn syscall_stop(status: i32) -\u003e bool {\n    // From ptrace(2), setting PTRACE_O_TRACESYSGOOD has the effect\n    // of delivering SIGTRAP | 0x80 as the signal number for syscall\n    // stops. This allows easily distinguishing syscall stops from\n    // genuine SIGTRAP signals.\n    libc::WSTOPSIG(status) == libc::SIGTRAP | 0x80\n}\n\n#[cfg(linux_android)]\nfn stop_additional(status: i32) -\u003e c_int {\n    (status \u003e\u003e 16) as c_int\n}\n\nfn continued(status: i32) -\u003e bool {\n    libc::WIFCONTINUED(status)\n}\n\nimpl WaitStatus {\n    /// Convert a raw `wstatus` as returned by `waitpid`/`wait` into a `WaitStatus`\n    ///\n    /// # Errors\n    ///\n    /// Returns an `Error` corresponding to `EINVAL` for invalid status values.\n    ///\n    /// # Examples\n    ///\n    /// Convert a `wstatus` obtained from `libc::waitpid` into a `WaitStatus`:\n    ///\n    /// ```\n    /// use nix::sys::wait::WaitStatus;\n    /// use nix::sys::signal::Signal;\n    /// let pid = nix::unistd::Pid::from_raw(1);\n    /// let status = WaitStatus::from_raw(pid, 0x0002);\n    /// assert_eq!(status, Ok(WaitStatus::Signaled(pid, Signal::SIGINT, false)));\n    /// ```\n    pub fn from_raw(pid: Pid, status: i32) -\u003e Result\u003cWaitStatus\u003e {\n        Ok(if exited(status) {\n            WaitStatus::Exited(pid, exit_status(status))\n        } else if signaled(status) {\n            WaitStatus::Signaled(pid, term_signal(status)?, dumped_core(status))\n        } else if stopped(status) {\n            cfg_if! {\n                if #[cfg(linux_android)] {\n                    fn decode_stopped(pid: Pid, status: i32) -\u003e Result\u003cWaitStatus\u003e {\n                        let status_additional = stop_additional(status);\n                        Ok(if syscall_stop(status) {\n                            WaitStatus::PtraceSyscall(pid)\n                        } else if status_additional == 0 {\n                            WaitStatus::Stopped(pid, stop_signal(status)?)\n                        } else {\n                            WaitStatus::PtraceEvent(pid, stop_signal(status)?,\n                                                    stop_additional(status))\n                        })\n                    }\n                } else {\n                    fn decode_stopped(pid: Pid, status: i32) -\u003e Result\u003cWaitStatus\u003e {\n                        Ok(WaitStatus::Stopped(pid, stop_signal(status)?))\n                    }\n                }\n            }\n            return decode_stopped(pid, status);\n        } else {\n            assert!(continued(status));\n            WaitStatus::Continued(pid)\n        })\n    }\n\n    /// Convert a `siginfo_t` as returned by `waitid` to a `WaitStatus`\n    ///\n    /// # Errors\n    ///\n    /// Returns an `Error` corresponding to `EINVAL` for invalid values.\n    ///\n    /// # Safety\n    ///\n    /// siginfo_t is actually a union, not all fields may be initialized.\n    /// The functions si_pid() and si_status() must be valid to call on\n    /// the passed siginfo_t.\n    #[cfg(any(\n        target_os = \"android\",\n        target_os = \"freebsd\",\n        target_os = \"haiku\",\n        all(target_os = \"linux\", not(target_env = \"uclibc\")),\n    ))]\n    unsafe fn from_siginfo(siginfo: \u0026libc::siginfo_t) -\u003e Result\u003cWaitStatus\u003e {\n        let si_pid = unsafe { siginfo.si_pid() };\n        if si_pid == 0 {\n            return Ok(WaitStatus::StillAlive);\n        }\n\n        assert_eq!(siginfo.si_signo, libc::SIGCHLD);\n\n        let pid = Pid::from_raw(si_pid);\n        let si_status = unsafe { siginfo.si_status() };\n\n        let status = match siginfo.si_code {\n            libc::CLD_EXITED =\u003e WaitStatus::Exited(pid, si_status),\n            libc::CLD_KILLED | libc::CLD_DUMPED =\u003e WaitStatus::Signaled(\n                pid,\n                Signal::try_from(si_status)?,\n                siginfo.si_code == libc::CLD_DUMPED,\n            ),\n            libc::CLD_STOPPED =\u003e {\n                WaitStatus::Stopped(pid, Signal::try_from(si_status)?)\n            }\n            libc::CLD_CONTINUED =\u003e WaitStatus::Continued(pid),\n            #[cfg(linux_android)]\n            libc::CLD_TRAPPED =\u003e {\n                if si_status == libc::SIGTRAP | 0x80 {\n                    WaitStatus::PtraceSyscall(pid)\n                } else {\n                    WaitStatus::PtraceEvent(\n                        pid,\n                        Signal::try_from(si_status \u0026 0xff)?,\n                        (si_status \u003e\u003e 8) as c_int,\n                    )\n                }\n            }\n            _ =\u003e return Err(Errno::EINVAL),\n        };\n\n        Ok(status)\n    }\n}\n\n/// Wait for a process to change status\n///\n/// See also [waitpid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/waitpid.html)\npub fn waitpid\u003cP: Into\u003cOption\u003cPid\u003e\u003e\u003e(\n    pid: P,\n    options: Option\u003cWaitPidFlag\u003e,\n) -\u003e Result\u003cWaitStatus\u003e {\n    use self::WaitStatus::*;\n\n    let mut status: i32 = 0;\n\n    let option_bits = match options {\n        Some(bits) =\u003e bits.bits(),\n        None =\u003e 0,\n    };\n\n    let res = unsafe {\n        libc::waitpid(\n            pid.into().unwrap_or_else(|| Pid::from_raw(-1)).into(),\n            \u0026mut status as *mut c_int,\n            option_bits,\n        )\n    };\n\n    match Errno::result(res)? {\n        0 =\u003e Ok(StillAlive),\n        res =\u003e WaitStatus::from_raw(Pid::from_raw(res), status),\n    }\n}\n\n/// Wait for any child process to change status or a signal is received.\n///\n/// See also [wait(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html)\npub fn wait() -\u003e Result\u003cWaitStatus\u003e {\n    waitpid(None, None)\n}\n\n/// The ID argument for `waitid`\n#[cfg(any(\n    target_os = \"android\",\n    target_os = \"freebsd\",\n    target_os = \"haiku\",\n    all(target_os = \"linux\", not(target_env = \"uclibc\")),\n))]\n#[derive(Debug)]\npub enum Id\u003c'fd\u003e {\n    /// Wait for any child\n    All,\n    /// Wait for the child whose process ID matches the given PID\n    Pid(Pid),\n    /// Wait for the child whose process group ID matches the given PID\n    ///\n    /// If the PID is zero, the caller's process group is used since Linux 5.4.\n    PGid(Pid),\n    /// Wait for the child referred to by the given PID file descriptor\n    #[cfg(linux_android)]\n    PIDFd(BorrowedFd\u003c'fd\u003e),\n    /// A helper variant to resolve the unused parameter (`'fd`) problem on platforms\n    /// other than Linux and Android.\n    #[doc(hidden)]\n    _Unreachable(std::marker::PhantomData\u003c\u0026'fd std::convert::Infallible\u003e),\n}\n\n/// Wait for a process to change status\n///\n/// See also [waitid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/waitid.html)\n#[cfg(any(\n    target_os = \"android\",\n    target_os = \"freebsd\",\n    target_os = \"haiku\",\n    all(target_os = \"linux\", not(target_env = \"uclibc\")),\n))]\npub fn waitid(id: Id, flags: WaitPidFlag) -\u003e Result\u003cWaitStatus\u003e {\n    let (idtype, idval) = match id {\n        Id::All =\u003e (libc::P_ALL, 0),\n        Id::Pid(pid) =\u003e (libc::P_PID, pid.as_raw() as libc::id_t),\n        Id::PGid(pid) =\u003e (libc::P_PGID, pid.as_raw() as libc::id_t),\n        #[cfg(linux_android)]\n        Id::PIDFd(fd) =\u003e (libc::P_PIDFD, fd.as_raw_fd() as libc::id_t),\n        Id::_Unreachable(_) =\u003e {\n            unreachable!(\"This variant could never be constructed\")\n        }\n    };\n\n    let siginfo = unsafe {\n        // Memory is zeroed rather than uninitialized, as not all platforms\n        // initialize the memory in the StillAlive case\n        let mut siginfo: libc::siginfo_t = std::mem::zeroed();\n        Errno::result(libc::waitid(idtype, idval, \u0026mut siginfo, flags.bits()))?;\n        siginfo\n    };\n\n    unsafe { WaitStatus::from_siginfo(\u0026siginfo) }\n}\n","traces":[{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["/","home","acooks","mcr","nix-0.30.1","src","syslog.rs"],"content":"//! Interfaces for controlling system log.\n\nuse crate::{NixPath, Result};\nuse std::ffi::OsStr;\nuse std::ptr;\n\n/// Logging options of subsequent [`syslog`] calls can be set by calling [`openlog`].\n///\n/// The parameter `ident` is a string that will be prepended to every message. The `logopt`\n/// argument specifies logging options. The `facility` parameter encodes a default facility to be\n/// assigned to all messages that do not have an explicit facility encoded.\n//\n// On Linux, the `ident` argument needs to have static lifetime according to the\n// man page:\n//\n// The argument ident in the call of openlog() is probably stored as-is. Thus,\n// if the string it points to is changed, syslog() may start prepending the changed\n// string, and if the string it points to ceases to exist, the results are\n// undefined.  Most portable is to use a string constant.\n#[cfg(target_os = \"linux\")]\npub fn openlog(\n    ident: Option\u003c\u0026'static std::ffi::CStr\u003e,\n    logopt: LogFlags,\n    facility: Facility,\n) -\u003e Result\u003c()\u003e {\n    let logopt = logopt.bits();\n    let facility = facility as libc::c_int;\n    match ident {\n        None =\u003e unsafe {\n            libc::openlog(ptr::null(), logopt, facility);\n        },\n        Some(ident) =\u003e ident.with_nix_path(|ident| unsafe {\n            libc::openlog(ident.as_ptr(), logopt, facility);\n        })?,\n    }\n\n    Ok(())\n}\n\n/// Logging options of subsequent [`syslog`] calls can be set by calling [`openlog`].\n///\n/// The parameter `ident` is a string that will be prepended to every message. The `logopt`\n/// argument specifies logging options. The `facility` parameter encodes a default facility to be\n/// assigned to all messages that do not have an explicit facility encoded.\n#[cfg(not(target_os = \"linux\"))]\npub fn openlog\u003cS: AsRef\u003cOsStr\u003e + ?Sized\u003e(\n    ident: Option\u003c\u0026S\u003e,\n    logopt: LogFlags,\n    facility: Facility,\n) -\u003e Result\u003c()\u003e {\n    let logopt = logopt.bits();\n    let facility = facility as libc::c_int;\n    match ident.map(OsStr::new) {\n        None =\u003e unsafe {\n            libc::openlog(ptr::null(), logopt, facility);\n        },\n        Some(ident) =\u003e ident.with_nix_path(|ident| unsafe {\n            libc::openlog(ident.as_ptr(), logopt, facility);\n        })?,\n    }\n\n    Ok(())\n}\n\n/// Writes message to the system message logger.\n///\n/// The message is then written to the system console, log files, logged-in users, or forwarded\n/// to other machines as appropriate.\n///\n/// # Examples\n///\n/// ```rust\n/// use nix::syslog::{openlog, syslog, Facility, LogFlags, Severity, Priority};\n///\n/// let priority = Priority::new(Severity::LOG_EMERG, Facility::LOG_USER);\n/// syslog(priority, \"Hello, nix!\").unwrap();\n///\n/// // use `format!` to format the message\n/// let name = \"syslog\";\n/// syslog(priority, \u0026format!(\"Hello, {name}!\")).unwrap();\n/// ```\npub fn syslog\u003cP, S\u003e(priority: P, message: \u0026S) -\u003e Result\u003c()\u003e\nwhere\n    P: Into\u003cPriority\u003e,\n    S: AsRef\u003cOsStr\u003e + ?Sized,\n{\n    let priority = priority.into();\n    let formatter = OsStr::new(\"%s\");\n    let message = OsStr::new(message);\n    formatter.with_nix_path(|formatter| {\n        message.with_nix_path(|message| unsafe {\n            libc::syslog(priority.0, formatter.as_ptr(), message.as_ptr())\n        })\n    })??;\n    Ok(())\n}\n\n/// Set the process-wide priority mask to `mask` and return the previous mask\n/// value.\n///\n/// Calls to `syslog()` with a priority level not set in `mask` are ignored. The\n/// default is to log all priorities.\n///\n/// If the `mask` argument is `None`, the current logmask is not modified, this\n/// can be used to query the current log mask.\npub fn setlogmask(mask: Option\u003cLogMask\u003e) -\u003e LogMask {\n    let mask = match mask {\n        Some(mask) =\u003e mask.0,\n        None =\u003e 0,\n    };\n    let prev_mask = unsafe { libc::setlogmask(mask) };\n    LogMask(prev_mask)\n}\n\n/// Closes the log file.\npub fn closelog() {\n    unsafe { libc::closelog() }\n}\n\n/// System log priority mask.\n#[derive(Debug, Clone, Copy)]\npub struct LogMask(libc::c_int);\n\nimpl LogMask {\n    /// Creates a mask of all priorities up to and including `priority`.\n    #[doc(alias(\"LOG_UPTO\"))]\n    pub fn up_to(priority: Severity) -\u003e Self {\n        let pri = priority as libc::c_int;\n        Self((1 \u003c\u003c (pri + 1)) - 1)\n    }\n\n    /// Creates a mask for the specified priority.\n    #[doc(alias(\"LOG_MASK\"))]\n    pub fn of_priority(priority: Severity) -\u003e Self {\n        let pri = priority as libc::c_int;\n        Self(1 \u003c\u003c pri)\n    }\n\n    /// Returns if the mask for the specified `priority` is set.\n    pub fn contains(\u0026self, priority: Severity) -\u003e bool {\n        let priority = Self::of_priority(priority);\n        let and_result = *self \u0026 priority;\n        and_result.0 != 0\n    }\n}\n\nimpl std::ops::BitOr for LogMask {\n    type Output = Self;\n    fn bitor(self, rhs: Self) -\u003e Self::Output {\n        Self(self.0 | rhs.0)\n    }\n}\n\nimpl std::ops::BitAnd for LogMask {\n    type Output = Self;\n    fn bitand(self, rhs: Self) -\u003e Self::Output {\n        Self(self.0 \u0026 rhs.0)\n    }\n}\n\nimpl std::ops::BitOrAssign for LogMask {\n    fn bitor_assign(\u0026mut self, rhs: Self) {\n        self.0 |= rhs.0;\n    }\n}\n\nimpl std::ops::BitAndAssign for LogMask {\n    fn bitand_assign(\u0026mut self, rhs: Self) {\n        self.0 \u0026= rhs.0;\n    }\n}\n\nimpl std::ops::Not for LogMask {\n    type Output = Self;\n    fn not(self) -\u003e Self::Output {\n        Self(!self.0)\n    }\n}\n\n/// The priority for a log message.\n#[derive(Debug, Clone, Copy)]\npub struct Priority(libc::c_int);\n\nimpl Priority {\n    /// Create a new priority from a facility and severity level.\n    pub fn new(severity: Severity, facility: Facility) -\u003e Self {\n        let priority = (facility as libc::c_int) | (severity as libc::c_int);\n        Priority(priority)\n    }\n}\n\nimpl From\u003cSeverity\u003e for Priority {\n    fn from(severity: Severity) -\u003e Self {\n        let priority = severity as libc::c_int;\n        Priority(priority)\n    }\n}\n\nlibc_bitflags! {\n    /// Options for system logging.\n    pub struct LogFlags: libc::c_int {\n        /// Log the process id with each message: useful for identifying instantiations of\n        /// daemons.\n        LOG_PID;\n        /// If syslog() cannot pass the message to syslogd(8) it will attempt to write the\n        /// message to the console (\"/dev/console\").\n        LOG_CONS;\n        /// The converse of [`LOG_NDELAY`][LogFlags::LOG_NDELAY]; opening of the connection is\n        /// delayed until `syslog` is called.\n        ///\n        /// This is the default, and need not be specified.\n        LOG_ODELAY;\n        /// Open the connection to syslogd(8) immediately. Normally the open is delayed until\n        /// the first message is logged. Useful for programs that need to manage the order in\n        /// which file descriptors are allocated.\n        LOG_NDELAY;\n        /// Write the message to standard error output as well to the system log.\n        #[cfg(not(any(solarish, target_os = \"redox\", target_os = \"cygwin\")))]\n        LOG_PERROR;\n    }\n}\n\nlibc_enum! {\n    /// Severity levels for log messages.\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum Severity {\n        /// A panic condition.\n        ///\n        /// This is normally broadcast to all users.\n        LOG_EMERG,\n        /// A condition that should be corrected immediately, such as a corrupted system database.\n        LOG_ALERT,\n        /// Critical conditions, e.g., hard device errors.\n        LOG_CRIT,\n        /// Errors.\n        LOG_ERR,\n        /// Warning messages.\n        LOG_WARNING,\n        /// Conditions that are not error conditions, but should possibly be handled specially.\n        LOG_NOTICE,\n        /// Informational messages.\n        LOG_INFO,\n        /// Messages that contain information normally of use only when debugging a program.\n        LOG_DEBUG,\n    }\n}\n\nlibc_enum! {\n    /// Facilities for log messages.\n    #[repr(i32)]\n    #[non_exhaustive]\n    pub enum Facility {\n        /// Messages generated by the kernel.\n        ///\n        /// These cannot be generated by any user processes.\n        LOG_KERN,\n        /// Messages generated by random user processes.\n        ///\n        /// This is the default facility identifier if none is specified.\n        LOG_USER,\n        /// The mail system.\n        LOG_MAIL,\n        /// System daemons, such as routed(8), that are not provided for explicitly by other facilities.\n        LOG_DAEMON,\n        /// The authorization system: login(1), su(1), getty(8), etc.\n        LOG_AUTH,\n        /// Messages generated internally by syslogd(8).\n        LOG_SYSLOG,\n        /// The line printer spooling system: cups-lpd(8), cupsd(8), etc.\n        LOG_LPR,\n        /// The network news system.\n        LOG_NEWS,\n        /// The uucp system.\n        LOG_UUCP,\n        /// Reserved for local use.\n        LOG_LOCAL0,\n        /// Reserved for local use.\n        LOG_LOCAL1,\n        /// Reserved for local use.\n        LOG_LOCAL2,\n        /// Reserved for local use.\n        LOG_LOCAL3,\n        /// Reserved for local use.\n        LOG_LOCAL4,\n        /// Reserved for local use.\n        LOG_LOCAL5,\n        /// Reserved for local use.\n        LOG_LOCAL6,\n        /// Reserved for local use.\n        LOG_LOCAL7,\n    }\n}\n","traces":[{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","home","acooks","mcr","nix-0.30.1","src","time.rs"],"content":"//! Sleep, query system clocks, and set system clock\nuse crate::sys::time::TimeSpec;\n#[cfg(any(freebsdlike, linux_android, target_os = \"emscripten\"))]\n#[cfg(feature = \"process\")]\nuse crate::unistd::Pid;\nuse crate::{Errno, Result};\nuse libc::{self, clockid_t};\nuse std::mem::MaybeUninit;\n\n/// Clock identifier\n///\n/// Newtype pattern around [`libc::clockid_t`].\n#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct ClockId(clockid_t);\n\nimpl ClockId {\n    /// Creates `ClockId` from raw `clockid_t`\n    pub const fn from_raw(clk_id: clockid_t) -\u003e Self {\n        ClockId(clk_id)\n    }\n\n    feature! {\n    #![feature = \"process\"]\n    /// Returns `ClockId` of a `pid` CPU-time clock\n    #[cfg(any(freebsdlike, linux_android, target_os = \"emscripten\"))]\n    pub fn pid_cpu_clock_id(pid: Pid) -\u003e Result\u003cSelf\u003e {\n        clock_getcpuclockid(pid)\n    }\n    }\n\n    /// Returns resolution of the clock id\n    #[cfg(not(target_os = \"redox\"))]\n    pub fn res(self) -\u003e Result\u003cTimeSpec\u003e {\n        clock_getres(self)\n    }\n\n    /// Returns the current time on the clock id\n    pub fn now(self) -\u003e Result\u003cTimeSpec\u003e {\n        clock_gettime(self)\n    }\n\n    /// Sets time to `timespec` on the clock id\n    #[cfg(not(any(\n        target_os = \"ios\",\n        target_os = \"tvos\",\n        target_os = \"watchos\",\n        target_os = \"redox\",\n        target_os = \"hermit\"\n    )))]\n    pub fn set_time(self, timespec: TimeSpec) -\u003e Result\u003c()\u003e {\n        clock_settime(self, timespec)\n    }\n\n    /// Gets the raw `clockid_t` wrapped by `self`\n    pub const fn as_raw(self) -\u003e clockid_t {\n        self.0\n    }\n\n    #[cfg(any(linux_android, target_os = \"emscripten\", target_os = \"fuchsia\"))]\n    /// Starts at zero when the kernel boots and increments monotonically in SI seconds while the\n    /// machine is running.\n    pub const CLOCK_BOOTTIME: ClockId = ClockId(libc::CLOCK_BOOTTIME);\n    /// Like [`CLOCK_BOOTTIME`](ClockId::CLOCK_BOOTTIME), but will wake the system if it is\n    /// suspended..\n    #[cfg(any(linux_android, target_os = \"emscripten\", target_os = \"fuchsia\"))]\n    pub const CLOCK_BOOTTIME_ALARM: ClockId =\n        ClockId(libc::CLOCK_BOOTTIME_ALARM);\n    /// Increments in SI seconds.\n    pub const CLOCK_MONOTONIC: ClockId = ClockId(libc::CLOCK_MONOTONIC);\n    /// Like [`CLOCK_MONOTONIC`](ClockId::CLOCK_MONOTONIC), but optimized for execution time at the expense of accuracy.\n    #[cfg(any(linux_android, target_os = \"emscripten\", target_os = \"fuchsia\"))]\n    pub const CLOCK_MONOTONIC_COARSE: ClockId =\n        ClockId(libc::CLOCK_MONOTONIC_COARSE);\n    #[cfg(freebsdlike)]\n    /// Like [`CLOCK_MONOTONIC`](ClockId::CLOCK_MONOTONIC), but optimized for execution time at the expense of accuracy.\n    pub const CLOCK_MONOTONIC_FAST: ClockId =\n        ClockId(libc::CLOCK_MONOTONIC_FAST);\n    #[cfg(freebsdlike)]\n    /// Like [`CLOCK_MONOTONIC`](ClockId::CLOCK_MONOTONIC), but optimized for accuracy at the expense of execution time.\n    pub const CLOCK_MONOTONIC_PRECISE: ClockId =\n        ClockId(libc::CLOCK_MONOTONIC_PRECISE);\n    /// Similar to [`CLOCK_MONOTONIC`](ClockId::CLOCK_MONOTONIC), but provides access to a raw\n    /// hardware-based time that is not subject to NTP adjustments.\n    #[cfg(any(linux_android, target_os = \"emscripten\", target_os = \"fuchsia\"))]\n    pub const CLOCK_MONOTONIC_RAW: ClockId = ClockId(libc::CLOCK_MONOTONIC_RAW);\n    #[cfg(any(\n        linux_android,\n        apple_targets,\n        freebsdlike,\n        target_os = \"emscripten\",\n        target_os = \"fuchsia\",\n        target_os = \"redox\",\n    ))]\n    /// Returns the execution time of the calling process.\n    pub const CLOCK_PROCESS_CPUTIME_ID: ClockId =\n        ClockId(libc::CLOCK_PROCESS_CPUTIME_ID);\n    #[cfg(freebsdlike)]\n    /// Increments when the CPU is running in user or kernel mode\n    pub const CLOCK_PROF: ClockId = ClockId(libc::CLOCK_PROF);\n    /// Increments as a wall clock should.\n    pub const CLOCK_REALTIME: ClockId = ClockId(libc::CLOCK_REALTIME);\n    /// Like [`CLOCK_REALTIME`](ClockId::CLOCK_REALTIME), but not settable.\n    #[cfg(any(linux_android, target_os = \"emscripten\", target_os = \"fuchsia\"))]\n    pub const CLOCK_REALTIME_ALARM: ClockId =\n        ClockId(libc::CLOCK_REALTIME_ALARM);\n    /// Like [`CLOCK_REALTIME`](ClockId::CLOCK_REALTIME), but optimized for execution time at the expense of accuracy.\n    #[cfg(any(linux_android, target_os = \"emscripten\", target_os = \"fuchsia\"))]\n    pub const CLOCK_REALTIME_COARSE: ClockId =\n        ClockId(libc::CLOCK_REALTIME_COARSE);\n    #[cfg(freebsdlike)]\n    /// Like [`CLOCK_REALTIME`](ClockId::CLOCK_REALTIME), but optimized for execution time at the expense of accuracy.\n    pub const CLOCK_REALTIME_FAST: ClockId = ClockId(libc::CLOCK_REALTIME_FAST);\n    #[cfg(freebsdlike)]\n    /// Like [`CLOCK_REALTIME`](ClockId::CLOCK_REALTIME), but optimized for accuracy at the expense of execution time.\n    pub const CLOCK_REALTIME_PRECISE: ClockId =\n        ClockId(libc::CLOCK_REALTIME_PRECISE);\n    #[cfg(freebsdlike)]\n    /// Returns the current second without performing a full time counter query, using an in-kernel\n    /// cached value of the current second.\n    pub const CLOCK_SECOND: ClockId = ClockId(libc::CLOCK_SECOND);\n    #[allow(missing_docs)] // Undocumented on Linux!\n    #[cfg(any(\n        target_os = \"emscripten\",\n        target_os = \"fuchsia\",\n        all(\n            target_os = \"linux\",\n            any(target_env = \"musl\", target_env = \"ohos\")\n        )\n    ))]\n    pub const CLOCK_SGI_CYCLE: ClockId = ClockId(libc::CLOCK_SGI_CYCLE);\n    /// International Atomic Time.\n    ///\n    /// A nonsettable system-wide clock derived from wall-clock time but ignoring leap seconds.\n    #[cfg(any(linux_android, target_os = \"emscripten\", target_os = \"fuchsia\"))]\n    pub const CLOCK_TAI: ClockId = ClockId(libc::CLOCK_TAI);\n    #[cfg(any(\n        linux_android,\n        apple_targets,\n        freebsdlike,\n        target_os = \"emscripten\",\n        target_os = \"fuchsia\",\n    ))]\n    /// Returns the execution time of the calling thread.\n    pub const CLOCK_THREAD_CPUTIME_ID: ClockId =\n        ClockId(libc::CLOCK_THREAD_CPUTIME_ID);\n    #[cfg(freebsdlike)]\n    /// Starts at zero when the kernel boots and increments monotonically in SI seconds while the\n    /// machine is running.\n    pub const CLOCK_UPTIME: ClockId = ClockId(libc::CLOCK_UPTIME);\n    #[cfg(freebsdlike)]\n    /// Like [`CLOCK_UPTIME`](ClockId::CLOCK_UPTIME), but optimized for execution time at the expense of accuracy.\n    pub const CLOCK_UPTIME_FAST: ClockId = ClockId(libc::CLOCK_UPTIME_FAST);\n    #[cfg(freebsdlike)]\n    /// Like [`CLOCK_UPTIME`](ClockId::CLOCK_UPTIME), but optimized for accuracy at the expense of execution time.\n    pub const CLOCK_UPTIME_PRECISE: ClockId =\n        ClockId(libc::CLOCK_UPTIME_PRECISE);\n    #[cfg(freebsdlike)]\n    /// Increments only when the CPU is running in user mode on behalf of the calling process.\n    pub const CLOCK_VIRTUAL: ClockId = ClockId(libc::CLOCK_VIRTUAL);\n}\n\nimpl From\u003cClockId\u003e for clockid_t {\n    fn from(clock_id: ClockId) -\u003e Self {\n        clock_id.as_raw()\n    }\n}\n\nimpl From\u003cclockid_t\u003e for ClockId {\n    fn from(clk_id: clockid_t) -\u003e Self {\n        ClockId::from_raw(clk_id)\n    }\n}\n\nimpl std::fmt::Display for ClockId {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        std::fmt::Display::fmt(\u0026self.0, f)\n    }\n}\n\n/// Get the resolution of the specified clock, (see\n/// [clock_getres(2)](https://pubs.opengroup.org/onlinepubs/7908799/xsh/clock_getres.html)).\n#[cfg(not(target_os = \"redox\"))]\npub fn clock_getres(clock_id: ClockId) -\u003e Result\u003cTimeSpec\u003e {\n    let mut c_time: MaybeUninit\u003clibc::timespec\u003e = MaybeUninit::uninit();\n    let ret =\n        unsafe { libc::clock_getres(clock_id.as_raw(), c_time.as_mut_ptr()) };\n    Errno::result(ret)?;\n    let res = unsafe { c_time.assume_init() };\n    Ok(TimeSpec::from(res))\n}\n\n/// Get the time of the specified clock, (see\n/// [clock_gettime(2)](https://pubs.opengroup.org/onlinepubs/7908799/xsh/clock_gettime.html)).\npub fn clock_gettime(clock_id: ClockId) -\u003e Result\u003cTimeSpec\u003e {\n    let mut c_time: MaybeUninit\u003clibc::timespec\u003e = MaybeUninit::uninit();\n    let ret =\n        unsafe { libc::clock_gettime(clock_id.as_raw(), c_time.as_mut_ptr()) };\n    Errno::result(ret)?;\n    let res = unsafe { c_time.assume_init() };\n    Ok(TimeSpec::from(res))\n}\n\n/// Set the time of the specified clock, (see\n/// [clock_settime(2)](https://pubs.opengroup.org/onlinepubs/7908799/xsh/clock_settime.html)).\n#[cfg(not(any(\n    target_os = \"ios\",\n    target_os = \"tvos\",\n    target_os = \"watchos\",\n    target_os = \"redox\",\n    target_os = \"hermit\"\n)))]\npub fn clock_settime(clock_id: ClockId, timespec: TimeSpec) -\u003e Result\u003c()\u003e {\n    let ret =\n        unsafe { libc::clock_settime(clock_id.as_raw(), timespec.as_ref()) };\n    Errno::result(ret).map(drop)\n}\n\n/// Get the clock id of the specified process id, (see\n/// [clock_getcpuclockid(3)](https://pubs.opengroup.org/onlinepubs/009695399/functions/clock_getcpuclockid.html)).\n#[cfg(any(freebsdlike, linux_android, target_os = \"emscripten\"))]\n#[cfg(feature = \"process\")]\n#[cfg_attr(docsrs, doc(cfg(feature = \"process\")))]\npub fn clock_getcpuclockid(pid: Pid) -\u003e Result\u003cClockId\u003e {\n    let mut clk_id: MaybeUninit\u003clibc::clockid_t\u003e = MaybeUninit::uninit();\n    let ret =\n        unsafe { libc::clock_getcpuclockid(pid.into(), clk_id.as_mut_ptr()) };\n    if ret == 0 {\n        let res = unsafe { clk_id.assume_init() };\n        Ok(ClockId::from(res))\n    } else {\n        Err(Errno::from_raw(ret))\n    }\n}\n\n#[cfg(any(\n    linux_android,\n    solarish,\n    freebsdlike,\n    target_os = \"netbsd\",\n    target_os = \"hurd\",\n    target_os = \"aix\"\n))]\nlibc_bitflags! {\n    /// Flags that are used for arming the timer.\n    pub struct ClockNanosleepFlags: libc::c_int {\n        /// Indicates that a requested time value should be treated as absolute instead of\n        /// relative.\n        TIMER_ABSTIME;\n    }\n}\n\n/// Suspend execution of this thread for the amount of time specified by `request`\n/// and measured against the clock speficied by `clock_id`.\n///\n/// If `flags` is [`TIMER_ABSTIME`](ClockNanosleepFlags::TIMER_ABSTIME), this function will suspend\n/// execution until the time value of clock_id reaches the absolute time specified by `request`. If\n/// a signal is caught by a signal-catching function, or a signal causes the process to terminate,\n/// this sleep is interrrupted.\n///\n/// see also [man 3 clock_nanosleep](https://pubs.opengroup.org/onlinepubs/009695399/functions/clock_nanosleep.html)\n#[cfg(any(\n    linux_android,\n    solarish,\n    freebsdlike,\n    target_os = \"netbsd\",\n    target_os = \"hurd\",\n    target_os = \"aix\"\n))]\npub fn clock_nanosleep(\n    clock_id: ClockId,\n    flags: ClockNanosleepFlags,\n    request: \u0026TimeSpec,\n) -\u003e Result\u003cTimeSpec\u003e {\n    let mut remain = TimeSpec::new(0, 0);\n    let ret = unsafe {\n        libc::clock_nanosleep(\n            clock_id.as_raw(),\n            flags.bits(),\n            request.as_ref() as *const _,\n            remain.as_mut() as *mut _,\n        )\n    };\n    if ret == 0 {\n        Ok(remain)\n    } else {\n        Err(Errno::from_raw(ret))\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","ucontext.rs"],"content":"#[cfg(not(any(target_env = \"musl\", target_env = \"ohos\")))]\nuse crate::errno::Errno;\nuse crate::sys::signal::SigSet;\n#[cfg(not(any(target_env = \"musl\", target_env = \"ohos\")))]\nuse crate::Result;\n#[cfg(not(any(target_env = \"musl\", target_env = \"ohos\")))]\nuse std::mem;\n\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\npub struct UContext {\n    context: libc::ucontext_t,\n}\n\nimpl UContext {\n    #[cfg(not(any(target_env = \"musl\", target_env = \"ohos\")))]\n    pub fn get() -\u003e Result\u003cUContext\u003e {\n        let mut context = mem::MaybeUninit::\u003clibc::ucontext_t\u003e::uninit();\n        let res = unsafe { libc::getcontext(context.as_mut_ptr()) };\n        Errno::result(res).map(|_| unsafe {\n            UContext {\n                context: context.assume_init(),\n            }\n        })\n    }\n\n    #[cfg(not(any(target_env = \"musl\", target_env = \"ohos\")))]\n    pub fn set(\u0026self) -\u003e Result\u003c()\u003e {\n        let res = unsafe {\n            libc::setcontext(\u0026self.context as *const libc::ucontext_t)\n        };\n        Errno::result(res).map(drop)\n    }\n\n    pub fn sigmask_mut(\u0026mut self) -\u003e \u0026mut SigSet {\n        unsafe {\n            \u0026mut *(\u0026mut self.context.uc_sigmask as *mut libc::sigset_t\n                as *mut SigSet)\n        }\n    }\n\n    pub fn sigmask(\u0026self) -\u003e \u0026SigSet {\n        unsafe {\n            \u0026*(\u0026self.context.uc_sigmask as *const libc::sigset_t\n                as *const SigSet)\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","src","unistd.rs"],"content":"//! Safe wrappers around functions found in libc \"unistd.h\" header\n\nuse crate::errno::Errno;\n\n#[cfg(not(target_os = \"redox\"))]\n#[cfg(feature = \"fs\")]\nuse crate::fcntl::AtFlags;\n\n#[cfg(feature = \"fs\")]\n#[cfg(any(\n    linux_android,\n    freebsdlike,\n    solarish,\n    netbsdlike,\n    target_os = \"emscripten\",\n    target_os = \"fuchsia\",\n    target_os = \"hurd\",\n    target_os = \"redox\",\n    target_os = \"cygwin\",\n))]\nuse crate::fcntl::OFlag;\n#[cfg(all(feature = \"fs\", bsd))]\nuse crate::sys::stat::FileFlag;\nuse crate::{Error, NixPath, Result};\n#[cfg(not(target_os = \"redox\"))]\nuse cfg_if::cfg_if;\nuse libc::{c_char, c_int, c_long, c_uint, gid_t, off_t, pid_t, size_t, uid_t};\nuse std::convert::Infallible;\n#[cfg(not(target_os = \"redox\"))]\nuse std::ffi::CString;\nuse std::ffi::{CStr, OsStr, OsString};\nuse std::os::unix::ffi::{OsStrExt, OsStringExt};\nuse std::path::PathBuf;\nuse std::{fmt, mem, ptr};\n\nfeature! {\n    #![feature = \"fs\"]\n    #[cfg(linux_android)]\n    pub use self::pivot_root::*;\n}\n\n#[cfg(any(freebsdlike, linux_android, target_os = \"openbsd\"))]\npub use self::setres::*;\n\n#[cfg(any(freebsdlike, linux_android, target_os = \"openbsd\"))]\npub use self::getres::*;\n\nfeature! {\n#![feature = \"user\"]\n\n/// User identifier\n///\n/// Newtype pattern around `uid_t` (which is just alias). It prevents bugs caused by accidentally\n/// passing wrong value.\n#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\npub struct Uid(uid_t);\n\nimpl Uid {\n    /// Creates `Uid` from raw `uid_t`.\n    pub const fn from_raw(uid: uid_t) -\u003e Self {\n        Uid(uid)\n    }\n\n    /// Returns Uid of calling process. This is practically a more Rusty alias for `getuid`.\n    #[doc(alias(\"getuid\"))]\n    pub fn current() -\u003e Self {\n        getuid()\n    }\n\n    /// Returns effective Uid of calling process. This is practically a more Rusty alias for `geteuid`.\n    #[doc(alias(\"geteuid\"))]\n    pub fn effective() -\u003e Self {\n        geteuid()\n    }\n\n    /// Returns true if the `Uid` represents privileged user - root. (If it equals zero.)\n    pub const fn is_root(self) -\u003e bool {\n        self.0 == ROOT.0\n    }\n\n    /// Get the raw `uid_t` wrapped by `self`.\n    pub const fn as_raw(self) -\u003e uid_t {\n        self.0\n    }\n}\n\nimpl From\u003cUid\u003e for uid_t {\n    fn from(uid: Uid) -\u003e Self {\n        uid.0\n    }\n}\n\nimpl From\u003cuid_t\u003e for Uid {\n    fn from(uid: uid_t) -\u003e Self {\n        Uid(uid)\n    }\n}\n\nimpl fmt::Display for Uid {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        fmt::Display::fmt(\u0026self.0, f)\n    }\n}\n\n/// Constant for UID = 0\npub const ROOT: Uid = Uid(0);\n\n/// Group identifier\n///\n/// Newtype pattern around `gid_t` (which is just alias). It prevents bugs caused by accidentally\n/// passing wrong value.\n#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\npub struct Gid(gid_t);\n\nimpl Gid {\n    /// Creates `Gid` from raw `gid_t`.\n    pub const fn from_raw(gid: gid_t) -\u003e Self {\n        Gid(gid)\n    }\n\n    /// Returns Gid of calling process. This is practically a more Rusty alias for `getgid`.\n    #[doc(alias(\"getgid\"))]\n    pub fn current() -\u003e Self {\n        getgid()\n    }\n\n    /// Returns effective Gid of calling process. This is practically a more Rusty alias for `getegid`.\n    #[doc(alias(\"getegid\"))]\n    pub fn effective() -\u003e Self {\n        getegid()\n    }\n\n    /// Get the raw `gid_t` wrapped by `self`.\n    pub const fn as_raw(self) -\u003e gid_t {\n        self.0\n    }\n}\n\nimpl From\u003cGid\u003e for gid_t {\n    fn from(gid: Gid) -\u003e Self {\n        gid.0\n    }\n}\n\nimpl From\u003cgid_t\u003e for Gid {\n    fn from(gid: gid_t) -\u003e Self {\n        Gid(gid)\n    }\n}\n\nimpl fmt::Display for Gid {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        fmt::Display::fmt(\u0026self.0, f)\n    }\n}\n}\n\nfeature! {\n#![feature = \"process\"]\n/// Process identifier\n///\n/// Newtype pattern around `pid_t` (which is just alias). It prevents bugs caused by accidentally\n/// passing wrong value.\n#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\npub struct Pid(pid_t);\n\nimpl Pid {\n    /// Creates `Pid` from raw `pid_t`.\n    pub const fn from_raw(pid: pid_t) -\u003e Self {\n        Pid(pid)\n    }\n\n    /// Returns PID of calling process\n    #[doc(alias(\"getpid\"))]\n    pub fn this() -\u003e Self {\n        getpid()\n    }\n\n    /// Returns PID of parent of calling process\n    #[doc(alias(\"getppid\"))]\n    pub fn parent() -\u003e Self {\n        getppid()\n    }\n\n    /// Get the raw `pid_t` wrapped by `self`.\n    pub const fn as_raw(self) -\u003e pid_t {\n        self.0\n    }\n}\n\nimpl From\u003cPid\u003e for pid_t {\n    fn from(pid: Pid) -\u003e Self {\n        pid.0\n    }\n}\n\nimpl fmt::Display for Pid {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        fmt::Display::fmt(\u0026self.0, f)\n    }\n}\n\n/// Represents the successful result of calling `fork`\n///\n/// When `fork` is called, the process continues execution in the parent process\n/// and in the new child.  This return type can be examined to determine whether\n/// you are now executing in the parent process or in the child.\n#[derive(Clone, Copy, Debug)]\npub enum ForkResult {\n    /// This is the parent process of the fork.\n    Parent {\n        /// The PID of the fork's child process\n        child: Pid\n    },\n    /// This is the child process of the fork.\n    Child,\n}\n\nimpl ForkResult {\n    /// Return `true` if this is the child process of the `fork()`\n    #[inline]\n    pub fn is_child(self) -\u003e bool {\n        matches!(self, ForkResult::Child)\n    }\n\n    /// Returns `true` if this is the parent process of the `fork()`\n    #[inline]\n    pub fn is_parent(self) -\u003e bool {\n        !self.is_child()\n    }\n}\n\n/// Create a new child process duplicating the parent process ([see\n/// fork(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fork.html)).\n///\n/// After successfully calling the fork system call, a second process will\n/// be created which is identical to the original except for the pid and the\n/// return value of this function.  As an example:\n///\n/// ```\n/// use nix::{sys::wait::waitpid,unistd::{fork, ForkResult, write}};\n///\n/// match unsafe{fork()} {\n///    Ok(ForkResult::Parent { child, .. }) =\u003e {\n///        println!(\"Continuing execution in parent process, new child has pid: {}\", child);\n///        waitpid(child, None).unwrap();\n///    }\n///    Ok(ForkResult::Child) =\u003e {\n///        // Unsafe to use `println!` (or `unwrap`) here. See Safety.\n///        write(std::io::stdout(), \"I'm a new child process\\n\".as_bytes()).ok();\n///        unsafe { libc::_exit(0) };\n///    }\n///    Err(_) =\u003e println!(\"Fork failed\"),\n/// }\n/// ```\n///\n/// This will print something like the following (order nondeterministic).  The\n/// thing to note is that you end up with two processes continuing execution\n/// immediately after the fork call but with different match arms.\n///\n/// ```text\n/// Continuing execution in parent process, new child has pid: 1234\n/// I'm a new child process\n/// ```\n///\n/// # Safety\n///\n/// In a multithreaded program, only [async-signal-safe] functions like `pause`\n/// and `_exit` may be called by the child (the parent isn't restricted) until\n/// a call of `execve(2)`. Note that memory allocation may **not** be\n/// async-signal-safe and thus must be prevented.\n///\n/// Those functions are only a small subset of your operating system's API, so\n/// special care must be taken to only invoke code you can control and audit.\n///\n/// [async-signal-safe]: https://man7.org/linux/man-pages/man7/signal-safety.7.html\n#[inline]\npub unsafe fn fork() -\u003e Result\u003cForkResult\u003e {\n    use self::ForkResult::*;\n    let res = unsafe { libc::fork() };\n\n    Errno::result(res).map(|res| match res {\n        0 =\u003e Child,\n        res =\u003e Parent { child: Pid(res) },\n    })\n}\n\n/// Get the pid of this process (see\n/// [getpid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpid.html)).\n///\n/// Since you are running code, there is always a pid to return, so there\n/// is no error case that needs to be handled.\n#[inline]\npub fn getpid() -\u003e Pid {\n    Pid(unsafe { libc::getpid() })\n}\n\n/// Get the pid of this processes' parent (see\n/// [getpid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getppid.html)).\n///\n/// There is always a parent pid to return, so there is no error case that needs\n/// to be handled.\n#[inline]\npub fn getppid() -\u003e Pid {\n    Pid(unsafe { libc::getppid() }) // no error handling, according to man page: \"These functions are always successful.\"\n}\n\n/// Set a process group ID (see\n/// [setpgid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/setpgid.html)).\n///\n/// Set the process group id (PGID) of a particular process.  If a pid of zero\n/// is specified, then the pid of the calling process is used.  Process groups\n/// may be used to group together a set of processes in order for the OS to\n/// apply some operations across the group.\n///\n/// `setsid()` may be used to create a new process group.\n#[inline]\npub fn setpgid(pid: Pid, pgid: Pid) -\u003e Result\u003c()\u003e {\n    let res = unsafe { libc::setpgid(pid.into(), pgid.into()) };\n    Errno::result(res).map(drop)\n}\n/// Get process group\n///\n/// See Also [`getpgid`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpgid.html)\n#[inline]\npub fn getpgid(pid: Option\u003cPid\u003e) -\u003e Result\u003cPid\u003e {\n    let res = unsafe { libc::getpgid(pid.unwrap_or(Pid(0)).into()) };\n    Errno::result(res).map(Pid)\n}\n\n/// Create new session and set process group id (see\n/// [setsid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/setsid.html)).\n#[inline]\npub fn setsid() -\u003e Result\u003cPid\u003e {\n    Errno::result(unsafe { libc::setsid() }).map(Pid)\n}\n\n/// Get the process group ID of a session leader\n/// [getsid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsid.html).\n///\n/// Obtain the process group ID of the process that is the session leader of the process specified\n/// by pid. If pid is zero, it specifies the calling process.\n#[inline]\n#[cfg(not(target_os = \"redox\"))]\npub fn getsid(pid: Option\u003cPid\u003e) -\u003e Result\u003cPid\u003e {\n    let res = unsafe { libc::getsid(pid.unwrap_or(Pid(0)).into()) };\n    Errno::result(res).map(Pid)\n}\n}\n\nfeature! {\n#![all(feature = \"process\", feature = \"term\")]\n/// Get the terminal foreground process group (see\n/// [tcgetpgrp(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tcgetpgrp.html)).\n///\n/// Get the group process id (GPID) of the foreground process group on the\n/// terminal associated to file descriptor (FD).\n#[inline]\npub fn tcgetpgrp\u003cF: std::os::fd::AsFd\u003e(fd: F) -\u003e Result\u003cPid\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = unsafe { libc::tcgetpgrp(fd.as_fd().as_raw_fd()) };\n    Errno::result(res).map(Pid)\n}\n/// Set the terminal foreground process group (see\n/// [tcgetpgrp(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/tcsetpgrp.html)).\n///\n/// Get the group process id (PGID) to the foreground process group on the\n/// terminal associated to file descriptor (FD).\n#[inline]\npub fn tcsetpgrp\u003cF: std::os::fd::AsFd\u003e(fd: F, pgrp: Pid) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = unsafe { libc::tcsetpgrp(fd.as_fd().as_raw_fd(), pgrp.into()) };\n    Errno::result(res).map(drop)\n}\n}\n\nfeature! {\n#![feature = \"process\"]\n/// Get the group id of the calling process (see\n///[getpgrp(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpgrp.html)).\n///\n/// Get the process group id (PGID) of the calling process.\n/// According to the man page it is always successful.\n#[inline]\npub fn getpgrp() -\u003e Pid {\n    Pid(unsafe { libc::getpgrp() })\n}\n\n/// Get the caller's thread ID (see\n/// [gettid(2)](https://man7.org/linux/man-pages/man2/gettid.2.html).\n///\n/// This function is only available on Linux based systems.  In a single\n/// threaded process, the main thread will have the same ID as the process.  In\n/// a multithreaded process, each thread will have a unique thread id but the\n/// same process ID.\n///\n/// No error handling is required as a thread id should always exist for any\n/// process, even if threads are not being used.\n#[cfg(linux_android)]\n#[inline]\npub fn gettid() -\u003e Pid {\n    Pid(unsafe { libc::syscall(libc::SYS_gettid) as pid_t })\n}\n}\n\nfeature! {\n#![feature = \"fs\"]\n/// Create a copy of the specified file descriptor.\n///\n/// The new file descriptor will have a new index but refer to the same\n/// resource as the old file descriptor and the old and new file descriptors may\n/// be used interchangeably.  The new and old file descriptor share the same\n/// underlying resource, offset, and file status flags.  The actual index used\n/// for the file descriptor will be the lowest fd index that is available.\n///\n/// The two file descriptors do not share file descriptor flags (e.g. `OFlag::FD_CLOEXEC`).\n///\n/// # Reference\n///\n/// * [POSIX manual](https://pubs.opengroup.org/onlinepubs/9699919799/functions/dup.html)\n///\n/// # See also\n///\n/// * [`dup2()`]\n/// * [`dup2_raw()`]\n/// * `dup3()`\n/// * `dup3_raw()`\n#[inline]\npub fn dup\u003cFd: std::os::fd::AsFd\u003e(oldfd: Fd) -\u003e Result\u003cstd::os::fd::OwnedFd\u003e {\n    use std::os::fd::AsRawFd;\n    use std::os::fd::OwnedFd;\n    use std::os::fd::FromRawFd;\n\n    let res = unsafe { libc::dup(oldfd.as_fd().as_raw_fd()) };\n    Errno::result(res)?;\n    // SAFETY:\n    //\n    // `dup(2)` would return a valid owned file descriptor on success\n    Ok( unsafe { OwnedFd::from_raw_fd(res) })\n}\n\n/// Duplicate `fd` with Stdin, i.e., Stdin redirection.\n#[inline]\npub fn dup2_stdin\u003cFd: std::os::fd::AsFd\u003e(fd: Fd) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n    use libc::STDIN_FILENO;\n\n    let res = unsafe { libc::dup2(fd.as_fd().as_raw_fd(), STDIN_FILENO) };\n    Errno::result(res).map(drop)\n}\n\n/// Duplicate `fd` with Stdout, i.e., Stdout redirection.\n///\n/// # Examples\n///\n/// Redirect the Stdout to file foo and restore it:\n///\n/// ```no_run\n/// use nix::fcntl::open;\n/// use nix::fcntl::OFlag;\n/// use nix::sys::stat::Mode;\n/// use nix::unistd::dup;\n/// use nix::unistd::dup2_stdout;\n/// use std::io::{stdout, Write};\n///\n/// let mut stdout = stdout();\n///\n/// // Save the previous Stdout so that we can restore it\n/// let saved_stdout = dup(\u0026stdout).unwrap();\n/// let foo = open(\n///     \"foo\",\n///     OFlag::O_RDWR | OFlag::O_CLOEXEC | OFlag::O_CREAT | OFlag::O_EXCL,\n///     Mode::S_IRWXU,\n/// )\n/// .unwrap();\n/// // Now our Stdout has been redirected to file foo\n/// dup2_stdout(foo).unwrap();\n/// // Let's say hi to foo\n/// // NOTE: add a newline here to flush the buffer\n/// stdout.write(b\"Hi, foo!\\n\").unwrap();\n///\n/// // Restore the Stdout\n/// dup2_stdout(saved_stdout).unwrap();\n///\n/// // Let's say hi to Stdout\n/// // NOTE: add a newline here to flush the buffer\n/// stdout.write(b\"Hi, Stdout!\\n\").unwrap();\n/// ```\n#[inline]\npub fn dup2_stdout\u003cFd: std::os::fd::AsFd\u003e(fd: Fd) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n    use libc::STDOUT_FILENO;\n\n    let res = unsafe { libc::dup2(fd.as_fd().as_raw_fd(), STDOUT_FILENO) };\n    Errno::result(res).map(drop)\n}\n\n/// Duplicate `fd` with Stderr, i.e., Stderr redirection.\n///\n/// # Examples\n///\n/// See the example of [`dup2_stdout()`](fn.dup2_stdout.html#examples)\n#[inline]\npub fn dup2_stderr\u003cFd: std::os::fd::AsFd\u003e(fd: Fd) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n    use libc::STDERR_FILENO;\n\n    let res = unsafe { libc::dup2(fd.as_fd().as_raw_fd(), STDERR_FILENO) };\n    Errno::result(res).map(drop)\n}\n\n/// Create a copy of `oldfd` using `newfd`.\n///\n/// This function behaves similar to `dup()` except that it will try to use the\n/// specified fd `newfd` instead of allocating a new one. See the man pages for\n/// more detail on the exact behavior of this function.\n///\n/// This function does not allow you to duplicate `oldfd` with any file descriptor\n/// you want, to do that, use [`dup2_raw()`].\n///\n/// # Stdin/Stdout/Stderr redirection\n///\n/// To duplicate a fd with Stdin/Stdout/Stderr, see:\n///\n/// * [`dup2_stdin()`]\n/// * [`dup2_stdout()`]\n/// * [`dup2_stderr()`]\n///\n/// # Reference\n///\n/// [dup(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/dup.html)\n#[inline]\npub fn dup2\u003cFd: std::os::fd::AsFd\u003e(oldfd: Fd, newfd: \u0026mut std::os::fd::OwnedFd) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = unsafe { libc::dup2(oldfd.as_fd().as_raw_fd(), newfd.as_raw_fd()) };\n\n    Errno::result(res).map(drop)\n}\n\n/// Create a copy of `oldfd` with any fd value you want.\n///\n/// # Safety\n///\n/// Since this function returns an `OwnedFd`, you have to ensure that the returned\n/// `OwnedFd` is the ONLY owner of the file descriptor specified `newfd`. Otherwise,\n/// double close could happen.\n///\n/// ```no_run\n/// # use nix::{\n/// #     fcntl::{open, OFlag},\n/// #     sys::stat::Mode,\n/// #     unistd::dup2_raw,\n/// # };\n/// # use std::os::fd::OwnedFd;\n/// # use std::os::fd::AsRawFd;\n/// let oldfd: OwnedFd = open(\"foo\", OFlag::O_RDONLY, Mode::empty()).unwrap();\n/// let newfd: OwnedFd = open(\"bar\", OFlag::O_RDONLY, Mode::empty()).unwrap();\n///\n/// // SAFETY:\n/// // it is NOT safe.\n/// // NOTE that we are passing a RawFd to `newfd`\n/// let duplicated_fd: OwnedFd = unsafe { dup2_raw(\u0026oldfd, newfd.as_raw_fd()) }.unwrap();\n///\n/// // `newfd` and `duplicated_fd` refer to the same file descriptor, and\n/// // they are both owned, double close will happen here.\n/// ```\n///\n/// # Examples\n///\n/// Duplicate a file descriptor with a descriptor that is still not open:\n///\n/// ```no_run\n/// # use nix::{\n/// #     fcntl::{open, OFlag},\n/// #     sys::stat::Mode,\n/// #     unistd::dup2_raw,\n/// # };\n/// let oldfd = open(\"foo\", OFlag::O_RDONLY, Mode::empty()).unwrap();\n///\n/// // SAFETY:\n/// // It is safe given that we are sure that fd 100 is not open, and the returned\n/// // OwnedFd will be its only owner.\n/// let duplicated_fd = unsafe { dup2_raw(\u0026oldfd, 100) }.unwrap();\n///\n/// // do something with `duplicated_fd`\n/// ```\n///\n/// The code demonstrating double close can be fixed by passing `newfd` by value:\n///\n/// ```no_run\n/// # use nix::{\n/// #     fcntl::{open, OFlag},\n/// #     sys::stat::Mode,\n/// #     unistd::dup2_raw,\n/// # };\n/// # use std::os::fd::OwnedFd;\n/// let oldfd: OwnedFd = open(\"foo\", OFlag::O_RDONLY, Mode::empty()).unwrap();\n/// let newfd: OwnedFd = open(\"bar\", OFlag::O_RDONLY, Mode::empty()).unwrap();\n///\n/// // SAFETY:\n/// // it is safe since `duplicated_fd` is the only owner of the fd it refers to.\n/// // NOTE that we are passing `newfd` by value, i.e., transfer the ownership\n/// let duplicated_fd: OwnedFd = unsafe { dup2_raw(\u0026oldfd, newfd) }.unwrap();\n/// ```\n///\n/// # Reference\n///\n/// * [POSIX manual](https://pubs.opengroup.org/onlinepubs/9699919799/functions/dup.html)\n///\n/// # See also\n///\n/// * [`dup2()`]\n#[inline]\npub unsafe fn dup2_raw\u003cFd1: std::os::fd::AsFd, Fd2: std::os::fd::IntoRawFd\u003e(oldfd: Fd1, newfd: Fd2) -\u003e Result\u003cstd::os::fd::OwnedFd\u003e {\n    use std::os::fd::AsRawFd;\n    use std::os::fd::FromRawFd;\n    use std::os::fd::OwnedFd;\n\n    let duplicated_fd = unsafe {\n        libc::dup2(oldfd.as_fd().as_raw_fd(), newfd.into_raw_fd())\n    };\n    // SAFETY:\n    //\n    // This is unsafe if `newfd` is not a file descriptor that can be consumed\n    Ok(unsafe {\n        OwnedFd::from_raw_fd(duplicated_fd)\n    })\n}\n\n/// Create a new copy of the specified file descriptor using the specified fd\n/// and flags.\n///\n/// This function behaves similar to [`dup2()`] but allows flags to be specified\n/// for the new file descriptor. Currently, the only flag that is allowed is\n/// [`OFlag::O_CLOEXEC`], setting other flags will return `EINVAL`. Also, if\n/// `oldfd` and `newfd` have the same fd value, `EINVAL` will also be returned.\n///\n/// This function does not allow you to duplicate `oldfd` with any file descriptor\n/// you want, to do that, use [`dup3_raw()`].\n///\n/// # References\n///\n/// * [FreeBSD](https://man.freebsd.org/cgi/man.cgi?query=dup3\u0026sektion=3)\n/// * [Linux](https://man7.org/linux/man-pages/man2/dup.2.html)\n/// * [NetBSD](https://man.netbsd.org/dup3.2)\n/// * [OpenBSD](https://man.openbsd.org/dup3.2)\n#[cfg(any(\n    netbsdlike,\n    solarish,\n    target_os = \"freebsd\",\n    target_os = \"fuchsia\",\n    target_os = \"hurd\",\n    target_os = \"linux\"\n))]\npub fn dup3\u003cFd: std::os::fd::AsFd\u003e(oldfd: Fd, newfd: \u0026mut std::os::fd::OwnedFd, flags: OFlag) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = unsafe { libc::dup3(oldfd.as_fd().as_raw_fd(), newfd.as_raw_fd(), flags.bits()) };\n    Errno::result(res).map(drop)\n}\n\n/// Create a new copy of the specified file descriptor using the specified fd\n/// and flags.\n///\n/// This function behaves similar to [`dup3()`] except for it allows you to specify\n/// arbitrary fd values.\n///\n/// # Safety\n///\n/// Since this function returns an `OwnedFd`, you have to ensure that the returned\n/// `OwnedFd` is the ONLY owner of the file descriptor specified `newfd`. Otherwise,\n/// double close could happen.\n///\n/// For more information, see the documentation of [`dup2_raw()`].\n///\n/// # References\n///\n/// * [FreeBSD](https://man.freebsd.org/cgi/man.cgi?query=dup3\u0026sektion=3)\n/// * [Linux](https://man7.org/linux/man-pages/man2/dup.2.html)\n/// * [NetBSD](https://man.netbsd.org/dup3.2)\n/// * [OpenBSD](https://man.openbsd.org/dup3.2)\n///\n/// # See also\n///\n/// * [`dup3()`]\n#[cfg(any(\n    netbsdlike,\n    solarish,\n    target_os = \"freebsd\",\n    target_os = \"fuchsia\",\n    target_os = \"hurd\",\n    target_os = \"linux\"\n))]\npub unsafe fn dup3_raw\u003cFd1: std::os::fd::AsFd, Fd2: std::os::fd::IntoRawFd\u003e(oldfd: Fd1, newfd: Fd2, flags: OFlag) -\u003e Result\u003cstd::os::fd::OwnedFd\u003e {\n    use std::os::fd::AsRawFd;\n    use std::os::fd::OwnedFd;\n    use std::os::fd::FromRawFd;\n\n    let res = unsafe { libc::dup3(oldfd.as_fd().as_raw_fd(), newfd.into_raw_fd(), flags.bits()) };\n    Errno::result(res)?;\n\n    // SAFETY:\n    //\n    // This is unsafe if `newfd` is not a file descriptor that can be consumed\n    Ok(unsafe {\n        OwnedFd::from_raw_fd(res)\n    })\n}\n\n/// Change the current working directory of the calling process (see\n/// [chdir(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/chdir.html)).\n///\n/// This function may fail in a number of different scenarios.  See the man\n/// pages for additional details on possible failure cases.\n#[inline]\npub fn chdir\u003cP: ?Sized + NixPath\u003e(path: \u0026P) -\u003e Result\u003c()\u003e {\n    let res =\n        path.with_nix_path(|cstr| unsafe { libc::chdir(cstr.as_ptr()) })?;\n\n    Errno::result(res).map(drop)\n}\n\n/// Change the current working directory of the process to the one\n/// given as an open file descriptor (see\n/// [fchdir(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fchdir.html)).\n///\n/// This function may fail in a number of different scenarios.  See the man\n/// pages for additional details on possible failure cases.\n#[inline]\n#[cfg(not(target_os = \"fuchsia\"))]\npub fn fchdir\u003cFd: std::os::fd::AsFd\u003e(dirfd: Fd) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = unsafe { libc::fchdir(dirfd.as_fd().as_raw_fd()) };\n\n    Errno::result(res).map(drop)\n}\n\n/// Creates new directory `path` with access rights `mode`.  (see [mkdir(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdir.html))\n///\n/// # Errors\n///\n/// There are several situations where mkdir might fail:\n///\n/// - current user has insufficient rights in the parent directory\n/// - the path already exists\n/// - the path name is too long (longer than `PATH_MAX`, usually 4096 on linux, 1024 on OS X)\n///\n/// # Example\n///\n/// ```rust\n/// use nix::unistd;\n/// use nix::sys::stat;\n/// use tempfile::tempdir;\n///\n/// let tmp_dir1 = tempdir().unwrap();\n/// let tmp_dir2 = tmp_dir1.path().join(\"new_dir\");\n///\n/// // create new directory and give read, write and execute rights to the owner\n/// match unistd::mkdir(\u0026tmp_dir2, stat::Mode::S_IRWXU) {\n///    Ok(_) =\u003e println!(\"created {:?}\", tmp_dir2),\n///    Err(err) =\u003e println!(\"Error creating directory: {}\", err),\n/// }\n/// ```\n#[inline]\npub fn mkdir\u003cP: ?Sized + NixPath\u003e(path: \u0026P, mode: crate::sys::stat::Mode) -\u003e Result\u003c()\u003e {\n    let res = path.with_nix_path(|cstr| unsafe {\n        libc::mkdir(cstr.as_ptr(), mode.bits() as libc::mode_t)\n    })?;\n\n    Errno::result(res).map(drop)\n}\n\n/// Creates new FIFO special file (named pipe) with path `path` and access rights `mode`.\n///\n/// # Errors\n///\n/// There are several situations where mkfifo might fail:\n///\n/// - current user has insufficient rights in the parent directory\n/// - the path already exists\n/// - the path name is too long (longer than `PATH_MAX`, usually 4096 on linux, 1024 on OS X)\n///\n/// For a full list consult\n/// [posix specification](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkfifo.html)\n///\n/// # Example\n///\n/// ```rust\n/// use nix::unistd;\n/// use nix::sys::stat;\n/// use tempfile::tempdir;\n///\n/// let tmp_dir = tempdir().unwrap();\n/// let fifo_path = tmp_dir.path().join(\"foo.pipe\");\n///\n/// // create new fifo and give read, write and execute rights to the owner\n/// match unistd::mkfifo(\u0026fifo_path, stat::Mode::S_IRWXU) {\n///    Ok(_) =\u003e println!(\"created {:?}\", fifo_path),\n///    Err(err) =\u003e println!(\"Error creating fifo: {}\", err),\n/// }\n/// ```\n#[inline]\n#[cfg(not(target_os = \"redox\"))] // RedoxFS does not support fifo yet\npub fn mkfifo\u003cP: ?Sized + NixPath\u003e(path: \u0026P, mode: crate::sys::stat::Mode) -\u003e Result\u003c()\u003e {\n    let res = path.with_nix_path(|cstr| unsafe {\n        libc::mkfifo(cstr.as_ptr(), mode.bits() as libc::mode_t)\n    })?;\n\n    Errno::result(res).map(drop)\n}\n\n/// Creates new FIFO special file (named pipe) with access rights set to `mode`\n/// in the path specified by `dirfd` and `path`.\n///\n/// # Examples\n///\n/// Create a FIFO in the current working directory:\n///\n/// ```no_run\n/// use nix::fcntl::AT_FDCWD;\n/// use nix::unistd::mkfifoat;\n/// use nix::sys::stat::Mode;\n///\n/// mkfifoat(AT_FDCWD, \"fifo\", Mode::S_IRWXU).unwrap();\n/// ```\n///\n/// # References\n///\n/// [mkfifoat(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkfifoat.html).\n// mkfifoat is not implemented in OSX or android\n#[inline]\n#[cfg(not(any(\n    apple_targets,\n    target_os = \"haiku\",\n    target_os = \"android\",\n    target_os = \"redox\"\n)))]\npub fn mkfifoat\u003cFd: std::os::fd::AsFd, P: ?Sized + NixPath\u003e(\n    dirfd: Fd,\n    path: \u0026P,\n    mode: crate::sys::stat::Mode,\n) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = path.with_nix_path(|cstr| unsafe {\n        libc::mkfifoat(dirfd.as_fd().as_raw_fd(), cstr.as_ptr(), mode.bits() as libc::mode_t)\n    })?;\n\n    Errno::result(res).map(drop)\n}\n\n/// Creates a symbolic link to `path1` in the path specified by `dirfd` and\n/// `path2`.\n///\n/// # Examples\n///\n/// Assume file `foo` exists in the current working directory, create a symlink\n/// to it:\n///\n/// ```no_run\n/// use nix::fcntl::AT_FDCWD;\n/// use nix::unistd::symlinkat;\n///\n/// symlinkat(\"foo\", AT_FDCWD, \"link_to_foo\").unwrap();\n/// ```\n///\n/// # References\n///\n/// [POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/functions/symlinkat.html)\n#[cfg(not(target_os = \"redox\"))]\npub fn symlinkat\u003cFd: std::os::fd::AsFd, P1: ?Sized + NixPath, P2: ?Sized + NixPath\u003e(\n    path1: \u0026P1,\n    dirfd: Fd,\n    path2: \u0026P2,\n) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = path1.with_nix_path(|path1| {\n        path2.with_nix_path(|path2| unsafe {\n            libc::symlinkat(\n                path1.as_ptr(),\n                dirfd.as_fd().as_raw_fd(),\n                path2.as_ptr(),\n            )\n        })\n    })??;\n    Errno::result(res).map(drop)\n}\n}\n\n// Double the buffer capacity up to limit. In case it already has\n// reached the limit, return Errno::ERANGE.\n#[cfg(any(feature = \"fs\", feature = \"user\"))]\nfn reserve_double_buffer_size\u003cT\u003e(buf: \u0026mut Vec\u003cT\u003e, limit: usize) -\u003e Result\u003c()\u003e {\n    use std::cmp::min;\n\n    if buf.capacity() \u003e= limit {\n        return Err(Errno::ERANGE);\n    }\n\n    let capacity = min(buf.capacity() * 2, limit);\n    buf.reserve(capacity);\n\n    Ok(())\n}\n\nfeature! {\n#![feature = \"fs\"]\n\n/// Returns the current directory as a `PathBuf`\n///\n/// Err is returned if the current user doesn't have the permission to read or search a component\n/// of the current path.\n///\n/// # Example\n///\n/// ```rust\n/// use nix::unistd;\n///\n/// // assume that we are allowed to get current directory\n/// let dir = unistd::getcwd().unwrap();\n/// println!(\"The current directory is {:?}\", dir);\n/// ```\n#[inline]\npub fn getcwd() -\u003e Result\u003cPathBuf\u003e {\n    let mut buf = Vec::\u003cu8\u003e::with_capacity(512);\n    loop {\n        unsafe {\n            let ptr = buf.as_mut_ptr().cast();\n\n            // The buffer must be large enough to store the absolute pathname plus\n            // a terminating null byte, or else null is returned.\n            // To safely handle this we start with a reasonable size (512 bytes)\n            // and double the buffer size upon every error\n            if !libc::getcwd(ptr, buf.capacity()).is_null() {\n                let len = CStr::from_ptr(buf.as_ptr().cast())\n                    .to_bytes()\n                    .len();\n                buf.set_len(len);\n                buf.shrink_to_fit();\n                return Ok(PathBuf::from(OsString::from_vec(buf)));\n            } else {\n                let error = Errno::last();\n                // ERANGE means buffer was too small to store directory name\n                if error != Errno::ERANGE {\n                    return Err(error);\n                }\n            }\n\n            #[cfg(not(target_os = \"hurd\"))]\n            const PATH_MAX: usize = libc::PATH_MAX as usize;\n            #[cfg(target_os = \"hurd\")]\n            const PATH_MAX: usize = 1024; // Hurd does not define a hard limit, so try a guess first\n\n            // Trigger the internal buffer resizing logic.\n            reserve_double_buffer_size(\u0026mut buf, PATH_MAX)?;\n        }\n    }\n}\n}\n\nfeature! {\n#![all(feature = \"user\", feature = \"fs\")]\n\n/// Computes the raw UID and GID values to pass to a `*chown` call.\n// The cast is not unnecessary on all platforms.\n#[allow(clippy::unnecessary_cast)]\nfn chown_raw_ids(owner: Option\u003cUid\u003e, group: Option\u003cGid\u003e) -\u003e (uid_t, gid_t) {\n    // According to the POSIX specification, -1 is used to indicate that owner and group\n    // are not to be changed.  Since uid_t and gid_t are unsigned types, we have to wrap\n    // around to get -1.\n    let uid = owner\n        .map(Into::into)\n        .unwrap_or_else(|| (0 as uid_t).wrapping_sub(1));\n    let gid = group\n        .map(Into::into)\n        .unwrap_or_else(|| (0 as gid_t).wrapping_sub(1));\n    (uid, gid)\n}\n\n/// Change the ownership of the file at `path` to be owned by the specified\n/// `owner` (user) and `group` (see\n/// [chown(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/chown.html)).\n///\n/// The owner/group for the provided path name will not be modified if `None` is\n/// provided for that argument.  Ownership change will be attempted for the path\n/// only if `Some` owner/group is provided.\n#[inline]\npub fn chown\u003cP: ?Sized + NixPath\u003e(\n    path: \u0026P,\n    owner: Option\u003cUid\u003e,\n    group: Option\u003cGid\u003e,\n) -\u003e Result\u003c()\u003e {\n    let res = path.with_nix_path(|cstr| {\n        let (uid, gid) = chown_raw_ids(owner, group);\n        unsafe { libc::chown(cstr.as_ptr(), uid, gid) }\n    })?;\n\n    Errno::result(res).map(drop)\n}\n\n/// Change the ownership of the file referred to by the open file descriptor\n/// `fd` to be owned by the specified `owner` (user) and `group`.\n///\n/// The owner/group for the provided file will not be modified if `None` is\n/// provided for that argument.  Ownership change will be attempted for the path\n/// only if `Some` owner/group is provided.\n///\n/// See also [`fchown(2)`](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fchown.html).\n#[inline]\npub fn fchown\u003cFd: std::os::fd::AsFd\u003e(fd: Fd, owner: Option\u003cUid\u003e, group: Option\u003cGid\u003e) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let (uid, gid) = chown_raw_ids(owner, group);\n    let res = unsafe { libc::fchown(fd.as_fd().as_raw_fd(), uid, gid) };\n    Errno::result(res).map(drop)\n}\n\n// Just a wrapper around `AtFlags` so that we can help our users migrate.\n#[allow(missing_docs)]\n#[cfg(not(target_os = \"redox\"))]\npub type FchownatFlags = AtFlags;\n#[allow(missing_docs)]\n#[cfg(not(target_os = \"redox\"))]\nimpl FchownatFlags {\n    #[deprecated(since = \"0.28.0\", note = \"The variant is deprecated, please use `AtFlags` instead\")]\n    #[allow(non_upper_case_globals)]\n    pub const FollowSymlink: FchownatFlags = FchownatFlags::empty();\n    #[deprecated(since = \"0.28.0\", note = \"The variant is deprecated, please use `AtFlags` instead\")]\n    #[allow(non_upper_case_globals)]\n    pub const NoFollowSymlink: FchownatFlags = FchownatFlags::AT_SYMLINK_NOFOLLOW;\n}\n\n/// Change the ownership of the file at `path` to be owned by the specified\n/// `owner` (user) and `group`.\n///\n/// The owner/group for the provided path name will not be modified if `None` is\n/// provided for that argument.  Ownership change will be attempted for the path\n/// only if `Some` owner/group is provided.\n///\n/// If `flag` is `AtFlags::AT_SYMLINK_NOFOLLOW` and `path` names a symbolic link,\n/// then the mode of the symbolic link is changed.\n///\n/// `fchownat(AT_FDCWD, path, owner, group, AtFlags::AT_SYMLINK_NOFOLLOW)` is identical to\n/// a call `libc::lchown(path, owner, group)`.  That's why `lchown` is unimplemented in\n/// the `nix` crate.\n///\n/// # References\n///\n/// [fchownat(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fchownat.html).\n#[cfg(not(target_os = \"redox\"))]\npub fn fchownat\u003cFd: std::os::fd::AsFd, P: ?Sized + NixPath\u003e(\n    dirfd: Fd,\n    path: \u0026P,\n    owner: Option\u003cUid\u003e,\n    group: Option\u003cGid\u003e,\n    flag: AtFlags,\n) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = path.with_nix_path(|cstr| unsafe {\n        let (uid, gid) = chown_raw_ids(owner, group);\n        libc::fchownat(\n            dirfd.as_fd().as_raw_fd(),\n            cstr.as_ptr(),\n            uid,\n            gid,\n            flag.bits()\n        )\n    })?;\n\n    Errno::result(res).map(drop)\n}\n}\n\nfeature! {\n#![feature = \"process\"]\nfn to_exec_array\u003cS: AsRef\u003cCStr\u003e\u003e(args: \u0026[S]) -\u003e Vec\u003c*const c_char\u003e {\n    use std::iter::once;\n    args.iter()\n        .map(|s| s.as_ref().as_ptr())\n        .chain(once(ptr::null()))\n        .collect()\n}\n\n/// Replace the current process image with a new one (see\n/// [exec(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html)).\n///\n/// See the `::nix::unistd::execve` system call for additional details.  `execv`\n/// performs the same action but does not allow for customization of the\n/// environment for the new process.\n#[inline]\npub fn execv\u003cS: AsRef\u003cCStr\u003e\u003e(path: \u0026CStr, argv: \u0026[S]) -\u003e Result\u003cInfallible\u003e {\n    let args_p = to_exec_array(argv);\n\n    unsafe { libc::execv(path.as_ptr(), args_p.as_ptr()) };\n\n    Err(Errno::last())\n}\n\n/// Replace the current process image with a new one (see\n/// [execve(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html)).\n///\n/// The execve system call allows for another process to be \"called\" which will\n/// replace the current process image.  That is, this process becomes the new\n/// command that is run. On success, this function will not return. Instead,\n/// the new program will run until it exits.\n///\n/// `::nix::unistd::execv` and `::nix::unistd::execve` take as arguments a slice\n/// of `::std::ffi::CString`s for `args` and `env` (for `execve`). Each element\n/// in the `args` list is an argument to the new process. Each element in the\n/// `env` list should be a string in the form \"key=value\".\n#[inline]\npub fn execve\u003cSA: AsRef\u003cCStr\u003e, SE: AsRef\u003cCStr\u003e\u003e(\n    path: \u0026CStr,\n    args: \u0026[SA],\n    env: \u0026[SE],\n) -\u003e Result\u003cInfallible\u003e {\n    let args_p = to_exec_array(args);\n    let env_p = to_exec_array(env);\n\n    unsafe { libc::execve(path.as_ptr(), args_p.as_ptr(), env_p.as_ptr()) };\n\n    Err(Errno::last())\n}\n\n/// Replace the current process image with a new one and replicate shell `PATH`\n/// searching behavior (see\n/// [exec(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html)).\n///\n/// See `::nix::unistd::execve` for additional details.  `execvp` behaves the\n/// same as execv except that it will examine the `PATH` environment variables\n/// for file names not specified with a leading slash.  For example, `execv`\n/// would not work if \"bash\" was specified for the path argument, but `execvp`\n/// would assuming that a bash executable was on the system `PATH`.\n#[inline]\npub fn execvp\u003cS: AsRef\u003cCStr\u003e\u003e(\n    filename: \u0026CStr,\n    args: \u0026[S],\n) -\u003e Result\u003cInfallible\u003e {\n    let args_p = to_exec_array(args);\n\n    unsafe { libc::execvp(filename.as_ptr(), args_p.as_ptr()) };\n\n    Err(Errno::last())\n}\n\n/// Replace the current process image with a new one and replicate shell `PATH`\n/// searching behavior (see\n/// [`execvpe(3)`](https://man7.org/linux/man-pages/man3/exec.3.html)).\n///\n/// This functions like a combination of `execvp(2)` and `execve(2)` to pass an\n/// environment and have a search path. See these two for additional\n/// information.\n#[cfg(any(target_os = \"haiku\", target_os = \"hurd\", target_os = \"linux\", target_os = \"openbsd\"))]\npub fn execvpe\u003cSA: AsRef\u003cCStr\u003e, SE: AsRef\u003cCStr\u003e\u003e(\n    filename: \u0026CStr,\n    args: \u0026[SA],\n    env: \u0026[SE],\n) -\u003e Result\u003cInfallible\u003e {\n    let args_p = to_exec_array(args);\n    let env_p = to_exec_array(env);\n\n    unsafe {\n        libc::execvpe(filename.as_ptr(), args_p.as_ptr(), env_p.as_ptr())\n    };\n\n    Err(Errno::last())\n}\n\n/// Replace the current process image with a new one (see\n/// [fexecve(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fexecve.html)).\n///\n/// The `fexecve` function allows for another process to be \"called\" which will\n/// replace the current process image.  That is, this process becomes the new\n/// command that is run. On success, this function will not return. Instead,\n/// the new program will run until it exits.\n///\n/// This function is similar to `execve`, except that the program to be executed\n/// is referenced as a file descriptor instead of a path.\n#[cfg(any(linux_android, freebsdlike, target_os = \"hurd\"))]\n#[inline]\npub fn fexecve\u003cFd: std::os::fd::AsFd, SA: AsRef\u003cCStr\u003e, SE: AsRef\u003cCStr\u003e\u003e(\n    fd: Fd,\n    args: \u0026[SA],\n    env: \u0026[SE],\n) -\u003e Result\u003cInfallible\u003e {\n    use std::os::fd::AsRawFd;\n\n    let args_p = to_exec_array(args);\n    let env_p = to_exec_array(env);\n\n    unsafe { libc::fexecve(fd.as_fd().as_raw_fd(), args_p.as_ptr(), env_p.as_ptr()) };\n\n    Err(Errno::last())\n}\n\n/// Execute program relative to a directory file descriptor (see\n/// [execveat(2)](https://man7.org/linux/man-pages/man2/execveat.2.html)).\n///\n/// The `execveat` function allows for another process to be \"called\" which will\n/// replace the current process image.  That is, this process becomes the new\n/// command that is run. On success, this function will not return. Instead,\n/// the new program will run until it exits.\n///\n/// This function is similar to `execve`, except that the program to be executed\n/// is referenced as a file descriptor to the base directory plus a path.\n#[cfg(linux_android)]\n#[inline]\npub fn execveat\u003cFd: std::os::fd::AsFd, SA: AsRef\u003cCStr\u003e, SE: AsRef\u003cCStr\u003e\u003e(\n    dirfd: Fd,\n    pathname: \u0026CStr,\n    args: \u0026[SA],\n    env: \u0026[SE],\n    flags: super::fcntl::AtFlags,\n) -\u003e Result\u003cInfallible\u003e {\n    use std::os::fd::AsRawFd;\n\n    let args_p = to_exec_array(args);\n    let env_p = to_exec_array(env);\n\n    unsafe {\n        libc::syscall(\n            libc::SYS_execveat,\n            dirfd.as_fd().as_raw_fd(),\n            pathname.as_ptr(),\n            args_p.as_ptr(),\n            env_p.as_ptr(),\n            flags,\n        );\n    };\n\n    Err(Errno::last())\n}\n\n/// Daemonize this process by detaching from the controlling terminal (see\n/// [daemon(3)](https://man7.org/linux/man-pages/man3/daemon.3.html)).\n///\n/// When a process is launched it is typically associated with a parent and it,\n/// in turn, by its controlling terminal/process.  In order for a process to run\n/// in the \"background\" it must daemonize itself by detaching itself.  Under\n/// posix, this is done by doing the following:\n///\n/// 1. Parent process (this one) forks\n/// 2. Parent process exits\n/// 3. Child process continues to run.\n///\n/// `nochdir`:\n///\n/// * `nochdir = true`: The current working directory after daemonizing will\n///    be the current working directory.\n/// *  `nochdir = false`: The current working directory after daemonizing will\n///    be the root direcory, `/`.\n///\n/// `noclose`:\n///\n/// * `noclose = true`: The process' current stdin, stdout, and stderr file\n///   descriptors will remain identical after daemonizing.\n/// * `noclose = false`: The process' stdin, stdout, and stderr will point to\n///   `/dev/null` after daemonizing.\n#[cfg(any(\n        linux_android,\n        freebsdlike,\n        solarish,\n        netbsdlike\n))]\npub fn daemon(nochdir: bool, noclose: bool) -\u003e Result\u003c()\u003e {\n    let res = unsafe { libc::daemon(nochdir as c_int, noclose as c_int) };\n    Errno::result(res).map(drop)\n}\n}\n\nfeature! {\n#![feature = \"hostname\"]\n\n/// Set the system host name (see\n/// [sethostname(2)](https://man7.org/linux/man-pages/man2/gethostname.2.html)).\n///\n/// Given a name, attempt to update the system host name to the given string.\n/// On some systems, the host name is limited to as few as 64 bytes.  An error\n/// will be returned if the name is not valid or the current process does not\n/// have permissions to update the host name.\n#[cfg(not(target_os = \"redox\"))]\npub fn sethostname\u003cS: AsRef\u003cOsStr\u003e\u003e(name: S) -\u003e Result\u003c()\u003e {\n    // Handle some differences in type of the len arg across platforms.\n    cfg_if! {\n        if #[cfg(any(freebsdlike,\n                     solarish,\n                     apple_targets,\n                     target_os = \"aix\"))] {\n            type sethostname_len_t = c_int;\n        } else {\n            type sethostname_len_t = size_t;\n        }\n    }\n    let ptr = name.as_ref().as_bytes().as_ptr().cast();\n    let len = name.as_ref().len() as sethostname_len_t;\n\n    let res = unsafe { libc::sethostname(ptr, len) };\n    Errno::result(res).map(drop)\n}\n\n/// Get the host name and store it in an internally allocated buffer, returning an\n/// `OsString` on success.\n///\n/// This function call attempts to get the host name for the running system and\n/// store it in an internal buffer, returning it as an `OsString` if successful.\n///\n/// # Examples\n///\n/// ```no_run\n/// use nix::unistd;\n///\n/// let hostname = unistd::gethostname().expect(\"Failed getting hostname\");\n/// let hostname = hostname.into_string().expect(\"Hostname wasn't valid UTF-8\");\n/// println!(\"Hostname: {}\", hostname);\n/// ```\n///\n/// See also [gethostname(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/gethostname.html).\npub fn gethostname() -\u003e Result\u003cOsString\u003e {\n    // The capacity is the max length of a hostname plus the NUL terminator.\n    let mut buffer: Vec\u003cu8\u003e = Vec::with_capacity(256);\n    let ptr = buffer.as_mut_ptr().cast();\n    let len = buffer.capacity() as size_t;\n\n    let res = unsafe { libc::gethostname(ptr, len) };\n    Errno::result(res).map(|_| {\n        unsafe {\n            buffer.as_mut_ptr().wrapping_add(len - 1).write(0); // ensure always null-terminated\n            let len = CStr::from_ptr(buffer.as_ptr().cast()).len();\n            buffer.set_len(len);\n        }\n        OsString::from_vec(buffer)\n    })\n}\n}\n\n/// Close a file descriptor.\n///\n/// If `fd` is an owned file descriptor, it is generally preferred to call\n/// `drop(fd)` rather than `close(fd)`.\npub fn close\u003cFd: std::os::fd::IntoRawFd\u003e(fd: Fd) -\u003e Result\u003c()\u003e {\n    let res = unsafe { libc::close(fd.into_raw_fd()) };\n    Errno::result(res).map(drop)\n}\n\n/// Read from a raw file descriptor.\n///\n/// See also [read(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/read.html)\npub fn read\u003cFd: std::os::fd::AsFd\u003e(fd: Fd, buf: \u0026mut [u8]) -\u003e Result\u003cusize\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = unsafe {\n        libc::read(\n            fd.as_fd().as_raw_fd(),\n            buf.as_mut_ptr().cast(),\n            buf.len() as size_t,\n        )\n    };\n\n    Errno::result(res).map(|r| r as usize)\n}\n\n/// Write to a raw file descriptor.\n///\n/// See also [write(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html)\npub fn write\u003cFd: std::os::fd::AsFd\u003e(fd: Fd, buf: \u0026[u8]) -\u003e Result\u003cusize\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = unsafe {\n        libc::write(\n            fd.as_fd().as_raw_fd(),\n            buf.as_ptr().cast(),\n            buf.len() as size_t,\n        )\n    };\n\n    Errno::result(res).map(|r| r as usize)\n}\n\nfeature! {\n#![feature = \"fs\"]\n\n/// Directive that tells [`lseek`] and [`lseek64`] what the offset is relative to.\n///\n/// [`lseek`]: ./fn.lseek.html\n/// [`lseek64`]: ./fn.lseek64.html\n#[repr(i32)]\n#[derive(Clone, Copy, Debug)]\npub enum Whence {\n    /// Specify an offset relative to the start of the file.\n    SeekSet = libc::SEEK_SET,\n    /// Specify an offset relative to the current file location.\n    SeekCur = libc::SEEK_CUR,\n    /// Specify an offset relative to the end of the file.\n    SeekEnd = libc::SEEK_END,\n    /// Specify an offset relative to the next location in the file greater than or\n    /// equal to offset that contains some data. If offset points to\n    /// some data, then the file offset is set to offset.\n    #[cfg(any(\n        apple_targets,\n        freebsdlike,\n        solarish,\n        target_os = \"hurd\",\n        target_os = \"linux\",\n    ))]\n    SeekData = libc::SEEK_DATA,\n    /// Specify an offset relative to the next hole in the file greater than\n    /// or equal to offset. If offset points into the middle of a hole, then\n    /// the file offset should be set to offset. If there is no hole past offset,\n    /// then the file offset should be adjusted to the end of the file (i.e., there\n    /// is an implicit hole at the end of any file).\n    #[cfg(any(\n        apple_targets,\n        freebsdlike,\n        solarish,\n        target_os = \"hurd\",\n        target_os = \"linux\",\n    ))]\n    SeekHole = libc::SEEK_HOLE,\n}\n\n/// Move the read/write file offset.\n///\n/// See also [lseek(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/lseek.html)\npub fn lseek\u003cFd: std::os::fd::AsFd\u003e(fd: Fd, offset: off_t, whence: Whence) -\u003e Result\u003coff_t\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = unsafe { libc::lseek(fd.as_fd().as_raw_fd(), offset, whence as i32) };\n\n    Errno::result(res).map(|r| r as off_t)\n}\n\n/// Move the read/write file offset.\n///\n/// Unlike [`lseek`], it takes a 64-bit argument even on platforms where [`libc::off_t`] is\n/// 32 bits.\n#[cfg(linux_android)]\npub fn lseek64\u003cFd: std::os::fd::AsFd\u003e(\n    fd: Fd,\n    offset: libc::off64_t,\n    whence: Whence,\n) -\u003e Result\u003clibc::off64_t\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = unsafe { libc::lseek64(fd.as_fd().as_raw_fd(), offset, whence as i32) };\n\n    Errno::result(res).map(|r| r as libc::off64_t)\n}\n}\n\n/// Create an interprocess channel.\n///\n/// See also [pipe(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pipe.html)\npub fn pipe(\n) -\u003e std::result::Result\u003c(std::os::fd::OwnedFd, std::os::fd::OwnedFd), Error\u003e {\n    let mut fds = mem::MaybeUninit::\u003c[std::os::fd::OwnedFd; 2]\u003e::uninit();\n\n    let res = unsafe { libc::pipe(fds.as_mut_ptr().cast()) };\n\n    Error::result(res)?;\n\n    let [read, write] = unsafe { fds.assume_init() };\n    Ok((read, write))\n}\n\nfeature! {\n#![feature = \"fs\"]\n/// Like `pipe`, but allows setting certain file descriptor flags.\n///\n/// The following flags are supported, and will be set atomically as the pipe is\n/// created:\n///\n/// - `O_CLOEXEC`:    Set the close-on-exec flag for the new file descriptors.\n#[cfg_attr(\n    target_os = \"linux\",\n    doc = \"- `O_DIRECT`: Create a pipe that performs I/O in \\\"packet\\\" mode.\"\n)]\n#[cfg_attr(\n    target_os = \"netbsd\",\n    doc = \"- `O_NOSIGPIPE`: Return `EPIPE` instead of raising `SIGPIPE`.\"\n)]\n/// - `O_NONBLOCK`:   Set the non-blocking flag for the ends of the pipe.\n///\n/// See also [pipe(2)](https://man7.org/linux/man-pages/man2/pipe.2.html)\n#[cfg(any(\n    linux_android,\n    freebsdlike,\n    solarish,\n    target_os = \"emscripten\",\n    target_os = \"hurd\",\n    target_os = \"redox\",\n    netbsdlike,\n    target_os = \"cygwin\",\n))]\npub fn pipe2(flags: OFlag) -\u003e Result\u003c(std::os::fd::OwnedFd, std::os::fd::OwnedFd)\u003e {\n    let mut fds = mem::MaybeUninit::\u003c[std::os::fd::OwnedFd; 2]\u003e::uninit();\n\n    let res =\n        unsafe { libc::pipe2(fds.as_mut_ptr().cast(), flags.bits()) };\n\n    Errno::result(res)?;\n\n    let [read, write] = unsafe { fds.assume_init() };\n    Ok((read, write))\n}\n\n/// Truncate a file to a specified length\n///\n/// See also\n/// [truncate(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/truncate.html)\n#[cfg(not(any(target_os = \"redox\", target_os = \"fuchsia\")))]\npub fn truncate\u003cP: ?Sized + NixPath\u003e(path: \u0026P, len: off_t) -\u003e Result\u003c()\u003e {\n    let res = path\n        .with_nix_path(|cstr| unsafe { libc::truncate(cstr.as_ptr(), len) })?;\n\n    Errno::result(res).map(drop)\n}\n\n/// Truncate a file to a specified length\n///\n/// See also\n/// [ftruncate(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/ftruncate.html)\npub fn ftruncate\u003cFd: std::os::fd::AsFd\u003e(fd: Fd, len: off_t) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    Errno::result(unsafe { libc::ftruncate(fd.as_fd().as_raw_fd(), len) }).map(drop)\n}\n\n/// Determines if the file descriptor refers to a valid terminal type device.\npub fn isatty\u003cFd: std::os::fd::AsFd\u003e(fd: Fd) -\u003e Result\u003cbool\u003e {\n    use std::os::fd::AsRawFd;\n\n    unsafe {\n        // ENOTTY means `fd` is a valid file descriptor, but not a TTY, so\n        // we return `Ok(false)`\n        if libc::isatty(fd.as_fd().as_raw_fd()) == 1 {\n            Ok(true)\n        } else {\n            match Errno::last() {\n                Errno::ENOTTY =\u003e Ok(false),\n                err =\u003e Err(err),\n            }\n        }\n    }\n}\n\n#[allow(missing_docs)]\n#[cfg(not(target_os = \"redox\"))]\npub type LinkatFlags = AtFlags;\n#[allow(missing_docs)]\n#[cfg(not(target_os = \"redox\"))]\nimpl LinkatFlags {\n    #[deprecated(since = \"0.28.0\", note = \"The variant is deprecated, please use `AtFlags` instead\")]\n    #[allow(non_upper_case_globals)]\n    pub const SymlinkFollow: LinkatFlags = LinkatFlags::AT_SYMLINK_FOLLOW;\n    #[deprecated(since = \"0.28.0\", note = \"The variant is deprecated, please use `AtFlags` instead\")]\n    #[allow(non_upper_case_globals)]\n    pub const NoSymlinkFollow: LinkatFlags = LinkatFlags::empty();\n}\n\n/// Link one file to another file\n///\n/// Creates a new hard link (directory entry) at `newpath` for the existing file\n/// at `oldpath`. In the case of a relative `oldpath`, the path is interpreted\n/// relative to the directory associated with file descriptor `olddirfd` instead\n/// of the current working directory, use [`AT_FDCWD`](crate::fcntl::AT_FDCWD)\n/// if you want to make it relative to the current working directory. Similarly\n/// for `newpath` and file descriptor `newdirfd`. If either `oldpath` or `newpath`\n/// is absolute, then `dirfd` is ignored.\n///\n/// In case `flag` is `AtFlags::AT_SYMLINK_FOLLOW` and `oldpath` names a symoblic\n/// link, a new link for the target of the symbolic link is created.\n///\n/// # References\n/// See also [linkat(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/linkat.html)\n#[cfg(not(target_os = \"redox\"))] // Redox does not have this yet\npub fn linkat\u003cFd1: std::os::fd::AsFd, Fd2: std::os::fd::AsFd, P1: ?Sized + NixPath, P2: ?Sized + NixPath\u003e(\n    olddirfd: Fd1,\n    oldpath: \u0026P1,\n    newdirfd: Fd2,\n    newpath: \u0026P2,\n    flag: AtFlags,\n) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = oldpath.with_nix_path(|oldcstr| {\n        newpath.with_nix_path(|newcstr| unsafe {\n            libc::linkat(\n                olddirfd.as_fd().as_raw_fd(),\n                oldcstr.as_ptr(),\n                newdirfd.as_fd().as_raw_fd(),\n                newcstr.as_ptr(),\n                flag.bits(),\n            )\n        })\n    })??;\n    Errno::result(res).map(drop)\n}\n\n/// Remove a directory entry\n///\n/// See also [unlink(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/unlink.html)\npub fn unlink\u003cP: ?Sized + NixPath\u003e(path: \u0026P) -\u003e Result\u003c()\u003e {\n    let res =\n        path.with_nix_path(|cstr| unsafe { libc::unlink(cstr.as_ptr()) })?;\n    Errno::result(res).map(drop)\n}\n\n/// Flags for `unlinkat` function.\n#[derive(Clone, Copy, Debug)]\npub enum UnlinkatFlags {\n    /// Remove the directory entry as a directory, not a normal file\n    RemoveDir,\n    /// Remove the directory entry as a normal file, not a directory\n    NoRemoveDir,\n}\n\n/// Remove a directory entry\n///\n/// In the case of a relative path, the directory entry to be removed is determined\n/// relative to the directory associated with the file descriptor `dirfd` (Use\n/// [`AT_FDCWD`](crate::fcntl::AT_FDCWD) if you want to specify the current working\n/// directory in `dirfd`). In the case of an absolute path, `dirfd` is ignored.\n///\n/// If `flag` is `UnlinkatFlags::RemoveDir` then removal of the directory entry\n/// specified by `dirfd` and `path` is performed.\n///\n/// # References\n/// See also [unlinkat(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/unlinkat.html)\n#[cfg(not(target_os = \"redox\"))]\npub fn unlinkat\u003cFd: std::os::fd::AsFd, P: ?Sized + NixPath\u003e(\n    dirfd: Fd,\n    path: \u0026P,\n    flag: UnlinkatFlags,\n) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let atflag = match flag {\n        UnlinkatFlags::RemoveDir =\u003e AtFlags::AT_REMOVEDIR,\n        UnlinkatFlags::NoRemoveDir =\u003e AtFlags::empty(),\n    };\n    let res = path.with_nix_path(|cstr| unsafe {\n        libc::unlinkat(\n            dirfd.as_fd().as_raw_fd(),\n            cstr.as_ptr(),\n            atflag.bits() as libc::c_int,\n        )\n    })?;\n    Errno::result(res).map(drop)\n}\n\n/// Change a process's root directory\n#[inline]\n#[cfg(not(target_os = \"fuchsia\"))]\npub fn chroot\u003cP: ?Sized + NixPath\u003e(path: \u0026P) -\u003e Result\u003c()\u003e {\n    let res =\n        path.with_nix_path(|cstr| unsafe { libc::chroot(cstr.as_ptr()) })?;\n\n    Errno::result(res).map(drop)\n}\n\n/// Commit filesystem caches to disk\n///\n/// See also [sync(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/sync.html)\n#[cfg(any(bsd, linux_android, solarish, target_os = \"haiku\", target_os = \"aix\", target_os = \"hurd\"))]\npub fn sync() {\n    unsafe { libc::sync() };\n}\n\n/// Commit filesystem caches containing file referred to by the open file\n/// descriptor `fd` to disk\n///\n/// See also [syncfs(2)](https://man7.org/linux/man-pages/man2/sync.2.html)\n#[cfg(any(linux_android, target_os = \"hurd\"))]\npub fn syncfs\u003cFd: std::os::fd::AsFd\u003e(fd: Fd) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = unsafe { libc::syncfs(fd.as_fd().as_raw_fd()) };\n\n    Errno::result(res).map(drop)\n}\n\n/// Synchronize changes to a file\n///\n/// See also [fsync(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fsync.html)\n#[inline]\npub fn fsync\u003cFd: std::os::fd::AsFd\u003e(fd: Fd) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = unsafe { libc::fsync(fd.as_fd().as_raw_fd()) };\n\n    Errno::result(res).map(drop)\n}\n\n/// Synchronize the data of a file\n///\n/// See also\n/// [fdatasync(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/fdatasync.html)\n#[cfg(any(\n    linux_android,\n    solarish,\n    netbsdlike,\n    apple_targets,\n    target_os = \"freebsd\",\n    target_os = \"emscripten\",\n    target_os = \"fuchsia\",\n    target_os = \"aix\",\n    target_os = \"hurd\",\n))]\n#[inline]\npub fn fdatasync\u003cFd: std::os::fd::AsFd\u003e(fd: Fd) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    cfg_if! {\n        // apple libc supports fdatasync too, albeit not being present in its headers\n        // [fdatasync](https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/bsd/vfs/vfs_syscalls.c#L7728)\n        if #[cfg(apple_targets)] {\n            extern \"C\" {\n                fn fdatasync(fd: libc::c_int) -\u003e libc::c_int;\n            }\n        } else {\n            use libc::fdatasync as fdatasync;\n        }\n    }\n    let res = unsafe { fdatasync(fd.as_fd().as_raw_fd()) };\n\n    Errno::result(res).map(drop)\n}\n}\n\nfeature! {\n#![feature = \"user\"]\n\n/// Get a real user ID\n///\n/// See also [getuid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getuid.html)\n// POSIX requires that getuid is always successful, so no need to check return\n// value or errno.\n#[inline]\npub fn getuid() -\u003e Uid {\n    Uid(unsafe { libc::getuid() })\n}\n\n/// Get the effective user ID\n///\n/// See also [geteuid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/geteuid.html)\n// POSIX requires that geteuid is always successful, so no need to check return\n// value or errno.\n#[inline]\npub fn geteuid() -\u003e Uid {\n    Uid(unsafe { libc::geteuid() })\n}\n\n/// Get the real group ID\n///\n/// See also [getgid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getgid.html)\n// POSIX requires that getgid is always successful, so no need to check return\n// value or errno.\n#[inline]\npub fn getgid() -\u003e Gid {\n    Gid(unsafe { libc::getgid() })\n}\n\n/// Get the effective group ID\n///\n/// See also [getegid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getegid.html)\n// POSIX requires that getegid is always successful, so no need to check return\n// value or errno.\n#[inline]\npub fn getegid() -\u003e Gid {\n    Gid(unsafe { libc::getegid() })\n}\n\n/// Set the effective user ID\n///\n/// See also [seteuid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/seteuid.html)\n#[inline]\npub fn seteuid(euid: Uid) -\u003e Result\u003c()\u003e {\n    let res = unsafe { libc::seteuid(euid.into()) };\n\n    Errno::result(res).map(drop)\n}\n\n/// Set the effective group ID\n///\n/// See also [setegid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/setegid.html)\n#[inline]\npub fn setegid(egid: Gid) -\u003e Result\u003c()\u003e {\n    let res = unsafe { libc::setegid(egid.into()) };\n\n    Errno::result(res).map(drop)\n}\n\n/// Set the user ID\n///\n/// See also [setuid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/setuid.html)\n#[inline]\npub fn setuid(uid: Uid) -\u003e Result\u003c()\u003e {\n    let res = unsafe { libc::setuid(uid.into()) };\n\n    Errno::result(res).map(drop)\n}\n\n/// Set the group ID\n///\n/// See also [setgid(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/setgid.html)\n#[inline]\npub fn setgid(gid: Gid) -\u003e Result\u003c()\u003e {\n    let res = unsafe { libc::setgid(gid.into()) };\n\n    Errno::result(res).map(drop)\n}\n}\n\nfeature! {\n#![all(feature = \"fs\", feature = \"user\")]\n/// Set the user identity used for filesystem checks per-thread.\n/// On both success and failure, this call returns the previous filesystem user\n/// ID of the caller.\n///\n/// See also [setfsuid(2)](https://man7.org/linux/man-pages/man2/setfsuid.2.html)\n#[cfg(linux_android)]\npub fn setfsuid(uid: Uid) -\u003e Uid {\n    let prev_fsuid = unsafe { libc::setfsuid(uid.into()) };\n    Uid::from_raw(prev_fsuid as uid_t)\n}\n\n/// Set the group identity used for filesystem checks per-thread.\n/// On both success and failure, this call returns the previous filesystem group\n/// ID of the caller.\n///\n/// See also [setfsgid(2)](https://man7.org/linux/man-pages/man2/setfsgid.2.html)\n#[cfg(linux_android)]\npub fn setfsgid(gid: Gid) -\u003e Gid {\n    let prev_fsgid = unsafe { libc::setfsgid(gid.into()) };\n    Gid::from_raw(prev_fsgid as gid_t)\n}\n}\n\nfeature! {\n#![feature = \"user\"]\n\n/// Get the list of supplementary group IDs of the calling process.\n///\n/// [Further reading](https://pubs.opengroup.org/onlinepubs/009695399/functions/getgroups.html)\n///\n/// **Note:** This function is not available for Apple platforms. On those\n/// platforms, checking group membership should be achieved via communication\n/// with the `opendirectoryd` service.\n#[cfg(not(apple_targets))]\npub fn getgroups() -\u003e Result\u003cVec\u003cGid\u003e\u003e {\n    // First get the maximum number of groups. The value returned\n    // shall always be greater than or equal to one and less than or\n    // equal to the value of {NGROUPS_MAX} + 1.\n    let ngroups_max = match sysconf(SysconfVar::NGROUPS_MAX) {\n        Ok(Some(n)) =\u003e (n + 1) as usize,\n        Ok(None) | Err(_) =\u003e usize::MAX,\n    };\n\n    // Next, get the number of groups so we can size our Vec\n    let ngroups = unsafe { libc::getgroups(0, ptr::null_mut()) };\n\n    // If there are no supplementary groups, return early.\n    // This prevents a potential buffer over-read if the number of groups\n    // increases from zero before the next call. It would return the total\n    // number of groups beyond the capacity of the buffer.\n    if ngroups == 0 {\n        return Ok(Vec::new());\n    }\n\n    // Now actually get the groups. We try multiple times in case the number of\n    // groups has changed since the first call to getgroups() and the buffer is\n    // now too small.\n    let mut groups =\n        Vec::\u003cGid\u003e::with_capacity(Errno::result(ngroups)? as usize);\n    loop {\n        // FIXME: On the platforms we currently support, the `Gid` struct has\n        // the same representation in memory as a bare `gid_t`. This is not\n        // necessarily the case on all Rust platforms, though. See RFC 1785.\n        let ngroups = unsafe {\n            libc::getgroups(\n                groups.capacity() as c_int,\n                groups.as_mut_ptr().cast(),\n            )\n        };\n\n        match Errno::result(ngroups) {\n            Ok(s) =\u003e {\n                unsafe { groups.set_len(s as usize) };\n                return Ok(groups);\n            }\n            Err(Errno::EINVAL) =\u003e {\n                // EINVAL indicates that the buffer size was too\n                // small, resize it up to ngroups_max as limit.\n                reserve_double_buffer_size(\u0026mut groups, ngroups_max)\n                    .or(Err(Errno::EINVAL))?;\n            }\n            Err(e) =\u003e return Err(e),\n        }\n    }\n}\n\n/// Set the list of supplementary group IDs for the calling process.\n///\n/// [Further reading](https://man7.org/linux/man-pages/man2/getgroups.2.html)\n///\n/// **Note:** This function is not available for Apple platforms. On those\n/// platforms, group membership management should be achieved via communication\n/// with the `opendirectoryd` service.\n///\n/// # Examples\n///\n/// `setgroups` can be used when dropping privileges from the root user to a\n/// specific user and group. For example, given the user `www-data` with UID\n/// `33` and the group `backup` with the GID `34`, one could switch the user as\n/// follows:\n///\n/// ```rust,no_run\n/// # use std::error::Error;\n/// # use nix::unistd::*;\n/// #\n/// # fn try_main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n/// let uid = Uid::from_raw(33);\n/// let gid = Gid::from_raw(34);\n/// setgroups(\u0026[gid])?;\n/// setgid(gid)?;\n/// setuid(uid)?;\n/// #\n/// #     Ok(())\n/// # }\n/// #\n/// # try_main().unwrap();\n/// ```\n#[cfg(not(any(\n    apple_targets,\n    target_os = \"redox\",\n    target_os = \"haiku\"\n)))]\npub fn setgroups(groups: \u0026[Gid]) -\u003e Result\u003c()\u003e {\n    cfg_if! {\n        if #[cfg(any(bsd,\n                     solarish,\n                     target_os = \"aix\",\n                     target_os = \"cygwin\"))] {\n            type setgroups_ngroups_t = c_int;\n        } else {\n            type setgroups_ngroups_t = size_t;\n        }\n    }\n    // FIXME: On the platforms we currently support, the `Gid` struct has the\n    // same representation in memory as a bare `gid_t`. This is not necessarily\n    // the case on all Rust platforms, though. See RFC 1785.\n    let res = unsafe {\n        libc::setgroups(\n            groups.len() as setgroups_ngroups_t,\n            groups.as_ptr().cast(),\n        )\n    };\n\n    Errno::result(res).map(drop)\n}\n\n/// Calculate the supplementary group access list.\n///\n/// Gets the group IDs of all groups that `user` is a member of. The additional\n/// group `group` is also added to the list.\n///\n/// [Further reading](https://man7.org/linux/man-pages/man3/getgrouplist.3.html)\n///\n/// **Note:** This function is not available for Apple platforms. On those\n/// platforms, checking group membership should be achieved via communication\n/// with the `opendirectoryd` service.\n///\n/// # Errors\n///\n/// Although the `getgrouplist()` call does not return any specific\n/// errors on any known platforms, this implementation will return a system\n/// error of `EINVAL` if the number of groups to be fetched exceeds the\n/// `NGROUPS_MAX` sysconf value. This mimics the behaviour of `getgroups()`\n/// and `setgroups()`. Additionally, while some implementations will return a\n/// partial list of groups when `NGROUPS_MAX` is exceeded, this implementation\n/// will only ever return the complete list or else an error.\n#[cfg(not(any(\n    target_os = \"aix\",\n    solarish,\n    apple_targets,\n    target_os = \"redox\",\n    target_os = \"emscripten\",\n)))]\npub fn getgrouplist(user: \u0026CStr, group: Gid) -\u003e Result\u003cVec\u003cGid\u003e\u003e {\n    let ngroups_max = match sysconf(SysconfVar::NGROUPS_MAX) {\n        Ok(Some(n)) =\u003e n as c_int,\n        Ok(None) | Err(_) =\u003e c_int::MAX,\n    };\n    use std::cmp::min;\n    let mut groups = Vec::\u003cGid\u003e::with_capacity(min(ngroups_max, 8) as usize);\n    cfg_if! {\n        if #[cfg(apple_targets)] {\n            type getgrouplist_group_t = c_int;\n        } else {\n            type getgrouplist_group_t = gid_t;\n        }\n    }\n    let gid: gid_t = group.into();\n    loop {\n        let mut ngroups = groups.capacity() as i32;\n        let ret = unsafe {\n            libc::getgrouplist(\n                user.as_ptr(),\n                gid as getgrouplist_group_t,\n                groups.as_mut_ptr().cast(),\n                \u0026mut ngroups,\n            )\n        };\n\n        // BSD systems only return 0 or -1, Linux returns ngroups on success.\n        if ret \u003e= 0 {\n            unsafe { groups.set_len(ngroups as usize) };\n            return Ok(groups);\n        } else if ret == -1 {\n            // Returns -1 if ngroups is too small, but does not set errno.\n            // BSD systems will still fill the groups buffer with as many\n            // groups as possible, but Linux manpages do not mention this\n            // behavior.\n            reserve_double_buffer_size(\u0026mut groups, ngroups_max as usize)\n                .map_err(|_| Errno::EINVAL)?;\n        }\n    }\n}\n\n/// Initialize the supplementary group access list.\n///\n/// Sets the supplementary group IDs for the calling process using all groups\n/// that `user` is a member of. The additional group `group` is also added to\n/// the list.\n///\n/// [Further reading](https://man7.org/linux/man-pages/man3/initgroups.3.html)\n///\n/// **Note:** This function is not available for Apple platforms. On those\n/// platforms, group membership management should be achieved via communication\n/// with the `opendirectoryd` service.\n///\n/// # Examples\n///\n/// `initgroups` can be used when dropping privileges from the root user to\n/// another user. For example, given the user `www-data`, we could look up the\n/// UID and GID for the user in the system's password database (usually found\n/// in `/etc/passwd`). If the `www-data` user's UID and GID were `33` and `33`,\n/// respectively, one could switch the user as follows:\n///\n/// ```rust,no_run\n/// # use std::error::Error;\n/// # use std::ffi::CString;\n/// # use nix::unistd::*;\n/// #\n/// # fn try_main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n/// let user = CString::new(\"www-data\").unwrap();\n/// let uid = Uid::from_raw(33);\n/// let gid = Gid::from_raw(33);\n/// initgroups(\u0026user, gid)?;\n/// setgid(gid)?;\n/// setuid(uid)?;\n/// #\n/// #     Ok(())\n/// # }\n/// #\n/// # try_main().unwrap();\n/// ```\n#[cfg(not(any(\n    apple_targets,\n    target_os = \"redox\",\n    target_os = \"haiku\",\n    target_os = \"emscripten\",\n)))]\npub fn initgroups(user: \u0026CStr, group: Gid) -\u003e Result\u003c()\u003e {\n    cfg_if! {\n        if #[cfg(apple_targets)] {\n            type initgroups_group_t = c_int;\n        } else {\n            type initgroups_group_t = gid_t;\n        }\n    }\n    let gid: gid_t = group.into();\n    let res =\n        unsafe { libc::initgroups(user.as_ptr(), gid as initgroups_group_t) };\n\n    Errno::result(res).map(drop)\n}\n}\n\nfeature! {\n#![feature = \"signal\"]\n\n/// Suspend the thread until a signal is received.\n///\n/// See also [pause(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pause.html).\n#[inline]\n#[cfg(not(target_os = \"redox\"))]\npub fn pause() {\n    unsafe { libc::pause() };\n}\n\npub mod alarm {\n    //! Alarm signal scheduling.\n    //!\n    //! Scheduling an alarm will trigger a `SIGALRM` signal when the time has\n    //! elapsed, which has to be caught, because the default action for the\n    //! signal is to terminate the program. This signal also can't be ignored\n    //! because the system calls like `pause` will not be interrupted, see the\n    //! second example below.\n    //!\n    //! # Examples\n    //!\n    //! Canceling an alarm:\n    //!\n    //! ```\n    //! use nix::unistd::alarm;\n    //!\n    //! // Set an alarm for 60 seconds from now.\n    //! alarm::set(60);\n    //!\n    //! // Cancel the above set alarm, which returns the number of seconds left\n    //! // of the previously set alarm.\n    //! assert_eq!(alarm::cancel(), Some(60));\n    //! ```\n    //!\n    //! Scheduling an alarm and waiting for the signal:\n    //!\n    #![cfg_attr(target_os = \"redox\", doc = \" ```rust,ignore\")]\n    #![cfg_attr(not(target_os = \"redox\"), doc = \" ```rust\")]\n    //! use std::time::{Duration, Instant};\n    //!\n    //! use nix::unistd::{alarm, pause};\n    //! use nix::sys::signal::*;\n    //!\n    //! // We need to setup an empty signal handler to catch the alarm signal,\n    //! // otherwise the program will be terminated once the signal is delivered.\n    //! extern fn signal_handler(_: nix::libc::c_int) { }\n    //! let sa = SigAction::new(\n    //!     SigHandler::Handler(signal_handler),\n    //!     SaFlags::SA_RESTART,\n    //!     SigSet::empty()\n    //! );\n    //! unsafe {\n    //!     sigaction(Signal::SIGALRM, \u0026sa);\n    //! }\n    //!\n    //! let start = Instant::now();\n    //!\n    //! // Set an alarm for 1 second from now.\n    //! alarm::set(1);\n    //!\n    //! // Pause the process until the alarm signal is received.\n    //! let mut sigset = SigSet::empty();\n    //! sigset.add(Signal::SIGALRM);\n    //! sigset.wait();\n    //!\n    //! // On Solaris, the signal can arrive before the full second.\n    //! const TOLERANCE: Duration = Duration::from_millis(10);\n    //! assert!(start.elapsed() + TOLERANCE \u003e= Duration::from_secs(1));\n    //! ```\n    //!\n    //! # References\n    //!\n    //! See also [alarm(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/alarm.html).\n\n    /// Schedule an alarm signal.\n    ///\n    /// This will cause the system to generate a `SIGALRM` signal for the\n    /// process after the specified number of seconds have elapsed.\n    ///\n    /// Returns the leftover time of a previously set alarm if there was one.\n    pub fn set(secs: libc::c_uint) -\u003e Option\u003clibc::c_uint\u003e {\n        assert!(secs != 0, \"passing 0 to `alarm::set` is not allowed, to cancel an alarm use `alarm::cancel`\");\n        alarm(secs)\n    }\n\n    /// Cancel an previously set alarm signal.\n    ///\n    /// Returns the leftover time of a previously set alarm if there was one.\n    pub fn cancel() -\u003e Option\u003clibc::c_uint\u003e {\n        alarm(0)\n    }\n\n    fn alarm(secs: libc::c_uint) -\u003e Option\u003clibc::c_uint\u003e {\n        match unsafe { libc::alarm(secs) } {\n            0 =\u003e None,\n            secs =\u003e Some(secs),\n        }\n    }\n}\n}\n\n/// Suspend execution for an interval of time\n///\n/// See also [sleep(2)](https://pubs.opengroup.org/onlinepubs/009695399/functions/sleep.html#tag_03_705_05)\n// Per POSIX, does not fail\n#[inline]\npub fn sleep(seconds: c_uint) -\u003e c_uint {\n    unsafe { libc::sleep(seconds) }\n}\n\nfeature! {\n#![feature = \"acct\"]\n\n/// Process accounting\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\", target_os = \"cygwin\")))]\npub mod acct {\n    use crate::errno::Errno;\n    use crate::{NixPath, Result};\n    use std::ptr;\n\n    /// Enable process accounting\n    ///\n    /// See also [acct(2)](https://linux.die.net/man/2/acct)\n    pub fn enable\u003cP: ?Sized + NixPath\u003e(filename: \u0026P) -\u003e Result\u003c()\u003e {\n        let res = filename\n            .with_nix_path(|cstr| unsafe { libc::acct(cstr.as_ptr()) })?;\n\n        Errno::result(res).map(drop)\n    }\n\n    /// Disable process accounting\n    pub fn disable() -\u003e Result\u003c()\u003e {\n        let res = unsafe { libc::acct(ptr::null()) };\n\n        Errno::result(res).map(drop)\n    }\n}\n}\n\nfeature! {\n#![feature = \"fs\"]\n/// Creates a regular file which persists even after process termination\n///\n/// * `template`: a path whose 6 rightmost characters must be X, e.g. `/tmp/tmpfile_XXXXXX`\n/// * returns: tuple of file descriptor and filename\n///\n/// Err is returned either if no temporary filename could be created or the template doesn't\n/// end with XXXXXX\n///\n/// See also [mkstemp(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkstemp.html)\n///\n/// # Example\n///\n/// ```rust\n/// use nix::unistd;\n///\n/// let _ = match unistd::mkstemp(\"/tmp/tempfile_XXXXXX\") {\n///     Ok((fd, path)) =\u003e {\n///         unistd::unlink(path.as_path()).unwrap(); // flag file to be deleted at app termination\n///         fd\n///     }\n///     Err(e) =\u003e panic!(\"mkstemp failed: {}\", e)\n/// };\n/// // do something with fd\n/// ```\n#[inline]\npub fn mkstemp\u003cP: ?Sized + NixPath\u003e(template: \u0026P) -\u003e Result\u003c(std::os::fd::OwnedFd, PathBuf)\u003e {\n    use std::os::fd::OwnedFd;\n    use std::os::fd::FromRawFd;\n\n    let mut path =\n        template.with_nix_path(|path| path.to_bytes_with_nul().to_owned())?;\n    let p = path.as_mut_ptr().cast();\n    let fd = unsafe { libc::mkstemp(p) };\n    let last = path.pop(); // drop the trailing nul\n    debug_assert!(last == Some(b'\\0'));\n    let pathname = OsString::from_vec(path);\n    Errno::result(fd)?;\n    // SAFETY:\n    //\n    // `mkstemp(3)` should return a valid owned file descriptor on success.\n    let fd = unsafe { OwnedFd::from_raw_fd(fd) };\n    Ok((fd, PathBuf::from(pathname)))\n}\n}\n\nfeature! {\n#![all(feature = \"fs\", feature = \"feature\")]\n\n/// Creates a directory which persists even after process termination\n///\n/// * `template`: a path whose rightmost characters contain some number of X, e.g. `/tmp/tmpdir_XXXXXX`\n/// * returns: filename\n///\n/// Err is returned either if no temporary filename could be created or the template had insufficient X\n///\n/// See also [mkstemp(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html)\n///\n/// ```\n/// use nix::unistd;\n///\n/// match unistd::mkdtemp(\"/tmp/tempdir_XXXXXX\") {\n///     Ok(_path) =\u003e {\n///         // do something with directory\n///     }\n///     Err(e) =\u003e panic!(\"mkdtemp failed: {}\", e)\n/// };\n/// ```\npub fn mkdtemp\u003cP: ?Sized + NixPath\u003e(template: \u0026P) -\u003e Result\u003cPathBuf\u003e {\n    let mut path = template.with_nix_path(|path| {path.to_bytes_with_nul().to_owned()})?;\n    let p = path.as_mut_ptr() as *mut _;\n    let p = unsafe { libc::mkdtemp(p) };\n    if p.is_null() {\n        return Err(Errno::last());\n    }\n    let last = path.pop(); // drop the trailing nul\n    debug_assert!(last == Some(b'\\0'));\n    let pathname = OsString::from_vec(path);\n    Ok(PathBuf::from(pathname))\n}\n\n/// Variable names for `pathconf`\n///\n/// Nix uses the same naming convention for these variables as the\n/// [getconf(1)](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/getconf.html) utility.\n/// That is, `PathconfVar` variables have the same name as the abstract\n/// variables  shown in the `pathconf(2)` man page.  Usually, it's the same as\n/// the C variable name without the leading `_PC_`.\n///\n/// POSIX 1003.1-2008 standardizes all of these variables, but some OSes choose\n/// not to implement variables that cannot change at runtime.\n///\n/// # References\n///\n/// - [pathconf(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pathconf.html)\n/// - [limits.h](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/limits.h.html)\n/// - [unistd.h](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/unistd.h.html)\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\n#[repr(i32)]\n#[non_exhaustive]\npub enum PathconfVar {\n    #[cfg(any(\n        freebsdlike,\n        netbsdlike,\n        target_os = \"linux\",\n        target_os = \"redox\"\n    ))]\n    /// Minimum number of bits needed to represent, as a signed integer value,\n    /// the maximum size of a regular file allowed in the specified directory.\n    FILESIZEBITS = libc::_PC_FILESIZEBITS,\n    /// Maximum number of links to a single file.\n    LINK_MAX = libc::_PC_LINK_MAX,\n    /// Maximum number of bytes in a terminal canonical input line.\n    MAX_CANON = libc::_PC_MAX_CANON,\n    /// Minimum number of bytes for which space is available in a terminal input\n    /// queue; therefore, the maximum number of bytes a conforming application\n    /// may require to be typed as input before reading them.\n    MAX_INPUT = libc::_PC_MAX_INPUT,\n    #[cfg(any(\n        apple_targets,\n        solarish,\n        freebsdlike,\n        target_os = \"netbsd\",\n    ))]\n    /// If a file system supports the reporting of holes (see lseek(2)),\n    /// pathconf() and fpathconf() return a positive number that represents the\n    /// minimum hole size returned in bytes.  The offsets of holes returned will\n    /// be aligned to this same value.  A special value of 1 is returned if the\n    /// file system does not specify the minimum hole size but still reports\n    /// holes.\n    MIN_HOLE_SIZE = libc::_PC_MIN_HOLE_SIZE,\n    /// Maximum number of bytes in a filename (not including the terminating\n    /// null of a filename string).\n    NAME_MAX = libc::_PC_NAME_MAX,\n    /// Maximum number of bytes the implementation will store as a pathname in a\n    /// user-supplied buffer of unspecified size, including the terminating null\n    /// character. Minimum number the implementation will accept as the maximum\n    /// number of bytes in a pathname.\n    PATH_MAX = libc::_PC_PATH_MAX,\n    /// Maximum number of bytes that is guaranteed to be atomic when writing to\n    /// a pipe.\n    PIPE_BUF = libc::_PC_PIPE_BUF,\n    #[cfg(any(\n        linux_android,\n        solarish,\n        netbsdlike,\n        target_os = \"dragonfly\",\n        target_os = \"redox\",\n    ))]\n    /// Symbolic links can be created.\n    POSIX2_SYMLINKS = libc::_PC_2_SYMLINKS,\n    #[cfg(any(\n        linux_android,\n        freebsdlike,\n        target_os = \"openbsd\",\n        target_os = \"redox\"\n    ))]\n    /// Minimum number of bytes of storage actually allocated for any portion of\n    /// a file.\n    POSIX_ALLOC_SIZE_MIN = libc::_PC_ALLOC_SIZE_MIN,\n    #[cfg(any(\n        freebsdlike,\n        linux_android,\n        target_os = \"openbsd\"\n    ))]\n    /// Recommended increment for file transfer sizes between the\n    /// `POSIX_REC_MIN_XFER_SIZE` and `POSIX_REC_MAX_XFER_SIZE` values.\n    POSIX_REC_INCR_XFER_SIZE = libc::_PC_REC_INCR_XFER_SIZE,\n    #[cfg(any(\n        linux_android,\n        freebsdlike,\n        target_os = \"openbsd\",\n        target_os = \"redox\"\n    ))]\n    /// Maximum recommended file transfer size.\n    POSIX_REC_MAX_XFER_SIZE = libc::_PC_REC_MAX_XFER_SIZE,\n    #[cfg(any(\n        linux_android,\n        freebsdlike,\n        target_os = \"openbsd\",\n        target_os = \"redox\"\n    ))]\n    /// Minimum recommended file transfer size.\n    POSIX_REC_MIN_XFER_SIZE = libc::_PC_REC_MIN_XFER_SIZE,\n    #[cfg(any(\n        linux_android,\n        freebsdlike,\n        target_os = \"openbsd\",\n        target_os = \"redox\"\n    ))]\n    ///  Recommended file transfer buffer alignment.\n    POSIX_REC_XFER_ALIGN = libc::_PC_REC_XFER_ALIGN,\n    #[cfg(any(\n        linux_android,\n        freebsdlike,\n        solarish,\n        netbsdlike,\n        target_os = \"redox\",\n    ))]\n    /// Maximum number of bytes in a symbolic link.\n    SYMLINK_MAX = libc::_PC_SYMLINK_MAX,\n    /// The use of `chown` and `fchown` is restricted to a process with\n    /// appropriate privileges, and to changing the group ID of a file only to\n    /// the effective group ID of the process or to one of its supplementary\n    /// group IDs.\n    _POSIX_CHOWN_RESTRICTED = libc::_PC_CHOWN_RESTRICTED,\n    /// Pathname components longer than {NAME_MAX} generate an error.\n    _POSIX_NO_TRUNC = libc::_PC_NO_TRUNC,\n    /// This symbol shall be defined to be the value of a character that shall\n    /// disable terminal special character handling.\n    _POSIX_VDISABLE = libc::_PC_VDISABLE,\n    #[cfg(any(\n        linux_android,\n        freebsdlike,\n        solarish,\n        target_os = \"openbsd\",\n        target_os = \"redox\",\n    ))]\n    /// Asynchronous input or output operations may be performed for the\n    /// associated file.\n    _POSIX_ASYNC_IO = libc::_PC_ASYNC_IO,\n    #[cfg(any(\n        linux_android,\n        freebsdlike,\n        solarish,\n        target_os = \"openbsd\",\n        target_os = \"redox\",\n    ))]\n    /// Prioritized input or output operations may be performed for the\n    /// associated file.\n    _POSIX_PRIO_IO = libc::_PC_PRIO_IO,\n    #[cfg(any(\n        linux_android,\n        freebsdlike,\n        solarish,\n        netbsdlike,\n        target_os = \"redox\",\n    ))]\n    /// Synchronized input or output operations may be performed for the\n    /// associated file.\n    _POSIX_SYNC_IO = libc::_PC_SYNC_IO,\n    #[cfg(any(target_os = \"dragonfly\", target_os = \"openbsd\"))]\n    /// The resolution in nanoseconds for all file timestamps.\n    _POSIX_TIMESTAMP_RESOLUTION = libc::_PC_TIMESTAMP_RESOLUTION,\n}\n\n/// Like `pathconf`, but works with file descriptors instead of paths (see\n/// [fpathconf(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pathconf.html))\n///\n/// # Parameters\n///\n/// - `fd`:   The file descriptor whose variable should be interrogated\n/// - `var`:  The pathconf variable to lookup\n///\n/// # Returns\n///\n/// - `Ok(Some(x))`: the variable's limit (for limit variables) or its\n///     implementation level (for option variables).  Implementation levels are\n///     usually a decimal-coded date, such as 200112 for POSIX 2001.12\n/// - `Ok(None)`: the variable has no limit (for limit variables) or is\n///     unsupported (for option variables)\n/// - `Err(x)`: an error occurred\npub fn fpathconf\u003cF: std::os::fd::AsFd\u003e(fd: F, var: PathconfVar) -\u003e Result\u003cOption\u003cc_long\u003e\u003e {\n    use std::os::fd::AsRawFd;\n\n    let raw = unsafe {\n        Errno::clear();\n        libc::fpathconf(fd.as_fd().as_raw_fd(), var as c_int)\n    };\n    if raw == -1 {\n        if Errno::last_raw() == 0 {\n            Ok(None)\n        } else {\n            Err(Errno::last())\n        }\n    } else {\n        Ok(Some(raw))\n    }\n}\n\n/// Get path-dependent configurable system variables (see\n/// [pathconf(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pathconf.html))\n///\n/// Returns the value of a path-dependent configurable system variable.  Most\n/// supported variables also have associated compile-time constants, but POSIX\n/// allows their values to change at runtime.  There are generally two types of\n/// `pathconf` variables: options and limits.  See [pathconf(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/pathconf.html) for more details.\n///\n/// # Parameters\n///\n/// - `path`: Lookup the value of `var` for this file or directory\n/// - `var`:  The `pathconf` variable to lookup\n///\n/// # Returns\n///\n/// - `Ok(Some(x))`: the variable's limit (for limit variables) or its\n///     implementation level (for option variables).  Implementation levels are\n///     usually a decimal-coded date, such as 200112 for POSIX 2001.12\n/// - `Ok(None)`: the variable has no limit (for limit variables) or is\n///     unsupported (for option variables)\n/// - `Err(x)`: an error occurred\npub fn pathconf\u003cP: ?Sized + NixPath\u003e(\n    path: \u0026P,\n    var: PathconfVar,\n) -\u003e Result\u003cOption\u003cc_long\u003e\u003e {\n    let raw = path.with_nix_path(|cstr| unsafe {\n        Errno::clear();\n        libc::pathconf(cstr.as_ptr(), var as c_int)\n    })?;\n    if raw == -1 {\n        if Errno::last_raw() == 0 {\n            Ok(None)\n        } else {\n            Err(Errno::last())\n        }\n    } else {\n        Ok(Some(raw))\n    }\n}\n}\n\nfeature! {\n#![feature = \"feature\"]\n\n/// Variable names for `sysconf`\n///\n/// Nix uses the same naming convention for these variables as the\n/// [getconf(1)](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/getconf.html) utility.\n/// That is, `SysconfVar` variables have the same name as the abstract variables\n/// shown in the `sysconf(3)` man page.  Usually, it's the same as the C\n/// variable name without the leading `_SC_`.\n///\n/// All of these symbols are standardized by POSIX 1003.1-2008, but haven't been\n/// implemented by all platforms.\n///\n/// # References\n///\n/// - [sysconf(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/sysconf.html)\n/// - [unistd.h](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/unistd.h.html)\n/// - [limits.h](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/limits.h.html)\n#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]\n#[repr(i32)]\n#[non_exhaustive]\npub enum SysconfVar {\n    /// Maximum number of I/O operations in a single list I/O call supported by\n    /// the implementation.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    AIO_LISTIO_MAX = libc::_SC_AIO_LISTIO_MAX,\n    /// Maximum number of outstanding asynchronous I/O operations supported by\n    /// the implementation.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    AIO_MAX = libc::_SC_AIO_MAX,\n    #[cfg(any(\n        linux_android,\n        freebsdlike,\n        apple_targets,\n        target_os = \"openbsd\"\n    ))]\n    /// The maximum amount by which a process can decrease its asynchronous I/O\n    /// priority level from its own scheduling priority.\n    AIO_PRIO_DELTA_MAX = libc::_SC_AIO_PRIO_DELTA_MAX,\n    /// Maximum length of argument to the exec functions including environment data.\n    ARG_MAX = libc::_SC_ARG_MAX,\n    /// Maximum number of functions that may be registered with `atexit`.\n    #[cfg(not(target_os = \"redox\"))]\n    ATEXIT_MAX = libc::_SC_ATEXIT_MAX,\n    /// Maximum obase values allowed by the bc utility.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    BC_BASE_MAX = libc::_SC_BC_BASE_MAX,\n    /// Maximum number of elements permitted in an array by the bc utility.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    BC_DIM_MAX = libc::_SC_BC_DIM_MAX,\n    /// Maximum scale value allowed by the bc utility.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    BC_SCALE_MAX = libc::_SC_BC_SCALE_MAX,\n    /// Maximum length of a string constant accepted by the bc utility.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    BC_STRING_MAX = libc::_SC_BC_STRING_MAX,\n    /// Maximum number of simultaneous processes per real user ID.\n    CHILD_MAX = libc::_SC_CHILD_MAX,\n    /// The frequency of the statistics clock in ticks per second.\n    CLK_TCK = libc::_SC_CLK_TCK,\n    /// Maximum number of weights that can be assigned to an entry of the\n    /// LC_COLLATE order keyword in the locale definition file\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    COLL_WEIGHTS_MAX = libc::_SC_COLL_WEIGHTS_MAX,\n    /// Maximum number of timer expiration overruns.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    DELAYTIMER_MAX = libc::_SC_DELAYTIMER_MAX,\n    /// Maximum number of expressions that can be nested within parentheses by\n    /// the expr utility.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    EXPR_NEST_MAX = libc::_SC_EXPR_NEST_MAX,\n    #[cfg(any(bsd, solarish, target_os = \"linux\"))]\n    /// Maximum length of a host name (not including the terminating null) as\n    /// returned from the `gethostname` function\n    HOST_NAME_MAX = libc::_SC_HOST_NAME_MAX,\n    /// Maximum number of iovec structures that one process has available for\n    /// use with `readv` or `writev`.\n    #[cfg(not(target_os = \"redox\"))]\n    IOV_MAX = libc::_SC_IOV_MAX,\n    /// Unless otherwise noted, the maximum length, in bytes, of a utility's\n    /// input line (either standard input or another file), when the utility is\n    /// described as processing text files. The length includes room for the\n    /// trailing newline.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    LINE_MAX = libc::_SC_LINE_MAX,\n    /// Maximum length of a login name.\n    #[cfg(not(target_os = \"haiku\"))]\n    LOGIN_NAME_MAX = libc::_SC_LOGIN_NAME_MAX,\n    /// Maximum number of simultaneous supplementary group IDs per process.\n    NGROUPS_MAX = libc::_SC_NGROUPS_MAX,\n    /// Initial size of `getgrgid_r` and `getgrnam_r` data buffers\n    #[cfg(not(target_os = \"redox\"))]\n    GETGR_R_SIZE_MAX = libc::_SC_GETGR_R_SIZE_MAX,\n    /// Initial size of `getpwuid_r` and `getpwnam_r` data buffers\n    #[cfg(not(target_os = \"redox\"))]\n    GETPW_R_SIZE_MAX = libc::_SC_GETPW_R_SIZE_MAX,\n    /// The maximum number of open message queue descriptors a process may hold.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    MQ_OPEN_MAX = libc::_SC_MQ_OPEN_MAX,\n    /// The maximum number of message priorities supported by the implementation.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    MQ_PRIO_MAX = libc::_SC_MQ_PRIO_MAX,\n    /// A value one greater than the maximum value that the system may assign to\n    /// a newly-created file descriptor.\n    OPEN_MAX = libc::_SC_OPEN_MAX,\n    #[cfg(any(\n        freebsdlike,\n        apple_targets,\n        target_os = \"linux\",\n        target_os = \"openbsd\"\n    ))]\n    /// The implementation supports the Advisory Information option.\n    _POSIX_ADVISORY_INFO = libc::_SC_ADVISORY_INFO,\n    #[cfg(any(bsd, solarish, target_os = \"linux\"))]\n    /// The implementation supports barriers.\n    _POSIX_BARRIERS = libc::_SC_BARRIERS,\n    /// The implementation supports asynchronous input and output.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _POSIX_ASYNCHRONOUS_IO = libc::_SC_ASYNCHRONOUS_IO,\n    #[cfg(any(bsd, solarish, target_os = \"linux\"))]\n    /// The implementation supports clock selection.\n    _POSIX_CLOCK_SELECTION = libc::_SC_CLOCK_SELECTION,\n    #[cfg(any(bsd, solarish, target_os = \"linux\"))]\n    /// The implementation supports the Process CPU-Time Clocks option.\n    _POSIX_CPUTIME = libc::_SC_CPUTIME,\n    /// The implementation supports the File Synchronization option.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _POSIX_FSYNC = libc::_SC_FSYNC,\n    #[cfg(any(\n        freebsdlike,\n        apple_targets,\n        solarish,\n        target_os = \"linux\",\n        target_os = \"openbsd\",\n    ))]\n    /// The implementation supports the IPv6 option.\n    _POSIX_IPV6 = libc::_SC_IPV6,\n    /// The implementation supports job control.\n    #[cfg(not(target_os = \"redox\"))]\n    _POSIX_JOB_CONTROL = libc::_SC_JOB_CONTROL,\n    /// The implementation supports memory mapped Files.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _POSIX_MAPPED_FILES = libc::_SC_MAPPED_FILES,\n    /// The implementation supports the Process Memory Locking option.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _POSIX_MEMLOCK = libc::_SC_MEMLOCK,\n    /// The implementation supports the Range Memory Locking option.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _POSIX_MEMLOCK_RANGE = libc::_SC_MEMLOCK_RANGE,\n    /// The implementation supports memory protection.\n    #[cfg(not(target_os = \"redox\"))]\n    _POSIX_MEMORY_PROTECTION = libc::_SC_MEMORY_PROTECTION,\n    /// The implementation supports the Message Passing option.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _POSIX_MESSAGE_PASSING = libc::_SC_MESSAGE_PASSING,\n    /// The implementation supports the Monotonic Clock option.\n    #[cfg(not(target_os = \"redox\"))]\n    _POSIX_MONOTONIC_CLOCK = libc::_SC_MONOTONIC_CLOCK,\n    #[cfg(any(\n        linux_android,\n        freebsdlike,\n        solarish,\n        apple_targets,\n        target_os = \"openbsd\",\n    ))]\n    /// The implementation supports the Prioritized Input and Output option.\n    _POSIX_PRIORITIZED_IO = libc::_SC_PRIORITIZED_IO,\n    /// The implementation supports the Process Scheduling option.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _POSIX_PRIORITY_SCHEDULING = libc::_SC_PRIORITY_SCHEDULING,\n    #[cfg(any(\n        freebsdlike,\n        solarish,\n        apple_targets,\n        target_os = \"linux\",\n        target_os = \"openbsd\",\n    ))]\n    /// The implementation supports the Raw Sockets option.\n    _POSIX_RAW_SOCKETS = libc::_SC_RAW_SOCKETS,\n    #[cfg(any(\n        bsd,\n        solarish,\n        target_os = \"linux\",\n    ))]\n    /// The implementation supports read-write locks.\n    _POSIX_READER_WRITER_LOCKS = libc::_SC_READER_WRITER_LOCKS,\n    #[cfg(any(\n        linux_android,\n        freebsdlike,\n        apple_targets,\n        target_os = \"openbsd\"\n    ))]\n    /// The implementation supports realtime signals.\n    _POSIX_REALTIME_SIGNALS = libc::_SC_REALTIME_SIGNALS,\n    #[cfg(any(\n        bsd,\n        solarish,\n        target_os = \"linux\",\n    ))]\n    /// The implementation supports the Regular Expression Handling option.\n    _POSIX_REGEXP = libc::_SC_REGEXP,\n    /// Each process has a saved set-user-ID and a saved set-group-ID.\n    #[cfg(not(target_os = \"redox\"))]\n    _POSIX_SAVED_IDS = libc::_SC_SAVED_IDS,\n    /// The implementation supports semaphores.\n    #[cfg(not(target_os = \"redox\"))]\n    _POSIX_SEMAPHORES = libc::_SC_SEMAPHORES,\n    /// The implementation supports the Shared Memory Objects option.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _POSIX_SHARED_MEMORY_OBJECTS = libc::_SC_SHARED_MEMORY_OBJECTS,\n    #[cfg(any(bsd, target_os = \"linux\",))]\n    /// The implementation supports the POSIX shell.\n    _POSIX_SHELL = libc::_SC_SHELL,\n    #[cfg(any(bsd, target_os = \"linux\",))]\n    /// The implementation supports the Spawn option.\n    _POSIX_SPAWN = libc::_SC_SPAWN,\n    #[cfg(any(bsd, target_os = \"linux\",))]\n    /// The implementation supports spin locks.\n    _POSIX_SPIN_LOCKS = libc::_SC_SPIN_LOCKS,\n    #[cfg(any(\n        freebsdlike,\n        apple_targets,\n        target_os = \"linux\",\n        target_os = \"openbsd\"\n    ))]\n    /// The implementation supports the Process Sporadic Server option.\n    _POSIX_SPORADIC_SERVER = libc::_SC_SPORADIC_SERVER,\n    /// The number of replenishment operations that can be simultaneously pending for a particular\n    /// sporadic server scheduler.\n    #[cfg(any(\n        apple_targets,\n        target_os = \"linux\",\n        target_os = \"openbsd\"\n    ))]\n    _POSIX_SS_REPL_MAX = libc::_SC_SS_REPL_MAX,\n    /// The implementation supports the Synchronized Input and Output option.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _POSIX_SYNCHRONIZED_IO = libc::_SC_SYNCHRONIZED_IO,\n    /// The implementation supports the Thread Stack Address Attribute option.\n    #[cfg(not(target_os = \"redox\"))]\n    _POSIX_THREAD_ATTR_STACKADDR = libc::_SC_THREAD_ATTR_STACKADDR,\n    /// The implementation supports the Thread Stack Size Attribute option.\n    #[cfg(not(target_os = \"redox\"))]\n    _POSIX_THREAD_ATTR_STACKSIZE = libc::_SC_THREAD_ATTR_STACKSIZE,\n    #[cfg(any(\n        apple_targets,\n        target_os = \"linux\",\n        netbsdlike,\n    ))]\n    /// The implementation supports the Thread CPU-Time Clocks option.\n    _POSIX_THREAD_CPUTIME = libc::_SC_THREAD_CPUTIME,\n    /// The implementation supports the Non-Robust Mutex Priority Inheritance\n    /// option.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _POSIX_THREAD_PRIO_INHERIT = libc::_SC_THREAD_PRIO_INHERIT,\n    /// The implementation supports the Non-Robust Mutex Priority Protection option.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _POSIX_THREAD_PRIO_PROTECT = libc::_SC_THREAD_PRIO_PROTECT,\n    /// The implementation supports the Thread Execution Scheduling option.\n    #[cfg(not(target_os = \"redox\"))]\n    _POSIX_THREAD_PRIORITY_SCHEDULING = libc::_SC_THREAD_PRIORITY_SCHEDULING,\n    #[cfg(any(bsd, target_os = \"linux\"))]\n    /// The implementation supports the Thread Process-Shared Synchronization\n    /// option.\n    _POSIX_THREAD_PROCESS_SHARED = libc::_SC_THREAD_PROCESS_SHARED,\n    #[cfg(any(\n        target_os = \"dragonfly\",\n        target_os = \"linux\",\n        target_os = \"openbsd\"\n    ))]\n    /// The implementation supports the Robust Mutex Priority Inheritance option.\n    _POSIX_THREAD_ROBUST_PRIO_INHERIT = libc::_SC_THREAD_ROBUST_PRIO_INHERIT,\n    #[cfg(any(\n        target_os = \"dragonfly\",\n        target_os = \"linux\",\n        target_os = \"openbsd\"\n    ))]\n    /// The implementation supports the Robust Mutex Priority Protection option.\n    _POSIX_THREAD_ROBUST_PRIO_PROTECT = libc::_SC_THREAD_ROBUST_PRIO_PROTECT,\n    /// The implementation supports thread-safe functions.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _POSIX_THREAD_SAFE_FUNCTIONS = libc::_SC_THREAD_SAFE_FUNCTIONS,\n    #[cfg(any(\n        freebsdlike,\n        apple_targets,\n        target_os = \"linux\",\n        target_os = \"openbsd\"\n    ))]\n    /// The implementation supports the Thread Sporadic Server option.\n    _POSIX_THREAD_SPORADIC_SERVER = libc::_SC_THREAD_SPORADIC_SERVER,\n    /// The implementation supports threads.\n    #[cfg(not(target_os = \"redox\"))]\n    _POSIX_THREADS = libc::_SC_THREADS,\n    #[cfg(any(\n        freebsdlike,\n        apple_targets,\n        target_os = \"linux\",\n        target_os = \"openbsd\"\n    ))]\n    /// The implementation supports timeouts.\n    _POSIX_TIMEOUTS = libc::_SC_TIMEOUTS,\n    /// The implementation supports timers.\n    #[cfg(not(target_os = \"redox\"))]\n    _POSIX_TIMERS = libc::_SC_TIMERS,\n    #[cfg(any(\n        freebsdlike,\n        apple_targets,\n        target_os = \"linux\",\n        target_os = \"openbsd\"\n    ))]\n    /// The implementation supports the Trace option.\n    _POSIX_TRACE = libc::_SC_TRACE,\n    #[cfg(any(\n        freebsdlike,\n        apple_targets,\n        target_os = \"linux\",\n        target_os = \"openbsd\"\n    ))]\n    /// The implementation supports the Trace Event Filter option.\n    _POSIX_TRACE_EVENT_FILTER = libc::_SC_TRACE_EVENT_FILTER,\n    /// Maximum size of a trace event name in characters.\n    #[cfg(any(\n        apple_targets,\n        target_os = \"linux\",\n        target_os = \"openbsd\"\n    ))]\n    _POSIX_TRACE_EVENT_NAME_MAX = libc::_SC_TRACE_EVENT_NAME_MAX,\n    #[cfg(any(\n        freebsdlike,\n        apple_targets,\n        target_os = \"linux\",\n        target_os = \"openbsd\"\n    ))]\n    /// The implementation supports the Trace Inherit option.\n    _POSIX_TRACE_INHERIT = libc::_SC_TRACE_INHERIT,\n    #[cfg(any(\n        freebsdlike,\n        apple_targets,\n        target_os = \"linux\",\n        target_os = \"openbsd\"\n    ))]\n    /// The implementation supports the Trace Log option.\n    _POSIX_TRACE_LOG = libc::_SC_TRACE_LOG,\n    /// The length in bytes of a trace generation version string or a trace stream name.\n    #[cfg(any(\n        apple_targets,\n        target_os = \"linux\",\n        target_os = \"openbsd\"\n    ))]\n    _POSIX_TRACE_NAME_MAX = libc::_SC_TRACE_NAME_MAX,\n    /// Maximum number of times `posix_trace_create` may be called from the same or different\n    /// processes.\n    #[cfg(any(\n        apple_targets,\n        target_os = \"linux\",\n        target_os = \"openbsd\"\n    ))]\n    _POSIX_TRACE_SYS_MAX = libc::_SC_TRACE_SYS_MAX,\n    /// Maximum number of user trace event type identifiers for a single process.\n    #[cfg(any(\n        apple_targets,\n        target_os = \"linux\",\n        target_os = \"openbsd\"\n    ))]\n    _POSIX_TRACE_USER_EVENT_MAX = libc::_SC_TRACE_USER_EVENT_MAX,\n    #[cfg(any(\n        freebsdlike,\n        apple_targets,\n        target_os = \"linux\",\n        target_os = \"openbsd\"\n    ))]\n    /// The implementation supports the Typed Memory Objects option.\n    _POSIX_TYPED_MEMORY_OBJECTS = libc::_SC_TYPED_MEMORY_OBJECTS,\n    /// Integer value indicating version of this standard (C-language binding)\n    /// to which the implementation conforms. For implementations conforming to\n    /// POSIX.1-2008, the value shall be 200809L.\n    _POSIX_VERSION = libc::_SC_VERSION,\n    #[cfg(any(bsd, target_os = \"linux\"))]\n    /// The implementation provides a C-language compilation environment with\n    /// 32-bit `int`, `long`, `pointer`, and `off_t` types.\n    _POSIX_V6_ILP32_OFF32 = libc::_SC_V6_ILP32_OFF32,\n    #[cfg(any(bsd, target_os = \"linux\"))]\n    /// The implementation provides a C-language compilation environment with\n    /// 32-bit `int`, `long`, and pointer types and an `off_t` type using at\n    /// least 64 bits.\n    _POSIX_V6_ILP32_OFFBIG = libc::_SC_V6_ILP32_OFFBIG,\n    #[cfg(any(bsd, target_os = \"linux\"))]\n    /// The implementation provides a C-language compilation environment with\n    /// 32-bit `int` and 64-bit `long`, `pointer`, and `off_t` types.\n    _POSIX_V6_LP64_OFF64 = libc::_SC_V6_LP64_OFF64,\n    #[cfg(any(bsd, target_os = \"linux\"))]\n    /// The implementation provides a C-language compilation environment with an\n    /// `int` type using at least 32 bits and `long`, pointer, and `off_t` types\n    /// using at least 64 bits.\n    _POSIX_V6_LPBIG_OFFBIG = libc::_SC_V6_LPBIG_OFFBIG,\n    /// The implementation supports the C-Language Binding option.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _POSIX2_C_BIND = libc::_SC_2_C_BIND,\n    /// The implementation supports the C-Language Development Utilities option.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _POSIX2_C_DEV = libc::_SC_2_C_DEV,\n    /// The implementation supports the Terminal Characteristics option.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _POSIX2_CHAR_TERM = libc::_SC_2_CHAR_TERM,\n    /// The implementation supports the FORTRAN Development Utilities option.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _POSIX2_FORT_DEV = libc::_SC_2_FORT_DEV,\n    /// The implementation supports the FORTRAN Runtime Utilities option.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _POSIX2_FORT_RUN = libc::_SC_2_FORT_RUN,\n    /// The implementation supports the creation of locales by the localedef\n    /// utility.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _POSIX2_LOCALEDEF = libc::_SC_2_LOCALEDEF,\n    #[cfg(any(bsd, target_os = \"linux\"))]\n    /// The implementation supports the Batch Environment Services and Utilities\n    /// option.\n    _POSIX2_PBS = libc::_SC_2_PBS,\n    #[cfg(any(bsd, target_os = \"linux\"))]\n    /// The implementation supports the Batch Accounting option.\n    _POSIX2_PBS_ACCOUNTING = libc::_SC_2_PBS_ACCOUNTING,\n    #[cfg(any(bsd, target_os = \"linux\"))]\n    /// The implementation supports the Batch Checkpoint/Restart option.\n    _POSIX2_PBS_CHECKPOINT = libc::_SC_2_PBS_CHECKPOINT,\n    #[cfg(any(bsd, target_os = \"linux\"))]\n    /// The implementation supports the Locate Batch Job Request option.\n    _POSIX2_PBS_LOCATE = libc::_SC_2_PBS_LOCATE,\n    #[cfg(any(bsd, target_os = \"linux\"))]\n    /// The implementation supports the Batch Job Message Request option.\n    _POSIX2_PBS_MESSAGE = libc::_SC_2_PBS_MESSAGE,\n    #[cfg(any(bsd, target_os = \"linux\"))]\n    /// The implementation supports the Track Batch Job Request option.\n    _POSIX2_PBS_TRACK = libc::_SC_2_PBS_TRACK,\n    /// The implementation supports the Software Development Utilities option.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _POSIX2_SW_DEV = libc::_SC_2_SW_DEV,\n    /// The implementation supports the User Portability Utilities option.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _POSIX2_UPE = libc::_SC_2_UPE,\n    /// Integer value indicating version of the Shell and Utilities volume of\n    /// POSIX.1 to which the implementation conforms.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _POSIX2_VERSION = libc::_SC_2_VERSION,\n    /// The size of a system page in bytes.\n    ///\n    /// POSIX also defines an alias named `PAGESIZE`, but Rust does not allow two\n    /// enum constants to have the same value, so nix omits `PAGESIZE`.\n    PAGE_SIZE = libc::_SC_PAGE_SIZE,\n    /// Maximum number of attempts made to destroy a thread's thread-specific data values on thread\n    /// exit.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    PTHREAD_DESTRUCTOR_ITERATIONS = libc::_SC_THREAD_DESTRUCTOR_ITERATIONS,\n    /// Maximum number of data keys that can be created by a process.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    PTHREAD_KEYS_MAX = libc::_SC_THREAD_KEYS_MAX,\n    /// Minimum size in bytes of thread stack storage.\n    #[cfg(not(target_os = \"redox\"))]\n    PTHREAD_STACK_MIN = libc::_SC_THREAD_STACK_MIN,\n    /// Maximum number of threads that can be created per process.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    PTHREAD_THREADS_MAX = libc::_SC_THREAD_THREADS_MAX,\n    /// The maximum number of repeated occurrences of a regular expression permitted when using\n    /// interval notation.\n    #[cfg(not(target_os = \"haiku\"))]\n    RE_DUP_MAX = libc::_SC_RE_DUP_MAX,\n    /// Maximum number of realtime signals reserved for application use.\n    #[cfg(any(\n        linux_android,\n        freebsdlike,\n        apple_targets,\n        target_os = \"openbsd\"\n    ))]\n    RTSIG_MAX = libc::_SC_RTSIG_MAX,\n    /// Maximum number of semaphores that a process may have.\n    #[cfg(not(target_os = \"redox\"))]\n    SEM_NSEMS_MAX = libc::_SC_SEM_NSEMS_MAX,\n    /// The maximum value a semaphore may have.\n    #[cfg(any(\n        linux_android,\n        freebsdlike,\n        apple_targets,\n        target_os = \"openbsd\"\n    ))]\n    SEM_VALUE_MAX = libc::_SC_SEM_VALUE_MAX,\n    /// Maximum number of queued signals that a process may send and have pending at the\n    /// receiver(s) at any time.\n    #[cfg(any(\n        linux_android,\n        freebsdlike,\n        apple_targets,\n        target_os = \"openbsd\"\n    ))]\n    SIGQUEUE_MAX = libc::_SC_SIGQUEUE_MAX,\n    /// The minimum maximum number of streams that a process may have open at any one time.\n    STREAM_MAX = libc::_SC_STREAM_MAX,\n    /// Maximum number of symbolic links that can be reliably traversed in the resolution of a\n    /// pathname in the absence of a loop.\n    #[cfg(any(bsd, target_os = \"linux\"))]\n    SYMLOOP_MAX = libc::_SC_SYMLOOP_MAX,\n    /// Maximum number of timers per process supported.\n    #[cfg(not(target_os = \"redox\"))]\n    TIMER_MAX = libc::_SC_TIMER_MAX,\n    /// Maximum length of terminal device name.\n    TTY_NAME_MAX = libc::_SC_TTY_NAME_MAX,\n    /// The minimum maximum number of types supported for the name of a timezone.\n    TZNAME_MAX = libc::_SC_TZNAME_MAX,\n    #[cfg(any(\n        linux_android,\n        freebsdlike,\n        apple_targets,\n        target_os = \"openbsd\"\n    ))]\n    /// The implementation supports the X/Open Encryption Option Group.\n    _XOPEN_CRYPT = libc::_SC_XOPEN_CRYPT,\n    #[cfg(any(\n        linux_android,\n        freebsdlike,\n        apple_targets,\n        target_os = \"openbsd\"\n    ))]\n    /// The implementation supports the Issue 4, Version 2 Enhanced\n    /// Internationalization Option Group.\n    _XOPEN_ENH_I18N = libc::_SC_XOPEN_ENH_I18N,\n    #[cfg(any(\n        linux_android,\n        freebsdlike,\n        apple_targets,\n        target_os = \"openbsd\"\n    ))]\n    /// The implementation supports the XOpen Legacy Option group.\n    ///\n    /// See Also \u003chttps://pubs.opengroup.org/onlinepubs/007904975/basedefs/xbd_chap02.html\u003e\n    _XOPEN_LEGACY = libc::_SC_XOPEN_LEGACY,\n    #[cfg(any(\n        linux_android,\n        freebsdlike,\n        apple_targets,\n        target_os = \"openbsd\"\n    ))]\n    /// The implementation supports the X/Open Realtime Option Group.\n    _XOPEN_REALTIME = libc::_SC_XOPEN_REALTIME,\n    #[cfg(any(\n        linux_android,\n        freebsdlike,\n        apple_targets,\n        target_os = \"openbsd\"\n    ))]\n    /// The implementation supports the X/Open Realtime Threads Option Group.\n    _XOPEN_REALTIME_THREADS = libc::_SC_XOPEN_REALTIME_THREADS,\n    /// The implementation supports the Issue 4, Version 2 Shared Memory Option\n    /// Group.\n    #[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n    _XOPEN_SHM = libc::_SC_XOPEN_SHM,\n    #[cfg(any(\n        freebsdlike,\n        apple_targets,\n        target_os = \"linux\",\n        target_os = \"openbsd\"\n    ))]\n    /// The implementation supports the XSI STREAMS Option Group.\n    _XOPEN_STREAMS = libc::_SC_XOPEN_STREAMS,\n    #[cfg(any(\n        linux_android,\n        freebsdlike,\n        apple_targets,\n        target_os = \"openbsd\"\n    ))]\n    /// The implementation supports the XSI option\n    _XOPEN_UNIX = libc::_SC_XOPEN_UNIX,\n    #[cfg(any(\n        linux_android,\n        freebsdlike,\n        apple_targets,\n        target_os = \"openbsd\"\n    ))]\n    /// Integer value indicating version of the X/Open Portability Guide to\n    /// which the implementation conforms.\n    _XOPEN_VERSION = libc::_SC_XOPEN_VERSION,\n    /// The number of pages of physical memory. Note that it is possible for\n    /// the product of this value to overflow.\n    #[cfg(linux_android)]\n    _PHYS_PAGES = libc::_SC_PHYS_PAGES,\n    /// The number of currently available pages of physical memory.\n    #[cfg(linux_android)]\n    _AVPHYS_PAGES = libc::_SC_AVPHYS_PAGES,\n    /// The number of processors configured.\n    #[cfg(linux_android)]\n    _NPROCESSORS_CONF = libc::_SC_NPROCESSORS_CONF,\n    /// The number of processors currently online (available).\n    #[cfg(linux_android)]\n    _NPROCESSORS_ONLN = libc::_SC_NPROCESSORS_ONLN,\n}\n\n/// Get configurable system variables (see\n/// [sysconf(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/sysconf.html))\n///\n/// Returns the value of a configurable system variable.  Most supported\n/// variables also have associated compile-time constants, but POSIX\n/// allows their values to change at runtime.  There are generally two types of\n/// sysconf variables: options and limits.  See sysconf(3) for more details.\n///\n/// # Returns\n///\n/// - `Ok(Some(x))`: the variable's limit (for limit variables) or its\n///     implementation level (for option variables).  Implementation levels are\n///     usually a decimal-coded date, such as 200112 for POSIX 2001.12\n/// - `Ok(None)`: the variable has no limit (for limit variables) or is\n///     unsupported (for option variables)\n/// - `Err(x)`: an error occurred\npub fn sysconf(var: SysconfVar) -\u003e Result\u003cOption\u003cc_long\u003e\u003e {\n    let raw = unsafe {\n        Errno::clear();\n        libc::sysconf(var as c_int)\n    };\n    if raw == -1 {\n        if Errno::last_raw() == 0 {\n            Ok(None)\n        } else {\n            Err(Errno::last())\n        }\n    } else {\n        Ok(Some(raw))\n    }\n}\n}\n\n#[cfg(linux_android)]\n#[cfg(feature = \"fs\")]\nmod pivot_root {\n    use crate::errno::Errno;\n    use crate::{NixPath, Result};\n\n    /// Change the root file system.\n    ///\n    /// See Also [`pivot_root`](https://man7.org/linux/man-pages/man2/pivot_root.2.html)\n    pub fn pivot_root\u003cP1: ?Sized + NixPath, P2: ?Sized + NixPath\u003e(\n        new_root: \u0026P1,\n        put_old: \u0026P2,\n    ) -\u003e Result\u003c()\u003e {\n        let res = new_root.with_nix_path(|new_root| {\n            put_old.with_nix_path(|put_old| unsafe {\n                libc::syscall(\n                    libc::SYS_pivot_root,\n                    new_root.as_ptr(),\n                    put_old.as_ptr(),\n                )\n            })\n        })??;\n\n        Errno::result(res).map(drop)\n    }\n}\n\n#[cfg(any(linux_android, freebsdlike, target_os = \"openbsd\"))]\nmod setres {\n    feature! {\n    #![feature = \"user\"]\n\n    use super::{Gid, Uid};\n    use crate::errno::Errno;\n    use crate::Result;\n\n    /// Sets the real, effective, and saved uid.\n    /// ([see setresuid(2)](https://man7.org/linux/man-pages/man2/setresuid.2.html))\n    ///\n    /// * `ruid`: real user id\n    /// * `euid`: effective user id\n    /// * `suid`: saved user id\n    /// * returns: Ok or libc error code.\n    ///\n    /// Err is returned if the user doesn't have permission to set this UID.\n    #[inline]\n    pub fn setresuid(ruid: Uid, euid: Uid, suid: Uid) -\u003e Result\u003c()\u003e {\n        let res =\n            unsafe { libc::setresuid(ruid.into(), euid.into(), suid.into()) };\n\n        Errno::result(res).map(drop)\n    }\n\n    /// Sets the real, effective, and saved gid.\n    /// ([see setresuid(2)](https://man7.org/linux/man-pages/man2/setresuid.2.html))\n    ///\n    /// * `rgid`: real group id\n    /// * `egid`: effective group id\n    /// * `sgid`: saved group id\n    /// * returns: Ok or libc error code.\n    ///\n    /// Err is returned if the user doesn't have permission to set this GID.\n    #[inline]\n    pub fn setresgid(rgid: Gid, egid: Gid, sgid: Gid) -\u003e Result\u003c()\u003e {\n        let res =\n            unsafe { libc::setresgid(rgid.into(), egid.into(), sgid.into()) };\n\n        Errno::result(res).map(drop)\n    }\n    }\n}\n\n#[cfg(any(linux_android, freebsdlike, target_os = \"openbsd\"))]\nmod getres {\n    feature! {\n    #![feature = \"user\"]\n\n    use super::{Gid, Uid};\n    use crate::errno::Errno;\n    use crate::Result;\n\n    /// Real, effective and saved user IDs.\n    #[derive(Debug, Copy, Clone, Eq, PartialEq)]\n    pub struct ResUid {\n        /// Real UID\n        pub real: Uid,\n        /// Effective UID\n        pub effective: Uid,\n        /// Saved UID\n        pub saved: Uid,\n    }\n\n    /// Real, effective and saved group IDs.\n    #[derive(Debug, Copy, Clone, Eq, PartialEq)]\n    pub struct ResGid {\n        /// Real GID\n        pub real: Gid,\n        /// Effective GID\n        pub effective: Gid,\n        /// Saved GID\n        pub saved: Gid,\n    }\n\n    /// Gets the real, effective, and saved user IDs.\n    ///\n    /// ([see getresuid(2)](http://man7.org/linux/man-pages/man2/getresuid.2.html))\n    ///\n    /// #Returns\n    ///\n    /// - `Ok((Uid, Uid, Uid))`: tuple of real, effective and saved uids on success.\n    /// - `Err(x)`: libc error code on failure.\n    ///\n    #[inline]\n    pub fn getresuid() -\u003e Result\u003cResUid\u003e {\n        let mut ruid = libc::uid_t::MAX;\n        let mut euid = libc::uid_t::MAX;\n        let mut suid = libc::uid_t::MAX;\n        let res = unsafe { libc::getresuid(\u0026mut ruid, \u0026mut euid, \u0026mut suid) };\n\n        Errno::result(res).map(|_| ResUid {\n            real: Uid(ruid),\n            effective: Uid(euid),\n            saved: Uid(suid),\n        })\n    }\n\n    /// Gets the real, effective, and saved group IDs.\n    ///\n    /// ([see getresgid(2)](http://man7.org/linux/man-pages/man2/getresgid.2.html))\n    ///\n    /// #Returns\n    ///\n    /// - `Ok((Gid, Gid, Gid))`: tuple of real, effective and saved gids on success.\n    /// - `Err(x)`: libc error code on failure.\n    ///\n    #[inline]\n    pub fn getresgid() -\u003e Result\u003cResGid\u003e {\n        let mut rgid = libc::gid_t::MAX;\n        let mut egid = libc::gid_t::MAX;\n        let mut sgid = libc::gid_t::MAX;\n        let res = unsafe { libc::getresgid(\u0026mut rgid, \u0026mut egid, \u0026mut sgid) };\n\n        Errno::result(res).map(|_| ResGid {\n            real: Gid(rgid),\n            effective: Gid(egid),\n            saved: Gid(sgid),\n        })\n    }\n    }\n}\n\n#[cfg(feature = \"process\")]\n#[cfg(target_os = \"freebsd\")]\nlibc_bitflags! {\n    /// Flags for [`rfork`]\n    ///\n    /// subset of flags supported by FreeBSD 12.x and onwards\n    /// with a safe outcome, thus as `RFMEM` can possibly lead to undefined behavior,\n    /// it is not in the list. And `rfork_thread` is deprecated.\n    pub struct RforkFlags: libc::c_int {\n        /// creates a new process.\n        RFPROC;\n        /// the child process will detach from the parent.\n        /// however, no status will be emitted at child's exit.\n        RFNOWAIT;\n        /// the file descriptor's table will be copied\n        RFFDG;\n        /// a new file descriptor's table will be created\n        RFCFDG;\n        /// force sharing the sigacts structure between\n        /// the child and the parent.\n        RFSIGSHARE;\n        /// enables kernel thread support.\n        RFTHREAD;\n        /// sets a status to emit at child's exit.\n        RFTSIGZMB;\n        /// linux's behavior compatibility setting.\n        /// emits SIGUSR1 as opposed to SIGCHLD upon child's exit.\n        RFLINUXTHPN;\n    }\n}\n\nfeature! {\n#![feature = \"process\"]\n#[cfg(target_os = \"freebsd\")]\n/// Like [`fork`], `rfork` can be used to have a tigher control about which\n/// resources child and parent process will be sharing, file descriptors,\n/// address spaces and child exit's behavior.\n///\n/// # Safety\n///\n/// The same restrictions apply as for [`fork`].\n///\n/// # See Also\n///\n/// * [rfork(2)](https://man.freebsd.org/cgi/man.cgi?query=rfork)\npub unsafe fn rfork(flags: RforkFlags) -\u003e Result\u003cForkResult\u003e {\n    use ForkResult::*;\n    let res = unsafe { libc::rfork(flags.bits()) };\n\n    Errno::result(res).map(|res| match res {\n        0 =\u003e Child,\n        res =\u003e Parent { child: Pid(res) },\n    })\n}\n}\n\n#[cfg(feature = \"fs\")]\nlibc_bitflags! {\n    /// Options for access()\n    #[cfg_attr(docsrs, doc(cfg(feature = \"fs\")))]\n    pub struct AccessFlags : c_int {\n        /// Test for existence of file.\n        F_OK;\n        /// Test for read permission.\n        R_OK;\n        /// Test for write permission.\n        W_OK;\n        /// Test for execute (search) permission.\n        X_OK;\n    }\n}\n\nfeature! {\n#![feature = \"fs\"]\n\n/// Checks the file named by `path` for accessibility according to the flags given by `amode`\n/// See [access(2)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/access.html)\npub fn access\u003cP: ?Sized + NixPath\u003e(path: \u0026P, amode: AccessFlags) -\u003e Result\u003c()\u003e {\n    let res = path.with_nix_path(|cstr| unsafe {\n        libc::access(cstr.as_ptr(), amode.bits())\n    })?;\n    Errno::result(res).map(drop)\n}\n\n/// Checks the file named by `dirfd` and `path` for accessibility according to\n/// the flags given by `mode`\n///\n/// # References\n///\n/// [faccessat(2)](http://pubs.opengroup.org/onlinepubs/9699919799/functions/faccessat.html)\n// redox: does not appear to support the *at family of syscalls.\n#[cfg(not(target_os = \"redox\"))]\npub fn faccessat\u003cFd: std::os::fd::AsFd, P: ?Sized + NixPath\u003e(\n    dirfd: Fd,\n    path: \u0026P,\n    mode: AccessFlags,\n    flags: AtFlags,\n) -\u003e Result\u003c()\u003e {\n    use std::os::fd::AsRawFd;\n\n    let res = path.with_nix_path(|cstr| unsafe {\n        libc::faccessat(\n            dirfd.as_fd().as_raw_fd(),\n            cstr.as_ptr(),\n            mode.bits(),\n            flags.bits(),\n        )\n    })?;\n    Errno::result(res).map(drop)\n}\n\n/// Checks the file named by `path` for accessibility according to the flags given\n/// by `mode` using effective UID, effective GID and supplementary group lists.\n///\n/// # References\n///\n/// * [FreeBSD man page](https://www.freebsd.org/cgi/man.cgi?query=eaccess\u0026sektion=2\u0026n=1)\n/// * [Linux man page](https://man7.org/linux/man-pages/man3/euidaccess.3.html)\n#[cfg(any(\n    freebsdlike,\n    all(target_os = \"linux\", not(target_env = \"uclibc\")),\n))]\npub fn eaccess\u003cP: ?Sized + NixPath\u003e(path: \u0026P, mode: AccessFlags) -\u003e Result\u003c()\u003e {\n    let res = path.with_nix_path(|cstr| unsafe {\n        libc::eaccess(cstr.as_ptr(), mode.bits())\n    })?;\n    Errno::result(res).map(drop)\n}\n}\n\nfeature! {\n#![feature = \"user\"]\n\n/// Representation of a User, based on `libc::passwd`\n///\n/// The reason some fields in this struct are `String` and others are `CString` is because some\n/// fields are based on the user's locale, which could be non-UTF8, while other fields are\n/// guaranteed to conform to [`NAME_REGEX`](https://serverfault.com/a/73101/407341), which only\n/// contains ASCII.\n#[cfg(not(target_os = \"redox\"))] // RedoxFS does not support passwd\n#[derive(Debug, Clone, Eq, PartialEq)]\npub struct User {\n    /// Username\n    pub name: String,\n    /// User password (probably hashed)\n    pub passwd: CString,\n    /// User ID\n    pub uid: Uid,\n    /// Group ID\n    pub gid: Gid,\n    /// User information\n    #[cfg(not(all(target_os = \"android\", target_pointer_width = \"32\")))]\n    pub gecos: CString,\n    /// Home directory\n    pub dir: PathBuf,\n    /// Path to shell\n    pub shell: PathBuf,\n    /// Login class\n    #[cfg(not(any(\n        linux_android,\n        solarish,\n        target_os = \"aix\",\n        target_os = \"fuchsia\",\n        target_os = \"haiku\",\n        target_os = \"hurd\",\n        target_os = \"emscripten\",\n        target_os = \"cygwin\",\n    )))]\n    pub class: CString,\n    /// Last password change\n    #[cfg(not(any(\n        linux_android,\n        solarish,\n        target_os = \"aix\",\n        target_os = \"fuchsia\",\n        target_os = \"haiku\",\n        target_os = \"hurd\",\n        target_os = \"emscripten\",\n        target_os = \"cygwin\",\n    )))]\n    pub change: libc::time_t,\n    /// Expiration time of account\n    #[cfg(not(any(\n        linux_android,\n        solarish,\n        target_os = \"aix\",\n        target_os = \"fuchsia\",\n        target_os = \"haiku\",\n        target_os = \"hurd\",\n        target_os = \"emscripten\",\n        target_os = \"cygwin\",\n    )))]\n    pub expire: libc::time_t,\n}\n\n#[cfg(not(target_os = \"redox\"))] //RedoxFS does not support passwd\nimpl From\u003c\u0026libc::passwd\u003e for User {\n    fn from(pw: \u0026libc::passwd) -\u003e User {\n        unsafe {\n            User {\n                name: if pw.pw_name.is_null() {\n                    Default::default()\n                } else {\n                    CStr::from_ptr(pw.pw_name).to_string_lossy().into_owned()\n                },\n                passwd: if pw.pw_passwd.is_null() {\n                    Default::default()\n                } else {\n                    CString::new(CStr::from_ptr(pw.pw_passwd).to_bytes())\n                        .unwrap()\n                },\n                #[cfg(not(all(\n                    target_os = \"android\",\n                    target_pointer_width = \"32\"\n                )))]\n                gecos: if pw.pw_gecos.is_null() {\n                    Default::default()\n                } else {\n                    CString::new(CStr::from_ptr(pw.pw_gecos).to_bytes())\n                        .unwrap()\n                },\n                dir: if pw.pw_dir.is_null() {\n                    Default::default()\n                } else {\n                    PathBuf::from(OsStr::from_bytes(\n                        CStr::from_ptr(pw.pw_dir).to_bytes(),\n                    ))\n                },\n                shell: if pw.pw_shell.is_null() {\n                    Default::default()\n                } else {\n                    PathBuf::from(OsStr::from_bytes(\n                        CStr::from_ptr(pw.pw_shell).to_bytes(),\n                    ))\n                },\n                uid: Uid::from_raw(pw.pw_uid),\n                gid: Gid::from_raw(pw.pw_gid),\n                #[cfg(not(any(\n                    linux_android,\n                    solarish,\n                    target_os = \"aix\",\n                    target_os = \"fuchsia\",\n                    target_os = \"haiku\",\n                    target_os = \"hurd\",\n                    target_os = \"emscripten\",\n                    target_os = \"cygwin\",\n                )))]\n                class: CString::new(CStr::from_ptr(pw.pw_class).to_bytes())\n                    .unwrap(),\n                #[cfg(not(any(\n                    linux_android,\n                    solarish,\n                    target_os = \"aix\",\n                    target_os = \"fuchsia\",\n                    target_os = \"haiku\",\n                    target_os = \"hurd\",\n                    target_os = \"emscripten\",\n                    target_os = \"cygwin\",\n                )))]\n                change: pw.pw_change,\n                #[cfg(not(any(\n                    linux_android,\n                    solarish,\n                    target_os = \"aix\",\n                    target_os = \"fuchsia\",\n                    target_os = \"haiku\",\n                    target_os = \"hurd\",\n                    target_os = \"emscripten\",\n                    target_os = \"cygwin\",\n                )))]\n                expire: pw.pw_expire,\n            }\n        }\n    }\n}\n\n#[cfg(not(target_os = \"redox\"))] // RedoxFS does not support passwd\nimpl From\u003cUser\u003e for libc::passwd {\n    fn from(u: User) -\u003e Self {\n        let name = match CString::new(u.name) {\n            Ok(n) =\u003e n.into_raw(),\n            Err(_) =\u003e CString::new(\"\").unwrap().into_raw(),\n        };\n        let dir = match u.dir.into_os_string().into_string() {\n            Ok(s) =\u003e CString::new(s.as_str()).unwrap().into_raw(),\n            Err(_) =\u003e CString::new(\"\").unwrap().into_raw(),\n        };\n        let shell = match u.shell.into_os_string().into_string() {\n            Ok(s) =\u003e CString::new(s.as_str()).unwrap().into_raw(),\n            Err(_) =\u003e CString::new(\"\").unwrap().into_raw(),\n        };\n        Self {\n            pw_name: name,\n            pw_passwd: u.passwd.into_raw(),\n            #[cfg(not(all(\n                target_os = \"android\",\n                target_pointer_width = \"32\"\n            )))]\n            pw_gecos: u.gecos.into_raw(),\n            pw_dir: dir,\n            pw_shell: shell,\n            pw_uid: u.uid.0,\n            pw_gid: u.gid.0,\n            #[cfg(not(any(\n                linux_android,\n                solarish,\n                target_os = \"aix\",\n                target_os = \"fuchsia\",\n                target_os = \"haiku\",\n                target_os = \"hurd\",\n                target_os = \"emscripten\",\n                target_os = \"cygwin\",\n            )))]\n            pw_class: u.class.into_raw(),\n            #[cfg(not(any(\n                linux_android,\n                solarish,\n                target_os = \"aix\",\n                target_os = \"fuchsia\",\n                target_os = \"haiku\",\n                target_os = \"hurd\",\n                target_os = \"emscripten\",\n                target_os = \"cygwin\",\n            )))]\n            pw_change: u.change,\n            #[cfg(not(any(\n                linux_android,\n                solarish,\n                target_os = \"aix\",\n                target_os = \"fuchsia\",\n                target_os = \"haiku\",\n                target_os = \"hurd\",\n                target_os = \"emscripten\",\n                target_os = \"cygwin\",\n            )))]\n            pw_expire: u.expire,\n            #[cfg(solarish)]\n            pw_age: CString::new(\"\").unwrap().into_raw(),\n            #[cfg(any(solarish, target_os = \"cygwin\"))]\n            pw_comment: CString::new(\"\").unwrap().into_raw(),\n            #[cfg(freebsdlike)]\n            pw_fields: 0,\n        }\n    }\n}\n\n#[cfg(not(target_os = \"redox\"))] // RedoxFS does not support passwd\nimpl User {\n    /// # Safety\n    ///\n    /// If `f` writes to its `*mut *mut libc::passwd` parameter, then it must\n    /// also initialize the value pointed to by its `*mut libc::group`\n    /// parameter.\n    unsafe fn from_anything\u003cF\u003e(f: F) -\u003e Result\u003cOption\u003cSelf\u003e\u003e\n    where\n        F: Fn(\n            *mut libc::passwd,\n            *mut c_char,\n            libc::size_t,\n            *mut *mut libc::passwd,\n        ) -\u003e libc::c_int,\n    {\n        let buflimit = 1048576;\n        let bufsize = match sysconf(SysconfVar::GETPW_R_SIZE_MAX) {\n            Ok(Some(n)) =\u003e n as usize,\n            Ok(None) | Err(_) =\u003e 16384,\n        };\n\n        let mut cbuf = Vec::with_capacity(bufsize);\n        let mut pwd = mem::MaybeUninit::\u003clibc::passwd\u003e::uninit();\n        let mut res = ptr::null_mut();\n\n        loop {\n            let error = f(\n                pwd.as_mut_ptr(),\n                cbuf.as_mut_ptr(),\n                cbuf.capacity(),\n                \u0026mut res,\n            );\n            if error == 0 {\n                if res.is_null() {\n                    return Ok(None);\n                } else {\n                    // SAFETY: `f` guarantees that `pwd` is initialized if `res`\n                    // is not null.\n                    let pwd = unsafe { pwd.assume_init() };\n                    return Ok(Some(User::from(\u0026pwd)));\n                }\n            } else if Errno::last() == Errno::ERANGE {\n                // Trigger the internal buffer resizing logic.\n                reserve_double_buffer_size(\u0026mut cbuf, buflimit)?;\n            } else {\n                return Err(Errno::last());\n            }\n        }\n    }\n\n    /// Get a user by UID.\n    ///\n    /// Internally, this function calls\n    /// [getpwuid_r(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpwuid_r.html)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use nix::unistd::{Uid, User};\n    /// // Returns an Result\u003cOption\u003cUser\u003e\u003e, thus the double unwrap.\n    /// let res = User::from_uid(Uid::from_raw(0)).unwrap().unwrap();\n    /// assert_eq!(res.name, \"root\");\n    /// ```\n    #[doc(alias(\"getpwuid\", \"getpwuid_r\"))]\n    pub fn from_uid(uid: Uid) -\u003e Result\u003cOption\u003cSelf\u003e\u003e {\n        // SAFETY: `getpwuid_r` will write to `res` if it initializes the value\n        // at `pwd`.\n        unsafe {\n            User::from_anything(|pwd, cbuf, cap, res| {\n                libc::getpwuid_r(uid.0, pwd, cbuf, cap, res)\n            })\n        }\n    }\n\n    /// Get a user by name.\n    ///\n    /// Internally, this function calls\n    /// [getpwnam_r(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpwnam_r.html)\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// use nix::unistd::User;\n    /// // Returns an Result\u003cOption\u003cUser\u003e\u003e, thus the double unwrap.\n    /// let res = User::from_name(\"root\").unwrap().unwrap();\n    /// assert_eq!(res.name, \"root\");\n    /// ```\n    #[doc(alias(\"getpwnam\", \"getpwnam_r\"))]\n    pub fn from_name(name: \u0026str) -\u003e Result\u003cOption\u003cSelf\u003e\u003e {\n        let name = match CString::new(name) {\n            Ok(c_str) =\u003e c_str,\n            Err(_nul_error) =\u003e return Ok(None),\n        };\n        // SAFETY: `getpwnam_r` will write to `res` if it initializes the value\n        // at `pwd`.\n        unsafe {\n            User::from_anything(|pwd, cbuf, cap, res| {\n                libc::getpwnam_r(name.as_ptr(), pwd, cbuf, cap, res)\n            })\n        }\n    }\n}\n\n/// Representation of a Group, based on `libc::group`\n#[cfg(not(target_os = \"redox\"))] // RedoxFS does not support passwd\n#[derive(Debug, Clone, Eq, PartialEq)]\npub struct Group {\n    /// Group name\n    pub name: String,\n    /// Group password\n    pub passwd: CString,\n    /// Group ID\n    pub gid: Gid,\n    /// List of Group members\n    pub mem: Vec\u003cString\u003e,\n}\n\n#[cfg(not(target_os = \"redox\"))] // RedoxFS does not support passwd\nimpl From\u003c\u0026libc::group\u003e for Group {\n    fn from(gr: \u0026libc::group) -\u003e Group {\n        unsafe {\n            Group {\n                name: if gr.gr_name.is_null() {\n                    Default::default()\n                } else {\n                    CStr::from_ptr(gr.gr_name).to_string_lossy().into_owned()\n                },\n                passwd: if gr.gr_passwd.is_null() {\n                    Default::default()\n                } else {\n                    CString::new(CStr::from_ptr(gr.gr_passwd).to_bytes())\n                        .unwrap()\n                },\n                gid: Gid::from_raw(gr.gr_gid),\n                mem: if gr.gr_mem.is_null() {\n                    Default::default()\n                } else {\n                    Group::members(gr.gr_mem)\n                },\n            }\n        }\n    }\n}\n\n#[cfg(not(target_os = \"redox\"))] // RedoxFS does not support passwd\nimpl Group {\n    unsafe fn members(mem: *mut *mut c_char) -\u003e Vec\u003cString\u003e {\n        let mut ret = Vec::new();\n\n        for i in 0.. {\n            let u = unsafe { mem.offset(i).read_unaligned() };\n            if u.is_null() {\n                break;\n            } else {\n                let s = unsafe {CStr::from_ptr(u).to_string_lossy().into_owned()};\n                ret.push(s);\n            }\n        }\n\n        ret\n    }\n    /// # Safety\n    ///\n    /// If `f` writes to its `*mut *mut libc::group` parameter, then it must\n    /// also initialize the value pointed to by its `*mut libc::group`\n    /// parameter.\n    unsafe fn from_anything\u003cF\u003e(f: F) -\u003e Result\u003cOption\u003cSelf\u003e\u003e\n    where\n        F: Fn(\n            *mut libc::group,\n            *mut c_char,\n            libc::size_t,\n            *mut *mut libc::group,\n        ) -\u003e libc::c_int,\n    {\n        let buflimit = 1048576;\n        let bufsize = match sysconf(SysconfVar::GETGR_R_SIZE_MAX) {\n            Ok(Some(n)) =\u003e n as usize,\n            Ok(None) | Err(_) =\u003e 16384,\n        };\n\n        let mut cbuf = Vec::with_capacity(bufsize);\n        let mut grp = mem::MaybeUninit::\u003clibc::group\u003e::uninit();\n        let mut res = ptr::null_mut();\n\n        loop {\n            let error = f(\n                grp.as_mut_ptr(),\n                cbuf.as_mut_ptr(),\n                cbuf.capacity(),\n                \u0026mut res,\n            );\n            if error == 0 {\n                if res.is_null() {\n                    return Ok(None);\n                } else {\n                    // SAFETY: `f` guarantees that `grp` is initialized if `res`\n                    // is not null.\n                    let grp = unsafe { grp.assume_init() };\n                    return Ok(Some(Group::from(\u0026grp)));\n                }\n            } else if Errno::last() == Errno::ERANGE {\n                // Trigger the internal buffer resizing logic.\n                reserve_double_buffer_size(\u0026mut cbuf, buflimit)?;\n            } else {\n                return Err(Errno::last());\n            }\n        }\n    }\n\n    /// Get a group by GID.\n    ///\n    /// Internally, this function calls\n    /// [getgrgid_r(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpwuid_r.html)\n    ///\n    /// # Examples\n    ///\n    // Disable this test on all OS except Linux as root group may not exist.\n    #[cfg_attr(not(target_os = \"linux\"), doc = \" ```no_run\")]\n    #[cfg_attr(target_os = \"linux\", doc = \" ```\")]\n    /// use nix::unistd::{Gid, Group};\n    /// // Returns an Result\u003cOption\u003cGroup\u003e\u003e, thus the double unwrap.\n    /// let res = Group::from_gid(Gid::from_raw(0)).unwrap().unwrap();\n    /// assert!(res.name == \"root\");\n    /// ```\n    pub fn from_gid(gid: Gid) -\u003e Result\u003cOption\u003cSelf\u003e\u003e {\n        // SAFETY: `getgrgid_r` will write to `res` if it initializes the value\n        // at `grp`.\n        unsafe {\n            Group::from_anything(|grp, cbuf, cap, res| {\n                libc::getgrgid_r(gid.0, grp, cbuf, cap, res)\n            })\n        }\n    }\n\n    /// Get a group by name.\n    ///\n    /// Internally, this function calls\n    /// [getgrnam_r(3)](https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpwuid_r.html)\n    ///\n    /// # Examples\n    ///\n    // Disable this test on all OS except Linux as root group may not exist.\n    #[cfg_attr(not(target_os = \"linux\"), doc = \" ```no_run\")]\n    #[cfg_attr(target_os = \"linux\", doc = \" ```\")]\n    /// use nix::unistd::Group;\n    /// // Returns an Result\u003cOption\u003cGroup\u003e\u003e, thus the double unwrap.\n    /// let res = Group::from_name(\"root\").unwrap().unwrap();\n    /// assert!(res.name == \"root\");\n    /// ```\n    pub fn from_name(name: \u0026str) -\u003e Result\u003cOption\u003cSelf\u003e\u003e {\n        let name = match CString::new(name) {\n            Ok(c_str) =\u003e c_str,\n            Err(_nul_error) =\u003e return Ok(None),\n        };\n        // SAFETY: `getgrnam_r` will write to `res` if it initializes the value\n        // at `grp`.\n        unsafe {\n            Group::from_anything(|grp, cbuf, cap, res| {\n                libc::getgrnam_r(name.as_ptr(), grp, cbuf, cap, res)\n            })\n        }\n    }\n}\n}\n\nfeature! {\n#![feature = \"term\"]\n\n/// Get the name of the terminal device that is open on file descriptor fd\n/// (see [`ttyname(3)`](https://man7.org/linux/man-pages/man3/ttyname.3.html)).\n#[cfg(not(target_os = \"fuchsia\"))]\npub fn ttyname\u003cF: std::os::fd::AsFd\u003e(fd: F) -\u003e Result\u003cPathBuf\u003e {\n    use std::os::fd::AsRawFd;\n\n    #[cfg(not(target_os = \"hurd\"))]\n    const PATH_MAX: usize = libc::PATH_MAX as usize;\n    #[cfg(target_os = \"hurd\")]\n    const PATH_MAX: usize = 1024; // Hurd does not define a hard limit, so try a guess first\n    let mut buf = vec![0_u8; PATH_MAX];\n    let c_buf = buf.as_mut_ptr().cast();\n\n    let ret = unsafe { libc::ttyname_r(fd.as_fd().as_raw_fd(), c_buf, buf.len()) };\n    if ret != 0 {\n        return Err(Errno::from_raw(ret));\n    }\n\n    CStr::from_bytes_until_nul(\u0026buf[..])\n        .map(|s| OsStr::from_bytes(s.to_bytes()).into())\n        .map_err(|_| Errno::EINVAL)\n}\n}\n\nfeature! {\n#![all(feature = \"socket\", feature = \"user\")]\n\n/// Get the effective user ID and group ID associated with a Unix domain socket.\n///\n/// See also [getpeereid(3)](https://www.freebsd.org/cgi/man.cgi?query=getpeereid)\n#[cfg(bsd)]\npub fn getpeereid\u003cF: std::os::fd::AsFd\u003e(fd: F) -\u003e Result\u003c(Uid, Gid)\u003e {\n    use std::os::fd::AsRawFd;\n\n    let mut uid = 1;\n    let mut gid = 1;\n\n    let ret = unsafe { libc::getpeereid(fd.as_fd().as_raw_fd(), \u0026mut uid, \u0026mut gid) };\n\n    Errno::result(ret).map(|_| (Uid(uid), Gid(gid)))\n}\n}\n\nfeature! {\n#![all(feature = \"fs\")]\n\n/// Set the file flags.\n///\n/// See also [chflags(2)](https://www.freebsd.org/cgi/man.cgi?query=chflags\u0026sektion=2)\n#[cfg(bsd)]\npub fn chflags\u003cP: ?Sized + NixPath\u003e(path: \u0026P, flags: FileFlag) -\u003e Result\u003c()\u003e {\n    let res = path.with_nix_path(|cstr| unsafe {\n        libc::chflags(cstr.as_ptr(), flags.bits())\n    })?;\n\n    Errno::result(res).map(drop)\n}\n}\n","traces":[{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":902,"address":[],"length":0,"stats":{"Line":0}},{"line":905,"address":[],"length":0,"stats":{"Line":0}},{"line":906,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":1346,"address":[],"length":0,"stats":{"Line":0}},{"line":1347,"address":[],"length":0,"stats":{"Line":0}},{"line":1348,"address":[],"length":0,"stats":{"Line":0}},{"line":1354,"address":[],"length":0,"stats":{"Line":0}},{"line":1359,"address":[],"length":0,"stats":{"Line":0}},{"line":1360,"address":[],"length":0,"stats":{"Line":0}},{"line":1361,"address":[],"length":0,"stats":{"Line":0}},{"line":1365,"address":[],"length":0,"stats":{"Line":0}},{"line":1371,"address":[],"length":0,"stats":{"Line":0}},{"line":1376,"address":[],"length":0,"stats":{"Line":0}},{"line":1377,"address":[],"length":0,"stats":{"Line":0}},{"line":1378,"address":[],"length":0,"stats":{"Line":0}},{"line":1382,"address":[],"length":0,"stats":{"Line":0}},{"line":2204,"address":[],"length":0,"stats":{"Line":0}},{"line":2205,"address":[],"length":0,"stats":{"Line":0}},{"line":3199,"address":[],"length":0,"stats":{"Line":0}},{"line":3200,"address":[],"length":0,"stats":{"Line":0}},{"line":3201,"address":[],"length":0,"stats":{"Line":0}},{"line":3202,"address":[],"length":0,"stats":{"Line":0}},{"line":3203,"address":[],"length":0,"stats":{"Line":0}},{"line":3204,"address":[],"length":0,"stats":{"Line":0}},{"line":3209,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":28},{"path":["/","home","acooks","mcr","nix-0.30.1","test","common","mod.rs"],"content":"use cfg_if::cfg_if;\n\n#[macro_export]\nmacro_rules! skip {\n    ($($reason: expr),+) =\u003e {{\n        use ::std::io::{self, Write};\n\n        let stderr = io::stderr();\n        let mut handle = stderr.lock();\n        writeln!(handle, $($reason),+).unwrap();\n        return;\n    }}\n}\n\ncfg_if! {\n    if #[cfg(linux_android)] {\n        #[macro_export] macro_rules! require_capability {\n            ($name:expr, $capname:ident) =\u003e {\n                use ::caps::{Capability, CapSet, has_cap};\n\n                if !has_cap(None, CapSet::Effective, Capability::$capname)\n                    .unwrap()\n                {\n                    skip!(\"{} requires capability {}. Skipping test.\", $name, Capability::$capname);\n                }\n            }\n        }\n    } else if #[cfg(not(target_os = \"redox\"))] {\n        #[macro_export] macro_rules! require_capability {\n            ($name:expr, $capname:ident) =\u003e {}\n        }\n    }\n}\n\n/// Skip the test if we don't have the ability to mount file systems.\n#[cfg(target_os = \"freebsd\")]\n#[macro_export]\nmacro_rules! require_mount {\n    ($name:expr) =\u003e {\n        use nix::unistd::Uid;\n        use sysctl::{CtlValue, Sysctl};\n\n        let ctl = ::sysctl::Ctl::new(\"vfs.usermount\").unwrap();\n        if !Uid::current().is_root() \u0026\u0026 CtlValue::Int(0) == ctl.value().unwrap()\n        {\n            skip!(\n                \"{} requires the ability to mount file systems. Skipping test.\",\n                $name\n            );\n        }\n    };\n}\n\n#[cfg(linux_android)]\n#[macro_export]\nmacro_rules! skip_if_cirrus {\n    ($reason:expr) =\u003e {\n        if std::env::var_os(\"CIRRUS_CI\").is_some() {\n            skip!(\"{}\", $reason);\n        }\n    };\n}\n\n#[cfg(target_os = \"freebsd\")]\n#[macro_export]\nmacro_rules! skip_if_jailed {\n    ($name:expr) =\u003e {\n        use sysctl::{CtlValue, Sysctl};\n\n        let ctl = ::sysctl::Ctl::new(\"security.jail.jailed\").unwrap();\n        if let CtlValue::Int(1) = ctl.value().unwrap() {\n            skip!(\"{} cannot run in a jail. Skipping test.\", $name);\n        }\n    };\n}\n\n#[cfg(not(any(target_os = \"redox\", target_os = \"fuchsia\")))]\n#[macro_export]\nmacro_rules! skip_if_not_root {\n    ($name:expr) =\u003e {\n        use nix::unistd::Uid;\n\n        if !Uid::current().is_root() {\n            skip!(\"{} requires root privileges. Skipping test.\", $name);\n        }\n    };\n}\n\ncfg_if! {\n    if #[cfg(linux_android)] {\n        #[macro_export] macro_rules! skip_if_seccomp {\n            ($name:expr) =\u003e {\n                if let Ok(s) = std::fs::read_to_string(\"/proc/self/status\") {\n                    for l in s.lines() {\n                        let mut fields = l.split_whitespace();\n                        if fields.next() == Some(\"Seccomp:\") \u0026\u0026\n                            fields.next() != Some(\"0\")\n                        {\n                            skip!(\"{} cannot be run in Seccomp mode.  Skipping test.\",\n                                stringify!($name));\n                        }\n                    }\n                }\n            }\n        }\n    } else if #[cfg(not(target_os = \"redox\"))] {\n        #[macro_export] macro_rules! skip_if_seccomp {\n            ($name:expr) =\u003e {}\n        }\n    }\n}\n\ncfg_if! {\n    if #[cfg(target_os = \"linux\")] {\n        #[macro_export] macro_rules! require_kernel_version {\n            ($name:expr, $version_requirement:expr) =\u003e {\n                use semver::{Version, VersionReq};\n\n                let version_requirement = VersionReq::parse($version_requirement)\n                        .expect(\"Bad match_version provided\");\n\n                let uname = nix::sys::utsname::uname().unwrap();\n                println!(\"{}\", uname.sysname().to_str().unwrap());\n                println!(\"{}\", uname.nodename().to_str().unwrap());\n                println!(\"{}\", uname.release().to_str().unwrap());\n                println!(\"{}\", uname.version().to_str().unwrap());\n                println!(\"{}\", uname.machine().to_str().unwrap());\n\n                // Fix stuff that the semver parser can't handle\n                let fixed_release = \u0026uname.release().to_str().unwrap().to_string()\n                    // Fedora 33 reports version as 4.18.el8_2.x86_64 or\n                    // 5.18.200-fc33.x86_64.  Remove the underscore.\n                    .replace(\"_\", \"-\")\n                    // Cirrus-CI reports version as 4.19.112+ .  Remove the +\n                    .replace(\"+\", \"\");\n                let mut version = Version::parse(fixed_release).unwrap();\n\n                //Keep only numeric parts\n                version.pre = semver::Prerelease::EMPTY;\n                version.build = semver::BuildMetadata::EMPTY;\n\n                if !version_requirement.matches(\u0026version) {\n                    skip!(\"Skip {} because kernel version `{}` doesn't match the requirement `{}`\",\n                        stringify!($name), version, version_requirement);\n                }\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","mount","mod.rs"],"content":"#[cfg(target_os = \"linux\")]\nmod test_mount;\n#[cfg(apple_targets)]\nmod test_mount_apple;\n#[cfg(target_os = \"freebsd\")]\nmod test_nmount;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","mount","test_mount.rs"],"content":"use std::fs::{self, File};\nuse std::io::{Read, Write};\nuse std::os::unix::fs::OpenOptionsExt;\nuse std::os::unix::fs::PermissionsExt;\nuse std::process::Command;\n\nuse libc::{EACCES, EROFS};\n\nuse nix::mount::{mount, umount, MsFlags};\nuse nix::sys::stat::{self, Mode};\n\nuse crate::*;\n\nstatic SCRIPT_CONTENTS: \u0026[u8] = b\"#!/bin/sh\nexit 23\";\n\nconst EXPECTED_STATUS: i32 = 23;\n\nconst NONE: Option\u003c\u0026'static [u8]\u003e = None;\n\n#[test]\nfn test_mount_tmpfs_without_flags_allows_rwx() {\n    require_capability!(\n        \"test_mount_tmpfs_without_flags_allows_rwx\",\n        CAP_SYS_ADMIN\n    );\n    let tempdir = tempfile::tempdir().unwrap();\n\n    mount(\n        NONE,\n        tempdir.path(),\n        Some(b\"tmpfs\".as_ref()),\n        MsFlags::empty(),\n        NONE,\n    )\n    .unwrap_or_else(|e| panic!(\"mount failed: {e}\"));\n\n    let test_path = tempdir.path().join(\"test\");\n\n    // Verify write.\n    fs::OpenOptions::new()\n        .create(true)\n        .write(true)\n        .mode((Mode::S_IRWXU | Mode::S_IRWXG | Mode::S_IRWXO).bits())\n        .open(\u0026test_path)\n        .and_then(|mut f| f.write(SCRIPT_CONTENTS))\n        .unwrap_or_else(|e| panic!(\"write failed: {e}\"));\n\n    // Verify read.\n    let mut buf = Vec::new();\n    File::open(\u0026test_path)\n        .and_then(|mut f| f.read_to_end(\u0026mut buf))\n        .unwrap_or_else(|e| panic!(\"read failed: {e}\"));\n    assert_eq!(buf, SCRIPT_CONTENTS);\n\n    // while forking and unmounting prevent other child processes\n    let _m = FORK_MTX.lock();\n    // Verify execute.\n    assert_eq!(\n        EXPECTED_STATUS,\n        Command::new(\u0026test_path)\n            .status()\n            .unwrap_or_else(|e| panic!(\"exec failed: {e}\"))\n            .code()\n            .unwrap_or_else(|| panic!(\"child killed by signal\"))\n    );\n\n    umount(tempdir.path()).unwrap_or_else(|e| panic!(\"umount failed: {e}\"));\n}\n\n#[test]\nfn test_mount_rdonly_disallows_write() {\n    require_capability!(\"test_mount_rdonly_disallows_write\", CAP_SYS_ADMIN);\n    let tempdir = tempfile::tempdir().unwrap();\n\n    mount(\n        NONE,\n        tempdir.path(),\n        Some(b\"tmpfs\".as_ref()),\n        MsFlags::MS_RDONLY,\n        NONE,\n    )\n    .unwrap_or_else(|e| panic!(\"mount failed: {e}\"));\n\n    // EROFS: Read-only file system\n    assert_eq!(\n        EROFS,\n        File::create(tempdir.path().join(\"test\"))\n            .unwrap_err()\n            .raw_os_error()\n            .unwrap()\n    );\n\n    umount(tempdir.path()).unwrap_or_else(|e| panic!(\"umount failed: {e}\"));\n}\n\n#[test]\nfn test_mount_noexec_disallows_exec() {\n    require_capability!(\"test_mount_noexec_disallows_exec\", CAP_SYS_ADMIN);\n    let tempdir = tempfile::tempdir().unwrap();\n\n    mount(\n        NONE,\n        tempdir.path(),\n        Some(b\"tmpfs\".as_ref()),\n        MsFlags::MS_NOEXEC,\n        NONE,\n    )\n    .unwrap_or_else(|e| panic!(\"mount failed: {e}\"));\n\n    let test_path = tempdir.path().join(\"test\");\n\n    fs::OpenOptions::new()\n        .create(true)\n        .write(true)\n        .mode((Mode::S_IRWXU | Mode::S_IRWXG | Mode::S_IRWXO).bits())\n        .open(\u0026test_path)\n        .and_then(|mut f| f.write(SCRIPT_CONTENTS))\n        .unwrap_or_else(|e| panic!(\"write failed: {e}\"));\n\n    // Verify that we cannot execute despite a+x permissions being set.\n    let mode = stat::Mode::from_bits_truncate(\n        fs::metadata(\u0026test_path)\n            .map(|md| md.permissions().mode())\n            .unwrap_or_else(|e| panic!(\"metadata failed: {e}\")),\n    );\n\n    assert!(\n        mode.contains(Mode::S_IXUSR | Mode::S_IXGRP | Mode::S_IXOTH),\n        \"{:?} did not have execute permissions\",\n        \u0026test_path\n    );\n\n    // while forking and unmounting prevent other child processes\n    let _m = FORK_MTX.lock();\n    // EACCES: Permission denied\n    assert_eq!(\n        EACCES,\n        Command::new(\u0026test_path)\n            .status()\n            .unwrap_err()\n            .raw_os_error()\n            .unwrap()\n    );\n\n    umount(tempdir.path()).unwrap_or_else(|e| panic!(\"umount failed: {e}\"));\n}\n\n#[test]\nfn test_mount_bind() {\n    require_capability!(\"test_mount_bind\", CAP_SYS_ADMIN);\n    let tempdir = tempfile::tempdir().unwrap();\n    let file_name = \"test\";\n\n    {\n        let mount_point = tempfile::tempdir().unwrap();\n\n        mount(\n            Some(tempdir.path()),\n            mount_point.path(),\n            NONE,\n            MsFlags::MS_BIND,\n            NONE,\n        )\n        .unwrap_or_else(|e| panic!(\"mount failed: {e}\"));\n\n        fs::OpenOptions::new()\n            .create(true)\n            .write(true)\n            .mode((Mode::S_IRWXU | Mode::S_IRWXG | Mode::S_IRWXO).bits())\n            .open(mount_point.path().join(file_name))\n            .and_then(|mut f| f.write(SCRIPT_CONTENTS))\n            .unwrap_or_else(|e| panic!(\"write failed: {e}\"));\n\n        // wait for child processes to prevent EBUSY\n        let _m = FORK_MTX.lock();\n        umount(mount_point.path())\n            .unwrap_or_else(|e| panic!(\"umount failed: {e}\"));\n    }\n\n    // Verify the file written in the mount shows up in source directory, even\n    // after unmounting.\n\n    let mut buf = Vec::new();\n    File::open(tempdir.path().join(file_name))\n        .and_then(|mut f| f.read_to_end(\u0026mut buf))\n        .unwrap_or_else(|e| panic!(\"read failed: {e}\"));\n    assert_eq!(buf, SCRIPT_CONTENTS);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","mount","test_mount_apple.rs"],"content":"use nix::errno::Errno;\nuse nix::mount::{mount, MntFlags};\n\n#[test]\nfn test_mount() {\n    let res = mount::\u003cstr, str, str\u003e(\"\", \"\", MntFlags::empty(), None);\n    assert_eq!(res, Err(Errno::ENOENT));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","mount","test_nmount.rs"],"content":"use crate::*;\nuse nix::{\n    errno::Errno,\n    mount::{unmount, MntFlags, Nmount},\n};\nuse std::{ffi::CString, fs::File, path::Path};\nuse tempfile::tempdir;\n\n#[test]\nfn ok() {\n    require_mount!(\"nullfs\");\n\n    let mountpoint = tempdir().unwrap();\n    let target = tempdir().unwrap();\n    let _sentry = File::create(target.path().join(\"sentry\")).unwrap();\n\n    let fstype = CString::new(\"fstype\").unwrap();\n    let nullfs = CString::new(\"nullfs\").unwrap();\n    Nmount::new()\n        .str_opt(\u0026fstype, \u0026nullfs)\n        .str_opt_owned(\"fspath\", mountpoint.path().to_str().unwrap())\n        .str_opt_owned(\"target\", target.path().to_str().unwrap())\n        .nmount(MntFlags::empty())\n        .unwrap();\n\n    // Now check that the sentry is visible through the mountpoint\n    let exists = Path::exists(\u0026mountpoint.path().join(\"sentry\"));\n\n    // Cleanup the mountpoint before asserting\n    unmount(mountpoint.path(), MntFlags::empty()).unwrap();\n\n    assert!(exists);\n}\n\n#[test]\nfn bad_fstype() {\n    let mountpoint = tempdir().unwrap();\n    let target = tempdir().unwrap();\n    let _sentry = File::create(target.path().join(\"sentry\")).unwrap();\n\n    let e = Nmount::new()\n        .str_opt_owned(\"fspath\", mountpoint.path().to_str().unwrap())\n        .str_opt_owned(\"target\", target.path().to_str().unwrap())\n        .nmount(MntFlags::empty())\n        .unwrap_err();\n\n    assert_eq!(e.error(), Errno::EINVAL);\n    assert_eq!(e.errmsg(), Some(\"Invalid fstype\"));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","mod.rs"],"content":"mod test_signal;\n\n// NOTE: DragonFly lacks a kernel-level implementation of Posix AIO as of\n// this writing. There is an user-level implementation, but whether aio\n// works or not heavily depends on which pthread implementation is chosen\n// by the user at link time. For this reason we do not want to run aio test\n// cases on DragonFly.\n#[cfg(any(\n    target_os = \"freebsd\",\n    apple_targets,\n    all(\n        target_os = \"linux\",\n        not(any(target_env = \"uclibc\", target_env = \"ohos\"))\n    ),\n    target_os = \"netbsd\"\n))]\nmod test_aio;\n#[cfg(not(any(\n    target_os = \"redox\",\n    target_os = \"fuchsia\",\n    target_os = \"haiku\",\n    target_os = \"hurd\",\n    target_os = \"cygwin\"\n)))]\nmod test_ioctl;\n#[cfg(not(target_os = \"redox\"))]\nmod test_mman;\n#[cfg(not(target_os = \"redox\"))]\nmod test_select;\n#[cfg(target_os = \"linux\")]\nmod test_signalfd;\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nmod test_socket;\n#[cfg(not(any(target_os = \"redox\")))]\nmod test_sockopt;\nmod test_stat;\n#[cfg(linux_android)]\nmod test_sysinfo;\n#[cfg(not(any(\n    target_os = \"redox\",\n    target_os = \"fuchsia\",\n    target_os = \"haiku\"\n)))]\nmod test_termios;\nmod test_uio;\nmod test_wait;\n\n#[cfg(linux_android)]\nmod test_epoll;\n#[cfg(target_os = \"linux\")]\nmod test_fanotify;\n#[cfg(target_os = \"linux\")]\nmod test_inotify;\nmod test_pthread;\n\n#[cfg(any(linux_android, freebsdlike, netbsdlike, apple_targets))]\nmod test_ptrace;\n#[cfg(linux_android)]\nmod test_timerfd;\n\n#[cfg(all(\n    any(\n        target_os = \"freebsd\",\n        solarish,\n        target_os = \"linux\",\n        target_os = \"netbsd\"\n    ),\n    feature = \"time\",\n    feature = \"signal\"\n))]\nmod test_timer;\n\n#[cfg(bsd)]\nmod test_event;\nmod test_statvfs;\nmod test_time;\nmod test_utsname;\n\n#[cfg(any(linux_android, freebsdlike, apple_targets, target_os = \"openbsd\"))]\nmod test_statfs;\n\n#[cfg(not(any(\n    target_os = \"redox\",\n    target_os = \"fuchsia\",\n    solarish,\n    target_os = \"haiku\"\n)))]\nmod test_resource;\n\n// This test module should be enabled for both linux_android and freebsd, but\n// the `memfd_create(2)` symbol is not available under Linux QEMU,\n//\n// https://github.com/nix-rust/nix/actions/runs/9427112650/job/25970870477\n//\n// and I haven't found a way to stop the linker from linking that symbol, so\n// only enable this for FreeBSD for now.\n#[cfg(target_os = \"freebsd\")]\nmod test_memfd;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_aio.rs"],"content":"use std::{\n    io::{Read, Seek, Write},\n    ops::Deref,\n    os::unix::io::{AsFd, AsRawFd, BorrowedFd},\n    pin::Pin,\n    sync::atomic::{AtomicBool, Ordering},\n    thread, time,\n};\n\nuse libc::c_int;\nuse nix::{\n    errno::*,\n    sys::{\n        aio::*,\n        signal::{\n            sigaction, SaFlags, SigAction, SigHandler, SigSet, SigevNotify,\n            Signal,\n        },\n        time::{TimeSpec, TimeValLike},\n    },\n};\nuse tempfile::tempfile;\n\npub static SIGNALED: AtomicBool = AtomicBool::new(false);\n\nextern \"C\" fn sigfunc(_: c_int) {\n    SIGNALED.store(true, Ordering::Relaxed);\n}\n\n// Helper that polls an AioCb for completion or error\nmacro_rules! poll_aio {\n    ($aiocb: expr) =\u003e {\n        loop {\n            let err = $aiocb.as_mut().error();\n            if err != Err(Errno::EINPROGRESS) {\n                break err;\n            };\n            thread::sleep(time::Duration::from_millis(10));\n        }\n    };\n}\n\nmod aio_fsync {\n    use super::*;\n\n    #[test]\n    fn test_accessors() {\n        let f = tempfile().unwrap();\n        let aiocb = AioFsync::new(\n            f.as_fd(),\n            AioFsyncMode::O_SYNC,\n            42,\n            SigevNotify::SigevSignal {\n                signal: Signal::SIGUSR2,\n                si_value: 99,\n            },\n        );\n        assert_eq!(f.as_raw_fd(), aiocb.fd().as_raw_fd());\n        assert_eq!(AioFsyncMode::O_SYNC, aiocb.mode());\n        assert_eq!(42, aiocb.priority());\n        let sev = aiocb.sigevent().sigevent();\n        assert_eq!(Signal::SIGUSR2 as i32, sev.sigev_signo);\n        assert_eq!(99, sev.sigev_value.sival_ptr as i64);\n    }\n\n    /// `AioFsync::submit` should not modify the `AioCb` object if\n    /// `libc::aio_fsync` returns an error\n    // Skip on Linux, because Linux's AIO implementation can't detect errors\n    // synchronously\n    #[test]\n    #[cfg_attr(any(target_os = \"android\", target_os = \"linux\"), ignore)]\n    fn error() {\n        use std::mem;\n\n        const INITIAL: \u0026[u8] = b\"abcdef123456\";\n        // Create an invalid AioFsyncMode\n        let mode = unsafe { mem::transmute::\u003ci32, AioFsyncMode\u003e(666) };\n        let mut f = tempfile().unwrap();\n        f.write_all(INITIAL).unwrap();\n        let mut aiof =\n            Box::pin(AioFsync::new(f.as_fd(), mode, 0, SigevNotify::SigevNone));\n        let err = aiof.as_mut().submit();\n        err.expect_err(\"assertion failed\");\n    }\n\n    #[test]\n    #[cfg_attr(all(target_env = \"musl\", target_arch = \"x86_64\"), ignore)]\n    fn ok() {\n        const INITIAL: \u0026[u8] = b\"abcdef123456\";\n        let mut f = tempfile().unwrap();\n        f.write_all(INITIAL).unwrap();\n        let mut aiof = Box::pin(AioFsync::new(\n            f.as_fd(),\n            AioFsyncMode::O_SYNC,\n            0,\n            SigevNotify::SigevNone,\n        ));\n        aiof.as_mut().submit().unwrap();\n        poll_aio!(\u0026mut aiof).unwrap();\n        aiof.as_mut().aio_return().unwrap();\n    }\n}\n\nmod aio_read {\n    use super::*;\n\n    #[test]\n    fn test_accessors() {\n        let f = tempfile().unwrap();\n        let mut rbuf = vec![0; 4];\n        let aiocb = AioRead::new(\n            f.as_fd(),\n            2, //offset\n            \u0026mut rbuf,\n            42, //priority\n            SigevNotify::SigevSignal {\n                signal: Signal::SIGUSR2,\n                si_value: 99,\n            },\n        );\n        assert_eq!(f.as_raw_fd(), aiocb.fd().as_raw_fd());\n        assert_eq!(4, aiocb.nbytes());\n        assert_eq!(2, aiocb.offset());\n        assert_eq!(42, aiocb.priority());\n        let sev = aiocb.sigevent().sigevent();\n        assert_eq!(Signal::SIGUSR2 as i32, sev.sigev_signo);\n        assert_eq!(99, sev.sigev_value.sival_ptr as i64);\n    }\n\n    // Tests AioWrite.cancel.  We aren't trying to test the OS's implementation,\n    // only our bindings.  So it's sufficient to check that cancel\n    // returned any AioCancelStat value.\n    #[test]\n    #[cfg_attr(all(target_env = \"musl\", target_arch = \"x86_64\"), ignore)]\n    fn cancel() {\n        const INITIAL: \u0026[u8] = b\"abcdef123456\";\n        let mut rbuf = vec![0; 4];\n        let mut f = tempfile().unwrap();\n        f.write_all(INITIAL).unwrap();\n        let fd = f.as_fd();\n        let mut aior =\n            Box::pin(AioRead::new(fd, 2, \u0026mut rbuf, 0, SigevNotify::SigevNone));\n        aior.as_mut().submit().unwrap();\n\n        aior.as_mut().cancel().unwrap();\n\n        // Wait for aiow to complete, but don't care whether it succeeded\n        let _ = poll_aio!(\u0026mut aior);\n        let _ = aior.as_mut().aio_return();\n    }\n\n    /// `AioRead::submit` should not modify the `AioCb` object if\n    /// `libc::aio_read` returns an error\n    // Skip on Linux, because Linux's AIO implementation can't detect errors\n    // synchronously\n    #[test]\n    #[cfg(any(target_os = \"freebsd\", apple_targets))]\n    fn error() {\n        const INITIAL: \u0026[u8] = b\"abcdef123456\";\n        let mut rbuf = vec![0; 4];\n        let mut f = tempfile().unwrap();\n        f.write_all(INITIAL).unwrap();\n        let mut aior = Box::pin(AioRead::new(\n            f.as_fd(),\n            -1, //an invalid offset\n            \u0026mut rbuf,\n            0, //priority\n            SigevNotify::SigevNone,\n        ));\n        aior.as_mut().submit().expect_err(\"assertion failed\");\n    }\n\n    // Test a simple aio operation with no completion notification.  We must\n    // poll for completion\n    #[test]\n    #[cfg_attr(all(target_env = \"musl\", target_arch = \"x86_64\"), ignore)]\n    fn ok() {\n        const INITIAL: \u0026[u8] = b\"abcdef123456\";\n        let mut rbuf = vec![0; 4];\n        const EXPECT: \u0026[u8] = b\"cdef\";\n        let mut f = tempfile().unwrap();\n        f.write_all(INITIAL).unwrap();\n        {\n            let fd = f.as_fd();\n            let mut aior = Box::pin(AioRead::new(\n                fd,\n                2,\n                \u0026mut rbuf,\n                0,\n                SigevNotify::SigevNone,\n            ));\n            aior.as_mut().submit().unwrap();\n\n            let err = poll_aio!(\u0026mut aior);\n            assert_eq!(err, Ok(()));\n            assert_eq!(aior.as_mut().aio_return().unwrap(), EXPECT.len());\n        }\n        assert_eq!(EXPECT, rbuf.deref());\n    }\n\n    // Like ok, but allocates the structure on the stack.\n    #[test]\n    #[cfg_attr(all(target_env = \"musl\", target_arch = \"x86_64\"), ignore)]\n    fn on_stack() {\n        const INITIAL: \u0026[u8] = b\"abcdef123456\";\n        let mut rbuf = vec![0; 4];\n        const EXPECT: \u0026[u8] = b\"cdef\";\n        let mut f = tempfile().unwrap();\n        f.write_all(INITIAL).unwrap();\n        {\n            let fd = f.as_fd();\n            let mut aior =\n                AioRead::new(fd, 2, \u0026mut rbuf, 0, SigevNotify::SigevNone);\n            let mut aior = unsafe { Pin::new_unchecked(\u0026mut aior) };\n            aior.as_mut().submit().unwrap();\n\n            let err = poll_aio!(\u0026mut aior);\n            assert_eq!(err, Ok(()));\n            assert_eq!(aior.as_mut().aio_return().unwrap(), EXPECT.len());\n        }\n        assert_eq!(EXPECT, rbuf.deref());\n    }\n}\n\n#[cfg(target_os = \"freebsd\")]\n#[cfg(fbsd14)]\nmod aio_readv {\n    use std::io::IoSliceMut;\n\n    use super::*;\n\n    #[test]\n    fn test_accessors() {\n        let f = tempfile().unwrap();\n        let mut rbuf0 = vec![0; 4];\n        let mut rbuf1 = vec![0; 8];\n        let mut rbufs =\n            [IoSliceMut::new(\u0026mut rbuf0), IoSliceMut::new(\u0026mut rbuf1)];\n        let aiocb = AioReadv::new(\n            f.as_fd(),\n            2, //offset\n            \u0026mut rbufs,\n            42, //priority\n            SigevNotify::SigevSignal {\n                signal: Signal::SIGUSR2,\n                si_value: 99,\n            },\n        );\n        assert_eq!(f.as_raw_fd(), aiocb.fd().as_raw_fd());\n        assert_eq!(2, aiocb.iovlen());\n        assert_eq!(2, aiocb.offset());\n        assert_eq!(42, aiocb.priority());\n        let sev = aiocb.sigevent().sigevent();\n        assert_eq!(Signal::SIGUSR2 as i32, sev.sigev_signo);\n        assert_eq!(99, sev.sigev_value.sival_ptr as i64);\n    }\n\n    #[test]\n    #[cfg_attr(all(target_env = \"musl\", target_arch = \"x86_64\"), ignore)]\n    fn ok() {\n        const INITIAL: \u0026[u8] = b\"abcdef123456\";\n        let mut rbuf0 = vec![0; 4];\n        let mut rbuf1 = vec![0; 2];\n        let mut rbufs =\n            [IoSliceMut::new(\u0026mut rbuf0), IoSliceMut::new(\u0026mut rbuf1)];\n        const EXPECT0: \u0026[u8] = b\"cdef\";\n        const EXPECT1: \u0026[u8] = b\"12\";\n        let mut f = tempfile().unwrap();\n        f.write_all(INITIAL).unwrap();\n        {\n            let fd = f.as_fd();\n            let mut aior = Box::pin(AioReadv::new(\n                fd,\n                2,\n                \u0026mut rbufs,\n                0,\n                SigevNotify::SigevNone,\n            ));\n            aior.as_mut().submit().unwrap();\n\n            let err = poll_aio!(\u0026mut aior);\n            assert_eq!(err, Ok(()));\n            assert_eq!(\n                aior.as_mut().aio_return().unwrap(),\n                EXPECT0.len() + EXPECT1.len()\n            );\n        }\n        assert_eq!(\u0026EXPECT0, \u0026rbuf0);\n        assert_eq!(\u0026EXPECT1, \u0026rbuf1);\n    }\n}\n\nmod aio_write {\n    use super::*;\n\n    #[test]\n    fn test_accessors() {\n        let f = tempfile().unwrap();\n        let wbuf = vec![0; 4];\n        let aiocb = AioWrite::new(\n            f.as_fd(),\n            2, //offset\n            \u0026wbuf,\n            42, //priority\n            SigevNotify::SigevSignal {\n                signal: Signal::SIGUSR2,\n                si_value: 99,\n            },\n        );\n        assert_eq!(f.as_raw_fd(), aiocb.fd().as_raw_fd());\n        assert_eq!(4, aiocb.nbytes());\n        assert_eq!(2, aiocb.offset());\n        assert_eq!(42, aiocb.priority());\n        let sev = aiocb.sigevent().sigevent();\n        assert_eq!(Signal::SIGUSR2 as i32, sev.sigev_signo);\n        assert_eq!(99, sev.sigev_value.sival_ptr as i64);\n    }\n\n    // Tests AioWrite.cancel.  We aren't trying to test the OS's implementation,\n    // only our bindings.  So it's sufficient to check that cancel\n    // returned any AioCancelStat value.\n    #[test]\n    #[cfg_attr(target_env = \"musl\", ignore)]\n    fn cancel() {\n        let wbuf: \u0026[u8] = b\"CDEF\";\n\n        let f = tempfile().unwrap();\n        let mut aiow = Box::pin(AioWrite::new(\n            f.as_fd(),\n            0,\n            wbuf,\n            0,\n            SigevNotify::SigevNone,\n        ));\n        aiow.as_mut().submit().unwrap();\n        let err = aiow.as_mut().error();\n        assert!(err == Ok(()) || err == Err(Errno::EINPROGRESS));\n\n        aiow.as_mut().cancel().unwrap();\n\n        // Wait for aiow to complete, but don't care whether it succeeded\n        let _ = poll_aio!(\u0026mut aiow);\n        let _ = aiow.as_mut().aio_return();\n    }\n\n    // Test a simple aio operation with no completion notification.  We must\n    // poll for completion.\n    #[test]\n    #[cfg_attr(all(target_env = \"musl\", target_arch = \"x86_64\"), ignore)]\n    fn ok() {\n        const INITIAL: \u0026[u8] = b\"abcdef123456\";\n        let wbuf = \"CDEF\".to_string().into_bytes();\n        let mut rbuf = Vec::new();\n        const EXPECT: \u0026[u8] = b\"abCDEF123456\";\n\n        let mut f = tempfile().unwrap();\n        f.write_all(INITIAL).unwrap();\n        {\n            let mut aiow = Box::pin(AioWrite::new(\n                f.as_fd(),\n                2,\n                \u0026wbuf,\n                0,\n                SigevNotify::SigevNone,\n            ));\n            aiow.as_mut().submit().unwrap();\n\n            let err = poll_aio!(\u0026mut aiow);\n            assert_eq!(err, Ok(()));\n            assert_eq!(aiow.as_mut().aio_return().unwrap(), wbuf.len());\n        }\n\n        f.rewind().unwrap();\n        let len = f.read_to_end(\u0026mut rbuf).unwrap();\n        assert_eq!(len, EXPECT.len());\n        assert_eq!(rbuf, EXPECT);\n    }\n\n    // Like ok, but allocates the structure on the stack.\n    #[test]\n    #[cfg_attr(all(target_env = \"musl\", target_arch = \"x86_64\"), ignore)]\n    fn on_stack() {\n        const INITIAL: \u0026[u8] = b\"abcdef123456\";\n        let wbuf = \"CDEF\".to_string().into_bytes();\n        let mut rbuf = Vec::new();\n        const EXPECT: \u0026[u8] = b\"abCDEF123456\";\n\n        let mut f = tempfile().unwrap();\n        f.write_all(INITIAL).unwrap();\n        {\n            let mut aiow = AioWrite::new(\n                f.as_fd(),\n                2, //offset\n                \u0026wbuf,\n                0, //priority\n                SigevNotify::SigevNone,\n            );\n            let mut aiow = unsafe { Pin::new_unchecked(\u0026mut aiow) };\n            aiow.as_mut().submit().unwrap();\n\n            let err = poll_aio!(\u0026mut aiow);\n            assert_eq!(err, Ok(()));\n            assert_eq!(aiow.as_mut().aio_return().unwrap(), wbuf.len());\n        }\n\n        f.rewind().unwrap();\n        let len = f.read_to_end(\u0026mut rbuf).unwrap();\n        assert_eq!(len, EXPECT.len());\n        assert_eq!(rbuf, EXPECT);\n    }\n\n    /// `AioWrite::write` should not modify the `AioCb` object if\n    /// `libc::aio_write` returns an error.\n    // Skip on Linux, because Linux's AIO implementation can't detect errors\n    // synchronously\n    #[test]\n    #[cfg_attr(any(target_os = \"android\", target_os = \"linux\"), ignore)]\n    fn error() {\n        // Not I/O safe!  Deliberately create an invalid fd.\n        let fd = unsafe { BorrowedFd::borrow_raw(666) };\n        let wbuf = \"CDEF\".to_string().into_bytes();\n        let mut aiow = Box::pin(AioWrite::new(\n            fd,\n            0, //offset\n            \u0026wbuf,\n            0, //priority\n            SigevNotify::SigevNone,\n        ));\n        aiow.as_mut().submit().expect_err(\"assertion failed\");\n        // Dropping the AioWrite at this point should not panic\n    }\n}\n\n#[cfg(target_os = \"freebsd\")]\n#[cfg(fbsd14)]\nmod aio_writev {\n    use std::io::IoSlice;\n\n    use super::*;\n\n    #[test]\n    fn test_accessors() {\n        let f = tempfile().unwrap();\n        let wbuf0 = vec![0; 4];\n        let wbuf1 = vec![0; 8];\n        let wbufs = [IoSlice::new(\u0026wbuf0), IoSlice::new(\u0026wbuf1)];\n        let aiocb = AioWritev::new(\n            f.as_fd(),\n            2, //offset\n            \u0026wbufs,\n            42, //priority\n            SigevNotify::SigevSignal {\n                signal: Signal::SIGUSR2,\n                si_value: 99,\n            },\n        );\n        assert_eq!(f.as_raw_fd(), aiocb.fd().as_raw_fd());\n        assert_eq!(2, aiocb.iovlen());\n        assert_eq!(2, aiocb.offset());\n        assert_eq!(42, aiocb.priority());\n        let sev = aiocb.sigevent().sigevent();\n        assert_eq!(Signal::SIGUSR2 as i32, sev.sigev_signo);\n        assert_eq!(99, sev.sigev_value.sival_ptr as i64);\n    }\n\n    // Test a simple aio operation with no completion notification.  We must\n    // poll for completion.\n    #[test]\n    #[cfg_attr(all(target_env = \"musl\", target_arch = \"x86_64\"), ignore)]\n    fn ok() {\n        const INITIAL: \u0026[u8] = b\"abcdef123456\";\n        let wbuf0 = b\"BC\";\n        let wbuf1 = b\"DEF\";\n        let wbufs = [IoSlice::new(wbuf0), IoSlice::new(wbuf1)];\n        let wlen = wbuf0.len() + wbuf1.len();\n        let mut rbuf = Vec::new();\n        const EXPECT: \u0026[u8] = b\"aBCDEF123456\";\n\n        let mut f = tempfile().unwrap();\n        f.write_all(INITIAL).unwrap();\n        {\n            let mut aiow = Box::pin(AioWritev::new(\n                f.as_fd(),\n                1,\n                \u0026wbufs,\n                0,\n                SigevNotify::SigevNone,\n            ));\n            aiow.as_mut().submit().unwrap();\n\n            let err = poll_aio!(\u0026mut aiow);\n            assert_eq!(err, Ok(()));\n            assert_eq!(aiow.as_mut().aio_return().unwrap(), wlen);\n        }\n\n        f.rewind().unwrap();\n        let len = f.read_to_end(\u0026mut rbuf).unwrap();\n        assert_eq!(len, EXPECT.len());\n        assert_eq!(rbuf, EXPECT);\n    }\n}\n\n// Test an aio operation with completion delivered by a signal\n#[test]\n#[cfg_attr(\n    any(\n        all(target_env = \"musl\", target_arch = \"x86_64\"),\n        target_arch = \"mips\",\n        target_arch = \"mips32r6\",\n        target_arch = \"mips64\",\n        target_arch = \"mips64r6\"\n    ),\n    ignore\n)]\nfn sigev_signal() {\n    let _m = crate::SIGNAL_MTX.lock();\n    let sa = SigAction::new(\n        SigHandler::Handler(sigfunc),\n        SaFlags::SA_RESETHAND,\n        SigSet::empty(),\n    );\n    SIGNALED.store(false, Ordering::Relaxed);\n    unsafe { sigaction(Signal::SIGUSR2, \u0026sa) }.unwrap();\n\n    const INITIAL: \u0026[u8] = b\"abcdef123456\";\n    const WBUF: \u0026[u8] = b\"CDEF\";\n    let mut rbuf = Vec::new();\n    const EXPECT: \u0026[u8] = b\"abCDEF123456\";\n\n    let mut f = tempfile().unwrap();\n    f.write_all(INITIAL).unwrap();\n    {\n        let mut aiow = Box::pin(AioWrite::new(\n            f.as_fd(),\n            2, //offset\n            WBUF,\n            0, //priority\n            SigevNotify::SigevSignal {\n                signal: Signal::SIGUSR2,\n                si_value: 0, //TODO: validate in sigfunc\n            },\n        ));\n        aiow.as_mut().submit().unwrap();\n        while !SIGNALED.load(Ordering::Relaxed) {\n            thread::sleep(time::Duration::from_millis(10));\n        }\n\n        assert_eq!(aiow.as_mut().aio_return().unwrap(), WBUF.len());\n    }\n\n    f.rewind().unwrap();\n    let len = f.read_to_end(\u0026mut rbuf).unwrap();\n    assert_eq!(len, EXPECT.len());\n    assert_eq!(rbuf, EXPECT);\n}\n\n// Tests using aio_cancel_all for all outstanding IOs.\n#[test]\n#[cfg_attr(target_env = \"musl\", ignore)]\nfn test_aio_cancel_all() {\n    let wbuf: \u0026[u8] = b\"CDEF\";\n\n    let f = tempfile().unwrap();\n    let mut aiocb = Box::pin(AioWrite::new(\n        f.as_fd(),\n        0, //offset\n        wbuf,\n        0, //priority\n        SigevNotify::SigevNone,\n    ));\n    aiocb.as_mut().submit().unwrap();\n    let err = aiocb.as_mut().error();\n    assert!(err == Ok(()) || err == Err(Errno::EINPROGRESS));\n\n    aio_cancel_all(f.as_fd()).unwrap();\n\n    // Wait for aiocb to complete, but don't care whether it succeeded\n    let _ = poll_aio!(\u0026mut aiocb);\n    let _ = aiocb.as_mut().aio_return();\n}\n\n#[test]\nfn test_aio_suspend() {\n    const INITIAL: \u0026[u8] = b\"abcdef123456\";\n    const WBUF: \u0026[u8] = b\"CDEFG\";\n    let timeout = TimeSpec::seconds(10);\n    let mut rbuf = vec![0; 4];\n    let rlen = rbuf.len();\n    let mut f = tempfile().unwrap();\n    f.write_all(INITIAL).unwrap();\n\n    let mut wcb = Box::pin(AioWrite::new(\n        f.as_fd(),\n        2, //offset\n        WBUF,\n        0, //priority\n        SigevNotify::SigevNone,\n    ));\n\n    let mut rcb = Box::pin(AioRead::new(\n        f.as_fd(),\n        8, //offset\n        \u0026mut rbuf,\n        0, //priority\n        SigevNotify::SigevNone,\n    ));\n    wcb.as_mut().submit().unwrap();\n    rcb.as_mut().submit().unwrap();\n    loop {\n        {\n            let cbbuf = [\n                \u0026*wcb as \u0026dyn AsRef\u003clibc::aiocb\u003e,\n                \u0026*rcb as \u0026dyn AsRef\u003clibc::aiocb\u003e,\n            ];\n            let r = aio_suspend(\u0026cbbuf[..], Some(timeout));\n            match r {\n                Err(Errno::EINTR) =\u003e continue,\n                Err(e) =\u003e panic!(\"aio_suspend returned {e:?}\"),\n                Ok(_) =\u003e (),\n            };\n        }\n        if rcb.as_mut().error() != Err(Errno::EINPROGRESS)\n            \u0026\u0026 wcb.as_mut().error() != Err(Errno::EINPROGRESS)\n        {\n            break;\n        }\n    }\n\n    assert_eq!(wcb.as_mut().aio_return().unwrap(), WBUF.len());\n    assert_eq!(rcb.as_mut().aio_return().unwrap(), rlen);\n}\n\n/// aio_suspend relies on casting Rust Aio* struct pointers to libc::aiocb\n/// pointers.  This test ensures that such casts are valid.\n#[test]\nfn casting() {\n    let sev = SigevNotify::SigevNone;\n    // Only safe because we'll never await the futures\n    let fd = unsafe { BorrowedFd::borrow_raw(666) };\n    let aiof = AioFsync::new(fd, AioFsyncMode::O_SYNC, 0, sev);\n    assert_eq!(\n        aiof.as_ref() as *const libc::aiocb,\n        \u0026aiof as *const AioFsync as *const libc::aiocb\n    );\n\n    let mut rbuf = [];\n    let aior = AioRead::new(fd, 0, \u0026mut rbuf, 0, sev);\n    assert_eq!(\n        aior.as_ref() as *const libc::aiocb,\n        \u0026aior as *const AioRead as *const libc::aiocb\n    );\n\n    let wbuf = [];\n    let aiow = AioWrite::new(fd, 0, \u0026wbuf, 0, sev);\n    assert_eq!(\n        aiow.as_ref() as *const libc::aiocb,\n        \u0026aiow as *const AioWrite as *const libc::aiocb\n    );\n}\n\n#[cfg(target_os = \"freebsd\")]\n#[test]\nfn casting_vectored() {\n    use std::io::{IoSlice, IoSliceMut};\n\n    let sev = SigevNotify::SigevNone;\n\n    let mut rbuf = [];\n    let mut rbufs = [IoSliceMut::new(\u0026mut rbuf)];\n    // Only safe because we'll never await the futures\n    let fd = unsafe { BorrowedFd::borrow_raw(666) };\n    let aiorv = AioReadv::new(fd, 0, \u0026mut rbufs[..], 0, sev);\n    assert_eq!(\n        aiorv.as_ref() as *const libc::aiocb,\n        \u0026aiorv as *const AioReadv as *const libc::aiocb\n    );\n\n    let wbuf = [];\n    let wbufs = [IoSlice::new(\u0026wbuf)];\n    let aiowv = AioWritev::new(fd, 0, \u0026wbufs, 0, sev);\n    assert_eq!(\n        aiowv.as_ref() as *const libc::aiocb,\n        \u0026aiowv as *const AioWritev as *const libc::aiocb\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_aio_drop.rs"],"content":"// Test dropping an AioCb that hasn't yet finished.\n// This must happen in its own process, because on OSX this test seems to hose\n// the AIO subsystem and causes subsequent tests to fail\n#[test]\n#[should_panic(expected = \"Dropped an in-progress AioCb\")]\n#[cfg(all(\n    not(target_env = \"musl\"),\n    not(target_env = \"uclibc\"),\n    not(target_env = \"ohos\"),\n    any(\n        target_os = \"linux\",\n        apple_targets,\n        target_os = \"freebsd\",\n        target_os = \"netbsd\"\n    )\n))]\nfn test_drop() {\n    use nix::sys::aio::*;\n    use nix::sys::signal::*;\n    use std::os::unix::io::AsFd;\n    use tempfile::tempfile;\n\n    const WBUF: \u0026[u8] = b\"CDEF\";\n\n    let f = tempfile().unwrap();\n    f.set_len(6).unwrap();\n    let mut aiocb = Box::pin(AioWrite::new(\n        f.as_fd(),\n        2, //offset\n        WBUF,\n        0, //priority\n        SigevNotify::SigevNone,\n    ));\n    aiocb.as_mut().submit().unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_epoll.rs"],"content":"#![allow(deprecated)]\n\nuse nix::errno::Errno;\nuse nix::sys::epoll::{epoll_create1, epoll_ctl};\nuse nix::sys::epoll::{EpollCreateFlags, EpollEvent, EpollFlags, EpollOp};\n\n#[test]\npub fn test_epoll_errno() {\n    let efd = epoll_create1(EpollCreateFlags::empty()).unwrap();\n    let result = epoll_ctl(efd, EpollOp::EpollCtlDel, 1, None);\n    result.expect_err(\"assertion failed\");\n    assert_eq!(result.unwrap_err(), Errno::ENOENT);\n\n    let result = epoll_ctl(efd, EpollOp::EpollCtlAdd, 1, None);\n    result.expect_err(\"assertion failed\");\n    assert_eq!(result.unwrap_err(), Errno::EINVAL);\n}\n\n#[test]\npub fn test_epoll_ctl() {\n    let efd = epoll_create1(EpollCreateFlags::empty()).unwrap();\n    let mut event =\n        EpollEvent::new(EpollFlags::EPOLLIN | EpollFlags::EPOLLERR, 1);\n    epoll_ctl(efd, EpollOp::EpollCtlAdd, 1, \u0026mut event).unwrap();\n    epoll_ctl(efd, EpollOp::EpollCtlDel, 1, None).unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_event.rs"],"content":"use libc::intptr_t;\nuse nix::sys::event::{EvFlags, EventFilter, FilterFlag, KEvent};\n\n#[test]\nfn test_struct_kevent() {\n    use std::mem;\n\n    let udata: intptr_t = 12345;\n    let data: intptr_t = 0x1337;\n\n    let actual = KEvent::new(\n        0xdead_beef,\n        EventFilter::EVFILT_READ,\n        EvFlags::EV_ONESHOT | EvFlags::EV_ADD,\n        FilterFlag::NOTE_CHILD | FilterFlag::NOTE_EXIT,\n        data,\n        udata,\n    );\n    assert_eq!(0xdead_beef, actual.ident());\n    assert_eq!(EventFilter::EVFILT_READ, actual.filter().unwrap());\n    assert_eq!(libc::EV_ONESHOT | libc::EV_ADD, actual.flags().bits());\n    assert_eq!(libc::NOTE_CHILD | libc::NOTE_EXIT, actual.fflags().bits());\n    assert_eq!(data, actual.data());\n    assert_eq!(udata, actual.udata());\n    assert_eq!(mem::size_of::\u003clibc::kevent\u003e(), mem::size_of::\u003cKEvent\u003e());\n}\n\n#[test]\nfn test_kevent_filter() {\n    let udata: intptr_t = 12345;\n\n    let actual = KEvent::new(\n        0xdead_beef,\n        EventFilter::EVFILT_READ,\n        EvFlags::EV_ONESHOT | EvFlags::EV_ADD,\n        FilterFlag::NOTE_CHILD | FilterFlag::NOTE_EXIT,\n        0x1337,\n        udata,\n    );\n    assert_eq!(EventFilter::EVFILT_READ, actual.filter().unwrap());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_fanotify.rs"],"content":"use crate::*;\nuse nix::errno::Errno;\nuse nix::fcntl::AT_FDCWD;\nuse nix::sys::fanotify::{\n    EventFFlags, Fanotify, FanotifyResponse, InitFlags, MarkFlags, MaskFlags,\n    Response,\n};\nuse std::fs::{read_link, read_to_string, File, OpenOptions};\nuse std::io::ErrorKind;\nuse std::io::{Read, Write};\nuse std::os::fd::AsRawFd;\nuse std::thread;\n\n#[test]\n/// Run fanotify tests sequentially to avoid tmp files races\npub fn test_fanotify() {\n    require_capability!(\"test_fanotify\", CAP_SYS_ADMIN);\n\n    test_fanotify_notifications();\n    test_fanotify_responses();\n    test_fanotify_overflow();\n}\n\nfn test_fanotify_notifications() {\n    let group =\n        Fanotify::init(InitFlags::FAN_CLASS_NOTIF, EventFFlags::O_RDONLY)\n            .unwrap();\n    let tempdir = tempfile::tempdir().unwrap();\n    let tempfile = tempdir.path().join(\"test\");\n    OpenOptions::new()\n        .write(true)\n        .create_new(true)\n        .open(\u0026tempfile)\n        .unwrap();\n\n    group\n        .mark(\n            MarkFlags::FAN_MARK_ADD,\n            MaskFlags::FAN_OPEN | MaskFlags::FAN_MODIFY | MaskFlags::FAN_CLOSE,\n            AT_FDCWD,\n            Some(\u0026tempfile),\n        )\n        .unwrap();\n\n    // modify test file\n    {\n        let mut f = OpenOptions::new().write(true).open(\u0026tempfile).unwrap();\n        f.write_all(b\"hello\").unwrap();\n    }\n\n    let mut events = group.read_events().unwrap();\n    assert_eq!(events.len(), 1, \"should have read exactly one event\");\n    let event = events.pop().unwrap();\n    assert!(event.check_version());\n    assert_eq!(\n        event.mask(),\n        MaskFlags::FAN_OPEN\n            | MaskFlags::FAN_MODIFY\n            | MaskFlags::FAN_CLOSE_WRITE\n    );\n    let fd_opt = event.fd();\n    let fd = fd_opt.as_ref().unwrap();\n    let path = read_link(format!(\"/proc/self/fd/{}\", fd.as_raw_fd())).unwrap();\n    assert_eq!(path, tempfile);\n\n    // read test file\n    {\n        let mut f = File::open(\u0026tempfile).unwrap();\n        let mut s = String::new();\n        f.read_to_string(\u0026mut s).unwrap();\n    }\n\n    let mut events = group.read_events().unwrap();\n    assert_eq!(events.len(), 1, \"should have read exactly one event\");\n    let event = events.pop().unwrap();\n    assert!(event.check_version());\n    assert_eq!(\n        event.mask(),\n        MaskFlags::FAN_OPEN | MaskFlags::FAN_CLOSE_NOWRITE\n    );\n    let fd_opt = event.fd();\n    let fd = fd_opt.as_ref().unwrap();\n    let path = read_link(format!(\"/proc/self/fd/{}\", fd.as_raw_fd())).unwrap();\n    assert_eq!(path, tempfile);\n}\n\nfn test_fanotify_responses() {\n    let group =\n        Fanotify::init(InitFlags::FAN_CLASS_CONTENT, EventFFlags::O_RDONLY)\n            .unwrap();\n    let tempdir = tempfile::tempdir().unwrap();\n    let tempfile = tempdir.path().join(\"test\");\n    OpenOptions::new()\n        .write(true)\n        .create_new(true)\n        .open(\u0026tempfile)\n        .unwrap();\n\n    group\n        .mark(\n            MarkFlags::FAN_MARK_ADD,\n            MaskFlags::FAN_OPEN_PERM,\n            AT_FDCWD,\n            Some(\u0026tempfile),\n        )\n        .unwrap();\n\n    let file_thread = thread::spawn({\n        let tempfile = tempfile.clone();\n\n        move || {\n            // first open, should fail\n            let Err(e) = File::open(\u0026tempfile) else {\n                panic!(\"The first open should fail\");\n            };\n            assert_eq!(e.kind(), ErrorKind::PermissionDenied);\n\n            // second open, should succeed\n            File::open(\u0026tempfile).unwrap();\n        }\n    });\n\n    // Deny the first open try\n    let mut events = group.read_events().unwrap();\n    assert_eq!(events.len(), 1, \"should have read exactly one event\");\n    let event = events.pop().unwrap();\n    assert!(event.check_version());\n    assert_eq!(event.mask(), MaskFlags::FAN_OPEN_PERM);\n    let fd_opt = event.fd();\n    let fd = fd_opt.as_ref().unwrap();\n    let path = read_link(format!(\"/proc/self/fd/{}\", fd.as_raw_fd())).unwrap();\n    assert_eq!(path, tempfile);\n    group\n        .write_response(FanotifyResponse::new(*fd, Response::FAN_DENY))\n        .unwrap();\n\n    // Allow the second open try\n    let mut events = group.read_events().unwrap();\n    assert_eq!(events.len(), 1, \"should have read exactly one event\");\n    let event = events.pop().unwrap();\n    assert!(event.check_version());\n    assert_eq!(event.mask(), MaskFlags::FAN_OPEN_PERM);\n    let fd_opt = event.fd();\n    let fd = fd_opt.as_ref().unwrap();\n    let path = read_link(format!(\"/proc/self/fd/{}\", fd.as_raw_fd())).unwrap();\n    assert_eq!(path, tempfile);\n    group\n        .write_response(FanotifyResponse::new(*fd, Response::FAN_ALLOW))\n        .unwrap();\n\n    file_thread.join().unwrap();\n}\n\nfn test_fanotify_overflow() {\n    let max_events: usize =\n        read_to_string(\"/proc/sys/fs/fanotify/max_queued_events\")\n            .unwrap()\n            .trim()\n            .parse()\n            .unwrap();\n\n    // make sure the kernel is configured with the default value,\n    // just so this test doesn't run forever\n    assert_eq!(max_events, 16384);\n\n    let group = Fanotify::init(\n        InitFlags::FAN_CLASS_NOTIF\n            | InitFlags::FAN_REPORT_TID\n            | InitFlags::FAN_NONBLOCK,\n        EventFFlags::O_RDONLY,\n    )\n    .unwrap();\n    let tempdir = tempfile::tempdir().unwrap();\n    let tempfile = tempdir.path().join(\"test\");\n\n    OpenOptions::new()\n        .write(true)\n        .create_new(true)\n        .open(\u0026tempfile)\n        .unwrap();\n\n    group\n        .mark(\n            MarkFlags::FAN_MARK_ADD,\n            MaskFlags::FAN_OPEN,\n            AT_FDCWD,\n            Some(\u0026tempfile),\n        )\n        .unwrap();\n\n    thread::scope(|s| {\n        // perform 10 more events to demonstrate some will be dropped\n        for _ in 0..(max_events + 10) {\n            s.spawn(|| {\n                File::open(\u0026tempfile).unwrap();\n            });\n        }\n    });\n\n    // flush the queue until it's empty\n    let mut n = 0;\n    let mut last_event = None;\n    loop {\n        match group.read_events() {\n            Ok(events) =\u003e {\n                n += events.len();\n                if let Some(event) = events.last() {\n                    last_event = Some(event.mask());\n                }\n            }\n            Err(e) if e == Errno::EWOULDBLOCK =\u003e break,\n            Err(e) =\u003e panic!(\"{e:?}\"),\n        }\n    }\n\n    // make sure we read all we expected.\n    // the +1 is for the overflow event.\n    assert_eq!(n, max_events + 1);\n    assert_eq!(last_event, Some(MaskFlags::FAN_Q_OVERFLOW));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_inotify.rs"],"content":"use nix::errno::Errno;\nuse nix::sys::inotify::{AddWatchFlags, InitFlags, Inotify};\nuse std::ffi::OsString;\nuse std::fs::{rename, File};\n\n#[test]\npub fn test_inotify() {\n    let instance = Inotify::init(InitFlags::IN_NONBLOCK).unwrap();\n    let tempdir = tempfile::tempdir().unwrap();\n\n    instance\n        .add_watch(tempdir.path(), AddWatchFlags::IN_ALL_EVENTS)\n        .unwrap();\n\n    let events = instance.read_events();\n    assert_eq!(events.unwrap_err(), Errno::EAGAIN);\n\n    File::create(tempdir.path().join(\"test\")).unwrap();\n\n    let events = instance.read_events().unwrap();\n    assert_eq!(events[0].name, Some(OsString::from(\"test\")));\n}\n\n#[test]\npub fn test_inotify_multi_events() {\n    let instance = Inotify::init(InitFlags::IN_NONBLOCK).unwrap();\n    let tempdir = tempfile::tempdir().unwrap();\n\n    instance\n        .add_watch(tempdir.path(), AddWatchFlags::IN_ALL_EVENTS)\n        .unwrap();\n\n    let events = instance.read_events();\n    assert_eq!(events.unwrap_err(), Errno::EAGAIN);\n\n    File::create(tempdir.path().join(\"test\")).unwrap();\n    rename(tempdir.path().join(\"test\"), tempdir.path().join(\"test2\")).unwrap();\n\n    // Now there should be 5 events in queue:\n    //   - IN_CREATE on test\n    //   - IN_OPEN on test\n    //   - IN_CLOSE_WRITE on test\n    //   - IN_MOVED_FROM on test with a cookie\n    //   - IN_MOVED_TO on test2 with the same cookie\n\n    let events = instance.read_events().unwrap();\n    assert_eq!(events.len(), 5);\n\n    assert_eq!(events[0].mask, AddWatchFlags::IN_CREATE);\n    assert_eq!(events[0].name, Some(OsString::from(\"test\")));\n\n    assert_eq!(events[1].mask, AddWatchFlags::IN_OPEN);\n    assert_eq!(events[1].name, Some(OsString::from(\"test\")));\n\n    assert_eq!(events[2].mask, AddWatchFlags::IN_CLOSE_WRITE);\n    assert_eq!(events[2].name, Some(OsString::from(\"test\")));\n\n    assert_eq!(events[3].mask, AddWatchFlags::IN_MOVED_FROM);\n    assert_eq!(events[3].name, Some(OsString::from(\"test\")));\n\n    assert_eq!(events[4].mask, AddWatchFlags::IN_MOVED_TO);\n    assert_eq!(events[4].name, Some(OsString::from(\"test2\")));\n\n    assert_eq!(events[3].cookie, events[4].cookie);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_ioctl.rs"],"content":"#![allow(dead_code)]\n\n// Simple tests to ensure macro generated fns compile\nioctl_none_bad!(do_bad, 0x1234);\nioctl_read_bad!(do_bad_read, 0x1234, u16);\nioctl_write_int_bad!(do_bad_write_int, 0x1234);\nioctl_write_ptr_bad!(do_bad_write_ptr, 0x1234, u8);\nioctl_readwrite_bad!(do_bad_readwrite, 0x1234, u32);\nioctl_none!(do_none, 0, 0);\nioctl_read!(read_test, 0, 0, u32);\nioctl_write_int!(write_ptr_int, 0, 0);\nioctl_write_ptr!(write_ptr_u8, 0, 0, u8);\nioctl_write_ptr!(write_ptr_u32, 0, 0, u32);\nioctl_write_ptr!(write_ptr_u64, 0, 0, u64);\nioctl_readwrite!(readwrite_test, 0, 0, u64);\nioctl_read_buf!(readbuf_test, 0, 0, u32);\nconst SPI_IOC_MAGIC: u8 = b'k';\nconst SPI_IOC_MESSAGE: u8 = 0;\nioctl_write_buf!(writebuf_test_consts, SPI_IOC_MAGIC, SPI_IOC_MESSAGE, u8);\nioctl_write_buf!(writebuf_test_u8, 0, 0, u8);\nioctl_write_buf!(writebuf_test_u32, 0, 0, u32);\nioctl_write_buf!(writebuf_test_u64, 0, 0, u64);\nioctl_readwrite_buf!(readwritebuf_test, 0, 0, u32);\n\n// See C code for source of values for op calculations (does NOT work for mips/powerpc):\n// https://gist.github.com/posborne/83ea6880770a1aef332e\n//\n// TODO:  Need a way to compute these constants at test time.  Using precomputed\n// values is fragile and needs to be maintained.\n\n#[cfg(linux_android)]\nmod linux {\n    // The cast is not unnecessary on all platforms.\n    #[allow(clippy::unnecessary_cast)]\n    #[test]\n    fn test_op_none() {\n        if cfg!(any(\n            target_arch = \"mips\",\n            target_arch = \"mips32r6\",\n            target_arch = \"mips64\",\n            target_arch = \"mips64r6\",\n            target_arch = \"powerpc\",\n            target_arch = \"powerpc64\"\n        )) {\n            assert_eq!(request_code_none!(b'q', 10) as u32, 0x2000_710A);\n            assert_eq!(request_code_none!(b'a', 255) as u32, 0x2000_61FF);\n        } else {\n            assert_eq!(request_code_none!(b'q', 10) as u32, 0x0000_710A);\n            assert_eq!(request_code_none!(b'a', 255) as u32, 0x0000_61FF);\n        }\n    }\n\n    // The cast is not unnecessary on all platforms.\n    #[allow(clippy::unnecessary_cast)]\n    #[test]\n    fn test_op_write() {\n        if cfg!(any(\n            target_arch = \"mips\",\n            target_arch = \"mips32r6\",\n            target_arch = \"mips64\",\n            target_arch = \"mips64r6\",\n            target_arch = \"powerpc\",\n            target_arch = \"powerpc64\"\n        )) {\n            assert_eq!(request_code_write!(b'z', 10, 1) as u32, 0x8001_7A0A);\n            assert_eq!(request_code_write!(b'z', 10, 512) as u32, 0x8200_7A0A);\n        } else {\n            assert_eq!(request_code_write!(b'z', 10, 1) as u32, 0x4001_7A0A);\n            assert_eq!(request_code_write!(b'z', 10, 512) as u32, 0x4200_7A0A);\n        }\n    }\n\n    #[cfg(target_pointer_width = \"64\")]\n    #[test]\n    fn test_op_write_64() {\n        if cfg!(any(\n            target_arch = \"mips64\",\n            target_arch = \"mips64r6\",\n            target_arch = \"powerpc64\"\n        )) {\n            assert_eq!(\n                request_code_write!(b'z', 10, 1u64 \u003c\u003c 32) as u32,\n                0x8000_7A0A\n            );\n        } else {\n            assert_eq!(\n                request_code_write!(b'z', 10, 1u64 \u003c\u003c 32) as u32,\n                0x4000_7A0A\n            );\n        }\n    }\n\n    // The cast is not unnecessary on all platforms.\n    #[allow(clippy::unnecessary_cast)]\n    #[test]\n    fn test_op_read() {\n        if cfg!(any(\n            target_arch = \"mips\",\n            target_arch = \"mips32r6\",\n            target_arch = \"mips64\",\n            target_arch = \"mips64r6\",\n            target_arch = \"powerpc\",\n            target_arch = \"powerpc64\"\n        )) {\n            assert_eq!(request_code_read!(b'z', 10, 1) as u32, 0x4001_7A0A);\n            assert_eq!(request_code_read!(b'z', 10, 512) as u32, 0x4200_7A0A);\n        } else {\n            assert_eq!(request_code_read!(b'z', 10, 1) as u32, 0x8001_7A0A);\n            assert_eq!(request_code_read!(b'z', 10, 512) as u32, 0x8200_7A0A);\n        }\n    }\n\n    #[cfg(target_pointer_width = \"64\")]\n    #[test]\n    fn test_op_read_64() {\n        if cfg!(any(\n            target_arch = \"mips64\",\n            target_arch = \"mips64r6\",\n            target_arch = \"powerpc64\"\n        )) {\n            assert_eq!(\n                request_code_read!(b'z', 10, 1u64 \u003c\u003c 32) as u32,\n                0x4000_7A0A\n            );\n        } else {\n            assert_eq!(\n                request_code_read!(b'z', 10, 1u64 \u003c\u003c 32) as u32,\n                0x8000_7A0A\n            );\n        }\n    }\n\n    // The cast is not unnecessary on all platforms.\n    #[allow(clippy::unnecessary_cast)]\n    #[test]\n    fn test_op_read_write() {\n        assert_eq!(request_code_readwrite!(b'z', 10, 1) as u32, 0xC001_7A0A);\n        assert_eq!(request_code_readwrite!(b'z', 10, 512) as u32, 0xC200_7A0A);\n    }\n\n    #[cfg(target_pointer_width = \"64\")]\n    #[test]\n    fn test_op_read_write_64() {\n        assert_eq!(\n            request_code_readwrite!(b'z', 10, 1u64 \u003c\u003c 32) as u32,\n            0xC000_7A0A\n        );\n    }\n}\n\n#[cfg(bsd)]\nmod bsd {\n    #[test]\n    fn test_op_none() {\n        assert_eq!(request_code_none!(b'q', 10), 0x2000_710A);\n        assert_eq!(request_code_none!(b'a', 255), 0x2000_61FF);\n    }\n\n    #[cfg(freebsdlike)]\n    #[test]\n    fn test_op_write_int() {\n        assert_eq!(request_code_write_int!(b'v', 4), 0x2004_7604);\n        assert_eq!(request_code_write_int!(b'p', 2), 0x2004_7002);\n    }\n\n    #[test]\n    fn test_op_write() {\n        assert_eq!(request_code_write!(b'z', 10, 1), 0x8001_7A0A);\n        assert_eq!(request_code_write!(b'z', 10, 512), 0x8200_7A0A);\n    }\n\n    #[cfg(target_pointer_width = \"64\")]\n    #[test]\n    fn test_op_write_64() {\n        assert_eq!(request_code_write!(b'z', 10, 1u64 \u003c\u003c 32), 0x8000_7A0A);\n    }\n\n    #[test]\n    fn test_op_read() {\n        assert_eq!(request_code_read!(b'z', 10, 1), 0x4001_7A0A);\n        assert_eq!(request_code_read!(b'z', 10, 512), 0x4200_7A0A);\n    }\n\n    #[cfg(target_pointer_width = \"64\")]\n    #[test]\n    fn test_op_read_64() {\n        assert_eq!(request_code_read!(b'z', 10, 1u64 \u003c\u003c 32), 0x4000_7A0A);\n    }\n\n    #[test]\n    fn test_op_read_write() {\n        assert_eq!(request_code_readwrite!(b'z', 10, 1), 0xC001_7A0A);\n        assert_eq!(request_code_readwrite!(b'z', 10, 512), 0xC200_7A0A);\n    }\n\n    #[cfg(target_pointer_width = \"64\")]\n    #[test]\n    fn test_op_read_write_64() {\n        assert_eq!(request_code_readwrite!(b'z', 10, 1u64 \u003c\u003c 32), 0xC000_7A0A);\n    }\n}\n\n#[cfg(linux_android)]\nmod linux_ioctls {\n    use std::mem;\n    use std::os::unix::io::AsRawFd;\n\n    use libc::{termios, TCGETS, TCSBRK, TCSETS, TIOCNXCL};\n    use tempfile::tempfile;\n\n    use nix::errno::Errno;\n\n    ioctl_none_bad!(tiocnxcl, TIOCNXCL);\n    #[test]\n    fn test_ioctl_none_bad() {\n        let file = tempfile().unwrap();\n        let res = unsafe { tiocnxcl(file.as_raw_fd()) };\n        assert_eq!(res, Err(Errno::ENOTTY));\n    }\n\n    ioctl_read_bad!(tcgets, TCGETS, termios);\n    #[test]\n    fn test_ioctl_read_bad() {\n        let file = tempfile().unwrap();\n        let mut termios = unsafe { mem::zeroed() };\n        let res = unsafe { tcgets(file.as_raw_fd(), \u0026mut termios) };\n        assert_eq!(res, Err(Errno::ENOTTY));\n    }\n\n    ioctl_write_int_bad!(tcsbrk, TCSBRK);\n    #[test]\n    fn test_ioctl_write_int_bad() {\n        let file = tempfile().unwrap();\n        let res = unsafe { tcsbrk(file.as_raw_fd(), 0) };\n        assert_eq!(res, Err(Errno::ENOTTY));\n    }\n\n    ioctl_write_ptr_bad!(tcsets, TCSETS, termios);\n    #[test]\n    fn test_ioctl_write_ptr_bad() {\n        let file = tempfile().unwrap();\n        let termios: termios = unsafe { mem::zeroed() };\n        let res = unsafe { tcsets(file.as_raw_fd(), \u0026termios) };\n        assert_eq!(res, Err(Errno::ENOTTY));\n    }\n\n    // FIXME: Find a suitable example for `ioctl_readwrite_bad`\n\n    // From linux/videodev2.h\n    ioctl_none!(log_status, b'V', 70);\n    #[test]\n    fn test_ioctl_none() {\n        let file = tempfile().unwrap();\n        let res = unsafe { log_status(file.as_raw_fd()) };\n        assert!(res == Err(Errno::ENOTTY) || res == Err(Errno::ENOSYS));\n    }\n\n    #[repr(C)]\n    pub struct v4l2_audio {\n        index: u32,\n        name: [u8; 32],\n        capability: u32,\n        mode: u32,\n        reserved: [u32; 2],\n    }\n\n    // From linux/videodev2.h\n    ioctl_write_ptr!(s_audio, b'V', 34, v4l2_audio);\n    #[test]\n    fn test_ioctl_write_ptr() {\n        let file = tempfile().unwrap();\n        let data: v4l2_audio = unsafe { mem::zeroed() };\n        let res = unsafe { s_audio(file.as_raw_fd(), \u0026data) };\n        assert!(res == Err(Errno::ENOTTY) || res == Err(Errno::ENOSYS));\n    }\n\n    // From linux/net/bluetooth/hci_sock.h\n    const HCI_IOC_MAGIC: u8 = b'H';\n    const HCI_IOC_HCIDEVUP: u8 = 201;\n    ioctl_write_int!(hcidevup, HCI_IOC_MAGIC, HCI_IOC_HCIDEVUP);\n    #[test]\n    fn test_ioctl_write_int() {\n        let file = tempfile().unwrap();\n        let res = unsafe { hcidevup(file.as_raw_fd(), 0) };\n        assert!(res == Err(Errno::ENOTTY) || res == Err(Errno::ENOSYS));\n    }\n\n    // From linux/videodev2.h\n    ioctl_read!(g_audio, b'V', 33, v4l2_audio);\n    #[test]\n    fn test_ioctl_read() {\n        let file = tempfile().unwrap();\n        let mut data: v4l2_audio = unsafe { mem::zeroed() };\n        let res = unsafe { g_audio(file.as_raw_fd(), \u0026mut data) };\n        assert!(res == Err(Errno::ENOTTY) || res == Err(Errno::ENOSYS));\n    }\n\n    // From linux/videodev2.h\n    ioctl_readwrite!(enum_audio, b'V', 65, v4l2_audio);\n    #[test]\n    fn test_ioctl_readwrite() {\n        let file = tempfile().unwrap();\n        let mut data: v4l2_audio = unsafe { mem::zeroed() };\n        let res = unsafe { enum_audio(file.as_raw_fd(), \u0026mut data) };\n        assert!(res == Err(Errno::ENOTTY) || res == Err(Errno::ENOSYS));\n    }\n\n    // FIXME: Find a suitable example for `ioctl_read_buf`.\n\n    #[repr(C)]\n    pub struct spi_ioc_transfer {\n        tx_buf: u64,\n        rx_buf: u64,\n        len: u32,\n        speed_hz: u32,\n        delay_usecs: u16,\n        bits_per_word: u8,\n        cs_change: u8,\n        tx_nbits: u8,\n        rx_nbits: u8,\n        pad: u16,\n    }\n\n    // From linux/spi/spidev.h\n    ioctl_write_buf!(\n        spi_ioc_message,\n        super::SPI_IOC_MAGIC,\n        super::SPI_IOC_MESSAGE,\n        spi_ioc_transfer\n    );\n    #[test]\n    fn test_ioctl_write_buf() {\n        let file = tempfile().unwrap();\n        let data: [spi_ioc_transfer; 4] = unsafe { mem::zeroed() };\n        let res = unsafe { spi_ioc_message(file.as_raw_fd(), \u0026data[..]) };\n        assert!(res == Err(Errno::ENOTTY) || res == Err(Errno::ENOSYS));\n    }\n\n    // FIXME: Find a suitable example for `ioctl_readwrite_buf`.\n}\n\n#[cfg(target_os = \"freebsd\")]\nmod freebsd_ioctls {\n    use std::mem;\n    use std::os::unix::io::AsRawFd;\n\n    use libc::termios;\n    use tempfile::tempfile;\n\n    use nix::errno::Errno;\n\n    // From sys/sys/ttycom.h\n    const TTY_IOC_MAGIC: u8 = b't';\n    const TTY_IOC_TYPE_NXCL: u8 = 14;\n    const TTY_IOC_TYPE_GETA: u8 = 19;\n    const TTY_IOC_TYPE_SETA: u8 = 20;\n\n    ioctl_none!(tiocnxcl, TTY_IOC_MAGIC, TTY_IOC_TYPE_NXCL);\n    #[test]\n    fn test_ioctl_none() {\n        let file = tempfile().unwrap();\n        let res = unsafe { tiocnxcl(file.as_raw_fd()) };\n        assert_eq!(res, Err(Errno::ENOTTY));\n    }\n\n    ioctl_read!(tiocgeta, TTY_IOC_MAGIC, TTY_IOC_TYPE_GETA, termios);\n    #[test]\n    fn test_ioctl_read() {\n        let file = tempfile().unwrap();\n        let mut termios = unsafe { mem::zeroed() };\n        let res = unsafe { tiocgeta(file.as_raw_fd(), \u0026mut termios) };\n        assert_eq!(res, Err(Errno::ENOTTY));\n    }\n\n    ioctl_write_ptr!(tiocseta, TTY_IOC_MAGIC, TTY_IOC_TYPE_SETA, termios);\n    #[test]\n    fn test_ioctl_write_ptr() {\n        let file = tempfile().unwrap();\n        let termios: termios = unsafe { mem::zeroed() };\n        let res = unsafe { tiocseta(file.as_raw_fd(), \u0026termios) };\n        assert_eq!(res, Err(Errno::ENOTTY));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_memfd.rs"],"content":"#[test]\nfn test_memfd_create() {\n    use nix::sys::memfd::memfd_create;\n    use nix::sys::memfd::MFdFlags;\n    use nix::unistd::lseek;\n    use nix::unistd::read;\n    use nix::unistd::{write, Whence};\n\n    let fd =\n        memfd_create(\"test_memfd_create_name\", MFdFlags::MFD_CLOEXEC).unwrap();\n    let contents = b\"hello\";\n    assert_eq!(write(\u0026fd, contents).unwrap(), 5);\n\n    lseek(\u0026fd, 0, Whence::SeekSet).unwrap();\n\n    let mut buf = vec![0_u8; contents.len()];\n    assert_eq!(read(\u0026fd, \u0026mut buf).unwrap(), 5);\n\n    assert_eq!(contents, buf.as_slice());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_mman.rs"],"content":"#![allow(clippy::redundant_slicing)]\n\nuse nix::sys::mman::{mmap_anonymous, MapFlags, ProtFlags};\nuse std::num::NonZeroUsize;\n\n#[test]\nfn test_mmap_anonymous() {\n    unsafe {\n        let mut ptr = mmap_anonymous(\n            None,\n            NonZeroUsize::new(1).unwrap(),\n            ProtFlags::PROT_READ | ProtFlags::PROT_WRITE,\n            MapFlags::MAP_PRIVATE,\n        )\n        .unwrap()\n        .cast::\u003cu8\u003e();\n        assert_eq!(*ptr.as_ref(), 0x00u8);\n        *ptr.as_mut() = 0xffu8;\n        assert_eq!(*ptr.as_ref(), 0xffu8);\n    }\n}\n\n#[test]\n#[cfg(any(target_os = \"linux\", target_os = \"netbsd\"))]\nfn test_mremap_grow() {\n    use nix::libc::size_t;\n    use nix::sys::mman::{mremap, MRemapFlags};\n    use std::ptr::NonNull;\n\n    const ONE_K: size_t = 1024;\n    let one_k_non_zero = NonZeroUsize::new(ONE_K).unwrap();\n\n    let slice: \u0026mut [u8] = unsafe {\n        let mem = mmap_anonymous(\n            None,\n            one_k_non_zero,\n            ProtFlags::PROT_READ | ProtFlags::PROT_WRITE,\n            MapFlags::MAP_PRIVATE,\n        )\n        .unwrap();\n        std::slice::from_raw_parts_mut(mem.as_ptr().cast(), ONE_K)\n    };\n    assert_eq!(slice[ONE_K - 1], 0x00);\n    slice[ONE_K - 1] = 0xFF;\n    assert_eq!(slice[ONE_K - 1], 0xFF);\n\n    let slice: \u0026mut [u8] = unsafe {\n        #[cfg(target_os = \"linux\")]\n        let mem = mremap(\n            NonNull::from(\u0026mut slice[..]).cast(),\n            ONE_K,\n            10 * ONE_K,\n            MRemapFlags::MREMAP_MAYMOVE,\n            None,\n        )\n        .unwrap();\n        #[cfg(target_os = \"netbsd\")]\n        let mem = mremap(\n            NonNull::from(\u0026mut slice[..]).cast(),\n            ONE_K,\n            10 * ONE_K,\n            MRemapFlags::MAP_REMAPDUP,\n            None,\n        )\n        .unwrap();\n        std::slice::from_raw_parts_mut(mem.cast().as_ptr(), 10 * ONE_K)\n    };\n\n    // The first KB should still have the old data in it.\n    assert_eq!(slice[ONE_K - 1], 0xFF);\n\n    // The additional range should be zero-init'd and accessible.\n    assert_eq!(slice[10 * ONE_K - 1], 0x00);\n    slice[10 * ONE_K - 1] = 0xFF;\n    assert_eq!(slice[10 * ONE_K - 1], 0xFF);\n}\n\n#[test]\n#[cfg(any(target_os = \"linux\", target_os = \"netbsd\"))]\n// Segfaults for unknown reasons under QEMU for 32-bit targets\n#[cfg_attr(all(target_pointer_width = \"32\", qemu), ignore)]\nfn test_mremap_shrink() {\n    use nix::libc::size_t;\n    use nix::sys::mman::{mremap, MRemapFlags};\n    use std::num::NonZeroUsize;\n    use std::ptr::NonNull;\n\n    const ONE_K: size_t = 1024;\n    let ten_one_k = NonZeroUsize::new(10 * ONE_K).unwrap();\n    let slice: \u0026mut [u8] = unsafe {\n        let mem = mmap_anonymous(\n            None,\n            ten_one_k,\n            ProtFlags::PROT_READ | ProtFlags::PROT_WRITE,\n            MapFlags::MAP_PRIVATE,\n        )\n        .unwrap();\n        std::slice::from_raw_parts_mut(mem.as_ptr().cast(), ONE_K)\n    };\n    assert_eq!(slice[ONE_K - 1], 0x00);\n    slice[ONE_K - 1] = 0xFF;\n    assert_eq!(slice[ONE_K - 1], 0xFF);\n\n    let slice: \u0026mut [u8] = unsafe {\n        let mem = mremap(\n            NonNull::from(\u0026mut slice[..]).cast(),\n            ten_one_k.into(),\n            ONE_K,\n            MRemapFlags::empty(),\n            None,\n        )\n        .unwrap();\n        // Since we didn't supply MREMAP_MAYMOVE, the address should be the\n        // same.\n        assert_eq!(mem.as_ptr(), NonNull::from(\u0026mut slice[..]).cast().as_ptr());\n        std::slice::from_raw_parts_mut(mem.as_ptr().cast(), ONE_K)\n    };\n\n    // The first KB should still be accessible and have the old data in it.\n    assert_eq!(slice[ONE_K - 1], 0xFF);\n}\n\n#[test]\n#[cfg(target_os = \"linux\")]\nfn test_mremap_dontunmap() {\n    use nix::libc::size_t;\n    use nix::sys::mman::{mremap, MRemapFlags};\n    use std::num::NonZeroUsize;\n    use std::ptr::NonNull;\n\n    const ONE_K: size_t = 1024;\n    let one_k_non_zero = NonZeroUsize::new(ONE_K).unwrap();\n\n    let slice: \u0026mut [u8] = unsafe {\n        let mem = mmap_anonymous(\n            None,\n            one_k_non_zero,\n            ProtFlags::PROT_READ | ProtFlags::PROT_WRITE,\n            MapFlags::MAP_PRIVATE,\n        )\n        .unwrap();\n        std::slice::from_raw_parts_mut(mem.as_ptr().cast(), ONE_K)\n    };\n\n    // because we do not unmap `slice`, `old_size` and `new_size`\n    // need to be equal or `EINVAL` is set.\n    let _new_slice: \u0026mut [u8] = unsafe {\n        let mem = mremap(\n            NonNull::from(\u0026mut slice[..]).cast(),\n            ONE_K,\n            ONE_K,\n            MRemapFlags::MREMAP_MAYMOVE | MRemapFlags::MREMAP_DONTUNMAP,\n            None,\n        )\n        .unwrap();\n        std::slice::from_raw_parts_mut(mem.cast().as_ptr(), 10 * ONE_K)\n    };\n}\n\n#[test]\n#[cfg(target_os = \"linux\")]\nfn test_madv_wipeonfork() {\n    use nix::libc::size_t;\n    use nix::sys::mman::{madvise, MmapAdvise};\n    use nix::unistd::{fork, ForkResult};\n    use std::num::NonZeroUsize;\n\n    const ONE_K: size_t = 1024;\n    let ten_one_k = NonZeroUsize::new(10 * ONE_K).unwrap();\n    let slice: \u0026mut [u8] = unsafe {\n        let mem = mmap_anonymous(\n            None,\n            ten_one_k,\n            ProtFlags::PROT_READ | ProtFlags::PROT_WRITE,\n            MapFlags::MAP_PRIVATE,\n        )\n        .unwrap();\n        madvise(mem, ONE_K, MmapAdvise::MADV_WIPEONFORK)\n            .expect(\"madvise failed\");\n        std::slice::from_raw_parts_mut(mem.as_ptr().cast(), ONE_K)\n    };\n    slice[ONE_K - 1] = 0xFF;\n    let _m = crate::FORK_MTX.lock();\n\n    unsafe {\n        let res = fork().expect(\"fork failed\");\n        match res {\n            ForkResult::Child =\u003e {\n                // that s the whole point of MADV_WIPEONFORK\n                assert_eq!(slice[ONE_K - 1], 0x00);\n                libc::_exit(0);\n            }\n            ForkResult::Parent { child } =\u003e {\n                nix::sys::signal::kill(child, nix::sys::signal::SIGTERM)\n                    .unwrap();\n                let _ = nix::sys::wait::wait().unwrap();\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_prctl.rs"],"content":"#[cfg(target_os = \"linux\")]\n#[cfg(feature = \"process\")]\nmod test_prctl {\n    use std::ffi::CStr;\n\n    use nix::sys::prctl;\n\n    #[cfg_attr(qemu, ignore)]\n    #[test]\n    fn test_get_set_subreaper() {\n        let original = prctl::get_child_subreaper().unwrap();\n\n        prctl::set_child_subreaper(true).unwrap();\n        let subreaper = prctl::get_child_subreaper().unwrap();\n        assert!(subreaper);\n\n        prctl::set_child_subreaper(original).unwrap();\n    }\n\n    #[test]\n    fn test_get_set_dumpable() {\n        let original = prctl::get_dumpable().unwrap();\n\n        prctl::set_dumpable(false).unwrap();\n        let dumpable = prctl::get_dumpable().unwrap();\n        assert!(!dumpable);\n\n        prctl::set_dumpable(original).unwrap();\n    }\n\n    #[test]\n    fn test_get_set_keepcaps() {\n        let original = prctl::get_keepcaps().unwrap();\n\n        prctl::set_keepcaps(true).unwrap();\n        let keepcaps = prctl::get_keepcaps().unwrap();\n        assert!(keepcaps);\n\n        prctl::set_keepcaps(original).unwrap();\n    }\n\n    #[test]\n    fn test_get_set_clear_mce_kill() {\n        use prctl::PrctlMCEKillPolicy::*;\n\n        prctl::set_mce_kill(PR_MCE_KILL_LATE).unwrap();\n        let mce = prctl::get_mce_kill().unwrap();\n        assert_eq!(mce, PR_MCE_KILL_LATE);\n\n        prctl::clear_mce_kill().unwrap();\n        let mce = prctl::get_mce_kill().unwrap();\n        assert_eq!(mce, PR_MCE_KILL_DEFAULT);\n    }\n\n    #[cfg_attr(qemu, ignore)]\n    #[test]\n    fn test_get_set_pdeathsig() {\n        use nix::sys::signal::Signal;\n\n        let original = prctl::get_pdeathsig().unwrap();\n\n        prctl::set_pdeathsig(Signal::SIGUSR1).unwrap();\n        let sig = prctl::get_pdeathsig().unwrap();\n        assert_eq!(sig, Some(Signal::SIGUSR1));\n\n        prctl::set_pdeathsig(original).unwrap();\n    }\n\n    #[test]\n    fn test_get_set_name() {\n        let original = prctl::get_name().unwrap();\n\n        let long_name =\n            CStr::from_bytes_with_nul(b\"0123456789abcdefghijklmn\\0\").unwrap();\n        prctl::set_name(long_name).unwrap();\n        let res = prctl::get_name().unwrap();\n\n        // name truncated by kernel to TASK_COMM_LEN\n        assert_eq!(\u0026long_name.to_str().unwrap()[..15], res.to_str().unwrap());\n\n        let short_name = CStr::from_bytes_with_nul(b\"01234567\\0\").unwrap();\n        prctl::set_name(short_name).unwrap();\n        let res = prctl::get_name().unwrap();\n        assert_eq!(short_name.to_str().unwrap(), res.to_str().unwrap());\n\n        prctl::set_name(\u0026original).unwrap();\n    }\n\n    #[cfg_attr(qemu, ignore)]\n    #[test]\n    fn test_get_set_timerslack() {\n        let original = prctl::get_timerslack().unwrap() as libc::c_ulong;\n\n        let slack = 60_000;\n        prctl::set_timerslack(slack).unwrap();\n        let res = prctl::get_timerslack().unwrap() as libc::c_ulong;\n        assert_eq!(slack, res);\n\n        prctl::set_timerslack(original).unwrap();\n    }\n\n    // Loongarch need to use a newer QEMU that disabled these PRCTL subcodes/methods.\n    // https://github.com/qemu/qemu/commit/220717a6f46a99031a5b1af964bbf4dec1310440\n    // So we should ignore them when testing in QEMU environments.\n    #[cfg_attr(all(qemu, target_arch = \"loongarch64\"), ignore)]\n    #[test]\n    fn test_disable_enable_perf_events() {\n        prctl::task_perf_events_disable().unwrap();\n        prctl::task_perf_events_enable().unwrap();\n    }\n\n    #[test]\n    fn test_get_set_no_new_privs() {\n        prctl::set_no_new_privs().unwrap();\n        let no_new_privs = prctl::get_no_new_privs().unwrap();\n        assert!(no_new_privs);\n    }\n\n    // Loongarch need to use a newer QEMU that disabled these PRCTL subcodes/methods\n    // https://github.com/qemu/qemu/commit/220717a6f46a99031a5b1af964bbf4dec1310440\n    // So we should ignore them when testing in QEMU environments.\n    #[cfg_attr(all(qemu, target_arch = \"loongarch64\"), ignore)]\n    #[test]\n    fn test_get_set_thp_disable() {\n        let original = prctl::get_thp_disable().unwrap();\n\n        prctl::set_thp_disable(true).unwrap();\n        let thp_disable = prctl::get_thp_disable().unwrap();\n        assert!(thp_disable);\n\n        prctl::set_thp_disable(original).unwrap();\n    }\n\n    // Ignore this test under QEMU, as it started failing after updating the Linux CI\n    // runner image, for reasons unknown.\n    //\n    // See: https://github.com/nix-rust/nix/issues/2418\n    #[test]\n    #[cfg_attr(qemu, ignore)]\n    fn test_set_vma_anon_name() {\n        use nix::errno::Errno;\n        use nix::sys::mman;\n        use std::num::NonZeroUsize;\n\n        const ONE_K: libc::size_t = 1024;\n        let sz = NonZeroUsize::new(ONE_K).unwrap();\n        let ptr = unsafe {\n            mman::mmap_anonymous(\n                None,\n                sz,\n                mman::ProtFlags::PROT_READ,\n                mman::MapFlags::MAP_SHARED,\n            )\n            .unwrap()\n        };\n        let err = prctl::set_vma_anon_name(\n            ptr,\n            sz,\n            Some(CStr::from_bytes_with_nul(b\"[,$\\0\").unwrap()),\n        )\n        .unwrap_err();\n        assert_eq!(err, Errno::EINVAL);\n        // `CONFIG_ANON_VMA_NAME` kernel config might not be set\n        prctl::set_vma_anon_name(\n            ptr,\n            sz,\n            Some(CStr::from_bytes_with_nul(b\"Nix\\0\").unwrap()),\n        )\n        .unwrap_or_default();\n        prctl::set_vma_anon_name(ptr, sz, None).unwrap_or_default();\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_pthread.rs"],"content":"use nix::sys::pthread::*;\n\n#[cfg(any(\n    target_env = \"musl\",\n    target_os = \"redox\",\n    target_env = \"ohos\",\n    target_os = \"cygwin\"\n))]\n#[test]\nfn test_pthread_self() {\n    let tid = pthread_self();\n    assert!(!tid.is_null());\n}\n\n#[cfg(not(any(\n    target_env = \"musl\",\n    target_os = \"redox\",\n    target_env = \"ohos\",\n    target_os = \"cygwin\"\n)))]\n#[test]\nfn test_pthread_self() {\n    let tid = pthread_self();\n    assert_ne!(tid, 0);\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_pthread_kill_none() {\n    pthread_kill(pthread_self(), None)\n        .expect(\"Should be able to send signal to my thread.\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_ptrace.rs"],"content":"#[cfg(all(\n    target_os = \"linux\",\n    target_env = \"gnu\",\n    any(target_arch = \"x86_64\", target_arch = \"x86\")\n))]\nuse memoffset::offset_of;\nuse nix::errno::Errno;\nuse nix::sys::ptrace;\n#[cfg(linux_android)]\nuse nix::sys::ptrace::Options;\nuse nix::unistd::getpid;\n\n#[cfg(linux_android)]\nuse std::mem;\n\nuse crate::*;\n\n#[test]\nfn test_ptrace() {\n    // Just make sure ptrace can be called at all, for now.\n    // FIXME: qemu-user doesn't implement ptrace on all arches, so permit ENOSYS\n    require_capability!(\"test_ptrace\", CAP_SYS_PTRACE);\n    let err = ptrace::attach(getpid()).unwrap_err();\n    assert!(\n        err == Errno::EPERM || err == Errno::EINVAL || err == Errno::ENOSYS\n    );\n}\n\n// Just make sure ptrace_setoptions can be called at all, for now.\n#[test]\n#[cfg(linux_android)]\nfn test_ptrace_setoptions() {\n    require_capability!(\"test_ptrace_setoptions\", CAP_SYS_PTRACE);\n    let err = ptrace::setoptions(getpid(), Options::PTRACE_O_TRACESYSGOOD)\n        .unwrap_err();\n    assert_ne!(err, Errno::EOPNOTSUPP);\n}\n\n// Just make sure ptrace_getevent can be called at all, for now.\n#[test]\n#[cfg(linux_android)]\nfn test_ptrace_getevent() {\n    require_capability!(\"test_ptrace_getevent\", CAP_SYS_PTRACE);\n    let err = ptrace::getevent(getpid()).unwrap_err();\n    assert_ne!(err, Errno::EOPNOTSUPP);\n}\n\n// Just make sure ptrace_getsiginfo can be called at all, for now.\n#[test]\n#[cfg(linux_android)]\nfn test_ptrace_getsiginfo() {\n    require_capability!(\"test_ptrace_getsiginfo\", CAP_SYS_PTRACE);\n    if let Err(Errno::EOPNOTSUPP) = ptrace::getsiginfo(getpid()) {\n        panic!(\"ptrace_getsiginfo returns Errno::EOPNOTSUPP!\");\n    }\n}\n\n// Just make sure ptrace_setsiginfo can be called at all, for now.\n#[test]\n#[cfg(linux_android)]\nfn test_ptrace_setsiginfo() {\n    require_capability!(\"test_ptrace_setsiginfo\", CAP_SYS_PTRACE);\n    let siginfo = unsafe { mem::zeroed() };\n    if let Err(Errno::EOPNOTSUPP) = ptrace::setsiginfo(getpid(), \u0026siginfo) {\n        panic!(\"ptrace_setsiginfo returns Errno::EOPNOTSUPP!\");\n    }\n}\n\n#[test]\nfn test_ptrace_cont() {\n    use nix::sys::ptrace;\n    use nix::sys::signal::{raise, Signal};\n    use nix::sys::wait::{waitpid, WaitPidFlag, WaitStatus};\n    use nix::unistd::fork;\n    use nix::unistd::ForkResult::*;\n\n    require_capability!(\"test_ptrace_cont\", CAP_SYS_PTRACE);\n\n    let _m = crate::FORK_MTX.lock();\n\n    // FIXME: qemu-user doesn't implement ptrace on all architectures\n    // and returns ENOSYS in this case.\n    // We (ab)use this behavior to detect the affected platforms\n    // and skip the test then.\n    // On valid platforms the ptrace call should return Errno::EPERM, this\n    // is already tested by `test_ptrace`.\n    let err = ptrace::attach(getpid()).unwrap_err();\n    if err == Errno::ENOSYS {\n        return;\n    }\n\n    match unsafe { fork() }.expect(\"Error: Fork Failed\") {\n        Child =\u003e {\n            ptrace::traceme().unwrap();\n            // As recommended by ptrace(2), raise SIGTRAP to pause the child\n            // until the parent is ready to continue\n            loop {\n                raise(Signal::SIGTRAP).unwrap();\n            }\n        }\n        Parent { child } =\u003e {\n            assert_eq!(\n                waitpid(child, None),\n                Ok(WaitStatus::Stopped(child, Signal::SIGTRAP))\n            );\n            ptrace::cont(child, None).unwrap();\n            assert_eq!(\n                waitpid(child, None),\n                Ok(WaitStatus::Stopped(child, Signal::SIGTRAP))\n            );\n            ptrace::cont(child, Some(Signal::SIGKILL)).unwrap();\n            match waitpid(child, None) {\n                Ok(WaitStatus::Signaled(pid, Signal::SIGKILL, _))\n                    if pid == child =\u003e\n                {\n                    // FIXME It's been observed on some systems (apple) the\n                    // tracee may not be killed but remain as a zombie process\n                    // affecting other wait based tests. Add an extra kill just\n                    // to make sure there are no zombies.\n                    let _ = waitpid(child, Some(WaitPidFlag::WNOHANG));\n                    while ptrace::cont(child, Some(Signal::SIGKILL)).is_ok() {\n                        let _ = waitpid(child, Some(WaitPidFlag::WNOHANG));\n                    }\n                }\n                _ =\u003e panic!(\"The process should have been killed\"),\n            }\n        }\n    }\n}\n\n#[cfg(target_os = \"linux\")]\n#[test]\nfn test_ptrace_interrupt() {\n    use nix::sys::ptrace;\n    use nix::sys::signal::Signal;\n    use nix::sys::wait::{waitpid, WaitPidFlag, WaitStatus};\n    use nix::unistd::fork;\n    use nix::unistd::ForkResult::*;\n    use std::thread::sleep;\n    use std::time::Duration;\n\n    require_capability!(\"test_ptrace_interrupt\", CAP_SYS_PTRACE);\n\n    let _m = crate::FORK_MTX.lock();\n\n    match unsafe { fork() }.expect(\"Error: Fork Failed\") {\n        Child =\u003e loop {\n            sleep(Duration::from_millis(1000));\n        },\n        Parent { child } =\u003e {\n            ptrace::seize(child, ptrace::Options::PTRACE_O_TRACESYSGOOD)\n                .unwrap();\n            ptrace::interrupt(child).unwrap();\n            assert_eq!(\n                waitpid(child, None),\n                Ok(WaitStatus::PtraceEvent(child, Signal::SIGTRAP, 128))\n            );\n            ptrace::syscall(child, None).unwrap();\n            assert_eq!(\n                waitpid(child, None),\n                Ok(WaitStatus::PtraceSyscall(child))\n            );\n            ptrace::detach(child, Some(Signal::SIGKILL)).unwrap();\n            match waitpid(child, None) {\n                Ok(WaitStatus::Signaled(pid, Signal::SIGKILL, _))\n                    if pid == child =\u003e\n                {\n                    let _ = waitpid(child, Some(WaitPidFlag::WNOHANG));\n                    while ptrace::cont(child, Some(Signal::SIGKILL)).is_ok() {\n                        let _ = waitpid(child, Some(WaitPidFlag::WNOHANG));\n                    }\n                }\n                _ =\u003e panic!(\"The process should have been killed\"),\n            }\n        }\n    }\n}\n\n// ptrace::{setoptions, getregs} are only available in these platforms\n#[cfg(all(\n    target_os = \"linux\",\n    any(\n        all(\n            target_env = \"gnu\",\n            any(\n                target_arch = \"x86_64\",\n                target_arch = \"x86\",\n                target_arch = \"aarch64\",\n                target_arch = \"riscv64\"\n            )\n        ),\n        all(target_env = \"musl\", target_arch = \"aarch64\")\n    )\n))]\n#[test]\nfn test_ptrace_syscall() {\n    use nix::sys::ptrace;\n    use nix::sys::signal::kill;\n    use nix::sys::signal::Signal;\n    use nix::sys::wait::{waitpid, WaitStatus};\n    use nix::unistd::fork;\n    use nix::unistd::getpid;\n    use nix::unistd::ForkResult::*;\n\n    require_capability!(\"test_ptrace_syscall\", CAP_SYS_PTRACE);\n\n    let _m = crate::FORK_MTX.lock();\n\n    match unsafe { fork() }.expect(\"Error: Fork Failed\") {\n        Child =\u003e {\n            ptrace::traceme().unwrap();\n            // first sigstop until parent is ready to continue\n            let pid = getpid();\n            kill(pid, Signal::SIGSTOP).unwrap();\n            kill(pid, Signal::SIGTERM).unwrap();\n            unsafe {\n                ::libc::_exit(0);\n            }\n        }\n\n        Parent { child } =\u003e {\n            assert_eq!(\n                waitpid(child, None),\n                Ok(WaitStatus::Stopped(child, Signal::SIGSTOP))\n            );\n\n            // set this option to recognize syscall-stops\n            ptrace::setoptions(child, ptrace::Options::PTRACE_O_TRACESYSGOOD)\n                .unwrap();\n\n            #[cfg(target_arch = \"x86_64\")]\n            let get_syscall_id =\n                || ptrace::getregs(child).unwrap().orig_rax as libc::c_long;\n\n            #[cfg(target_arch = \"x86\")]\n            let get_syscall_id =\n                || ptrace::getregs(child).unwrap().orig_eax as libc::c_long;\n\n            #[cfg(target_arch = \"aarch64\")]\n            let get_syscall_id =\n                || ptrace::getregs(child).unwrap().regs[8] as libc::c_long;\n\n            #[cfg(target_arch = \"riscv64\")]\n            let get_syscall_id =\n                || ptrace::getregs(child).unwrap().a7 as libc::c_long;\n\n            // this duplicates `get_syscall_id` for the purpose of testing `ptrace::read_user`.\n            #[cfg(target_arch = \"x86_64\")]\n            let rax_offset = offset_of!(libc::user_regs_struct, orig_rax);\n            #[cfg(target_arch = \"x86\")]\n            let rax_offset = offset_of!(libc::user_regs_struct, orig_eax);\n\n            #[cfg(any(target_arch = \"x86_64\", target_arch = \"x86\"))]\n            let get_syscall_from_user_area = || {\n                // Find the offset of `user.regs.rax` (or `user.regs.eax` for x86)\n                let rax_offset = offset_of!(libc::user, regs) + rax_offset;\n                ptrace::read_user(child, rax_offset as _).unwrap()\n                    as libc::c_long\n            };\n\n            // kill entry\n            ptrace::syscall(child, None).unwrap();\n            assert_eq!(\n                waitpid(child, None),\n                Ok(WaitStatus::PtraceSyscall(child))\n            );\n            assert_eq!(get_syscall_id(), ::libc::SYS_kill);\n            #[cfg(any(target_arch = \"x86_64\", target_arch = \"x86\"))]\n            assert_eq!(get_syscall_from_user_area(), ::libc::SYS_kill);\n\n            // kill exit\n            ptrace::syscall(child, None).unwrap();\n            assert_eq!(\n                waitpid(child, None),\n                Ok(WaitStatus::PtraceSyscall(child))\n            );\n            assert_eq!(get_syscall_id(), ::libc::SYS_kill);\n            #[cfg(any(target_arch = \"x86_64\", target_arch = \"x86\"))]\n            assert_eq!(get_syscall_from_user_area(), ::libc::SYS_kill);\n\n            // receive signal\n            ptrace::syscall(child, None).unwrap();\n            assert_eq!(\n                waitpid(child, None),\n                Ok(WaitStatus::Stopped(child, Signal::SIGTERM))\n            );\n\n            // inject signal\n            ptrace::syscall(child, Signal::SIGTERM).unwrap();\n            assert_eq!(\n                waitpid(child, None),\n                Ok(WaitStatus::Signaled(child, Signal::SIGTERM, false))\n            );\n        }\n    }\n}\n\n#[cfg(all(\n    target_os = \"linux\",\n    any(\n        all(\n            target_env = \"gnu\",\n            any(\n                target_arch = \"x86_64\",\n                target_arch = \"x86\",\n                target_arch = \"aarch64\",\n                target_arch = \"riscv64\"\n            )\n        ),\n        all(target_env = \"musl\", target_arch = \"aarch64\")\n    )\n))]\n#[test]\nfn test_ptrace_regsets() {\n    use nix::sys::ptrace::{self, getregset, regset, setregset};\n    use nix::sys::signal::*;\n    use nix::sys::wait::{waitpid, WaitStatus};\n    use nix::unistd::fork;\n    use nix::unistd::ForkResult::*;\n\n    require_capability!(\"test_ptrace_regsets\", CAP_SYS_PTRACE);\n\n    let _m = crate::FORK_MTX.lock();\n\n    match unsafe { fork() }.expect(\"Error: Fork Failed\") {\n        Child =\u003e {\n            ptrace::traceme().unwrap();\n            // As recommended by ptrace(2), raise SIGTRAP to pause the child\n            // until the parent is ready to continue\n            loop {\n                raise(Signal::SIGTRAP).unwrap();\n            }\n        }\n\n        Parent { child } =\u003e {\n            assert_eq!(\n                waitpid(child, None),\n                Ok(WaitStatus::Stopped(child, Signal::SIGTRAP))\n            );\n            let mut regstruct =\n                getregset::\u003cregset::NT_PRSTATUS\u003e(child).unwrap();\n            let mut fpregstruct =\n                getregset::\u003cregset::NT_PRFPREG\u003e(child).unwrap();\n\n            #[cfg(target_arch = \"x86_64\")]\n            let (reg, fpreg) =\n                (\u0026mut regstruct.r15, \u0026mut fpregstruct.st_space[5]);\n            #[cfg(target_arch = \"x86\")]\n            let (reg, fpreg) =\n                (\u0026mut regstruct.edx, \u0026mut fpregstruct.st_space[5]);\n            #[cfg(target_arch = \"aarch64\")]\n            let (reg, fpreg) =\n                (\u0026mut regstruct.regs[16], \u0026mut fpregstruct.vregs[5]);\n            #[cfg(target_arch = \"riscv64\")]\n            let (reg, fpreg) = (\u0026mut regstruct.t1, \u0026mut fpregstruct.__f[5]);\n\n            *reg = 0xdeadbeefu32 as _;\n            *fpreg = 0xfeedfaceu32 as _;\n            let _ = setregset::\u003cregset::NT_PRSTATUS\u003e(child, regstruct);\n            regstruct = getregset::\u003cregset::NT_PRSTATUS\u003e(child).unwrap();\n            let _ = setregset::\u003cregset::NT_PRFPREG\u003e(child, fpregstruct);\n            fpregstruct = getregset::\u003cregset::NT_PRFPREG\u003e(child).unwrap();\n\n            #[cfg(target_arch = \"x86_64\")]\n            let (reg, fpreg) = (regstruct.r15, fpregstruct.st_space[5]);\n            #[cfg(target_arch = \"x86\")]\n            let (reg, fpreg) = (regstruct.edx, fpregstruct.st_space[5]);\n            #[cfg(target_arch = \"aarch64\")]\n            let (reg, fpreg) = (regstruct.regs[16], fpregstruct.vregs[5]);\n            #[cfg(target_arch = \"riscv64\")]\n            let (reg, fpreg) = (regstruct.t1, fpregstruct.__f[5]);\n            assert_eq!(reg, 0xdeadbeefu32 as _);\n            assert_eq!(fpreg, 0xfeedfaceu32 as _);\n\n            ptrace::cont(child, Some(Signal::SIGKILL)).unwrap();\n            match waitpid(child, None) {\n                Ok(WaitStatus::Signaled(pid, Signal::SIGKILL, _))\n                    if pid == child =\u003e {}\n                _ =\u003e panic!(\"The process should have been killed\"),\n            }\n        }\n    }\n}\n\n#[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n#[test]\nfn test_ptrace_syscall_info() {\n    use nix::sys::ptrace;\n    use nix::sys::wait::{waitpid, WaitStatus};\n    use nix::unistd::fork;\n    use nix::unistd::ForkResult::*;\n\n    require_capability!(\"test_ptrace_syscall_info\", CAP_SYS_PTRACE);\n\n    let _m = crate::FORK_MTX.lock();\n    match unsafe { fork() }.expect(\"Error: Fork Failed\") {\n        Child =\u003e {\n            ptrace::traceme().unwrap();\n            std::thread::sleep(std::time::Duration::from_millis(1000));\n            unsafe {\n                ::libc::_exit(0);\n            }\n        }\n        Parent { child } =\u003e loop {\n            if let Ok(WaitStatus::Exited(_, 0)) = waitpid(child, None) {\n                break;\n            }\n            let si = ptrace::syscall_info(child).unwrap();\n            assert!(si.op \u003e= libc::PTRACE_SYSCALL_INFO_ENTRY);\n        },\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_resource.rs"],"content":"use nix::sys::resource::{getrlimit, setrlimit, Resource};\nuse nix::sys::resource::{getrusage, UsageWho};\n\n/// Tests the RLIMIT_NOFILE functionality of getrlimit(), where the resource RLIMIT_NOFILE refers\n/// to the maximum file descriptor number that can be opened by the process (aka the maximum number\n/// of file descriptors that the process can open, since Linux 4.5).\n///\n/// We first fetch the existing file descriptor maximum values using getrlimit(), then edit the\n/// soft limit to make sure it has a new and distinct value to the hard limit. We then setrlimit()\n/// to put the new soft limit in effect, and then getrlimit() once more to ensure the limits have\n/// been updated.\n#[test]\n#[cfg_attr(target_os = \"cygwin\", ignore)]\npub fn test_resource_limits_nofile() {\n    let (mut soft_limit, hard_limit) =\n        getrlimit(Resource::RLIMIT_NOFILE).unwrap();\n\n    soft_limit -= 1;\n    assert_ne!(soft_limit, hard_limit);\n    setrlimit(Resource::RLIMIT_NOFILE, soft_limit, hard_limit).unwrap();\n\n    let (new_soft_limit, _) = getrlimit(Resource::RLIMIT_NOFILE).unwrap();\n    assert_eq!(new_soft_limit, soft_limit);\n}\n\n#[test]\npub fn test_self_cpu_time() {\n    // Make sure some CPU time is used.\n    let mut numbers: Vec\u003ci32\u003e = (1..1_000_000).collect();\n    numbers.iter_mut().for_each(|item| *item *= 2);\n\n    // FIXME: this is here to help ensure the compiler does not optimize the whole\n    // thing away. Replace the assert with test::black_box once stabilized.\n    assert_eq!(numbers[100..200].iter().sum::\u003ci32\u003e(), 30_100);\n\n    let usage = getrusage(UsageWho::RUSAGE_SELF)\n        .expect(\"Failed to call getrusage for SELF\");\n    let rusage = usage.as_ref();\n\n    let user = usage.user_time();\n    assert!(user.tv_sec() \u003e 0 || user.tv_usec() \u003e 0);\n    assert_eq!(user.tv_sec(), rusage.ru_utime.tv_sec);\n    assert_eq!(user.tv_usec(), rusage.ru_utime.tv_usec);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_select.rs"],"content":"use nix::sys::select::*;\nuse nix::sys::signal::SigSet;\nuse nix::sys::time::{TimeSpec, TimeVal, TimeValLike};\nuse nix::unistd::{pipe, write};\nuse std::os::unix::io::{AsFd, AsRawFd, BorrowedFd, RawFd};\n\n#[test]\npub fn test_pselect() {\n    let _mtx = crate::SIGNAL_MTX.lock();\n\n    let (r1, w1) = pipe().unwrap();\n    write(\u0026w1, b\"hi!\").unwrap();\n    let (r2, _w2) = pipe().unwrap();\n\n    let mut fd_set = FdSet::new();\n    fd_set.insert(r1.as_fd());\n    fd_set.insert(r2.as_fd());\n\n    let timeout = TimeSpec::seconds(10);\n    let sigmask = SigSet::empty();\n    assert_eq!(\n        1,\n        pselect(None, \u0026mut fd_set, None, None, \u0026timeout, \u0026sigmask).unwrap()\n    );\n    assert!(fd_set.contains(r1.as_fd()));\n    assert!(!fd_set.contains(r2.as_fd()));\n}\n\n#[test]\npub fn test_pselect_nfds2() {\n    let (r1, w1) = pipe().unwrap();\n    write(\u0026w1, b\"hi!\").unwrap();\n    let (r2, _w2) = pipe().unwrap();\n\n    let mut fd_set = FdSet::new();\n    fd_set.insert(r1.as_fd());\n    fd_set.insert(r2.as_fd());\n\n    let timeout = TimeSpec::seconds(10);\n    assert_eq!(\n        1,\n        pselect(\n            std::cmp::max(r1.as_raw_fd(), r2.as_raw_fd()) + 1,\n            \u0026mut fd_set,\n            None,\n            None,\n            \u0026timeout,\n            None\n        )\n        .unwrap()\n    );\n    assert!(fd_set.contains(r1.as_fd()));\n    assert!(!fd_set.contains(r2.as_fd()));\n}\n\nmacro_rules! generate_fdset_bad_fd_tests {\n    ($fd:expr, $($method:ident),* $(,)?) =\u003e {\n        $(\n            #[test]\n            #[should_panic]\n            fn $method() {\n                let bad_fd = unsafe{BorrowedFd::borrow_raw($fd)};\n                FdSet::new().$method(bad_fd);\n            }\n        )*\n    }\n}\n\nmod test_fdset_too_large_fd {\n    use super::*;\n    generate_fdset_bad_fd_tests!(\n        FD_SETSIZE.try_into().unwrap(),\n        insert,\n        remove,\n        contains,\n    );\n}\n\n#[test]\nfn fdset_insert() {\n    let mut fd_set = FdSet::new();\n\n    for i in 0..FD_SETSIZE {\n        let borrowed_i = unsafe { BorrowedFd::borrow_raw(i as RawFd) };\n        assert!(!fd_set.contains(borrowed_i));\n    }\n\n    let fd_seven = unsafe { BorrowedFd::borrow_raw(7) };\n    fd_set.insert(fd_seven);\n\n    assert!(fd_set.contains(fd_seven));\n}\n\n#[test]\nfn fdset_remove() {\n    let mut fd_set = FdSet::new();\n\n    for i in 0..FD_SETSIZE {\n        let borrowed_i = unsafe { BorrowedFd::borrow_raw(i as RawFd) };\n        assert!(!fd_set.contains(borrowed_i));\n    }\n\n    let fd_seven = unsafe { BorrowedFd::borrow_raw(7) };\n    fd_set.insert(fd_seven);\n    fd_set.remove(fd_seven);\n\n    for i in 0..FD_SETSIZE {\n        let borrowed_i = unsafe { BorrowedFd::borrow_raw(i as RawFd) };\n        assert!(!fd_set.contains(borrowed_i));\n    }\n}\n\n#[test]\n#[allow(non_snake_case)]\nfn fdset_clear() {\n    let mut fd_set = FdSet::new();\n    let fd_one = unsafe { BorrowedFd::borrow_raw(1) };\n    let fd_FD_SETSIZE_divided_by_two =\n        unsafe { BorrowedFd::borrow_raw((FD_SETSIZE / 2) as RawFd) };\n    let fd_FD_SETSIZE_minus_one =\n        unsafe { BorrowedFd::borrow_raw((FD_SETSIZE - 1) as RawFd) };\n    fd_set.insert(fd_one);\n    fd_set.insert(fd_FD_SETSIZE_divided_by_two);\n    fd_set.insert(fd_FD_SETSIZE_minus_one);\n\n    fd_set.clear();\n\n    for i in 0..FD_SETSIZE {\n        let borrowed_i = unsafe { BorrowedFd::borrow_raw(i as RawFd) };\n        assert!(!fd_set.contains(borrowed_i));\n    }\n}\n\n#[test]\nfn fdset_highest() {\n    let mut set = FdSet::new();\n    assert_eq!(\n        set.highest().map(|borrowed_fd| borrowed_fd.as_raw_fd()),\n        None\n    );\n    let fd_zero = unsafe { BorrowedFd::borrow_raw(0) };\n    let fd_ninety = unsafe { BorrowedFd::borrow_raw(90) };\n    set.insert(fd_zero);\n    assert_eq!(\n        set.highest().map(|borrowed_fd| borrowed_fd.as_raw_fd()),\n        Some(0)\n    );\n    set.insert(fd_ninety);\n    assert_eq!(\n        set.highest().map(|borrowed_fd| borrowed_fd.as_raw_fd()),\n        Some(90)\n    );\n    set.remove(fd_zero);\n    assert_eq!(\n        set.highest().map(|borrowed_fd| borrowed_fd.as_raw_fd()),\n        Some(90)\n    );\n    set.remove(fd_ninety);\n    assert_eq!(\n        set.highest().map(|borrowed_fd| borrowed_fd.as_raw_fd()),\n        None\n    );\n\n    let fd_four = unsafe { BorrowedFd::borrow_raw(4) };\n    let fd_five = unsafe { BorrowedFd::borrow_raw(5) };\n    let fd_seven = unsafe { BorrowedFd::borrow_raw(7) };\n    set.insert(fd_four);\n    set.insert(fd_five);\n    set.insert(fd_seven);\n    assert_eq!(\n        set.highest().map(|borrowed_fd| borrowed_fd.as_raw_fd()),\n        Some(7)\n    );\n}\n\n#[test]\nfn fdset_fds() {\n    let mut set = FdSet::new();\n    let fd_zero = unsafe { BorrowedFd::borrow_raw(0) };\n    let fd_ninety = unsafe { BorrowedFd::borrow_raw(90) };\n    assert_eq!(\n        set.fds(None)\n            .map(|borrowed_fd| borrowed_fd.as_raw_fd())\n            .collect::\u003cVec\u003c_\u003e\u003e(),\n        vec![]\n    );\n    set.insert(fd_zero);\n    assert_eq!(\n        set.fds(None)\n            .map(|borrowed_fd| borrowed_fd.as_raw_fd())\n            .collect::\u003cVec\u003c_\u003e\u003e(),\n        vec![0]\n    );\n    set.insert(fd_ninety);\n    assert_eq!(\n        set.fds(None)\n            .map(|borrowed_fd| borrowed_fd.as_raw_fd())\n            .collect::\u003cVec\u003c_\u003e\u003e(),\n        vec![0, 90]\n    );\n\n    // highest limit\n    assert_eq!(\n        set.fds(Some(89))\n            .map(|borrowed_fd| borrowed_fd.as_raw_fd())\n            .collect::\u003cVec\u003c_\u003e\u003e(),\n        vec![0]\n    );\n    assert_eq!(\n        set.fds(Some(90))\n            .map(|borrowed_fd| borrowed_fd.as_raw_fd())\n            .collect::\u003cVec\u003c_\u003e\u003e(),\n        vec![0, 90]\n    );\n}\n\n#[test]\nfn test_select() {\n    let (r1, w1) = pipe().unwrap();\n    let (r2, _w2) = pipe().unwrap();\n\n    write(\u0026w1, b\"hi!\").unwrap();\n    let mut fd_set = FdSet::new();\n    fd_set.insert(r1.as_fd());\n    fd_set.insert(r2.as_fd());\n\n    let mut timeout = TimeVal::seconds(10);\n    assert_eq!(\n        1,\n        select(None, \u0026mut fd_set, None, None, \u0026mut timeout).unwrap()\n    );\n    assert!(fd_set.contains(r1.as_fd()));\n    assert!(!fd_set.contains(r2.as_fd()));\n}\n\n#[test]\nfn test_select_nfds() {\n    let (r1, w1) = pipe().unwrap();\n    let (r2, _w2) = pipe().unwrap();\n\n    write(\u0026w1, b\"hi!\").unwrap();\n    let mut fd_set = FdSet::new();\n    fd_set.insert(r1.as_fd());\n    fd_set.insert(r2.as_fd());\n\n    let mut timeout = TimeVal::seconds(10);\n    {\n        assert_eq!(\n            1,\n            select(\n                Some(\n                    fd_set\n                        .highest()\n                        .map(|borrowed_fd| borrowed_fd.as_raw_fd())\n                        .unwrap()\n                        + 1\n                ),\n                \u0026mut fd_set,\n                None,\n                None,\n                \u0026mut timeout\n            )\n            .unwrap()\n        );\n    }\n    assert!(fd_set.contains(r1.as_fd()));\n    assert!(!fd_set.contains(r2.as_fd()));\n}\n\n#[test]\nfn test_select_nfds2() {\n    let (r1, w1) = pipe().unwrap();\n    write(\u0026w1, b\"hi!\").unwrap();\n    let (r2, _w2) = pipe().unwrap();\n    let mut fd_set = FdSet::new();\n    fd_set.insert(r1.as_fd());\n    fd_set.insert(r2.as_fd());\n\n    let mut timeout = TimeVal::seconds(10);\n    assert_eq!(\n        1,\n        select(\n            std::cmp::max(r1.as_raw_fd(), r2.as_raw_fd()) + 1,\n            \u0026mut fd_set,\n            None,\n            None,\n            \u0026mut timeout\n        )\n        .unwrap()\n    );\n    assert!(fd_set.contains(r1.as_fd()));\n    assert!(!fd_set.contains(r2.as_fd()));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_signal.rs"],"content":"use nix::errno::Errno;\nuse nix::sys::signal::*;\nuse nix::unistd::*;\nuse std::hash::{Hash, Hasher};\nuse std::sync::atomic::{AtomicBool, Ordering};\n#[cfg(not(target_os = \"redox\"))]\nuse std::thread;\n\n#[test]\nfn test_kill_none() {\n    kill(getpid(), None).expect(\"Should be able to send signal to myself.\");\n}\n\n#[test]\n#[cfg(not(target_os = \"fuchsia\"))]\nfn test_killpg_none() {\n    killpg(getpgrp(), None)\n        .expect(\"Should be able to send signal to my process group.\");\n}\n\n#[test]\nfn test_old_sigaction_flags() {\n    let _m = crate::SIGNAL_MTX.lock();\n\n    extern \"C\" fn handler(_: ::libc::c_int) {}\n    let act = SigAction::new(\n        SigHandler::Handler(handler),\n        SaFlags::empty(),\n        SigSet::empty(),\n    );\n    let oact = unsafe { sigaction(SIGINT, \u0026act) }.unwrap();\n    let _flags = oact.flags();\n    let oact = unsafe { sigaction(SIGINT, \u0026act) }.unwrap();\n    let _flags = oact.flags();\n}\n\n#[test]\nfn test_sigprocmask_noop() {\n    sigprocmask(SigmaskHow::SIG_BLOCK, None, None)\n        .expect(\"this should be an effective noop\");\n}\n\n#[test]\nfn test_sigprocmask() {\n    let _m = crate::SIGNAL_MTX.lock();\n\n    // This needs to be a signal that rust doesn't use in the test harness.\n    const SIGNAL: Signal = Signal::SIGCHLD;\n\n    let mut old_signal_set = SigSet::empty();\n    sigprocmask(SigmaskHow::SIG_BLOCK, None, Some(\u0026mut old_signal_set))\n        .expect(\"expect to be able to retrieve old signals\");\n\n    // Make sure the old set doesn't contain the signal, otherwise the following\n    // test don't make sense.\n    assert!(\n        !old_signal_set.contains(SIGNAL),\n        \"the {SIGNAL:?} signal is already blocked, please change to a \\\n             different one\"\n    );\n\n    // Now block the signal.\n    let mut signal_set = SigSet::empty();\n    signal_set.add(SIGNAL);\n    sigprocmask(SigmaskHow::SIG_BLOCK, Some(\u0026signal_set), None)\n        .expect(\"expect to be able to block signals\");\n\n    // And test it again, to make sure the change was effective.\n    old_signal_set.clear();\n    sigprocmask(SigmaskHow::SIG_BLOCK, None, Some(\u0026mut old_signal_set))\n        .expect(\"expect to be able to retrieve old signals\");\n    assert!(\n        old_signal_set.contains(SIGNAL),\n        \"expected the {SIGNAL:?} to be blocked\"\n    );\n\n    // Reset the signal.\n    sigprocmask(SigmaskHow::SIG_UNBLOCK, Some(\u0026signal_set), None)\n        .expect(\"expect to be able to block signals\");\n}\n\nstatic SIGNALED: AtomicBool = AtomicBool::new(false);\n\nextern \"C\" fn test_sigaction_handler(signal: libc::c_int) {\n    let signal = Signal::try_from(signal).unwrap();\n    SIGNALED.store(signal == Signal::SIGINT, Ordering::Relaxed);\n}\n\n#[cfg(not(target_os = \"redox\"))]\nextern \"C\" fn test_sigaction_action(\n    _: libc::c_int,\n    _: *mut libc::siginfo_t,\n    _: *mut libc::c_void,\n) {\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_signal_sigaction() {\n    let _m = crate::SIGNAL_MTX.lock();\n\n    let action_handler = SigHandler::SigAction(test_sigaction_action);\n    assert_eq!(\n        unsafe { signal(Signal::SIGINT, action_handler) }.unwrap_err(),\n        Errno::ENOTSUP\n    );\n}\n\n#[test]\nfn test_signal() {\n    let _m = crate::SIGNAL_MTX.lock();\n\n    unsafe { signal(Signal::SIGINT, SigHandler::SigIgn) }.unwrap();\n    raise(Signal::SIGINT).unwrap();\n    assert_eq!(\n        unsafe { signal(Signal::SIGINT, SigHandler::SigDfl) }.unwrap(),\n        SigHandler::SigIgn\n    );\n\n    let handler = SigHandler::Handler(test_sigaction_handler);\n    assert_eq!(\n        unsafe { signal(Signal::SIGINT, handler) }.unwrap(),\n        SigHandler::SigDfl\n    );\n    raise(Signal::SIGINT).unwrap();\n    assert!(SIGNALED.load(Ordering::Relaxed));\n\n    #[cfg(not(solarish))]\n    assert_eq!(\n        unsafe { signal(Signal::SIGINT, SigHandler::SigDfl) }.unwrap(),\n        handler\n    );\n\n    // System V based OSes (e.g. illumos and Solaris) always resets the\n    // disposition to SIG_DFL prior to calling the signal handler\n    #[cfg(solarish)]\n    assert_eq!(\n        unsafe { signal(Signal::SIGINT, SigHandler::SigDfl) }.unwrap(),\n        SigHandler::SigDfl\n    );\n\n    // Restore default signal handler\n    unsafe { signal(Signal::SIGINT, SigHandler::SigDfl) }.unwrap();\n}\n\n#[test]\nfn test_contains() {\n    let mut mask = SigSet::empty();\n    mask.add(SIGUSR1);\n\n    assert!(mask.contains(SIGUSR1));\n    assert!(!mask.contains(SIGUSR2));\n\n    let all = SigSet::all();\n    assert!(all.contains(SIGUSR1));\n    assert!(all.contains(SIGUSR2));\n}\n\n#[test]\nfn test_clear() {\n    let mut set = SigSet::all();\n    set.clear();\n    for signal in Signal::iterator() {\n        assert!(!set.contains(signal));\n    }\n}\n\n#[test]\nfn test_from_str_round_trips() {\n    for signal in Signal::iterator() {\n        assert_eq!(signal.as_ref().parse::\u003cSignal\u003e().unwrap(), signal);\n        assert_eq!(signal.to_string().parse::\u003cSignal\u003e().unwrap(), signal);\n    }\n}\n\n#[test]\nfn test_from_str_invalid_value() {\n    let errval = Err(Errno::EINVAL);\n    assert_eq!(\"NOSIGNAL\".parse::\u003cSignal\u003e(), errval);\n    assert_eq!(\"kill\".parse::\u003cSignal\u003e(), errval);\n    assert_eq!(\"9\".parse::\u003cSignal\u003e(), errval);\n}\n\n#[test]\nfn test_extend() {\n    let mut one_signal = SigSet::empty();\n    one_signal.add(SIGUSR1);\n\n    let mut two_signals = SigSet::empty();\n    two_signals.add(SIGUSR2);\n    two_signals.extend(\u0026one_signal);\n\n    assert!(two_signals.contains(SIGUSR1));\n    assert!(two_signals.contains(SIGUSR2));\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_thread_signal_set_mask() {\n    thread::spawn(|| {\n        let prev_mask = SigSet::thread_get_mask()\n            .expect(\"Failed to get existing signal mask!\");\n\n        let mut test_mask = prev_mask;\n        test_mask.add(SIGUSR1);\n\n        test_mask.thread_set_mask().expect(\"assertion failed\");\n        let new_mask =\n            SigSet::thread_get_mask().expect(\"Failed to get new mask!\");\n\n        assert!(new_mask.contains(SIGUSR1));\n        assert!(!new_mask.contains(SIGUSR2));\n\n        prev_mask\n            .thread_set_mask()\n            .expect(\"Failed to revert signal mask!\");\n    })\n    .join()\n    .unwrap();\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_thread_signal_block() {\n    thread::spawn(|| {\n        let mut mask = SigSet::empty();\n        mask.add(SIGUSR1);\n\n        mask.thread_block().expect(\"assertion failed\");\n\n        assert!(SigSet::thread_get_mask().unwrap().contains(SIGUSR1));\n    })\n    .join()\n    .unwrap();\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_thread_signal_unblock() {\n    thread::spawn(|| {\n        let mut mask = SigSet::empty();\n        mask.add(SIGUSR1);\n\n        mask.thread_unblock().expect(\"assertion failed\");\n\n        assert!(!SigSet::thread_get_mask().unwrap().contains(SIGUSR1));\n    })\n    .join()\n    .unwrap();\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_thread_signal_swap() {\n    thread::spawn(|| {\n        let mut mask = SigSet::empty();\n        mask.add(SIGUSR1);\n        mask.thread_block().unwrap();\n\n        assert!(SigSet::thread_get_mask().unwrap().contains(SIGUSR1));\n\n        let mut mask2 = SigSet::empty();\n        mask2.add(SIGUSR2);\n\n        let oldmask = mask2.thread_swap_mask(SigmaskHow::SIG_SETMASK).unwrap();\n\n        assert!(oldmask.contains(SIGUSR1));\n        assert!(!oldmask.contains(SIGUSR2));\n\n        assert!(SigSet::thread_get_mask().unwrap().contains(SIGUSR2));\n    })\n    .join()\n    .unwrap();\n}\n\n#[test]\nfn test_from_and_into_iterator() {\n    let sigset = SigSet::from_iter(vec![Signal::SIGUSR1, Signal::SIGUSR2]);\n    let signals = sigset.into_iter().collect::\u003cVec\u003cSignal\u003e\u003e();\n    assert_eq!(signals, [Signal::SIGUSR1, Signal::SIGUSR2]);\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_sigaction() {\n    let _m = crate::SIGNAL_MTX.lock();\n    thread::spawn(|| {\n        extern \"C\" fn test_sigaction_handler(_: libc::c_int) {}\n        extern \"C\" fn test_sigaction_action(\n            _: libc::c_int,\n            _: *mut libc::siginfo_t,\n            _: *mut libc::c_void,\n        ) {\n        }\n\n        let handler_sig = SigHandler::Handler(test_sigaction_handler);\n\n        let flags =\n            SaFlags::SA_ONSTACK | SaFlags::SA_RESTART | SaFlags::SA_SIGINFO;\n\n        let mut mask = SigSet::empty();\n        mask.add(SIGUSR1);\n\n        let action_sig = SigAction::new(handler_sig, flags, mask);\n\n        assert_eq!(\n            action_sig.flags(),\n            SaFlags::SA_ONSTACK | SaFlags::SA_RESTART\n        );\n        assert_eq!(action_sig.handler(), handler_sig);\n\n        mask = action_sig.mask();\n        assert!(mask.contains(SIGUSR1));\n        assert!(!mask.contains(SIGUSR2));\n\n        let handler_act = SigHandler::SigAction(test_sigaction_action);\n        let action_act = SigAction::new(handler_act, flags, mask);\n        assert_eq!(action_act.handler(), handler_act);\n\n        let action_dfl = SigAction::new(SigHandler::SigDfl, flags, mask);\n        assert_eq!(action_dfl.handler(), SigHandler::SigDfl);\n\n        let action_ign = SigAction::new(SigHandler::SigIgn, flags, mask);\n        assert_eq!(action_ign.handler(), SigHandler::SigIgn);\n    })\n    .join()\n    .unwrap();\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_sigwait() {\n    thread::spawn(|| {\n        let mut mask = SigSet::empty();\n        mask.add(SIGUSR1);\n        mask.add(SIGUSR2);\n        mask.thread_block().unwrap();\n\n        raise(SIGUSR1).unwrap();\n        assert_eq!(mask.wait().unwrap(), SIGUSR1);\n    })\n    .join()\n    .unwrap();\n}\n\n#[cfg(any(\n    bsd,\n    linux_android,\n    solarish,\n    target_os = \"haiku\",\n    target_os = \"hurd\",\n    target_os = \"aix\",\n    target_os = \"fuchsia\"\n))]\n#[test]\nfn test_sigsuspend() {\n    // This test change signal handler\n    let _m = crate::SIGNAL_MTX.lock();\n    static SIGNAL_RECIEVED: AtomicBool = AtomicBool::new(false);\n    extern \"C\" fn test_sigsuspend_handler(_: libc::c_int) {\n        assert!(!SIGNAL_RECIEVED.swap(true, Ordering::SeqCst));\n    }\n    thread::spawn(|| {\n        const SIGNAL: Signal = Signal::SIGUSR1;\n\n        // Add signal mask to this thread\n        let mut signal_set = SigSet::empty();\n        signal_set.add(SIGNAL);\n        signal_set.thread_block().unwrap();\n\n        // Set signal handler and save old one.\n        let act = SigAction::new(\n            SigHandler::Handler(test_sigsuspend_handler),\n            SaFlags::empty(),\n            SigSet::empty(),\n        );\n        let old_act = unsafe { sigaction(SIGNAL, \u0026act) }\n            .expect(\"expect to be able to set new action and get old action\");\n\n        raise(SIGNAL).expect(\"expect be able to send signal\");\n        // Now `SIGNAL` was sended but it is blocked.\n        let mut not_wait_set = SigSet::all();\n        not_wait_set.remove(SIGNAL);\n        // signal handler must run in SigSet::suspend()\n        assert!(!SIGNAL_RECIEVED.load(Ordering::SeqCst));\n        not_wait_set.suspend().unwrap();\n        assert!(SIGNAL_RECIEVED.load(Ordering::SeqCst));\n\n        // Restore the signal handler.\n        unsafe { sigaction(SIGNAL, \u0026old_act) }\n            .expect(\"expect to be able to restore old action \");\n    })\n    .join()\n    .unwrap();\n}\n\n#[test]\nfn test_from_sigset_t_unchecked() {\n    let src_set = SigSet::empty();\n    let set = unsafe { SigSet::from_sigset_t_unchecked(*src_set.as_ref()) };\n\n    for signal in Signal::iterator() {\n        assert!(!set.contains(signal));\n    }\n\n    let src_set = SigSet::all();\n    let set = unsafe { SigSet::from_sigset_t_unchecked(*src_set.as_ref()) };\n\n    for signal in Signal::iterator() {\n        assert!(set.contains(signal));\n    }\n}\n\n#[test]\nfn test_eq_empty() {\n    let set0 = SigSet::empty();\n    let set1 = SigSet::empty();\n    assert_eq!(set0, set1);\n}\n\n#[test]\nfn test_eq_all() {\n    let set0 = SigSet::all();\n    let set1 = SigSet::all();\n    assert_eq!(set0, set1);\n}\n\n#[test]\nfn test_hash_empty() {\n    use std::collections::hash_map::DefaultHasher;\n\n    let set0 = SigSet::empty();\n    let mut h0 = DefaultHasher::new();\n    set0.hash(\u0026mut h0);\n\n    let set1 = SigSet::empty();\n    let mut h1 = DefaultHasher::new();\n    set1.hash(\u0026mut h1);\n\n    assert_eq!(h0.finish(), h1.finish());\n}\n\n#[test]\nfn test_hash_all() {\n    use std::collections::hash_map::DefaultHasher;\n\n    let set0 = SigSet::all();\n    let mut h0 = DefaultHasher::new();\n    set0.hash(\u0026mut h0);\n\n    let set1 = SigSet::all();\n    let mut h1 = DefaultHasher::new();\n    set1.hash(\u0026mut h1);\n\n    assert_eq!(h0.finish(), h1.finish());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_signalfd.rs"],"content":"use std::convert::TryFrom;\n\n#[test]\nfn create_signalfd() {\n    use nix::sys::{signal::SigSet, signalfd::SignalFd};\n\n    let mask = SigSet::empty();\n    SignalFd::new(\u0026mask).unwrap();\n}\n\n#[test]\nfn create_signalfd_with_opts() {\n    use nix::sys::{\n        signal::SigSet,\n        signalfd::{SfdFlags, SignalFd},\n    };\n\n    let mask = SigSet::empty();\n    SignalFd::with_flags(\u0026mask, SfdFlags::SFD_CLOEXEC | SfdFlags::SFD_NONBLOCK)\n        .unwrap();\n}\n\n#[test]\nfn read_empty_signalfd() {\n    use nix::sys::{\n        signal::SigSet,\n        signalfd::{SfdFlags, SignalFd},\n    };\n\n    let mask = SigSet::empty();\n    let fd = SignalFd::with_flags(\u0026mask, SfdFlags::SFD_NONBLOCK).unwrap();\n\n    let res = fd.read_signal();\n    assert!(res.unwrap().is_none());\n}\n\n#[test]\nfn test_signalfd() {\n    use nix::sys::signal::{self, raise, SigSet, Signal};\n    use nix::sys::signalfd::SignalFd;\n\n    // Grab the mutex for altering signals so we don't interfere with other tests.\n    let _m = crate::SIGNAL_MTX.lock();\n\n    // Block the SIGUSR1 signal from automatic processing for this thread\n    let mut mask = SigSet::empty();\n    mask.add(signal::SIGUSR1);\n    mask.thread_block().unwrap();\n\n    let fd = SignalFd::new(\u0026mask).unwrap();\n\n    // Send a SIGUSR1 signal to the current process. Note that this uses `raise` instead of `kill`\n    // because `kill` with `getpid` isn't correct during multi-threaded execution like during a\n    // cargo test session. Instead use `raise` which does the correct thing by default.\n    raise(signal::SIGUSR1).expect(\"Error: raise(SIGUSR1) failed\");\n\n    // And now catch that same signal.\n    let res = fd.read_signal().unwrap().unwrap();\n    let signo = Signal::try_from(res.ssi_signo as i32).unwrap();\n    assert_eq!(signo, signal::SIGUSR1);\n}\n\n/// Update the signal mask of an already existing signalfd.\n#[test]\nfn test_signalfd_setmask() {\n    use nix::sys::signal::{self, raise, SigSet, Signal};\n    use nix::sys::signalfd::SignalFd;\n\n    // Grab the mutex for altering signals so we don't interfere with other tests.\n    let _m = crate::SIGNAL_MTX.lock();\n\n    // Block the SIGUSR1 signal from automatic processing for this thread\n    let mut mask = SigSet::empty();\n\n    let fd = SignalFd::new(\u0026mask).unwrap();\n\n    mask.add(signal::SIGUSR1);\n    mask.thread_block().unwrap();\n    fd.set_mask(\u0026mask).unwrap();\n\n    // Send a SIGUSR1 signal to the current process. Note that this uses `raise` instead of `kill`\n    // because `kill` with `getpid` isn't correct during multi-threaded execution like during a\n    // cargo test session. Instead use `raise` which does the correct thing by default.\n    raise(signal::SIGUSR1).expect(\"Error: raise(SIGUSR1) failed\");\n\n    // And now catch that same signal.\n    let res = fd.read_signal().unwrap().unwrap();\n    let signo = Signal::try_from(res.ssi_signo as i32).unwrap();\n    assert_eq!(signo, signal::SIGUSR1);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_socket.rs"],"content":"#[cfg(linux_android)]\nuse crate::*;\nuse libc::c_char;\nuse nix::sys::socket::{getsockname, AddressFamily, UnixAddr};\nuse std::collections::hash_map::DefaultHasher;\nuse std::hash::{Hash, Hasher};\nuse std::net::{SocketAddrV4, SocketAddrV6};\nuse std::os::unix::io::{AsRawFd, RawFd};\nuse std::path::Path;\nuse std::slice;\nuse std::str::FromStr;\n\n#[cfg(target_os = \"linux\")]\n#[cfg_attr(qemu, ignore)]\n#[test]\npub fn test_timestamping() {\n    use nix::sys::socket::{\n        recvmsg, sendmsg, setsockopt, socket, sockopt::Timestamping,\n        ControlMessageOwned, MsgFlags, SockFlag, SockType, SockaddrIn,\n        TimestampingFlag,\n    };\n    use std::io::{IoSlice, IoSliceMut};\n\n    let sock_addr = SockaddrIn::from_str(\"127.0.0.1:6797\").unwrap();\n\n    let ssock = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .expect(\"send socket failed\");\n\n    let rsock = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    nix::sys::socket::bind(rsock.as_raw_fd(), \u0026sock_addr).unwrap();\n\n    setsockopt(\u0026rsock, Timestamping, \u0026TimestampingFlag::all()).unwrap();\n\n    let sbuf = [0u8; 2048];\n    let mut rbuf = [0u8; 2048];\n    let flags = MsgFlags::empty();\n    let iov1 = [IoSlice::new(\u0026sbuf)];\n    let mut iov2 = [IoSliceMut::new(\u0026mut rbuf)];\n\n    let mut cmsg = cmsg_space!(nix::sys::socket::Timestamps);\n    sendmsg(ssock.as_raw_fd(), \u0026iov1, \u0026[], flags, Some(\u0026sock_addr)).unwrap();\n    let recv =\n        recvmsg::\u003c()\u003e(rsock.as_raw_fd(), \u0026mut iov2, Some(\u0026mut cmsg), flags)\n            .unwrap();\n\n    let mut ts = None;\n    for c in recv.cmsgs().unwrap() {\n        if let ControlMessageOwned::ScmTimestampsns(timestamps) = c {\n            ts = Some(timestamps.system);\n        }\n    }\n    let ts = ts.expect(\"ScmTimestampns is present\");\n    let sys_time =\n        ::nix::time::clock_gettime(::nix::time::ClockId::CLOCK_REALTIME)\n            .unwrap();\n    let diff = if ts \u003e sys_time {\n        ts - sys_time\n    } else {\n        sys_time - ts\n    };\n    assert!(std::time::Duration::from(diff).as_secs() \u003c 60);\n}\n\n#[cfg(target_os = \"freebsd\")]\n#[test]\npub fn test_timestamping_realtime() {\n    use nix::sys::socket::{\n        recvmsg, sendmsg, setsockopt, socket, sockopt::ReceiveTimestamp,\n        sockopt::TsClock, ControlMessageOwned, MsgFlags, SockFlag, SockType,\n        SockaddrIn, SocketTimestamp,\n    };\n    use std::io::{IoSlice, IoSliceMut};\n\n    let sock_addr = SockaddrIn::from_str(\"127.0.0.1:6792\").unwrap();\n\n    let ssock = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .expect(\"send socket failed\");\n\n    let rsock = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    nix::sys::socket::bind(rsock.as_raw_fd(), \u0026sock_addr).unwrap();\n\n    setsockopt(\u0026rsock, ReceiveTimestamp, \u0026true).unwrap();\n    setsockopt(\u0026rsock, TsClock, \u0026SocketTimestamp::SO_TS_REALTIME).unwrap();\n\n    let sbuf = [0u8; 2048];\n    let mut rbuf = [0u8; 2048];\n    let flags = MsgFlags::empty();\n    let iov1 = [IoSlice::new(\u0026sbuf)];\n    let mut iov2 = [IoSliceMut::new(\u0026mut rbuf)];\n\n    let mut cmsg = cmsg_space!(nix::sys::time::TimeVal);\n    sendmsg(ssock.as_raw_fd(), \u0026iov1, \u0026[], flags, Some(\u0026sock_addr)).unwrap();\n    let recv =\n        recvmsg::\u003c()\u003e(rsock.as_raw_fd(), \u0026mut iov2, Some(\u0026mut cmsg), flags)\n            .unwrap();\n\n    let mut ts = None;\n    for c in recv.cmsgs().unwrap() {\n        if let ControlMessageOwned::ScmRealtime(timeval) = c {\n            ts = Some(timeval);\n        }\n    }\n    let ts = ts.expect(\"ScmRealtime is present\");\n    let sys_time =\n        ::nix::time::clock_gettime(::nix::time::ClockId::CLOCK_REALTIME)\n            .unwrap();\n    let diff = if ts \u003e sys_time {\n        ts - sys_time\n    } else {\n        sys_time - ts\n    };\n    assert!(std::time::Duration::from(diff).as_secs() \u003c 60);\n}\n\n#[cfg(target_os = \"freebsd\")]\n#[test]\npub fn test_timestamping_monotonic() {\n    use nix::sys::socket::{\n        recvmsg, sendmsg, setsockopt, socket, sockopt::ReceiveTimestamp,\n        sockopt::TsClock, ControlMessageOwned, MsgFlags, SockFlag, SockType,\n        SockaddrIn, SocketTimestamp,\n    };\n    use std::io::{IoSlice, IoSliceMut};\n\n    let sock_addr = SockaddrIn::from_str(\"127.0.0.1:6803\").unwrap();\n\n    let ssock = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .expect(\"send socket failed\");\n\n    let rsock = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    nix::sys::socket::bind(rsock.as_raw_fd(), \u0026sock_addr).unwrap();\n\n    setsockopt(\u0026rsock, ReceiveTimestamp, \u0026true).unwrap();\n    setsockopt(\u0026rsock, TsClock, \u0026SocketTimestamp::SO_TS_MONOTONIC).unwrap();\n\n    let sbuf = [0u8; 2048];\n    let mut rbuf = [0u8; 2048];\n    let flags = MsgFlags::empty();\n    let iov1 = [IoSlice::new(\u0026sbuf)];\n    let mut iov2 = [IoSliceMut::new(\u0026mut rbuf)];\n\n    let mut cmsg = cmsg_space!(nix::sys::time::TimeVal);\n    sendmsg(ssock.as_raw_fd(), \u0026iov1, \u0026[], flags, Some(\u0026sock_addr)).unwrap();\n    let recv =\n        recvmsg::\u003c()\u003e(rsock.as_raw_fd(), \u0026mut iov2, Some(\u0026mut cmsg), flags)\n            .unwrap();\n\n    let mut ts = None;\n    for c in recv.cmsgs().unwrap() {\n        if let ControlMessageOwned::ScmMonotonic(timeval) = c {\n            ts = Some(timeval);\n        }\n    }\n    let ts = ts.expect(\"ScmMonotonic is present\");\n    let sys_time =\n        ::nix::time::clock_gettime(::nix::time::ClockId::CLOCK_MONOTONIC)\n            .unwrap();\n    let diff = sys_time - ts; // Monotonic clock sys_time must be greater\n    assert!(std::time::Duration::from(diff).as_secs() \u003c 60);\n}\n\n#[test]\npub fn test_path_to_sock_addr() {\n    let path = \"/foo/bar\";\n    let actual = Path::new(path);\n    let addr = UnixAddr::new(actual).unwrap();\n\n    let expect: \u0026[c_char] =\n        unsafe { slice::from_raw_parts(path.as_ptr().cast(), path.len()) };\n    assert_eq!(unsafe { \u0026(\u0026(*addr.as_ptr()).sun_path)[..8] }, expect);\n\n    assert_eq!(addr.path(), Some(actual));\n}\n\nfn calculate_hash\u003cT: Hash\u003e(t: \u0026T) -\u003e u64 {\n    let mut s = DefaultHasher::new();\n    t.hash(\u0026mut s);\n    s.finish()\n}\n\n#[test]\npub fn test_addr_equality_path() {\n    let path = \"/foo/bar\";\n    let actual = Path::new(path);\n    let addr1 = UnixAddr::new(actual).unwrap();\n    let mut addr2 = addr1;\n\n    unsafe { (*addr2.as_mut_ptr()).sun_path[10] = 127 };\n\n    assert_eq!(addr1, addr2);\n    assert_eq!(calculate_hash(\u0026addr1), calculate_hash(\u0026addr2));\n}\n\n#[cfg(linux_android)]\n#[test]\npub fn test_abstract_sun_path_too_long() {\n    let name = String::from(\"nix\\0abstract\\0tesnix\\0abstract\\0tesnix\\0abstract\\0tesnix\\0abstract\\0tesnix\\0abstract\\0testttttnix\\0abstract\\0test\\0make\\0sure\\0this\\0is\\0long\\0enough\");\n    let addr = UnixAddr::new_abstract(name.as_bytes());\n    addr.expect_err(\"assertion failed\");\n}\n\n#[cfg(linux_android)]\n#[test]\npub fn test_addr_equality_abstract() {\n    let name = String::from(\"nix\\0abstract\\0test\");\n    let addr1 = UnixAddr::new_abstract(name.as_bytes()).unwrap();\n    let mut addr2 = addr1;\n\n    assert_eq!(addr1, addr2);\n    assert_eq!(calculate_hash(\u0026addr1), calculate_hash(\u0026addr2));\n\n    unsafe { (*addr2.as_mut_ptr()).sun_path[17] = 127 };\n    assert_ne!(addr1, addr2);\n    assert_ne!(calculate_hash(\u0026addr1), calculate_hash(\u0026addr2));\n}\n\n// Test getting/setting abstract addresses (without unix socket creation)\n#[cfg(linux_android)]\n#[test]\npub fn test_abstract_uds_addr() {\n    let empty = String::new();\n    let addr = UnixAddr::new_abstract(empty.as_bytes()).unwrap();\n    let sun_path: [u8; 0] = [];\n    assert_eq!(addr.as_abstract(), Some(\u0026sun_path[..]));\n\n    let name = String::from(\"nix\\0abstract\\0test\");\n    let addr = UnixAddr::new_abstract(name.as_bytes()).unwrap();\n    let sun_path = [\n        110u8, 105, 120, 0, 97, 98, 115, 116, 114, 97, 99, 116, 0, 116, 101,\n        115, 116,\n    ];\n    assert_eq!(addr.as_abstract(), Some(\u0026sun_path[..]));\n    assert_eq!(addr.path(), None);\n\n    // Internally, name is null-prefixed (abstract namespace)\n    assert_eq!(unsafe { (*addr.as_ptr()).sun_path[0] }, 0);\n}\n\n// Test getting an unnamed address (without unix socket creation)\n#[cfg(linux_android)]\n#[test]\npub fn test_unnamed_uds_addr() {\n    use crate::nix::sys::socket::SockaddrLike;\n\n    let addr = UnixAddr::new_unnamed();\n\n    assert!(addr.is_unnamed());\n    assert_eq!(addr.len(), 2);\n    assert!(addr.path().is_none());\n    assert_eq!(addr.path_len(), 0);\n\n    assert!(addr.as_abstract().is_none());\n}\n\n#[test]\npub fn test_getsockname() {\n    use nix::sys::socket::bind;\n    use nix::sys::socket::{socket, AddressFamily, SockFlag, SockType};\n\n    let tempdir = tempfile::tempdir().unwrap();\n    let sockname = tempdir.path().join(\"sock\");\n    let sock = socket(\n        AddressFamily::Unix,\n        SockType::Stream,\n        SockFlag::empty(),\n        None,\n    )\n    .expect(\"socket failed\");\n    let sockaddr = UnixAddr::new(\u0026sockname).unwrap();\n    bind(sock.as_raw_fd(), \u0026sockaddr).expect(\"bind failed\");\n    assert_eq!(\n        sockaddr,\n        getsockname(sock.as_raw_fd()).expect(\"getsockname failed\")\n    );\n}\n\n#[test]\npub fn test_socketpair() {\n    use nix::sys::socket::{socketpair, AddressFamily, SockFlag, SockType};\n    use nix::unistd::{read, write};\n\n    let (fd1, fd2) = socketpair(\n        AddressFamily::Unix,\n        SockType::Stream,\n        None,\n        SockFlag::empty(),\n    )\n    .unwrap();\n    write(\u0026fd1, b\"hello\").unwrap();\n    let mut buf = [0; 5];\n    read(\u0026fd2, \u0026mut buf).unwrap();\n\n    assert_eq!(\u0026buf[..], b\"hello\");\n}\n\n#[test]\n#[cfg_attr(target_os = \"cygwin\", ignore)]\npub fn test_recvmsg_sockaddr_un() {\n    use nix::sys::socket::{\n        self, bind, socket, AddressFamily, MsgFlags, SockFlag, SockType,\n    };\n\n    let tempdir = tempfile::tempdir().unwrap();\n    let sockname = tempdir.path().join(\"sock\");\n    let sock = socket(\n        AddressFamily::Unix,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .expect(\"socket failed\");\n    let sockaddr = UnixAddr::new(\u0026sockname).unwrap();\n    bind(sock.as_raw_fd(), \u0026sockaddr).expect(\"bind failed\");\n\n    // Send a message\n    let send_buffer = \"hello\".as_bytes();\n    if let Err(e) = socket::sendmsg(\n        sock.as_raw_fd(),\n        \u0026[std::io::IoSlice::new(send_buffer)],\n        \u0026[],\n        MsgFlags::empty(),\n        Some(\u0026sockaddr),\n    ) {\n        crate::skip!(\"Couldn't send ({e:?}), so skipping test\");\n    }\n\n    // Receive the message\n    let mut recv_buffer = [0u8; 32];\n    let mut iov = [std::io::IoSliceMut::new(\u0026mut recv_buffer)];\n    let received =\n        socket::recvmsg(sock.as_raw_fd(), \u0026mut iov, None, MsgFlags::empty())\n            .unwrap();\n    // Check the address in the received message\n    assert_eq!(sockaddr, received.address.unwrap());\n}\n\n#[test]\npub fn test_std_conversions() {\n    use nix::sys::socket::*;\n\n    let std_sa = SocketAddrV4::from_str(\"127.0.0.1:6789\").unwrap();\n    let sock_addr = SockaddrIn::from(std_sa);\n    assert_eq!(std_sa, sock_addr.into());\n\n    let std_sa = SocketAddrV6::from_str(\"[::1]:6000\").unwrap();\n    let sock_addr: SockaddrIn6 = SockaddrIn6::from(std_sa);\n    assert_eq!(std_sa, sock_addr.into());\n}\n\nmod recvfrom {\n    use super::*;\n    use nix::sys::socket::*;\n    use nix::{errno::Errno, Result};\n    use std::thread;\n\n    const MSG: \u0026[u8] = b\"Hello, World!\";\n\n    fn sendrecv\u003cFs, Fr\u003e(\n        rsock: RawFd,\n        ssock: RawFd,\n        f_send: Fs,\n        mut f_recv: Fr,\n    ) -\u003e Option\u003cSockaddrStorage\u003e\n    where\n        Fs: Fn(RawFd, \u0026[u8], MsgFlags) -\u003e Result\u003cusize\u003e + Send + 'static,\n        Fr: FnMut(usize, Option\u003cSockaddrStorage\u003e),\n    {\n        let mut buf: [u8; 13] = [0u8; 13];\n        let mut l = 0;\n        let mut from = None;\n\n        let send_thread = thread::spawn(move || {\n            let mut l = 0;\n            while l \u003c std::mem::size_of_val(MSG) {\n                l += f_send(ssock, \u0026MSG[l..], MsgFlags::empty()).unwrap();\n            }\n        });\n\n        while l \u003c std::mem::size_of_val(MSG) {\n            let (len, from_) = recvfrom(rsock, \u0026mut buf[l..]).unwrap();\n            f_recv(len, from_);\n            from = from_;\n            l += len;\n        }\n        assert_eq!(\u0026buf, MSG);\n        send_thread.join().unwrap();\n        from\n    }\n\n    #[test]\n    pub fn stream() {\n        let (fd2, fd1) = socketpair(\n            AddressFamily::Unix,\n            SockType::Stream,\n            None,\n            SockFlag::empty(),\n        )\n        .unwrap();\n        // Ignore from for stream sockets\n        let _ = sendrecv(fd1.as_raw_fd(), fd2.as_raw_fd(), send, |_, _| {});\n    }\n\n    #[test]\n    pub fn udp() {\n        let std_sa = SocketAddrV4::from_str(\"127.0.0.1:6795\").unwrap();\n        let sock_addr = SockaddrIn::from(std_sa);\n        let rsock = socket(\n            AddressFamily::Inet,\n            SockType::Datagram,\n            SockFlag::empty(),\n            None,\n        )\n        .unwrap();\n        bind(rsock.as_raw_fd(), \u0026sock_addr).unwrap();\n        let ssock = socket(\n            AddressFamily::Inet,\n            SockType::Datagram,\n            SockFlag::empty(),\n            None,\n        )\n        .expect(\"send socket failed\");\n        let from = sendrecv(\n            rsock.as_raw_fd(),\n            ssock.as_raw_fd(),\n            move |s, m, flags| sendto(s.as_raw_fd(), m, \u0026sock_addr, flags),\n            |_, _| {},\n        );\n        // UDP sockets should set the from address\n        assert_eq!(AddressFamily::Inet, from.unwrap().family().unwrap());\n    }\n\n    #[cfg(target_os = \"linux\")]\n    mod udp_offload {\n        use super::*;\n        use nix::sys::socket::sockopt::{UdpGroSegment, UdpGsoSegment};\n        use std::io::IoSlice;\n\n        #[test]\n        // Disable the test under emulation because it fails in Cirrus-CI.  Lack\n        // of QEMU support is suspected.\n        #[cfg_attr(qemu, ignore)]\n        pub fn gso() {\n            require_kernel_version!(udp_offload::gso, \"\u003e= 4.18\");\n\n            // In this test, we send the data and provide a GSO segment size.\n            // Since we are sending the buffer of size 13, six UDP packets\n            // with size 2 and two UDP packet with size 1 will be sent.\n            let segment_size: u16 = 2;\n\n            let sock_addr = SockaddrIn::new(127, 0, 0, 1, 6791);\n            let rsock = socket(\n                AddressFamily::Inet,\n                SockType::Datagram,\n                SockFlag::empty(),\n                None,\n            )\n            .unwrap();\n\n            setsockopt(\u0026rsock, UdpGsoSegment, \u0026(segment_size as _))\n                .expect(\"setsockopt UDP_SEGMENT failed\");\n\n            bind(rsock.as_raw_fd(), \u0026sock_addr).unwrap();\n            let ssock = socket(\n                AddressFamily::Inet,\n                SockType::Datagram,\n                SockFlag::empty(),\n                None,\n            )\n            .expect(\"send socket failed\");\n\n            let mut num_packets_received: i32 = 0;\n\n            sendrecv(\n                rsock.as_raw_fd(),\n                ssock.as_raw_fd(),\n                move |s, m, flags| {\n                    let iov = [IoSlice::new(m)];\n                    let cmsg = ControlMessage::UdpGsoSegments(\u0026segment_size);\n                    sendmsg(\n                        s.as_raw_fd(),\n                        \u0026iov,\n                        \u0026[cmsg],\n                        flags,\n                        Some(\u0026sock_addr),\n                    )\n                },\n                {\n                    let num_packets_received_ref = \u0026mut num_packets_received;\n\n                    move |len, _| {\n                        // check that we receive UDP packets with payload size\n                        // less or equal to segment size\n                        assert!(len \u003c= segment_size as usize);\n                        *num_packets_received_ref += 1;\n                    }\n                },\n            );\n\n            // Buffer size is 13, we will receive six packets of size 2,\n            // and one packet of size 1.\n            assert_eq!(7, num_packets_received);\n        }\n\n        #[test]\n        // Disable the test on emulated platforms because it fails in Cirrus-CI.\n        // Lack of QEMU support is suspected.\n        #[cfg_attr(qemu, ignore)]\n        pub fn gro() {\n            require_kernel_version!(udp_offload::gro, \"\u003e= 5.3\");\n\n            // It's hard to guarantee receiving GRO packets. Just checking\n            // that `setsockopt` doesn't fail with error\n\n            let rsock = socket(\n                AddressFamily::Inet,\n                SockType::Datagram,\n                SockFlag::empty(),\n                None,\n            )\n            .unwrap();\n\n            setsockopt(\u0026rsock, UdpGroSegment, \u0026true)\n                .expect(\"setsockopt UDP_GRO failed\");\n        }\n    }\n\n    #[cfg(any(linux_android, target_os = \"freebsd\", target_os = \"netbsd\"))]\n    #[test]\n    pub fn udp_sendmmsg() {\n        use std::io::IoSlice;\n\n        let std_sa = SocketAddrV4::from_str(\"127.0.0.1:6793\").unwrap();\n        let std_sa2 = SocketAddrV4::from_str(\"127.0.0.1:6794\").unwrap();\n        let sock_addr = SockaddrIn::from(std_sa);\n        let sock_addr2 = SockaddrIn::from(std_sa2);\n\n        let rsock = socket(\n            AddressFamily::Inet,\n            SockType::Datagram,\n            SockFlag::empty(),\n            None,\n        )\n        .unwrap();\n        bind(rsock.as_raw_fd(), \u0026sock_addr).unwrap();\n        let ssock = socket(\n            AddressFamily::Inet,\n            SockType::Datagram,\n            SockFlag::empty(),\n            None,\n        )\n        .expect(\"send socket failed\");\n\n        let from = sendrecv(\n            rsock.as_raw_fd(),\n            ssock.as_raw_fd(),\n            move |s, m, flags| {\n                let batch_size = 15;\n                let mut iovs = Vec::with_capacity(1 + batch_size);\n                let mut addrs = Vec::with_capacity(1 + batch_size);\n                let mut data = MultiHeaders::preallocate(1 + batch_size, None);\n                let iov = IoSlice::new(m);\n                // first chunk:\n                iovs.push([iov]);\n                addrs.push(Some(sock_addr));\n\n                for _ in 0..batch_size {\n                    iovs.push([iov]);\n                    addrs.push(Some(sock_addr2));\n                }\n\n                let res = sendmmsg(s, \u0026mut data, \u0026iovs, addrs, [], flags)?;\n                let mut sent_messages = 0;\n                let mut sent_bytes = 0;\n                for item in res {\n                    sent_messages += 1;\n                    sent_bytes += item.bytes;\n                }\n                //\n                assert_eq!(sent_messages, iovs.len());\n                assert_eq!(sent_bytes, sent_messages * m.len());\n                Ok(sent_messages)\n            },\n            |_, _| {},\n        );\n        // UDP sockets should set the from address\n        assert_eq!(AddressFamily::Inet, from.unwrap().family().unwrap());\n    }\n\n    #[cfg(any(linux_android, target_os = \"freebsd\", target_os = \"netbsd\"))]\n    #[test]\n    pub fn udp_recvmmsg() {\n        use nix::sys::socket::{recvmmsg, MsgFlags};\n        use std::io::IoSliceMut;\n\n        const NUM_MESSAGES_SENT: usize = 2;\n        const DATA: [u8; 2] = [1, 2];\n\n        let inet_addr = SocketAddrV4::from_str(\"127.0.0.1:6798\").unwrap();\n        let sock_addr = SockaddrIn::from(inet_addr);\n\n        let rsock = socket(\n            AddressFamily::Inet,\n            SockType::Datagram,\n            SockFlag::empty(),\n            None,\n        )\n        .unwrap();\n        bind(rsock.as_raw_fd(), \u0026sock_addr).unwrap();\n        let ssock = socket(\n            AddressFamily::Inet,\n            SockType::Datagram,\n            SockFlag::empty(),\n            None,\n        )\n        .expect(\"send socket failed\");\n\n        let send_thread = thread::spawn(move || {\n            for _ in 0..NUM_MESSAGES_SENT {\n                sendto(\n                    ssock.as_raw_fd(),\n                    \u0026DATA[..],\n                    \u0026sock_addr,\n                    MsgFlags::empty(),\n                )\n                .unwrap();\n            }\n        });\n\n        let mut msgs = std::collections::LinkedList::new();\n\n        // Buffers to receive exactly `NUM_MESSAGES_SENT` messages\n        let mut receive_buffers = [[0u8; 32]; NUM_MESSAGES_SENT];\n        msgs.extend(\n            receive_buffers\n                .iter_mut()\n                .map(|buf| [IoSliceMut::new(\u0026mut buf[..])]),\n        );\n\n        let mut data =\n            MultiHeaders::\u003cSockaddrIn\u003e::preallocate(msgs.len(), None);\n\n        let res: Vec\u003cRecvMsg\u003cSockaddrIn\u003e\u003e = recvmmsg(\n            rsock.as_raw_fd(),\n            \u0026mut data,\n            msgs.iter_mut(),\n            MsgFlags::empty(),\n            None,\n        )\n        .expect(\"recvmmsg\")\n        .collect();\n        assert_eq!(res.len(), DATA.len());\n\n        for RecvMsg { address, bytes, .. } in res.into_iter() {\n            assert_eq!(AddressFamily::Inet, address.unwrap().family().unwrap());\n            assert_eq!(DATA.len(), bytes);\n        }\n\n        for buf in \u0026receive_buffers {\n            assert_eq!(\u0026buf[..DATA.len()], DATA);\n        }\n\n        send_thread.join().unwrap();\n    }\n\n    #[cfg(any(linux_android, target_os = \"freebsd\", target_os = \"netbsd\"))]\n    #[test]\n    pub fn udp_recvmmsg_dontwait_short_read() {\n        use nix::sys::socket::{recvmmsg, MsgFlags};\n        use std::io::IoSliceMut;\n\n        const NUM_MESSAGES_SENT: usize = 2;\n        const DATA: [u8; 4] = [1, 2, 3, 4];\n\n        let inet_addr = SocketAddrV4::from_str(\"127.0.0.1:6799\").unwrap();\n        let sock_addr = SockaddrIn::from(inet_addr);\n\n        let rsock = socket(\n            AddressFamily::Inet,\n            SockType::Datagram,\n            SockFlag::empty(),\n            None,\n        )\n        .unwrap();\n        bind(rsock.as_raw_fd(), \u0026sock_addr).unwrap();\n        let ssock = socket(\n            AddressFamily::Inet,\n            SockType::Datagram,\n            SockFlag::empty(),\n            None,\n        )\n        .expect(\"send socket failed\");\n\n        let send_thread = thread::spawn(move || {\n            for _ in 0..NUM_MESSAGES_SENT {\n                sendto(\n                    ssock.as_raw_fd(),\n                    \u0026DATA[..],\n                    \u0026sock_addr,\n                    MsgFlags::empty(),\n                )\n                .unwrap();\n            }\n        });\n        // Ensure we've sent all the messages before continuing so `recvmmsg`\n        // will return right away\n        send_thread.join().unwrap();\n\n        let mut msgs = std::collections::LinkedList::new();\n\n        // Buffers to receive \u003e`NUM_MESSAGES_SENT` messages to ensure `recvmmsg`\n        // will return when there are fewer than requested messages in the\n        // kernel buffers when using `MSG_DONTWAIT`.\n        let mut receive_buffers = [[0u8; 32]; NUM_MESSAGES_SENT + 2];\n        msgs.extend(\n            receive_buffers\n                .iter_mut()\n                .map(|buf| [IoSliceMut::new(\u0026mut buf[..])]),\n        );\n\n        let mut data = MultiHeaders::\u003cSockaddrIn\u003e::preallocate(\n            NUM_MESSAGES_SENT + 2,\n            None,\n        );\n\n        let res: Vec\u003cRecvMsg\u003cSockaddrIn\u003e\u003e = recvmmsg(\n            rsock.as_raw_fd(),\n            \u0026mut data,\n            msgs.iter_mut(),\n            MsgFlags::MSG_DONTWAIT,\n            None,\n        )\n        .expect(\"recvmmsg\")\n        .collect();\n        assert_eq!(res.len(), NUM_MESSAGES_SENT);\n\n        for RecvMsg { address, bytes, .. } in res.into_iter() {\n            assert_eq!(AddressFamily::Inet, address.unwrap().family().unwrap());\n            assert_eq!(DATA.len(), bytes);\n        }\n\n        for buf in \u0026receive_buffers[..NUM_MESSAGES_SENT] {\n            assert_eq!(\u0026buf[..DATA.len()], DATA);\n        }\n    }\n\n    #[test]\n    pub fn udp_inet6() {\n        let addr = std::net::Ipv6Addr::from_str(\"::1\").unwrap();\n        let rport = 6796;\n        let rstd_sa = SocketAddrV6::new(addr, rport, 0, 0);\n        let raddr = SockaddrIn6::from(rstd_sa);\n        let sport = 6798;\n        let sstd_sa = SocketAddrV6::new(addr, sport, 0, 0);\n        let saddr = SockaddrIn6::from(sstd_sa);\n        let rsock = socket(\n            AddressFamily::Inet6,\n            SockType::Datagram,\n            SockFlag::empty(),\n            None,\n        )\n        .expect(\"receive socket failed\");\n        match bind(rsock.as_raw_fd(), \u0026raddr) {\n            Err(Errno::EADDRNOTAVAIL) =\u003e {\n                println!(\"IPv6 not available, skipping test.\");\n                return;\n            }\n            Err(e) =\u003e panic!(\"bind: {e}\"),\n            Ok(()) =\u003e (),\n        }\n        let ssock = socket(\n            AddressFamily::Inet6,\n            SockType::Datagram,\n            SockFlag::empty(),\n            None,\n        )\n        .expect(\"send socket failed\");\n        bind(ssock.as_raw_fd(), \u0026saddr).unwrap();\n        let from = sendrecv(\n            rsock.as_raw_fd(),\n            ssock.as_raw_fd(),\n            move |s, m, flags| sendto(s.as_raw_fd(), m, \u0026raddr, flags),\n            |_, _| {},\n        );\n        assert_eq!(AddressFamily::Inet6, from.unwrap().family().unwrap());\n        let osent_addr = from.unwrap();\n        let sent_addr = osent_addr.as_sockaddr_in6().unwrap();\n        assert_eq!(sent_addr.ip(), addr);\n        assert_eq!(sent_addr.port(), sport);\n    }\n}\n\n// Test error handling of our recvmsg wrapper\n#[test]\npub fn test_recvmsg_ebadf() {\n    use nix::errno::Errno;\n    use nix::sys::socket::{recvmsg, MsgFlags};\n    use std::io::IoSliceMut;\n\n    let mut buf = [0u8; 5];\n    let mut iov = [IoSliceMut::new(\u0026mut buf[..])];\n\n    let fd = -1; // Bad file descriptor\n    let r = recvmsg::\u003c()\u003e(fd.as_raw_fd(), \u0026mut iov, None, MsgFlags::empty());\n\n    assert_eq!(r.err().unwrap(), Errno::EBADF);\n}\n\n// Disable the test on emulated platforms due to a bug in QEMU versions \u003c\n// 2.12.0.  https://bugs.launchpad.net/qemu/+bug/1701808\n#[cfg_attr(qemu, ignore)]\n#[test]\n#[cfg_attr(target_os = \"cygwin\", ignore)]\npub fn test_scm_rights() {\n    use nix::sys::socket::{\n        recvmsg, sendmsg, socketpair, AddressFamily, ControlMessage,\n        ControlMessageOwned, MsgFlags, SockFlag, SockType,\n    };\n    use nix::unistd::{close, pipe, read, write};\n    use std::io::{IoSlice, IoSliceMut};\n\n    let (fd1, fd2) = socketpair(\n        AddressFamily::Unix,\n        SockType::Stream,\n        None,\n        SockFlag::empty(),\n    )\n    .unwrap();\n    let (r, w) = pipe().unwrap();\n    let mut received_r: Option\u003cRawFd\u003e = None;\n\n    {\n        let iov = [IoSlice::new(b\"hello\")];\n        let fds = [r.as_raw_fd()];\n        let cmsg = ControlMessage::ScmRights(\u0026fds);\n        assert_eq!(\n            sendmsg::\u003c()\u003e(\n                fd1.as_raw_fd(),\n                \u0026iov,\n                \u0026[cmsg],\n                MsgFlags::empty(),\n                None\n            )\n            .unwrap(),\n            5\n        );\n    }\n\n    {\n        let mut buf = [0u8; 5];\n\n        let mut iov = [IoSliceMut::new(\u0026mut buf[..])];\n        let mut cmsgspace = cmsg_space!([RawFd; 1]);\n        let msg = recvmsg::\u003c()\u003e(\n            fd2.as_raw_fd(),\n            \u0026mut iov,\n            Some(\u0026mut cmsgspace),\n            MsgFlags::empty(),\n        )\n        .unwrap();\n\n        for cmsg in msg.cmsgs().unwrap() {\n            if let ControlMessageOwned::ScmRights(fd) = cmsg {\n                assert_eq!(received_r, None);\n                assert_eq!(fd.len(), 1);\n                received_r = Some(fd[0]);\n            } else {\n                panic!(\"unexpected cmsg\");\n            }\n        }\n        assert_eq!(msg.bytes, 5);\n        assert!(!msg\n            .flags\n            .intersects(MsgFlags::MSG_TRUNC | MsgFlags::MSG_CTRUNC));\n    }\n\n    let received_r = received_r.expect(\"Did not receive passed fd\");\n    // Ensure that the received file descriptor works\n    write(\u0026w, b\"world\").unwrap();\n    let mut buf = [0u8; 5];\n    // SAFETY:\n    // should be safe since we don't use it after close\n    let borrowed_received_r =\n        unsafe { std::os::fd::BorrowedFd::borrow_raw(received_r) };\n    read(borrowed_received_r, \u0026mut buf).unwrap();\n    assert_eq!(\u0026buf[..], b\"world\");\n    close(received_r).unwrap();\n}\n\n// 1. Disable the test on emulated platforms due to not enabled support of\n//    AF_ALG in QEMU from rust cross\n// 2. Disable the test on aarch64/Linux CI because bind() fails with ENOENT\n//    https://github.com/nix-rust/nix/issues/1352\n#[cfg(linux_android)]\n#[cfg_attr(\n    any(qemu, all(target_os = \"linux\", target_arch = \"aarch64\")),\n    ignore\n)]\n#[test]\npub fn test_af_alg_cipher() {\n    use nix::sys::socket::sockopt::AlgSetKey;\n    use nix::sys::socket::{\n        accept, bind, sendmsg, setsockopt, socket, AddressFamily, AlgAddr,\n        ControlMessage, MsgFlags, SockFlag, SockType,\n    };\n    use nix::unistd::read;\n    use std::io::IoSlice;\n\n    let alg_type = \"skcipher\";\n    let alg_name = \"ctr-aes-aesni\";\n    // 256-bits secret key\n    let key = vec![0u8; 32];\n    // 16-bytes IV\n    let iv_len = 16;\n    let iv = vec![1u8; iv_len];\n    // 256-bytes plain payload\n    let payload_len = 256;\n    let payload = vec![2u8; payload_len];\n\n    let sock = socket(\n        AddressFamily::Alg,\n        SockType::SeqPacket,\n        SockFlag::empty(),\n        None,\n    )\n    .expect(\"socket failed\");\n\n    let sockaddr = AlgAddr::new(alg_type, alg_name);\n    bind(sock.as_raw_fd(), \u0026sockaddr).expect(\"bind failed\");\n\n    assert_eq!(sockaddr.alg_name().to_string_lossy(), alg_name);\n    assert_eq!(sockaddr.alg_type().to_string_lossy(), alg_type);\n\n    setsockopt(\u0026sock, AlgSetKey::default(), \u0026key).expect(\"setsockopt\");\n    let session_socket = accept(sock.as_raw_fd()).expect(\"accept failed\");\n\n    let msgs = [\n        ControlMessage::AlgSetOp(\u0026libc::ALG_OP_ENCRYPT),\n        ControlMessage::AlgSetIv(iv.as_slice()),\n    ];\n    let iov = IoSlice::new(\u0026payload);\n    sendmsg::\u003c()\u003e(\n        session_socket.as_raw_fd(),\n        \u0026[iov],\n        \u0026msgs,\n        MsgFlags::empty(),\n        None,\n    )\n    .expect(\"sendmsg encrypt\");\n\n    // allocate buffer for encrypted data\n    let mut encrypted = vec![0u8; payload_len];\n    // SAFETY:\n    // should be safe since session_socket won't be closed before the use of this borrowed one\n    let borrowed_session_socket =\n        unsafe { std::os::fd::BorrowedFd::borrow_raw(session_socket) };\n    let num_bytes =\n        read(borrowed_session_socket, \u0026mut encrypted).expect(\"read encrypt\");\n    assert_eq!(num_bytes, payload_len);\n\n    let iov = IoSlice::new(\u0026encrypted);\n\n    let iv = vec![1u8; iv_len];\n\n    let msgs = [\n        ControlMessage::AlgSetOp(\u0026libc::ALG_OP_DECRYPT),\n        ControlMessage::AlgSetIv(iv.as_slice()),\n    ];\n    sendmsg::\u003c()\u003e(\n        session_socket.as_raw_fd(),\n        \u0026[iov],\n        \u0026msgs,\n        MsgFlags::empty(),\n        None,\n    )\n    .expect(\"sendmsg decrypt\");\n\n    // allocate buffer for decrypted data\n    let mut decrypted = vec![0u8; payload_len];\n    // SAFETY:\n    // should be safe since session_socket won't be closed before the use of this borrowed one\n    let borrowed_session_socket =\n        unsafe { std::os::fd::BorrowedFd::borrow_raw(session_socket) };\n    let num_bytes =\n        read(borrowed_session_socket, \u0026mut decrypted).expect(\"read decrypt\");\n\n    assert_eq!(num_bytes, payload_len);\n    assert_eq!(decrypted, payload);\n}\n\n// Disable the test on emulated platforms due to not enabled support of AF_ALG\n// in QEMU from rust cross\n#[cfg(linux_android)]\n#[cfg_attr(qemu, ignore)]\n#[test]\npub fn test_af_alg_aead() {\n    use libc::{ALG_OP_DECRYPT, ALG_OP_ENCRYPT};\n    use nix::fcntl::{fcntl, FcntlArg, OFlag};\n    use nix::sys::socket::sockopt::{AlgSetAeadAuthSize, AlgSetKey};\n    use nix::sys::socket::{\n        accept, bind, sendmsg, setsockopt, socket, AddressFamily, AlgAddr,\n        ControlMessage, MsgFlags, SockFlag, SockType,\n    };\n    use nix::unistd::read;\n    use std::io::IoSlice;\n\n    skip_if_cirrus!(\"Fails for an unknown reason Cirrus CI.  Bug #1352\");\n    // Travis's seccomp profile blocks AF_ALG\n    // https://docs.docker.com/engine/security/seccomp/\n    skip_if_seccomp!(test_af_alg_aead);\n\n    let auth_size = 4usize;\n    let assoc_size = 16u32;\n\n    let alg_type = \"aead\";\n    let alg_name = \"gcm(aes)\";\n    // 256-bits secret key\n    let key = vec![0u8; 32];\n    // 12-bytes IV\n    let iv_len = 12;\n    let iv = vec![1u8; iv_len];\n    // 256-bytes plain payload\n    let payload_len = 256;\n    let mut payload =\n        vec![2u8; payload_len + (assoc_size as usize) + auth_size];\n\n    for i in 0..assoc_size {\n        payload[i as usize] = 10;\n    }\n\n    let len = payload.len();\n\n    for i in 0..auth_size {\n        payload[len - 1 - i] = 0;\n    }\n\n    let sock = socket(\n        AddressFamily::Alg,\n        SockType::SeqPacket,\n        SockFlag::empty(),\n        None,\n    )\n    .expect(\"socket failed\");\n\n    let sockaddr = AlgAddr::new(alg_type, alg_name);\n    bind(sock.as_raw_fd(), \u0026sockaddr).expect(\"bind failed\");\n\n    setsockopt(\u0026sock, AlgSetAeadAuthSize, \u0026auth_size)\n        .expect(\"setsockopt AlgSetAeadAuthSize\");\n    setsockopt(\u0026sock, AlgSetKey::default(), \u0026key)\n        .expect(\"setsockopt AlgSetKey\");\n    let session_socket = accept(sock.as_raw_fd()).expect(\"accept failed\");\n\n    let msgs = [\n        ControlMessage::AlgSetOp(\u0026ALG_OP_ENCRYPT),\n        ControlMessage::AlgSetIv(iv.as_slice()),\n        ControlMessage::AlgSetAeadAssoclen(\u0026assoc_size),\n    ];\n\n    let iov = IoSlice::new(\u0026payload);\n    sendmsg::\u003c()\u003e(\n        session_socket.as_raw_fd(),\n        \u0026[iov],\n        \u0026msgs,\n        MsgFlags::empty(),\n        None,\n    )\n    .expect(\"sendmsg encrypt\");\n\n    // allocate buffer for encrypted data\n    let mut encrypted =\n        vec![0u8; (assoc_size as usize) + payload_len + auth_size];\n    // SAFETY:\n    // should be safe since session_socket won't be closed before the use of this borrowed one\n    let borrowed_session_socket =\n        unsafe { std::os::fd::BorrowedFd::borrow_raw(session_socket) };\n    let num_bytes =\n        read(borrowed_session_socket, \u0026mut encrypted).expect(\"read encrypt\");\n    assert_eq!(num_bytes, payload_len + auth_size + (assoc_size as usize));\n\n    for i in 0..assoc_size {\n        encrypted[i as usize] = 10;\n    }\n\n    let iov = IoSlice::new(\u0026encrypted);\n\n    let iv = vec![1u8; iv_len];\n\n    let session_socket = accept(sock.as_raw_fd()).expect(\"accept failed\");\n\n    let msgs = [\n        ControlMessage::AlgSetOp(\u0026ALG_OP_DECRYPT),\n        ControlMessage::AlgSetIv(iv.as_slice()),\n        ControlMessage::AlgSetAeadAssoclen(\u0026assoc_size),\n    ];\n    sendmsg::\u003c()\u003e(\n        session_socket.as_raw_fd(),\n        \u0026[iov],\n        \u0026msgs,\n        MsgFlags::empty(),\n        None,\n    )\n    .expect(\"sendmsg decrypt\");\n\n    // allocate buffer for decrypted data\n    let mut decrypted =\n        vec![0u8; payload_len + (assoc_size as usize) + auth_size];\n    // Starting with kernel 4.9, the interface changed slightly such that the\n    // authentication tag memory is only needed in the output buffer for encryption\n    // and in the input buffer for decryption.\n    // Do not block on read, as we may have fewer bytes than buffer size\n\n    // SAFETY:\n    //\n    // `session_socket` will be valid for the lifetime of this test\n    // TODO: remove this workaround when accept(2) becomes I/O-safe.\n    let borrowed_fd =\n        unsafe { std::os::fd::BorrowedFd::borrow_raw(session_socket) };\n    fcntl(borrowed_fd, FcntlArg::F_SETFL(OFlag::O_NONBLOCK))\n        .expect(\"fcntl non_blocking\");\n    let num_bytes = read(borrowed_fd, \u0026mut decrypted).expect(\"read decrypt\");\n\n    assert!(num_bytes \u003e= payload_len + (assoc_size as usize));\n    assert_eq!(\n        decrypted[(assoc_size as usize)..(payload_len + (assoc_size as usize))],\n        payload[(assoc_size as usize)..payload_len + (assoc_size as usize)]\n    );\n}\n\n// Verify `ControlMessage::Ipv4PacketInfo` for `sendmsg`.\n// This creates a (udp) socket bound to localhost, then sends a message to\n// itself but uses Ipv4PacketInfo to force the source address to be localhost.\n//\n// This would be a more interesting test if we could assume that the test host\n// has more than one IP address (since we could select a different address to\n// test from).\n#[cfg(any(target_os = \"linux\", apple_targets, target_os = \"netbsd\"))]\n#[test]\npub fn test_sendmsg_ipv4packetinfo() {\n    use cfg_if::cfg_if;\n    use nix::sys::socket::{\n        bind, sendmsg, socket, AddressFamily, ControlMessage, MsgFlags,\n        SockFlag, SockType, SockaddrIn,\n    };\n    use std::io::IoSlice;\n\n    let sock = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .expect(\"socket failed\");\n\n    let sock_addr = SockaddrIn::new(127, 0, 0, 1, 4000);\n\n    bind(sock.as_raw_fd(), \u0026sock_addr).expect(\"bind failed\");\n\n    let slice = [1u8, 2, 3, 4, 5, 6, 7, 8];\n    let iov = [IoSlice::new(\u0026slice)];\n\n    cfg_if! {\n        if #[cfg(target_os = \"netbsd\")] {\n            let pi = libc::in_pktinfo {\n                ipi_ifindex: 0, /* Unspecified interface */\n                ipi_addr: libc::in_addr { s_addr: 0 },\n            };\n        } else {\n            let pi = libc::in_pktinfo {\n                ipi_ifindex: 0, /* Unspecified interface */\n                ipi_addr: libc::in_addr { s_addr: 0 },\n                ipi_spec_dst: sock_addr.as_ref().sin_addr,\n            };\n        }\n    }\n\n    let cmsg = [ControlMessage::Ipv4PacketInfo(\u0026pi)];\n\n    sendmsg(\n        sock.as_raw_fd(),\n        \u0026iov,\n        \u0026cmsg,\n        MsgFlags::empty(),\n        Some(\u0026sock_addr),\n    )\n    .expect(\"sendmsg\");\n}\n\n// Verify `ControlMessage::Ipv6PacketInfo` for `sendmsg`.\n// This creates a (udp) socket bound to ip6-localhost, then sends a message to\n// itself but uses Ipv6PacketInfo to force the source address to be\n// ip6-localhost.\n//\n// This would be a more interesting test if we could assume that the test host\n// has more than one IP address (since we could select a different address to\n// test from).\n#[cfg(any(\n    target_os = \"linux\",\n    apple_targets,\n    target_os = \"netbsd\",\n    target_os = \"freebsd\"\n))]\n#[test]\npub fn test_sendmsg_ipv6packetinfo() {\n    use nix::errno::Errno;\n    use nix::sys::socket::{\n        bind, sendmsg, socket, AddressFamily, ControlMessage, MsgFlags,\n        SockFlag, SockType, SockaddrIn6,\n    };\n    use std::io::IoSlice;\n\n    let sock = socket(\n        AddressFamily::Inet6,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .expect(\"socket failed\");\n\n    let std_sa = SocketAddrV6::from_str(\"[::1]:6000\").unwrap();\n    let sock_addr: SockaddrIn6 = SockaddrIn6::from(std_sa);\n\n    if let Err(Errno::EADDRNOTAVAIL) = bind(sock.as_raw_fd(), \u0026sock_addr) {\n        println!(\"IPv6 not available, skipping test.\");\n        return;\n    }\n\n    let slice = [1u8, 2, 3, 4, 5, 6, 7, 8];\n    let iov = [IoSlice::new(\u0026slice)];\n\n    let pi = libc::in6_pktinfo {\n        ipi6_ifindex: 0, /* Unspecified interface */\n        ipi6_addr: sock_addr.as_ref().sin6_addr,\n    };\n\n    let cmsg = [ControlMessage::Ipv6PacketInfo(\u0026pi)];\n\n    sendmsg::\u003cSockaddrIn6\u003e(\n        sock.as_raw_fd(),\n        \u0026iov,\n        \u0026cmsg,\n        MsgFlags::empty(),\n        Some(\u0026sock_addr),\n    )\n    .expect(\"sendmsg\");\n}\n\n// Verify that ControlMessage::Ipv4SendSrcAddr works for sendmsg. This\n// creates a UDP socket bound to all local interfaces (0.0.0.0). It then\n// sends message to itself at 127.0.0.1 while explicitly specifying\n// 127.0.0.1 as the source address through an Ipv4SendSrcAddr\n// (IP_SENDSRCADDR) control message.\n//\n// Note that binding to 0.0.0.0 is *required* on FreeBSD; sendmsg\n// returns EINVAL otherwise. (See FreeBSD's ip(4) man page.)\n#[cfg(any(freebsdlike, netbsdlike))]\n#[test]\npub fn test_sendmsg_ipv4sendsrcaddr() {\n    use nix::sys::socket::{\n        bind, sendmsg, socket, AddressFamily, ControlMessage, MsgFlags,\n        SockFlag, SockType, SockaddrIn,\n    };\n    use std::io::IoSlice;\n\n    let sock = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .expect(\"socket failed\");\n\n    let unspec_sock_addr = SockaddrIn::new(0, 0, 0, 0, 0);\n    bind(sock.as_raw_fd(), \u0026unspec_sock_addr).expect(\"bind failed\");\n    let bound_sock_addr: SockaddrIn = getsockname(sock.as_raw_fd()).unwrap();\n    let localhost_sock_addr: SockaddrIn =\n        SockaddrIn::new(127, 0, 0, 1, bound_sock_addr.port());\n\n    let slice = [1u8, 2, 3, 4, 5, 6, 7, 8];\n    let iov = [IoSlice::new(\u0026slice)];\n    let cmsg = [ControlMessage::Ipv4SendSrcAddr(\n        \u0026localhost_sock_addr.as_ref().sin_addr,\n    )];\n\n    sendmsg(\n        sock.as_raw_fd(),\n        \u0026iov,\n        \u0026cmsg,\n        MsgFlags::empty(),\n        Some(\u0026localhost_sock_addr),\n    )\n    .expect(\"sendmsg\");\n}\n\n/// Tests that passing multiple fds using a single `ControlMessage` works.\n// Disable the test on emulated platforms due to a bug in QEMU versions \u003c\n// 2.12.0.  https://bugs.launchpad.net/qemu/+bug/1701808\n#[cfg_attr(qemu, ignore)]\n#[test]\n#[cfg_attr(target_os = \"cygwin\", ignore)]\nfn test_scm_rights_single_cmsg_multiple_fds() {\n    use nix::sys::socket::{\n        recvmsg, sendmsg, ControlMessage, ControlMessageOwned, MsgFlags,\n    };\n    use std::io::{IoSlice, IoSliceMut};\n    use std::os::unix::io::{AsRawFd, RawFd};\n    use std::os::unix::net::UnixDatagram;\n    use std::thread;\n\n    let (send, receive) = UnixDatagram::pair().unwrap();\n    let thread = thread::spawn(move || {\n        let mut buf = [0u8; 8];\n        let mut iovec = [IoSliceMut::new(\u0026mut buf)];\n\n        let mut space = cmsg_space!([RawFd; 2]);\n        let msg = recvmsg::\u003c()\u003e(\n            receive.as_raw_fd(),\n            \u0026mut iovec,\n            Some(\u0026mut space),\n            MsgFlags::empty(),\n        )\n        .unwrap();\n        assert!(!msg\n            .flags\n            .intersects(MsgFlags::MSG_TRUNC | MsgFlags::MSG_CTRUNC));\n\n        let mut cmsgs = msg.cmsgs().unwrap();\n        match cmsgs.next() {\n            Some(ControlMessageOwned::ScmRights(fds)) =\u003e {\n                assert_eq!(\n                    fds.len(),\n                    2,\n                    \"unexpected fd count (expected 2 fds, got {})\",\n                    fds.len()\n                );\n            }\n            _ =\u003e panic!(),\n        }\n        assert!(cmsgs.next().is_none(), \"unexpected control msg\");\n\n        assert_eq!(msg.bytes, 8);\n        assert_eq!(*iovec[0], [1u8, 2, 3, 4, 5, 6, 7, 8]);\n    });\n\n    let slice = [1u8, 2, 3, 4, 5, 6, 7, 8];\n    let iov = [IoSlice::new(\u0026slice)];\n    let fds = [libc::STDIN_FILENO, libc::STDOUT_FILENO]; // pass stdin and stdout\n    let cmsg = [ControlMessage::ScmRights(\u0026fds)];\n    sendmsg::\u003c()\u003e(send.as_raw_fd(), \u0026iov, \u0026cmsg, MsgFlags::empty(), None)\n        .unwrap();\n    thread.join().unwrap();\n}\n\n// Verify `sendmsg` builds a valid `msghdr` when passing an empty\n// `cmsgs` argument.  This should result in a msghdr with a nullptr\n// msg_control field and a msg_controllen of 0 when calling into the\n// raw `sendmsg`.\n#[test]\npub fn test_sendmsg_empty_cmsgs() {\n    use nix::sys::socket::{\n        recvmsg, sendmsg, socketpair, AddressFamily, MsgFlags, SockFlag,\n        SockType,\n    };\n    use std::io::{IoSlice, IoSliceMut};\n\n    let (fd1, fd2) = socketpair(\n        AddressFamily::Unix,\n        SockType::Stream,\n        None,\n        SockFlag::empty(),\n    )\n    .unwrap();\n\n    {\n        let iov = [IoSlice::new(b\"hello\")];\n        assert_eq!(\n            sendmsg::\u003c()\u003e(fd1.as_raw_fd(), \u0026iov, \u0026[], MsgFlags::empty(), None)\n                .unwrap(),\n            5\n        );\n    }\n\n    {\n        let mut buf = [0u8; 5];\n        let mut iov = [IoSliceMut::new(\u0026mut buf[..])];\n\n        let mut cmsgspace = cmsg_space!([RawFd; 1]);\n        let msg = recvmsg::\u003c()\u003e(\n            fd2.as_raw_fd(),\n            \u0026mut iov,\n            Some(\u0026mut cmsgspace),\n            MsgFlags::empty(),\n        )\n        .unwrap();\n\n        if msg.cmsgs().unwrap().next().is_some() {\n            panic!(\"unexpected cmsg\");\n        }\n        assert!(!msg\n            .flags\n            .intersects(MsgFlags::MSG_TRUNC | MsgFlags::MSG_CTRUNC));\n        assert_eq!(msg.bytes, 5);\n    }\n}\n\n#[cfg(any(linux_android, freebsdlike))]\n#[test]\nfn test_scm_credentials() {\n    use nix::sys::socket::{\n        recvmsg, sendmsg, socketpair, AddressFamily, ControlMessage,\n        ControlMessageOwned, MsgFlags, SockFlag, SockType, UnixCredentials,\n    };\n    #[cfg(linux_android)]\n    use nix::sys::socket::{setsockopt, sockopt::PassCred};\n    use nix::unistd::{getgid, getpid, getuid};\n    use std::io::{IoSlice, IoSliceMut};\n\n    let (send, recv) = socketpair(\n        AddressFamily::Unix,\n        SockType::Stream,\n        None,\n        SockFlag::empty(),\n    )\n    .unwrap();\n    #[cfg(linux_android)]\n    setsockopt(\u0026recv, PassCred, \u0026true).unwrap();\n\n    {\n        let iov = [IoSlice::new(b\"hello\")];\n        #[cfg(linux_android)]\n        let cred = UnixCredentials::new();\n        #[cfg(linux_android)]\n        let cmsg = ControlMessage::ScmCredentials(\u0026cred);\n        #[cfg(freebsdlike)]\n        let cmsg = ControlMessage::ScmCreds;\n        assert_eq!(\n            sendmsg::\u003c()\u003e(\n                send.as_raw_fd(),\n                \u0026iov,\n                \u0026[cmsg],\n                MsgFlags::empty(),\n                None\n            )\n            .unwrap(),\n            5\n        );\n    }\n\n    {\n        let mut buf = [0u8; 5];\n        let mut iov = [IoSliceMut::new(\u0026mut buf[..])];\n\n        let mut cmsgspace = cmsg_space!(UnixCredentials);\n        let msg = recvmsg::\u003c()\u003e(\n            recv.as_raw_fd(),\n            \u0026mut iov,\n            Some(\u0026mut cmsgspace),\n            MsgFlags::empty(),\n        )\n        .unwrap();\n        let mut received_cred = None;\n\n        for cmsg in msg.cmsgs().unwrap() {\n            let cred = match cmsg {\n                #[cfg(linux_android)]\n                ControlMessageOwned::ScmCredentials(cred) =\u003e cred,\n                #[cfg(freebsdlike)]\n                ControlMessageOwned::ScmCreds(cred) =\u003e cred,\n                other =\u003e panic!(\"unexpected cmsg {other:?}\"),\n            };\n            assert!(received_cred.is_none());\n            assert_eq!(cred.pid(), getpid().as_raw());\n            assert_eq!(cred.uid(), getuid().as_raw());\n            assert_eq!(cred.gid(), getgid().as_raw());\n            received_cred = Some(cred);\n        }\n        received_cred.expect(\"no creds received\");\n        assert_eq!(msg.bytes, 5);\n        assert!(!msg\n            .flags\n            .intersects(MsgFlags::MSG_TRUNC | MsgFlags::MSG_CTRUNC));\n    }\n}\n\n/// Ensure that we can send `SCM_CREDENTIALS` and `SCM_RIGHTS` with a single\n/// `sendmsg` call.\n#[cfg(linux_android)]\n// qemu's handling of multiple cmsgs is bugged, ignore tests under emulation\n// see https://bugs.launchpad.net/qemu/+bug/1781280\n#[cfg_attr(qemu, ignore)]\n#[test]\nfn test_scm_credentials_and_rights() {\n    let space = cmsg_space!(libc::ucred, RawFd);\n    test_impl_scm_credentials_and_rights(space).unwrap();\n}\n\n/// Ensure that passing a an oversized control message buffer to recvmsg\n/// still works.\n#[cfg(linux_android)]\n// qemu's handling of multiple cmsgs is bugged, ignore tests under emulation\n// see https://bugs.launchpad.net/qemu/+bug/1781280\n#[cfg_attr(qemu, ignore)]\n#[test]\nfn test_too_large_cmsgspace() {\n    let space = vec![0u8; 1024];\n    test_impl_scm_credentials_and_rights(space).unwrap();\n}\n\n#[cfg(linux_android)]\n#[test]\nfn test_too_small_cmsgspace() {\n    let space = vec![0u8; 4];\n    assert_eq!(\n        test_impl_scm_credentials_and_rights(space),\n        Err(nix::errno::Errno::ENOBUFS)\n    );\n}\n\n#[cfg(linux_android)]\nfn test_impl_scm_credentials_and_rights(\n    mut space: Vec\u003cu8\u003e,\n) -\u003e Result\u003c(), nix::errno::Errno\u003e {\n    use libc::ucred;\n    use nix::sys::socket::sockopt::PassCred;\n    use nix::sys::socket::{\n        recvmsg, sendmsg, setsockopt, socketpair, ControlMessage,\n        ControlMessageOwned, MsgFlags, SockFlag, SockType,\n    };\n    use nix::unistd::{close, getgid, getpid, getuid, pipe, write};\n    use std::io::{IoSlice, IoSliceMut};\n\n    let (send, recv) = socketpair(\n        AddressFamily::Unix,\n        SockType::Stream,\n        None,\n        SockFlag::empty(),\n    )\n    .unwrap();\n    setsockopt(\u0026recv, PassCred, \u0026true).unwrap();\n\n    let (r, w) = pipe().unwrap();\n    let mut received_r: Option\u003cRawFd\u003e = None;\n\n    {\n        let iov = [IoSlice::new(b\"hello\")];\n        let cred = ucred {\n            pid: getpid().as_raw(),\n            uid: getuid().as_raw(),\n            gid: getgid().as_raw(),\n        }\n        .into();\n        let fds = [r.as_raw_fd()];\n        let cmsgs = [\n            ControlMessage::ScmCredentials(\u0026cred),\n            ControlMessage::ScmRights(\u0026fds),\n        ];\n        assert_eq!(\n            sendmsg::\u003c()\u003e(\n                send.as_raw_fd(),\n                \u0026iov,\n                \u0026cmsgs,\n                MsgFlags::empty(),\n                None\n            )\n            .unwrap(),\n            5\n        );\n    }\n\n    {\n        let mut buf = [0u8; 5];\n        let mut iov = [IoSliceMut::new(\u0026mut buf[..])];\n        let msg = recvmsg::\u003c()\u003e(\n            recv.as_raw_fd(),\n            \u0026mut iov,\n            Some(\u0026mut space),\n            MsgFlags::empty(),\n        )\n        .unwrap();\n        let mut received_cred = None;\n\n        assert_eq!(msg.cmsgs()?.count(), 2, \"expected 2 cmsgs\");\n\n        for cmsg in msg.cmsgs()? {\n            match cmsg {\n                ControlMessageOwned::ScmRights(fds) =\u003e {\n                    assert_eq!(received_r, None, \"already received fd\");\n                    assert_eq!(fds.len(), 1);\n                    received_r = Some(fds[0]);\n                }\n                ControlMessageOwned::ScmCredentials(cred) =\u003e {\n                    assert!(received_cred.is_none());\n                    assert_eq!(cred.pid(), getpid().as_raw());\n                    assert_eq!(cred.uid(), getuid().as_raw());\n                    assert_eq!(cred.gid(), getgid().as_raw());\n                    received_cred = Some(cred);\n                }\n                _ =\u003e panic!(\"unexpected cmsg\"),\n            }\n        }\n        received_cred.expect(\"no creds received\");\n        assert_eq!(msg.bytes, 5);\n        assert!(!msg\n            .flags\n            .intersects(MsgFlags::MSG_TRUNC | MsgFlags::MSG_CTRUNC));\n    }\n\n    let received_r = received_r.expect(\"Did not receive passed fd\");\n    // Ensure that the received file descriptor works\n    write(\u0026w, b\"world\").unwrap();\n    let mut buf = [0u8; 5];\n    // SAFETY:\n    // It should be safe if we don't use this BorrowedFd after close.\n    let received_r_borrowed =\n        unsafe { std::os::fd::BorrowedFd::borrow_raw(received_r) };\n    read(received_r_borrowed, \u0026mut buf).unwrap();\n    assert_eq!(\u0026buf[..], b\"world\");\n    close(received_r).unwrap();\n\n    Ok(())\n}\n\n// Test creating and using named unix domain sockets\n#[test]\npub fn test_named_unixdomain() {\n    use nix::sys::socket::{\n        accept, bind, connect, listen, socket, Backlog, UnixAddr,\n    };\n    use nix::sys::socket::{SockFlag, SockType};\n    use nix::unistd::{read, write};\n    use std::thread;\n\n    let tempdir = tempfile::tempdir().unwrap();\n    let sockname = tempdir.path().join(\"sock\");\n    let s1 = socket(\n        AddressFamily::Unix,\n        SockType::Stream,\n        SockFlag::empty(),\n        None,\n    )\n    .expect(\"socket failed\");\n    let sockaddr = UnixAddr::new(\u0026sockname).unwrap();\n    bind(s1.as_raw_fd(), \u0026sockaddr).expect(\"bind failed\");\n    listen(\u0026s1, Backlog::new(10).unwrap()).expect(\"listen failed\");\n\n    let thr = thread::spawn(move || {\n        let s2 = socket(\n            AddressFamily::Unix,\n            SockType::Stream,\n            SockFlag::empty(),\n            None,\n        )\n        .expect(\"socket failed\");\n        connect(s2.as_raw_fd(), \u0026sockaddr).expect(\"connect failed\");\n        write(\u0026s2, b\"hello\").expect(\"write failed\");\n    });\n\n    let s3 = accept(s1.as_raw_fd()).expect(\"accept failed\");\n\n    // SAFETY:\n    // It should be safe considering that s3 will be open within this test\n    let s3 = unsafe { std::os::fd::BorrowedFd::borrow_raw(s3) };\n    let mut buf = [0; 5];\n    read(s3, \u0026mut buf).unwrap();\n    thr.join().unwrap();\n\n    assert_eq!(\u0026buf[..], b\"hello\");\n}\n\n#[test]\npub fn test_listen_maxbacklog() {\n    use nix::sys::socket::Backlog;\n\n    assert!(Backlog::new(libc::SOMAXCONN).is_ok());\n}\n\n#[test]\npub fn test_listen_wrongbacklog() {\n    use nix::sys::socket::Backlog;\n\n    #[cfg(not(target_os = \"cygwin\"))]\n    assert!(Backlog::new(libc::SOMAXCONN + 1).is_err());\n    assert!(Backlog::new(-2).is_err());\n}\n\n// Test using unnamed unix domain addresses\n#[cfg(linux_android)]\n#[test]\npub fn test_unnamed_unixdomain() {\n    use nix::sys::socket::{getsockname, socketpair};\n    use nix::sys::socket::{SockFlag, SockType};\n\n    let (fd_1, _fd_2) = socketpair(\n        AddressFamily::Unix,\n        SockType::Stream,\n        None,\n        SockFlag::empty(),\n    )\n    .expect(\"socketpair failed\");\n\n    let addr_1: UnixAddr =\n        getsockname(fd_1.as_raw_fd()).expect(\"getsockname failed\");\n    assert!(addr_1.is_unnamed());\n}\n\n// Test creating and using unnamed unix domain addresses for autobinding sockets\n#[cfg(linux_android)]\n#[test]\npub fn test_unnamed_unixdomain_autobind() {\n    use nix::sys::socket::{bind, getsockname, socket};\n    use nix::sys::socket::{SockFlag, SockType};\n\n    let fd = socket(\n        AddressFamily::Unix,\n        SockType::Stream,\n        SockFlag::empty(),\n        None,\n    )\n    .expect(\"socket failed\");\n\n    // unix(7): \"If a bind(2) call specifies addrlen as `sizeof(sa_family_t)`, or [...], then the\n    // socket is autobound to an abstract address\"\n    bind(fd.as_raw_fd(), \u0026UnixAddr::new_unnamed()).expect(\"bind failed\");\n\n    let addr: UnixAddr =\n        getsockname(fd.as_raw_fd()).expect(\"getsockname failed\");\n    let addr = addr.as_abstract().unwrap();\n\n    // changed from 8 to 5 bytes in Linux 2.3.15, and rust's minimum supported Linux version is 3.2\n    // (as of 2022-11)\n    assert_eq!(addr.len(), 5);\n}\n\n// Test creating and using named system control sockets\n#[cfg(apple_targets)]\n#[test]\npub fn test_syscontrol() {\n    use nix::errno::Errno;\n    use nix::sys::socket::{\n        socket, SockFlag, SockProtocol, SockType, SysControlAddr,\n    };\n\n    let fd = socket(\n        AddressFamily::System,\n        SockType::Datagram,\n        SockFlag::empty(),\n        SockProtocol::KextControl,\n    )\n    .expect(\"socket failed\");\n    SysControlAddr::from_name(fd.as_raw_fd(), \"com.apple.net.utun_control\", 0)\n        .expect(\"resolving sys_control name failed\");\n    assert_eq!(\n        SysControlAddr::from_name(fd.as_raw_fd(), \"foo.bar.lol\", 0).err(),\n        Some(Errno::ENOENT)\n    );\n\n    // requires root privileges\n    // connect(fd.as_raw_fd(), \u0026sockaddr).expect(\"connect failed\");\n}\n\n#[cfg(any(bsd, linux_android))]\nfn loopback_address(\n    family: AddressFamily,\n) -\u003e Option\u003cnix::ifaddrs::InterfaceAddress\u003e {\n    use nix::ifaddrs::getifaddrs;\n    use nix::net::if_::*;\n    use nix::sys::socket::SockaddrLike;\n    use std::io;\n    use std::io::Write;\n\n    let mut addrs = match getifaddrs() {\n        Ok(iter) =\u003e iter,\n        Err(e) =\u003e {\n            let stdioerr = io::stderr();\n            let mut handle = stdioerr.lock();\n            writeln!(handle, \"getifaddrs: {e:?}\").unwrap();\n            return None;\n        }\n    };\n    // return first address matching family\n    addrs.find(|ifaddr| {\n        ifaddr.flags.contains(InterfaceFlags::IFF_LOOPBACK)\n            \u0026\u0026 ifaddr.address.as_ref().and_then(SockaddrLike::family)\n                == Some(family)\n    })\n}\n\n#[cfg(any(linux_android, apple_targets, target_os = \"netbsd\"))]\n// qemu doesn't seem to be emulating this correctly in these architectures\n#[cfg_attr(\n    all(\n        qemu,\n        any(\n            target_arch = \"mips\",\n            target_arch = \"mips32r6\",\n            target_arch = \"mips64\",\n            target_arch = \"mips64r6\",\n            target_arch = \"powerpc64\",\n        )\n    ),\n    ignore\n)]\n#[test]\npub fn test_recv_ipv4pktinfo() {\n    use nix::net::if_::*;\n    use nix::sys::socket::sockopt::Ipv4PacketInfo;\n    use nix::sys::socket::{bind, SockFlag, SockType, SockaddrIn};\n    use nix::sys::socket::{getsockname, setsockopt, socket};\n    use nix::sys::socket::{recvmsg, sendmsg, ControlMessageOwned, MsgFlags};\n    use std::io::{IoSlice, IoSliceMut};\n\n    let lo_ifaddr = loopback_address(AddressFamily::Inet);\n    let (lo_name, lo) = match lo_ifaddr {\n        Some(ifaddr) =\u003e (\n            ifaddr.interface_name,\n            ifaddr.address.expect(\"Expect IPv4 address on interface\"),\n        ),\n        None =\u003e return,\n    };\n    let receive = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .expect(\"receive socket failed\");\n    bind(receive.as_raw_fd(), \u0026lo).expect(\"bind failed\");\n    let sa: SockaddrIn =\n        getsockname(receive.as_raw_fd()).expect(\"getsockname failed\");\n    setsockopt(\u0026receive, Ipv4PacketInfo, \u0026true).expect(\"setsockopt failed\");\n\n    {\n        let slice = [1u8, 2, 3, 4, 5, 6, 7, 8];\n        let iov = [IoSlice::new(\u0026slice)];\n\n        let send = socket(\n            AddressFamily::Inet,\n            SockType::Datagram,\n            SockFlag::empty(),\n            None,\n        )\n        .expect(\"send socket failed\");\n        sendmsg(send.as_raw_fd(), \u0026iov, \u0026[], MsgFlags::empty(), Some(\u0026sa))\n            .expect(\"sendmsg failed\");\n    }\n\n    {\n        let mut buf = [0u8; 8];\n        let mut iovec = [IoSliceMut::new(\u0026mut buf)];\n\n        let mut space = cmsg_space!(libc::in_pktinfo);\n        let msg = recvmsg::\u003c()\u003e(\n            receive.as_raw_fd(),\n            \u0026mut iovec,\n            Some(\u0026mut space),\n            MsgFlags::empty(),\n        )\n        .expect(\"recvmsg failed\");\n        assert!(!msg\n            .flags\n            .intersects(MsgFlags::MSG_TRUNC | MsgFlags::MSG_CTRUNC));\n\n        let mut cmsgs = msg.cmsgs().unwrap();\n        if let Some(ControlMessageOwned::Ipv4PacketInfo(pktinfo)) = cmsgs.next()\n        {\n            let i = if_nametoindex(lo_name.as_bytes()).expect(\"if_nametoindex\");\n            assert_eq!(\n                pktinfo.ipi_ifindex as libc::c_uint, i,\n                \"unexpected ifindex (expected {}, got {})\",\n                i, pktinfo.ipi_ifindex\n            );\n        }\n        assert!(cmsgs.next().is_none(), \"unexpected additional control msg\");\n        assert_eq!(msg.bytes, 8);\n        assert_eq!(*iovec[0], [1u8, 2, 3, 4, 5, 6, 7, 8]);\n    }\n}\n\n#[cfg(bsd)]\n// qemu doesn't seem to be emulating this correctly in these architectures\n#[cfg_attr(\n    all(\n        qemu,\n        any(\n            target_arch = \"mips\",\n            target_arch = \"mips32r6\",\n            target_arch = \"mips64\",\n            target_arch = \"mips64r6\",\n            target_arch = \"powerpc64\",\n        )\n    ),\n    ignore\n)]\n#[test]\npub fn test_recvif() {\n    use nix::net::if_::*;\n    use nix::sys::socket::sockopt::{Ipv4RecvDstAddr, Ipv4RecvIf};\n    use nix::sys::socket::{bind, SockFlag, SockType, SockaddrIn};\n    use nix::sys::socket::{getsockname, setsockopt, socket};\n    use nix::sys::socket::{recvmsg, sendmsg, ControlMessageOwned, MsgFlags};\n    use std::io::{IoSlice, IoSliceMut};\n\n    let lo_ifaddr = loopback_address(AddressFamily::Inet);\n    let (lo_name, lo) = match lo_ifaddr {\n        Some(ifaddr) =\u003e (\n            ifaddr.interface_name,\n            ifaddr.address.expect(\"Expect IPv4 address on interface\"),\n        ),\n        None =\u003e return,\n    };\n    let receive = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .expect(\"receive socket failed\");\n    bind(receive.as_raw_fd(), \u0026lo).expect(\"bind failed\");\n    let sa: SockaddrIn =\n        getsockname(receive.as_raw_fd()).expect(\"getsockname failed\");\n    setsockopt(\u0026receive, Ipv4RecvIf, \u0026true)\n        .expect(\"setsockopt IP_RECVIF failed\");\n    setsockopt(\u0026receive, Ipv4RecvDstAddr, \u0026true)\n        .expect(\"setsockopt IP_RECVDSTADDR failed\");\n\n    {\n        let slice = [1u8, 2, 3, 4, 5, 6, 7, 8];\n        let iov = [IoSlice::new(\u0026slice)];\n\n        let send = socket(\n            AddressFamily::Inet,\n            SockType::Datagram,\n            SockFlag::empty(),\n            None,\n        )\n        .expect(\"send socket failed\");\n        sendmsg(send.as_raw_fd(), \u0026iov, \u0026[], MsgFlags::empty(), Some(\u0026sa))\n            .expect(\"sendmsg failed\");\n    }\n\n    {\n        let mut buf = [0u8; 8];\n        let mut iovec = [IoSliceMut::new(\u0026mut buf)];\n        let mut space = cmsg_space!(libc::sockaddr_dl, libc::in_addr);\n        let msg = recvmsg::\u003c()\u003e(\n            receive.as_raw_fd(),\n            \u0026mut iovec,\n            Some(\u0026mut space),\n            MsgFlags::empty(),\n        )\n        .expect(\"recvmsg failed\");\n        assert!(!msg\n            .flags\n            .intersects(MsgFlags::MSG_TRUNC | MsgFlags::MSG_CTRUNC));\n        assert_eq!(msg.cmsgs().unwrap().count(), 2, \"expected 2 cmsgs\");\n\n        let mut rx_recvif = false;\n        let mut rx_recvdstaddr = false;\n        for cmsg in msg.cmsgs().unwrap() {\n            match cmsg {\n                ControlMessageOwned::Ipv4RecvIf(dl) =\u003e {\n                    rx_recvif = true;\n                    let i = if_nametoindex(lo_name.as_bytes())\n                        .expect(\"if_nametoindex\");\n                    assert_eq!(\n                        dl.sdl_index as libc::c_uint, i,\n                        \"unexpected ifindex (expected {}, got {})\",\n                        i, dl.sdl_index\n                    );\n                }\n                ControlMessageOwned::Ipv4RecvDstAddr(addr) =\u003e {\n                    rx_recvdstaddr = true;\n                    if let Some(sin) = lo.as_sockaddr_in() {\n                        assert_eq!(sin.as_ref().sin_addr.s_addr,\n                                   addr.s_addr,\n                                   \"unexpected destination address (expected {}, got {})\",\n                                   sin.as_ref().sin_addr.s_addr,\n                                   addr.s_addr);\n                    } else {\n                        panic!(\"unexpected Sockaddr\");\n                    }\n                }\n                _ =\u003e panic!(\"unexpected additional control msg\"),\n            }\n        }\n        assert!(rx_recvif);\n        assert!(rx_recvdstaddr);\n        assert_eq!(msg.bytes, 8);\n        assert_eq!(*iovec[0], [1u8, 2, 3, 4, 5, 6, 7, 8]);\n    }\n}\n\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\n#[cfg_attr(qemu, ignore)]\n#[test]\npub fn test_recvif_ipv4() {\n    use nix::sys::socket::sockopt::Ipv4OrigDstAddr;\n    use nix::sys::socket::{bind, SockFlag, SockType, SockaddrIn};\n    use nix::sys::socket::{getsockname, setsockopt, socket};\n    use nix::sys::socket::{recvmsg, sendmsg, ControlMessageOwned, MsgFlags};\n    use std::io::{IoSlice, IoSliceMut};\n\n    let lo_ifaddr = loopback_address(AddressFamily::Inet);\n    let (_lo_name, lo) = match lo_ifaddr {\n        Some(ifaddr) =\u003e (\n            ifaddr.interface_name,\n            ifaddr.address.expect(\"Expect IPv4 address on interface\"),\n        ),\n        None =\u003e return,\n    };\n    let receive = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .expect(\"receive socket failed\");\n    bind(receive.as_raw_fd(), \u0026lo).expect(\"bind failed\");\n    let sa: SockaddrIn =\n        getsockname(receive.as_raw_fd()).expect(\"getsockname failed\");\n    setsockopt(\u0026receive, Ipv4OrigDstAddr, \u0026true)\n        .expect(\"setsockopt IP_ORIGDSTADDR failed\");\n\n    {\n        let slice = [1u8, 2, 3, 4, 5, 6, 7, 8];\n        let iov = [IoSlice::new(\u0026slice)];\n\n        let send = socket(\n            AddressFamily::Inet,\n            SockType::Datagram,\n            SockFlag::empty(),\n            None,\n        )\n        .expect(\"send socket failed\");\n        sendmsg(send.as_raw_fd(), \u0026iov, \u0026[], MsgFlags::empty(), Some(\u0026sa))\n            .expect(\"sendmsg failed\");\n    }\n\n    {\n        let mut buf = [0u8; 8];\n        let mut iovec = [IoSliceMut::new(\u0026mut buf)];\n        let mut space = cmsg_space!(libc::sockaddr_in);\n        let msg = recvmsg::\u003c()\u003e(\n            receive.as_raw_fd(),\n            \u0026mut iovec,\n            Some(\u0026mut space),\n            MsgFlags::empty(),\n        )\n        .expect(\"recvmsg failed\");\n        assert!(!msg\n            .flags\n            .intersects(MsgFlags::MSG_TRUNC | MsgFlags::MSG_CTRUNC));\n        assert_eq!(msg.cmsgs().unwrap().count(), 1, \"expected 1 cmsgs\");\n\n        let mut rx_recvorigdstaddr = false;\n        for cmsg in msg.cmsgs().unwrap() {\n            match cmsg {\n                ControlMessageOwned::Ipv4OrigDstAddr(addr) =\u003e {\n                    rx_recvorigdstaddr = true;\n                    if let Some(sin) = lo.as_sockaddr_in() {\n                        assert_eq!(sin.as_ref().sin_addr.s_addr,\n                                   addr.sin_addr.s_addr,\n                                   \"unexpected destination address (expected {}, got {})\",\n                                   sin.as_ref().sin_addr.s_addr,\n                                   addr.sin_addr.s_addr);\n                    } else {\n                        panic!(\"unexpected Sockaddr\");\n                    }\n                }\n                _ =\u003e panic!(\"unexpected additional control msg\"),\n            }\n        }\n        assert!(rx_recvorigdstaddr);\n        assert_eq!(msg.bytes, 8);\n        assert_eq!(*iovec[0], [1u8, 2, 3, 4, 5, 6, 7, 8]);\n    }\n}\n\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\n#[cfg_attr(qemu, ignore)]\n#[test]\npub fn test_recvif_ipv6() {\n    use nix::sys::socket::sockopt::Ipv6OrigDstAddr;\n    use nix::sys::socket::{bind, SockFlag, SockType, SockaddrIn6};\n    use nix::sys::socket::{getsockname, setsockopt, socket};\n    use nix::sys::socket::{recvmsg, sendmsg, ControlMessageOwned, MsgFlags};\n    use std::io::{IoSlice, IoSliceMut};\n\n    let lo_ifaddr = loopback_address(AddressFamily::Inet6);\n    let (_lo_name, lo) = match lo_ifaddr {\n        Some(ifaddr) =\u003e (\n            ifaddr.interface_name,\n            ifaddr.address.expect(\"Expect IPv6 address on interface\"),\n        ),\n        None =\u003e return,\n    };\n    let receive = socket(\n        AddressFamily::Inet6,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .expect(\"receive socket failed\");\n    bind(receive.as_raw_fd(), \u0026lo).expect(\"bind failed\");\n    let sa: SockaddrIn6 =\n        getsockname(receive.as_raw_fd()).expect(\"getsockname failed\");\n    setsockopt(\u0026receive, Ipv6OrigDstAddr, \u0026true)\n        .expect(\"setsockopt IP_ORIGDSTADDR failed\");\n\n    {\n        let slice = [1u8, 2, 3, 4, 5, 6, 7, 8];\n        let iov = [IoSlice::new(\u0026slice)];\n\n        let send = socket(\n            AddressFamily::Inet6,\n            SockType::Datagram,\n            SockFlag::empty(),\n            None,\n        )\n        .expect(\"send socket failed\");\n        sendmsg(send.as_raw_fd(), \u0026iov, \u0026[], MsgFlags::empty(), Some(\u0026sa))\n            .expect(\"sendmsg failed\");\n    }\n\n    {\n        let mut buf = [0u8; 8];\n        let mut iovec = [IoSliceMut::new(\u0026mut buf)];\n        let mut space = cmsg_space!(libc::sockaddr_in6);\n        let msg = recvmsg::\u003c()\u003e(\n            receive.as_raw_fd(),\n            \u0026mut iovec,\n            Some(\u0026mut space),\n            MsgFlags::empty(),\n        )\n        .expect(\"recvmsg failed\");\n        assert!(!msg\n            .flags\n            .intersects(MsgFlags::MSG_TRUNC | MsgFlags::MSG_CTRUNC));\n        assert_eq!(msg.cmsgs().unwrap().count(), 1, \"expected 1 cmsgs\");\n\n        let mut rx_recvorigdstaddr = false;\n        for cmsg in msg.cmsgs().unwrap() {\n            match cmsg {\n                ControlMessageOwned::Ipv6OrigDstAddr(addr) =\u003e {\n                    rx_recvorigdstaddr = true;\n                    if let Some(sin) = lo.as_sockaddr_in6() {\n                        assert_eq!(sin.as_ref().sin6_addr.s6_addr,\n                                   addr.sin6_addr.s6_addr,\n                                   \"unexpected destination address (expected {:?}, got {:?})\",\n                                   sin.as_ref().sin6_addr.s6_addr,\n                                   addr.sin6_addr.s6_addr);\n                    } else {\n                        panic!(\"unexpected Sockaddr\");\n                    }\n                }\n                _ =\u003e panic!(\"unexpected additional control msg\"),\n            }\n        }\n        assert!(rx_recvorigdstaddr);\n        assert_eq!(msg.bytes, 8);\n        assert_eq!(*iovec[0], [1u8, 2, 3, 4, 5, 6, 7, 8]);\n    }\n}\n\n#[cfg(any(linux_android, target_os = \"freebsd\", apple_targets, netbsdlike))]\n// qemu doesn't seem to be emulating this correctly in these architectures\n#[cfg_attr(\n    all(\n        qemu,\n        any(\n            target_arch = \"mips\",\n            target_arch = \"mips32r6\",\n            target_arch = \"mips64\",\n            target_arch = \"mips64r6\",\n            target_arch = \"powerpc64\",\n        )\n    ),\n    ignore\n)]\n#[test]\npub fn test_recv_ipv6pktinfo() {\n    use nix::net::if_::*;\n    use nix::sys::socket::sockopt::Ipv6RecvPacketInfo;\n    use nix::sys::socket::{bind, SockFlag, SockType, SockaddrIn6};\n    use nix::sys::socket::{getsockname, setsockopt, socket};\n    use nix::sys::socket::{recvmsg, sendmsg, ControlMessageOwned, MsgFlags};\n    use std::io::{IoSlice, IoSliceMut};\n\n    let lo_ifaddr = loopback_address(AddressFamily::Inet6);\n    let (lo_name, lo) = match lo_ifaddr {\n        Some(ifaddr) =\u003e (\n            ifaddr.interface_name,\n            ifaddr.address.expect(\"Expect IPv6 address on interface\"),\n        ),\n        None =\u003e return,\n    };\n    let receive = socket(\n        AddressFamily::Inet6,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .expect(\"receive socket failed\");\n    bind(receive.as_raw_fd(), \u0026lo).expect(\"bind failed\");\n    let sa: SockaddrIn6 =\n        getsockname(receive.as_raw_fd()).expect(\"getsockname failed\");\n    setsockopt(\u0026receive, Ipv6RecvPacketInfo, \u0026true).expect(\"setsockopt failed\");\n\n    {\n        let slice = [1u8, 2, 3, 4, 5, 6, 7, 8];\n        let iov = [IoSlice::new(\u0026slice)];\n\n        let send = socket(\n            AddressFamily::Inet6,\n            SockType::Datagram,\n            SockFlag::empty(),\n            None,\n        )\n        .expect(\"send socket failed\");\n        sendmsg(send.as_raw_fd(), \u0026iov, \u0026[], MsgFlags::empty(), Some(\u0026sa))\n            .expect(\"sendmsg failed\");\n    }\n\n    {\n        let mut buf = [0u8; 8];\n        let mut iovec = [IoSliceMut::new(\u0026mut buf)];\n\n        let mut space = cmsg_space!(libc::in6_pktinfo);\n        let msg = recvmsg::\u003c()\u003e(\n            receive.as_raw_fd(),\n            \u0026mut iovec,\n            Some(\u0026mut space),\n            MsgFlags::empty(),\n        )\n        .expect(\"recvmsg failed\");\n        assert!(!msg\n            .flags\n            .intersects(MsgFlags::MSG_TRUNC | MsgFlags::MSG_CTRUNC));\n\n        let mut cmsgs = msg.cmsgs().unwrap();\n        if let Some(ControlMessageOwned::Ipv6PacketInfo(pktinfo)) = cmsgs.next()\n        {\n            let i = if_nametoindex(lo_name.as_bytes()).expect(\"if_nametoindex\");\n            assert_eq!(\n                pktinfo.ipi6_ifindex as libc::c_uint, i,\n                \"unexpected ifindex (expected {}, got {})\",\n                i, pktinfo.ipi6_ifindex\n            );\n        }\n        assert!(cmsgs.next().is_none(), \"unexpected additional control msg\");\n        assert_eq!(msg.bytes, 8);\n        assert_eq!(*iovec[0], [1u8, 2, 3, 4, 5, 6, 7, 8]);\n    }\n}\n\n#[cfg(linux_android)]\n#[test]\npub fn test_vsock() {\n    use nix::sys::socket::SockaddrLike;\n    use nix::sys::socket::{AddressFamily, VsockAddr};\n    use std::mem;\n\n    let port: u32 = 3000;\n\n    let addr_local = VsockAddr::new(libc::VMADDR_CID_LOCAL, port);\n    assert_eq!(addr_local.cid(), libc::VMADDR_CID_LOCAL);\n    assert_eq!(addr_local.port(), port);\n\n    let addr_any = VsockAddr::new(libc::VMADDR_CID_ANY, libc::VMADDR_PORT_ANY);\n    assert_eq!(addr_any.cid(), libc::VMADDR_CID_ANY);\n    assert_eq!(addr_any.port(), libc::VMADDR_PORT_ANY);\n\n    assert_ne!(addr_local, addr_any);\n    assert_ne!(calculate_hash(\u0026addr_local), calculate_hash(\u0026addr_any));\n\n    let addr1 = VsockAddr::new(libc::VMADDR_CID_HOST, port);\n    let addr2 = VsockAddr::new(libc::VMADDR_CID_HOST, port);\n    assert_eq!(addr1, addr2);\n    assert_eq!(calculate_hash(\u0026addr1), calculate_hash(\u0026addr2));\n\n    let addr3 = unsafe {\n        VsockAddr::from_raw(\n            addr2.as_ref() as *const libc::sockaddr_vm as *const libc::sockaddr,\n            Some(mem::size_of::\u003clibc::sockaddr_vm\u003e().try_into().unwrap()),\n        )\n    }\n    .unwrap();\n    assert_eq!(\n        addr3.as_ref().svm_family,\n        AddressFamily::Vsock as libc::sa_family_t\n    );\n    assert_eq!(addr3.as_ref().svm_cid, addr1.cid());\n    assert_eq!(addr3.as_ref().svm_port, addr1.port());\n}\n\n#[cfg(apple_targets)]\n#[test]\npub fn test_vsock() {\n    use nix::sys::socket::SockaddrLike;\n    use nix::sys::socket::{AddressFamily, VsockAddr};\n    use std::mem;\n\n    let port: u32 = 3000;\n\n    // macOS doesn't have a VMADDR_CID_LOCAL, so test with host again\n    let addr_host = VsockAddr::new(libc::VMADDR_CID_HOST, port);\n    assert_eq!(addr_host.cid(), libc::VMADDR_CID_HOST);\n    assert_eq!(addr_host.port(), port);\n\n    let addr_any = VsockAddr::new(libc::VMADDR_CID_ANY, libc::VMADDR_PORT_ANY);\n    assert_eq!(addr_any.cid(), libc::VMADDR_CID_ANY);\n    assert_eq!(addr_any.port(), libc::VMADDR_PORT_ANY);\n\n    assert_ne!(addr_host, addr_any);\n    assert_ne!(calculate_hash(\u0026addr_host), calculate_hash(\u0026addr_any));\n\n    let addr1 = VsockAddr::new(libc::VMADDR_CID_HOST, port);\n    let addr2 = VsockAddr::new(libc::VMADDR_CID_HOST, port);\n    assert_eq!(addr1, addr2);\n    assert_eq!(calculate_hash(\u0026addr1), calculate_hash(\u0026addr2));\n\n    let addr3 = unsafe {\n        VsockAddr::from_raw(\n            addr2.as_ref() as *const libc::sockaddr_vm as *const libc::sockaddr,\n            Some(mem::size_of::\u003clibc::sockaddr_vm\u003e().try_into().unwrap()),\n        )\n    }\n    .unwrap();\n    assert_eq!(\n        addr3.as_ref().svm_family,\n        AddressFamily::Vsock as libc::sa_family_t\n    );\n    let cid = addr3.as_ref().svm_cid;\n    let port = addr3.as_ref().svm_port;\n    assert_eq!(cid, addr1.cid());\n    assert_eq!(port, addr1.port());\n}\n\n// Disable the test on emulated platforms because it fails in Cirrus-CI.  Lack\n// of QEMU support is suspected.\n#[cfg_attr(qemu, ignore)]\n#[cfg(target_os = \"linux\")]\n#[test]\nfn test_recvmsg_timestampns() {\n    use nix::sys::socket::*;\n    use nix::sys::time::*;\n    use std::io::{IoSlice, IoSliceMut};\n    use std::time::*;\n\n    // Set up\n    let message = \"Ohay!\".as_bytes();\n    let in_socket = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    setsockopt(\u0026in_socket, sockopt::ReceiveTimestampns, \u0026true).unwrap();\n    let localhost = SockaddrIn::new(127, 0, 0, 1, 0);\n    bind(in_socket.as_raw_fd(), \u0026localhost).unwrap();\n    let address: SockaddrIn = getsockname(in_socket.as_raw_fd()).unwrap();\n    // Get initial time\n    let time0 = SystemTime::now();\n    // Send the message\n    let iov = [IoSlice::new(message)];\n    let flags = MsgFlags::empty();\n    let l = sendmsg(in_socket.as_raw_fd(), \u0026iov, \u0026[], flags, Some(\u0026address))\n        .unwrap();\n    assert_eq!(message.len(), l);\n    // Receive the message\n    let mut buffer = vec![0u8; message.len()];\n    let mut cmsgspace = nix::cmsg_space!(TimeSpec);\n\n    let mut iov = [IoSliceMut::new(\u0026mut buffer)];\n    let r = recvmsg::\u003c()\u003e(\n        in_socket.as_raw_fd(),\n        \u0026mut iov,\n        Some(\u0026mut cmsgspace),\n        flags,\n    )\n    .unwrap();\n    let rtime = match r.cmsgs().unwrap().next() {\n        Some(ControlMessageOwned::ScmTimestampns(rtime)) =\u003e rtime,\n        Some(_) =\u003e panic!(\"Unexpected control message\"),\n        None =\u003e panic!(\"No control message\"),\n    };\n    // Check the final time\n    let time1 = SystemTime::now();\n    // the packet's received timestamp should lie in-between the two system\n    // times, unless the system clock was adjusted in the meantime.\n    let rduration =\n        Duration::new(rtime.tv_sec() as u64, rtime.tv_nsec() as u32);\n    assert!(time0.duration_since(UNIX_EPOCH).unwrap() \u003c= rduration);\n    assert!(rduration \u003c= time1.duration_since(UNIX_EPOCH).unwrap());\n}\n\n// Disable the test on emulated platforms because it fails in Cirrus-CI.  Lack\n// of QEMU support is suspected.\n#[cfg_attr(qemu, ignore)]\n#[cfg(target_os = \"linux\")]\n#[test]\nfn test_recvmmsg_timestampns() {\n    use nix::sys::socket::*;\n    use nix::sys::time::*;\n    use std::io::{IoSlice, IoSliceMut};\n    use std::time::*;\n\n    // Set up\n    let message = \"Ohay!\".as_bytes();\n    let in_socket = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    setsockopt(\u0026in_socket, sockopt::ReceiveTimestampns, \u0026true).unwrap();\n    let localhost = SockaddrIn::from_str(\"127.0.0.1:0\").unwrap();\n    bind(in_socket.as_raw_fd(), \u0026localhost).unwrap();\n    let address: SockaddrIn = getsockname(in_socket.as_raw_fd()).unwrap();\n    // Get initial time\n    let time0 = SystemTime::now();\n    // Send the message\n    let iov = [IoSlice::new(message)];\n    let flags = MsgFlags::empty();\n    let l = sendmsg(in_socket.as_raw_fd(), \u0026iov, \u0026[], flags, Some(\u0026address))\n        .unwrap();\n    assert_eq!(message.len(), l);\n    // Receive the message\n    let mut buffer = vec![0u8; message.len()];\n    let cmsgspace = nix::cmsg_space!(TimeSpec);\n    let mut iov = [[IoSliceMut::new(\u0026mut buffer)]];\n    let mut data = MultiHeaders::preallocate(1, Some(cmsgspace));\n    let r: Vec\u003cRecvMsg\u003c()\u003e\u003e = recvmmsg(\n        in_socket.as_raw_fd(),\n        \u0026mut data,\n        iov.iter_mut(),\n        flags,\n        None,\n    )\n    .unwrap()\n    .collect();\n    let rtime = match r[0].cmsgs().unwrap().next() {\n        Some(ControlMessageOwned::ScmTimestampns(rtime)) =\u003e rtime,\n        Some(_) =\u003e panic!(\"Unexpected control message\"),\n        None =\u003e panic!(\"No control message\"),\n    };\n    // Check the final time\n    let time1 = SystemTime::now();\n    // the packet's received timestamp should lie in-between the two system\n    // times, unless the system clock was adjusted in the meantime.\n    let rduration =\n        Duration::new(rtime.tv_sec() as u64, rtime.tv_nsec() as u32);\n    assert!(time0.duration_since(UNIX_EPOCH).unwrap() \u003c= rduration);\n    assert!(rduration \u003c= time1.duration_since(UNIX_EPOCH).unwrap());\n}\n\n// Disable the test on emulated platforms because it fails in Cirrus-CI.  Lack\n// of QEMU support is suspected.\n#[cfg_attr(qemu, ignore)]\n#[cfg(any(linux_android, target_os = \"fuchsia\"))]\n#[test]\nfn test_recvmsg_rxq_ovfl() {\n    use nix::sys::socket::sockopt::{RcvBuf, RxqOvfl};\n    use nix::sys::socket::*;\n    use nix::Error;\n    use std::io::{IoSlice, IoSliceMut};\n\n    let message = [0u8; 2048];\n    let bufsize = message.len() * 2;\n\n    let in_socket = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    let out_socket = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n\n    let localhost = SockaddrIn::from_str(\"127.0.0.1:0\").unwrap();\n    bind(in_socket.as_raw_fd(), \u0026localhost).unwrap();\n\n    let address: SockaddrIn = getsockname(in_socket.as_raw_fd()).unwrap();\n    connect(out_socket.as_raw_fd(), \u0026address).unwrap();\n\n    // Set SO_RXQ_OVFL flag.\n    setsockopt(\u0026in_socket, RxqOvfl, \u00261).unwrap();\n\n    // Set the receiver buffer size to hold only 2 messages.\n    setsockopt(\u0026in_socket, RcvBuf, \u0026bufsize).unwrap();\n\n    let mut drop_counter = 0;\n\n    for _ in 0..2 {\n        let iov = [IoSlice::new(\u0026message)];\n        let flags = MsgFlags::empty();\n\n        // Send the 3 messages (the receiver buffer can only hold 2 messages)\n        // to create an overflow.\n        for _ in 0..3 {\n            let l = sendmsg(\n                out_socket.as_raw_fd(),\n                \u0026iov,\n                \u0026[],\n                flags,\n                Some(\u0026address),\n            )\n            .unwrap();\n            assert_eq!(message.len(), l);\n        }\n\n        // Receive the message and check the drop counter if any.\n        loop {\n            let mut buffer = vec![0u8; message.len()];\n            let mut cmsgspace = nix::cmsg_space!(u32);\n\n            let mut iov = [IoSliceMut::new(\u0026mut buffer)];\n\n            match recvmsg::\u003c()\u003e(\n                in_socket.as_raw_fd(),\n                \u0026mut iov,\n                Some(\u0026mut cmsgspace),\n                MsgFlags::MSG_DONTWAIT,\n            ) {\n                Ok(r) =\u003e {\n                    drop_counter = match r.cmsgs().unwrap().next() {\n                        Some(ControlMessageOwned::RxqOvfl(drop_counter)) =\u003e {\n                            drop_counter\n                        }\n                        Some(_) =\u003e panic!(\"Unexpected control message\"),\n                        None =\u003e 0,\n                    };\n                }\n                Err(Error::EAGAIN) =\u003e {\n                    break;\n                }\n                _ =\u003e {\n                    panic!(\"unknown recvmsg() error\");\n                }\n            }\n        }\n    }\n\n    // One packet lost.\n    assert_eq!(drop_counter, 1);\n}\n\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\n#[cfg(feature = \"net\")]\n// qemu doesn't seem to be emulating this correctly in these architectures\n#[cfg_attr(\n    all(\n        qemu,\n        any(\n            target_arch = \"mips\",\n            target_arch = \"mips32r6\",\n            target_arch = \"mips64\",\n            target_arch = \"mips64r6\",\n        )\n    ),\n    ignore\n)]\n#[test]\npub fn test_ip_tos_udp() {\n    use nix::sys::socket::ControlMessageOwned;\n    use nix::sys::socket::{\n        bind, recvmsg, sendmsg, setsockopt, socket, sockopt, ControlMessage,\n        MsgFlags, SockFlag, SockType, SockaddrIn,\n    };\n\n    let sock_addr = SockaddrIn::from_str(\"127.0.0.1:6909\").unwrap();\n    let rsock = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    setsockopt(\u0026rsock, sockopt::IpRecvTos, \u0026true).unwrap();\n    bind(rsock.as_raw_fd(), \u0026sock_addr).unwrap();\n\n    let sbuf = [0u8; 2048];\n    let iov1 = [std::io::IoSlice::new(\u0026sbuf)];\n\n    let mut rbuf = [0u8; 2048];\n    let mut iov2 = [std::io::IoSliceMut::new(\u0026mut rbuf)];\n    let mut rcmsg = cmsg_space!(libc::c_int);\n\n    let ssock = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .expect(\"send socket failed\");\n    setsockopt(\u0026ssock, sockopt::Ipv4Tos, \u002620).unwrap();\n\n    // Test the sendmsg control message and check the received packet has the same TOS.\n    let scmsg = ControlMessage::Ipv4Tos(\u002620);\n    sendmsg(\n        ssock.as_raw_fd(),\n        \u0026iov1,\n        \u0026[scmsg],\n        MsgFlags::empty(),\n        Some(\u0026sock_addr),\n    )\n    .unwrap();\n\n    // TODO: this test is weak, but testing for the actual ToS value results in sporadic\n    // failures in CI where the ToS in the message header is not the one set by the\n    // sender, so for now the test only checks for the presence of the ToS in the message\n    // header.\n    let mut tc = None;\n    let recv = recvmsg::\u003c()\u003e(\n        rsock.as_raw_fd(),\n        \u0026mut iov2,\n        Some(\u0026mut rcmsg),\n        MsgFlags::empty(),\n    )\n    .unwrap();\n    for c in recv.cmsgs().unwrap() {\n        if let ControlMessageOwned::Ipv4Tos(t) = c {\n            tc = Some(t);\n        }\n    }\n    assert!(tc.is_some());\n}\n\n#[cfg(target_os = \"linux\")]\n// qemu doesn't seem to be emulating this correctly in these architectures\n#[cfg_attr(\n    all(\n        qemu,\n        any(\n            target_arch = \"mips\",\n            target_arch = \"mips32r6\",\n            target_arch = \"mips64\",\n            target_arch = \"mips64r6\",\n        )\n    ),\n    ignore\n)]\n#[cfg(feature = \"net\")]\n#[test]\npub fn test_ipv6_tclass_udp() {\n    use nix::sys::socket::ControlMessageOwned;\n    use nix::sys::socket::{\n        bind, recvmsg, sendmsg, setsockopt, socket, sockopt, ControlMessage,\n        MsgFlags, SockFlag, SockType, SockaddrIn6,\n    };\n\n    let std_sa = SocketAddrV6::from_str(\"[::1]:6902\").unwrap();\n    let sock_addr: SockaddrIn6 = SockaddrIn6::from(std_sa);\n    let rsock = socket(\n        AddressFamily::Inet6,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    setsockopt(\u0026rsock, sockopt::Ipv6RecvTClass, \u0026true).unwrap();\n    // This bind call with IPV6_RECVTCLASS fails on the Linux aarch64 target with EADDRNOTAVAIL,\n    // so the test will only run if `bind` does not return an error..\n    if bind(rsock.as_raw_fd(), \u0026sock_addr).is_ok() {\n        let sbuf = [0u8; 2048];\n        let iov1 = [std::io::IoSlice::new(\u0026sbuf)];\n\n        let mut rbuf = [0u8; 2048];\n        let mut iov2 = [std::io::IoSliceMut::new(\u0026mut rbuf)];\n        let mut rcmsg = cmsg_space!(libc::c_int);\n\n        let ssock = socket(\n            AddressFamily::Inet6,\n            SockType::Datagram,\n            SockFlag::empty(),\n            None,\n        )\n        .expect(\"send socket failed\");\n        setsockopt(\u0026ssock, sockopt::Ipv6TClass, \u002610).unwrap();\n\n        sendmsg(\n            ssock.as_raw_fd(),\n            \u0026iov1,\n            \u0026[],\n            MsgFlags::empty(),\n            Some(\u0026sock_addr),\n        )\n        .unwrap();\n\n        let mut tc = None;\n        let recv = recvmsg::\u003c()\u003e(\n            rsock.as_raw_fd(),\n            \u0026mut iov2,\n            Some(\u0026mut rcmsg),\n            MsgFlags::empty(),\n        )\n        .unwrap();\n        for c in recv.cmsgs().unwrap() {\n            if let ControlMessageOwned::Ipv6TClass(t) = c {\n                tc = Some(t);\n            }\n        }\n        assert_eq!(tc, Some(10));\n\n        let scmsg = ControlMessage::Ipv6TClass(\u002620);\n        sendmsg(\n            ssock.as_raw_fd(),\n            \u0026iov1,\n            \u0026[scmsg],\n            MsgFlags::empty(),\n            Some(\u0026sock_addr),\n        )\n        .unwrap();\n\n        let mut tc = None;\n        let recv = recvmsg::\u003c()\u003e(\n            rsock.as_raw_fd(),\n            \u0026mut iov2,\n            Some(\u0026mut rcmsg),\n            MsgFlags::empty(),\n        )\n        .unwrap();\n        for c in recv.cmsgs().unwrap() {\n            if let ControlMessageOwned::Ipv6TClass(t) = c {\n                tc = Some(t);\n            }\n        }\n\n        assert_eq!(tc, Some(20));\n    }\n}\n\n#[cfg(linux_android)]\nmod linux_errqueue {\n    use super::FromStr;\n    use nix::sys::socket::*;\n    use std::os::unix::io::AsRawFd;\n\n    // Send a UDP datagram to a bogus destination address and observe an ICMP error (v4).\n    //\n    // Disable the test on QEMU because QEMU emulation of IP_RECVERR is broken (as documented on PR\n    // #1514).\n    #[cfg_attr(qemu, ignore)]\n    #[test]\n    fn test_recverr_v4() {\n        #[repr(u8)]\n        enum IcmpTypes {\n            DestUnreach = 3, // ICMP_DEST_UNREACH\n        }\n        #[repr(u8)]\n        enum IcmpUnreachCodes {\n            PortUnreach = 3, // ICMP_PORT_UNREACH\n        }\n\n        test_recverr_impl::\u003csockaddr_in, _, _\u003e(\n            \"127.0.0.1:6800\",\n            AddressFamily::Inet,\n            sockopt::Ipv4RecvErr,\n            libc::SO_EE_ORIGIN_ICMP,\n            IcmpTypes::DestUnreach as u8,\n            IcmpUnreachCodes::PortUnreach as u8,\n            // Closure handles protocol-specific testing and returns generic sock_extended_err for\n            // protocol-independent test impl.\n            |cmsg| {\n                if let ControlMessageOwned::Ipv4RecvErr(ext_err, err_addr) =\n                    cmsg\n                {\n                    if let Some(origin) = err_addr {\n                        // Validate that our network error originated from 127.0.0.1:0.\n                        assert_eq!(origin.sin_family, AddressFamily::Inet as _);\n                        assert_eq!(\n                            origin.sin_addr.s_addr,\n                            u32::from_be(0x7f000001)\n                        );\n                        assert_eq!(origin.sin_port, 0);\n                    } else {\n                        panic!(\"Expected some error origin\");\n                    }\n                    *ext_err\n                } else {\n                    panic!(\"Unexpected control message {cmsg:?}\");\n                }\n            },\n        )\n    }\n\n    // Essentially the same test as v4.\n    //\n    // Disable the test on QEMU because QEMU emulation of IPV6_RECVERR is broken (as documented on\n    // PR #1514).\n    #[cfg_attr(qemu, ignore)]\n    #[test]\n    fn test_recverr_v6() {\n        #[repr(u8)]\n        enum IcmpV6Types {\n            DestUnreach = 1, // ICMPV6_DEST_UNREACH\n        }\n        #[repr(u8)]\n        enum IcmpV6UnreachCodes {\n            PortUnreach = 4, // ICMPV6_PORT_UNREACH\n        }\n\n        test_recverr_impl::\u003csockaddr_in6, _, _\u003e(\n            \"[::1]:6801\",\n            AddressFamily::Inet6,\n            sockopt::Ipv6RecvErr,\n            libc::SO_EE_ORIGIN_ICMP6,\n            IcmpV6Types::DestUnreach as u8,\n            IcmpV6UnreachCodes::PortUnreach as u8,\n            // Closure handles protocol-specific testing and returns generic sock_extended_err for\n            // protocol-independent test impl.\n            |cmsg| {\n                if let ControlMessageOwned::Ipv6RecvErr(ext_err, err_addr) =\n                    cmsg\n                {\n                    if let Some(origin) = err_addr {\n                        // Validate that our network error originated from localhost:0.\n                        assert_eq!(\n                            origin.sin6_family,\n                            AddressFamily::Inet6 as _\n                        );\n                        assert_eq!(\n                            origin.sin6_addr.s6_addr,\n                            std::net::Ipv6Addr::LOCALHOST.octets()\n                        );\n                        assert_eq!(origin.sin6_port, 0);\n                    } else {\n                        panic!(\"Expected some error origin\");\n                    }\n                    *ext_err\n                } else {\n                    panic!(\"Unexpected control message {cmsg:?}\");\n                }\n            },\n        )\n    }\n\n    fn test_recverr_impl\u003cSA, OPT, TESTF\u003e(\n        sa: \u0026str,\n        af: AddressFamily,\n        opt: OPT,\n        ee_origin: u8,\n        ee_type: u8,\n        ee_code: u8,\n        testf: TESTF,\n    ) where\n        OPT: SetSockOpt\u003cVal = bool\u003e,\n        TESTF: FnOnce(\u0026ControlMessageOwned) -\u003e libc::sock_extended_err,\n    {\n        use nix::errno::Errno;\n        use std::io::IoSliceMut;\n\n        const MESSAGE_CONTENTS: \u0026str = \"ABCDEF\";\n        let std_sa = std::net::SocketAddr::from_str(sa).unwrap();\n        let sock_addr = SockaddrStorage::from(std_sa);\n        let sock = socket(af, SockType::Datagram, SockFlag::SOCK_CLOEXEC, None)\n            .unwrap();\n        setsockopt(\u0026sock, opt, \u0026true).unwrap();\n        if let Err(e) = sendto(\n            sock.as_raw_fd(),\n            MESSAGE_CONTENTS.as_bytes(),\n            \u0026sock_addr,\n            MsgFlags::empty(),\n        ) {\n            assert_eq!(e, Errno::EADDRNOTAVAIL);\n            println!(\"{af:?} not available, skipping test.\");\n            return;\n        }\n\n        let mut buf = [0u8; 8];\n        let mut iovec = [IoSliceMut::new(\u0026mut buf)];\n        let mut cspace = cmsg_space!(libc::sock_extended_err, SA);\n\n        let msg = recvmsg(\n            sock.as_raw_fd(),\n            \u0026mut iovec,\n            Some(\u0026mut cspace),\n            MsgFlags::MSG_ERRQUEUE,\n        )\n        .unwrap();\n        // The sent message / destination associated with the error is returned:\n        assert_eq!(msg.bytes, MESSAGE_CONTENTS.len());\n        // recvmsg(2): \"The original destination address of the datagram that caused the error is\n        // supplied via msg_name;\" however, this is not literally true.  E.g., an earlier version\n        // of this test used 0.0.0.0 (::0) as the destination address, which was mutated into\n        // 127.0.0.1 (::1).\n        assert_eq!(msg.address, Some(sock_addr));\n\n        // Check for expected control message.\n        let ext_err = match msg.cmsgs().unwrap().next() {\n            Some(cmsg) =\u003e testf(\u0026cmsg),\n            None =\u003e panic!(\"No control message\"),\n        };\n\n        assert_eq!(ext_err.ee_errno, libc::ECONNREFUSED as u32);\n        assert_eq!(ext_err.ee_origin, ee_origin);\n        // ip(7): ee_type and ee_code are set from the type and code fields of the ICMP (ICMPv6)\n        // header.\n        assert_eq!(ext_err.ee_type, ee_type);\n        assert_eq!(ext_err.ee_code, ee_code);\n        // ip(7): ee_info contains the discovered MTU for EMSGSIZE errors.\n        assert_eq!(ext_err.ee_info, 0);\n\n        let bytes = msg.bytes;\n        assert_eq!(\u0026buf[..bytes], MESSAGE_CONTENTS.as_bytes());\n    }\n}\n\n// Disable the test on emulated platforms because it fails in Cirrus-CI.  Lack\n// of QEMU support is suspected.\n#[cfg_attr(qemu, ignore)]\n#[cfg(target_os = \"linux\")]\n#[test]\npub fn test_txtime() {\n    use nix::sys::socket::{\n        bind, recvmsg, sendmsg, setsockopt, socket, sockopt, ControlMessage,\n        MsgFlags, SockFlag, SockType, SockaddrIn,\n    };\n    use nix::sys::time::TimeValLike;\n    use nix::time::{clock_gettime, ClockId};\n\n    require_kernel_version!(test_txtime, \"\u003e= 5.8\");\n\n    let sock_addr = SockaddrIn::from_str(\"127.0.0.1:6802\").unwrap();\n\n    let ssock = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .expect(\"send socket failed\");\n\n    let txtime_cfg = libc::sock_txtime {\n        clockid: libc::CLOCK_MONOTONIC,\n        flags: 0,\n    };\n    setsockopt(\u0026ssock, sockopt::TxTime, \u0026txtime_cfg).unwrap();\n\n    let rsock = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    bind(rsock.as_raw_fd(), \u0026sock_addr).unwrap();\n\n    let sbuf = [0u8; 2048];\n    let iov1 = [std::io::IoSlice::new(\u0026sbuf)];\n\n    let now = clock_gettime(ClockId::CLOCK_MONOTONIC).unwrap();\n    let delay = std::time::Duration::from_secs(1).into();\n    let txtime = (now + delay).num_nanoseconds() as u64;\n\n    let cmsg = ControlMessage::TxTime(\u0026txtime);\n    sendmsg(\n        ssock.as_raw_fd(),\n        \u0026iov1,\n        \u0026[cmsg],\n        MsgFlags::empty(),\n        Some(\u0026sock_addr),\n    )\n    .unwrap();\n\n    let mut rbuf = [0u8; 2048];\n    let mut iov2 = [std::io::IoSliceMut::new(\u0026mut rbuf)];\n    recvmsg::\u003c()\u003e(rsock.as_raw_fd(), \u0026mut iov2, None, MsgFlags::empty())\n        .unwrap();\n}\n\n// cfg needed for capability check.\n#[cfg(linux_android)]\n#[test]\nfn test_icmp_protocol() {\n    use nix::sys::socket::{\n        sendto, socket, AddressFamily, MsgFlags, SockFlag, SockProtocol,\n        SockType, SockaddrIn,\n    };\n\n    require_capability!(\"test_icmp_protocol\", CAP_NET_RAW);\n\n    let owned_fd = socket(\n        AddressFamily::Inet,\n        SockType::Raw,\n        SockFlag::empty(),\n        SockProtocol::Icmp,\n    )\n    .unwrap();\n\n    // Send a minimal ICMP packet with no payload.\n    let packet = [\n        0x08, // Type\n        0x00, // Code\n        0x84, 0x85, // Checksum\n        0x73, 0x8a, // ID\n        0x00, 0x00, // Sequence Number\n    ];\n\n    let dest_addr = SockaddrIn::new(127, 0, 0, 1, 0);\n    sendto(owned_fd.as_raw_fd(), \u0026packet, \u0026dest_addr, MsgFlags::empty())\n        .unwrap();\n}\n\n// test contains both recvmmsg and timestaping which is linux only\n// there are existing tests for recvmmsg only in tests/\n#[cfg_attr(qemu, ignore)]\n#[cfg(target_os = \"linux\")]\n#[test]\nfn test_recvmm2() -\u003e nix::Result\u003c()\u003e {\n    use nix::sys::{\n        socket::{\n            bind, recvmmsg, sendmsg, setsockopt, socket, sockopt::Timestamping,\n            AddressFamily, ControlMessageOwned, MsgFlags, MultiHeaders,\n            SockFlag, SockType, SockaddrIn, TimestampingFlag, Timestamps,\n        },\n        time::TimeSpec,\n    };\n    use std::io::{IoSlice, IoSliceMut};\n    use std::os::unix::io::AsRawFd;\n    use std::str::FromStr;\n\n    let sock_addr = SockaddrIn::from_str(\"127.0.0.1:6790\").unwrap();\n\n    let ssock = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )?;\n\n    let rsock = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::SOCK_NONBLOCK,\n        None,\n    )?;\n\n    bind(rsock.as_raw_fd(), \u0026sock_addr)?;\n\n    setsockopt(\u0026rsock, Timestamping, \u0026TimestampingFlag::all())?;\n\n    let sbuf = (0..400).map(|i| i as u8).collect::\u003cVec\u003c_\u003e\u003e();\n\n    let mut recv_buf = vec![0; 1024];\n\n    let mut recv_iovs = Vec::new();\n    let mut pkt_iovs = Vec::new();\n\n    for (ix, chunk) in recv_buf.chunks_mut(256).enumerate() {\n        pkt_iovs.push(IoSliceMut::new(chunk));\n        if ix % 2 == 1 {\n            recv_iovs.push(pkt_iovs);\n            pkt_iovs = Vec::new();\n        }\n    }\n    drop(pkt_iovs);\n\n    let flags = MsgFlags::empty();\n    let iov1 = [IoSlice::new(\u0026sbuf)];\n\n    let cmsg = cmsg_space!(Timestamps);\n    sendmsg(ssock.as_raw_fd(), \u0026iov1, \u0026[], flags, Some(\u0026sock_addr)).unwrap();\n\n    let mut data = MultiHeaders::\u003c()\u003e::preallocate(recv_iovs.len(), Some(cmsg));\n\n    let t = TimeSpec::from_duration(std::time::Duration::from_secs(10));\n\n    let recv = recvmmsg(\n        rsock.as_raw_fd(),\n        \u0026mut data,\n        recv_iovs.iter_mut(),\n        flags,\n        Some(t),\n    )?;\n\n    for rmsg in recv {\n        #[cfg(not(any(qemu, target_arch = \"aarch64\")))]\n        let mut saw_time = false;\n        let mut recvd = 0;\n        for cmsg in rmsg.cmsgs().unwrap() {\n            if let ControlMessageOwned::ScmTimestampsns(timestamps) = cmsg {\n                let ts = timestamps.system;\n\n                let sys_time = nix::time::clock_gettime(\n                    nix::time::ClockId::CLOCK_REALTIME,\n                )?;\n                let diff = if ts \u003e sys_time {\n                    ts - sys_time\n                } else {\n                    sys_time - ts\n                };\n                assert!(std::time::Duration::from(diff).as_secs() \u003c 60);\n                #[cfg(not(any(qemu, target_arch = \"aarch64\")))]\n                {\n                    saw_time = true;\n                }\n            }\n        }\n\n        #[cfg(not(any(qemu, target_arch = \"aarch64\")))]\n        assert!(saw_time);\n\n        for iov in rmsg.iovs() {\n            recvd += iov.len();\n        }\n        assert_eq!(recvd, 400);\n    }\n\n    Ok(())\n}\n\n#[cfg(not(target_os = \"redox\"))]\n#[test]\nfn can_use_cmsg_space() {\n    let _ = cmsg_space!(u8);\n}\n\n#[cfg(not(any(\n    linux_android,\n    target_os = \"redox\",\n    target_os = \"haiku\",\n    target_os = \"cygwin\"\n)))]\n#[test]\nfn can_open_routing_socket() {\n    use nix::sys::socket::{socket, AddressFamily, SockFlag, SockType};\n\n    let _ =\n        socket(AddressFamily::Route, SockType::Raw, SockFlag::empty(), None)\n            .expect(\"Failed to open routing socket\");\n}\n","traces":[{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":2894,"address":[],"length":0,"stats":{"Line":0}},{"line":2895,"address":[],"length":0,"stats":{"Line":0}},{"line":2896,"address":[],"length":0,"stats":{"Line":0}},{"line":2898,"address":[],"length":0,"stats":{"Line":0}},{"line":2900,"address":[],"length":0,"stats":{"Line":0}},{"line":2901,"address":[],"length":0,"stats":{"Line":0}},{"line":2902,"address":[],"length":0,"stats":{"Line":0}},{"line":2903,"address":[],"length":0,"stats":{"Line":0}},{"line":2905,"address":[],"length":0,"stats":{"Line":0}},{"line":2906,"address":[],"length":0,"stats":{"Line":0}},{"line":2907,"address":[],"length":0,"stats":{"Line":0}},{"line":2910,"address":[],"length":0,"stats":{"Line":0}},{"line":2911,"address":[],"length":0,"stats":{"Line":0}},{"line":2912,"address":[],"length":0,"stats":{"Line":0}},{"line":2915,"address":[],"length":0,"stats":{"Line":0}},{"line":2916,"address":[],"length":0,"stats":{"Line":0}},{"line":2917,"address":[],"length":0,"stats":{"Line":0}},{"line":2918,"address":[],"length":0,"stats":{"Line":0}},{"line":2922,"address":[],"length":0,"stats":{"Line":0}},{"line":2927,"address":[],"length":0,"stats":{"Line":0}},{"line":2930,"address":[],"length":0,"stats":{"Line":0}},{"line":2931,"address":[],"length":0,"stats":{"Line":0}},{"line":2932,"address":[],"length":0,"stats":{"Line":0}},{"line":2935,"address":[],"length":0,"stats":{"Line":0}},{"line":2936,"address":[],"length":0,"stats":{"Line":0}},{"line":2939,"address":[],"length":0,"stats":{"Line":0}},{"line":2940,"address":[],"length":0,"stats":{"Line":0}},{"line":2942,"address":[],"length":0,"stats":{"Line":0}},{"line":2944,"address":[],"length":0,"stats":{"Line":0}},{"line":2945,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":49},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_sockopt.rs"],"content":"#[cfg(linux_android)]\nuse crate::*;\nuse nix::sys::socket::{\n    getsockopt, setsockopt, socket, sockopt, AddressFamily, SockFlag,\n    SockProtocol, SockType,\n};\nuse rand::{rng, Rng};\nuse std::os::unix::io::{AsRawFd, FromRawFd, OwnedFd};\n\n// NB: FreeBSD supports LOCAL_PEERCRED for SOCK_SEQPACKET, but OSX does not.\n#[cfg(freebsdlike)]\n#[test]\npub fn test_local_peercred_seqpacket() {\n    use nix::{\n        sys::socket::socketpair,\n        unistd::{Gid, Uid},\n    };\n\n    let (fd1, _fd2) = socketpair(\n        AddressFamily::Unix,\n        SockType::SeqPacket,\n        None,\n        SockFlag::empty(),\n    )\n    .unwrap();\n    let xucred = getsockopt(\u0026fd1, sockopt::LocalPeerCred).unwrap();\n    assert_eq!(xucred.version(), 0);\n    assert_eq!(Uid::from_raw(xucred.uid()), Uid::current());\n    assert_eq!(Gid::from_raw(xucred.groups()[0]), Gid::current());\n}\n\n#[cfg(any(freebsdlike, apple_targets))]\n#[test]\npub fn test_local_peercred_stream() {\n    use nix::{\n        sys::socket::socketpair,\n        unistd::{Gid, Uid},\n    };\n\n    let (fd1, _fd2) = socketpair(\n        AddressFamily::Unix,\n        SockType::Stream,\n        None,\n        SockFlag::empty(),\n    )\n    .unwrap();\n    let xucred = getsockopt(\u0026fd1, sockopt::LocalPeerCred).unwrap();\n    assert_eq!(xucred.version(), 0);\n    assert_eq!(Uid::from_raw(xucred.uid()), Uid::current());\n    assert_eq!(Gid::from_raw(xucred.groups()[0]), Gid::current());\n}\n\n#[cfg(apple_targets)]\n#[test]\npub fn test_local_peer_pid() {\n    use nix::sys::socket::socketpair;\n\n    let (fd1, _fd2) = socketpair(\n        AddressFamily::Unix,\n        SockType::Stream,\n        None,\n        SockFlag::empty(),\n    )\n    .unwrap();\n    let pid = getsockopt(\u0026fd1, sockopt::LocalPeerPid).unwrap();\n    assert_eq!(pid, std::process::id() as _);\n}\n\n#[cfg(apple_targets)]\n#[test]\npub fn test_local_peer_token() {\n    use nix::sys::socket::{audit_token_t, socketpair};\n\n    #[link(name = \"bsm\", kind = \"dylib\")]\n    extern \"C\" {\n        /// Extract the process ID from an `audit_token_t`, used to identify\n        /// Mach tasks and senders of Mach messages as subjects of the audit\n        /// system.\n        ///\n        /// - `atoken`: The Mach audit token.\n        /// - Returns: The process ID extracted from the Mach audit token.\n        fn audit_token_to_pid(atoken: audit_token_t) -\u003e libc::pid_t;\n    }\n\n    let (fd1, _fd2) = socketpair(\n        AddressFamily::Unix,\n        SockType::Stream,\n        None,\n        SockFlag::empty(),\n    )\n    .unwrap();\n    let audit_token = getsockopt(\u0026fd1, sockopt::LocalPeerToken).unwrap();\n    assert_eq!(\n        unsafe { audit_token_to_pid(audit_token) },\n        std::process::id() as _\n    );\n}\n\n#[cfg(target_os = \"linux\")]\n#[test]\nfn is_so_mark_functional() {\n    use nix::sys::socket::sockopt;\n\n    require_capability!(\"is_so_mark_functional\", CAP_NET_ADMIN);\n\n    let s = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    setsockopt(\u0026s, sockopt::Mark, \u00261337).unwrap();\n    let mark = getsockopt(\u0026s, sockopt::Mark).unwrap();\n    assert_eq!(mark, 1337);\n}\n\n#[test]\nfn test_so_buf() {\n    let fd = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        SockProtocol::Udp,\n    )\n    .unwrap();\n    let bufsize: usize = rng().random_range(4096..131_072);\n    setsockopt(\u0026fd, sockopt::SndBuf, \u0026bufsize).unwrap();\n    let actual = getsockopt(\u0026fd, sockopt::SndBuf).unwrap();\n    assert!(actual \u003e= bufsize);\n    setsockopt(\u0026fd, sockopt::RcvBuf, \u0026bufsize).unwrap();\n    let actual = getsockopt(\u0026fd, sockopt::RcvBuf).unwrap();\n    assert!(actual \u003e= bufsize);\n}\n\n#[cfg(target_os = \"freebsd\")]\n#[test]\nfn test_so_listen_q_limit() {\n    use nix::sys::socket::{bind, listen, Backlog, SockaddrIn};\n    use std::net::SocketAddrV4;\n    use std::str::FromStr;\n\n    let std_sa = SocketAddrV4::from_str(\"127.0.0.1:4004\").unwrap();\n    let sock_addr = SockaddrIn::from(std_sa);\n\n    let rsock = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        SockProtocol::Tcp,\n    )\n    .unwrap();\n    bind(rsock.as_raw_fd(), \u0026sock_addr).unwrap();\n    let pre_limit = getsockopt(\u0026rsock, sockopt::ListenQLimit).unwrap();\n    assert_eq!(pre_limit, 0);\n    listen(\u0026rsock, Backlog::new(42).unwrap()).unwrap();\n    let post_limit = getsockopt(\u0026rsock, sockopt::ListenQLimit).unwrap();\n    assert_eq!(post_limit, 42);\n}\n\n#[test]\n#[cfg_attr(target_os = \"cygwin\", ignore)]\nfn test_so_tcp_maxseg() {\n    use nix::sys::socket::{\n        accept, bind, connect, getsockname, listen, Backlog, SockaddrIn,\n    };\n    use std::net::SocketAddrV4;\n    use std::str::FromStr;\n\n    let std_sa = SocketAddrV4::from_str(\"127.0.0.1:0\").unwrap();\n    let mut sock_addr = SockaddrIn::from(std_sa);\n\n    let rsock = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        SockProtocol::Tcp,\n    )\n    .unwrap();\n    bind(rsock.as_raw_fd(), \u0026sock_addr).unwrap();\n    sock_addr = getsockname(rsock.as_raw_fd()).unwrap();\n    listen(\u0026rsock, Backlog::new(10).unwrap()).unwrap();\n    let initial = getsockopt(\u0026rsock, sockopt::TcpMaxSeg).unwrap();\n    // Initial MSS is expected to be 536 (https://tools.ietf.org/html/rfc879#section-1) but some\n    // platforms keep it even lower. This might fail if you've tuned your initial MSS to be larger\n    // than `segsize`\n    let segsize: u32 = 873;\n    assert!(initial \u003c segsize);\n    cfg_if! {\n        if #[cfg(linux_android)] {\n            setsockopt(\u0026rsock, sockopt::TcpMaxSeg, \u0026segsize).unwrap();\n        }\n    }\n\n    // Connect and check the MSS that was advertised\n    let ssock = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        SockProtocol::Tcp,\n    )\n    .unwrap();\n\n    connect(ssock.as_raw_fd(), \u0026sock_addr).unwrap();\n\n    let rsess = accept(rsock.as_raw_fd()).unwrap();\n    let rsess = unsafe { OwnedFd::from_raw_fd(rsess) };\n\n    cfg_if! {\n        if #[cfg(apple_targets)] {\n            // on apple targets (and unlike linux), we can only set the MSS on a *connected*\n            // socket. Also, the same MSS can't be read using getsockopt from the other end.\n\n            assert_ne!(segsize, getsockopt(\u0026rsess, sockopt::TcpMaxSeg).unwrap());\n            setsockopt(\u0026rsess, sockopt::TcpMaxSeg, \u0026segsize).unwrap();\n            assert_eq!(segsize, getsockopt(\u0026rsess, sockopt::TcpMaxSeg).unwrap());\n\n            assert_ne!(segsize, getsockopt(\u0026ssock, sockopt::TcpMaxSeg).unwrap());\n            setsockopt(\u0026ssock, sockopt::TcpMaxSeg, \u0026segsize).unwrap();\n            assert_eq!(segsize, getsockopt(\u0026ssock, sockopt::TcpMaxSeg).unwrap());\n        } else {\n            use nix::unistd::write;\n\n            write(\u0026rsess, b\"hello\").unwrap();\n            let actual = getsockopt(\u0026ssock, sockopt::TcpMaxSeg).unwrap();\n            // Actual max segment size takes header lengths into account, max IPv4 options (60 bytes) + max\n            // TCP options (40 bytes) are subtracted from the requested maximum as a lower boundary.\n            if cfg!(linux_android) {\n                assert!((segsize - 100) \u003c= actual);\n                assert!(actual \u003c= segsize);\n            } else {\n                assert!(initial \u003c actual);\n                assert!(536 \u003c actual);\n            }\n        }\n    }\n}\n\n#[test]\nfn test_so_type() {\n    let sockfd = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n\n    assert_eq!(Ok(SockType::Stream), getsockopt(\u0026sockfd, sockopt::SockType));\n}\n\n/// getsockopt(_, sockopt::SockType) should gracefully handle unknown socket\n/// types.  Regression test for https://github.com/nix-rust/nix/issues/1819\n#[cfg(linux_android)]\n#[test]\nfn test_so_type_unknown() {\n    use nix::errno::Errno;\n\n    require_capability!(\"test_so_type\", CAP_NET_RAW);\n    // SOCK_PACKET is deprecated, but since it is used for testing here, we allow it\n    #[allow(deprecated)]\n    let raw_fd = unsafe { libc::socket(libc::AF_PACKET, libc::SOCK_PACKET, 0) };\n    assert!(raw_fd \u003e= 0, \"Error opening socket: {}\", nix::Error::last());\n    let sockfd = unsafe { OwnedFd::from_raw_fd(raw_fd) };\n\n    assert_eq!(Err(Errno::EINVAL), getsockopt(\u0026sockfd, sockopt::SockType));\n}\n\n// The CI doesn't supported getsockopt and setsockopt on emulated processors.\n// It's believed to be a QEMU issue; the tests run ok on a fully emulated\n// system.  Current CI just runs the binary with QEMU but the kernel remains the\n// same as the host.\n// So the syscall doesn't work properly unless the kernel is also emulated.\n#[test]\n#[cfg(any(target_os = \"freebsd\", target_os = \"linux\"))]\n#[cfg_attr(qemu, ignore)]\nfn test_tcp_congestion() {\n    use std::ffi::OsString;\n    use std::os::unix::ffi::OsStrExt;\n\n    let fd = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n\n    let val = getsockopt(\u0026fd, sockopt::TcpCongestion).unwrap();\n    let bytes = val.as_os_str().as_bytes();\n    for b in bytes.iter() {\n        assert_ne!(*b, 0, \"OsString should contain no embedded NULs: {val:?}\");\n    }\n    setsockopt(\u0026fd, sockopt::TcpCongestion, \u0026val).unwrap();\n\n    setsockopt(\n        \u0026fd,\n        sockopt::TcpCongestion,\n        \u0026OsString::from(\"tcp_congestion_does_not_exist\"),\n    )\n    .unwrap_err();\n\n    assert_eq!(getsockopt(\u0026fd, sockopt::TcpCongestion).unwrap(), val);\n}\n\n#[test]\n#[cfg(target_os = \"freebsd\")]\nfn test_tcp_function_blk_alias() {\n    use std::ffi::CStr;\n\n    let fd = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n\n    let tfs = getsockopt(\u0026fd, sockopt::TcpFunctionBlk).unwrap();\n    let name = unsafe { CStr::from_ptr(tfs.function_set_name.as_ptr()) };\n    assert!(!name.to_bytes().is_empty());\n\n    let aliastfs = getsockopt(\u0026fd, sockopt::TcpFunctionAlias).unwrap();\n    let aliasname =\n        unsafe { CStr::from_ptr(aliastfs.function_set_name.as_ptr()) };\n    // freebsd default tcp stack has no alias.\n    assert!(aliasname.to_bytes().is_empty());\n\n    // We can't know at compile time what options are available.  So just test the setter by a\n    // no-op set.\n    // TODO: test if we can load for example BBR tcp stack kernel module.\n    setsockopt(\u0026fd, sockopt::TcpFunctionBlk, \u0026tfs).unwrap();\n}\n\n#[test]\n#[cfg(linux_android)]\nfn test_bindtodevice() {\n    skip_if_not_root!(\"test_bindtodevice\");\n\n    let fd = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n\n    let val = getsockopt(\u0026fd, sockopt::BindToDevice).unwrap();\n    setsockopt(\u0026fd, sockopt::BindToDevice, \u0026val).unwrap();\n\n    assert_eq!(getsockopt(\u0026fd, sockopt::BindToDevice).unwrap(), val);\n}\n\n#[test]\nfn test_so_tcp_keepalive() {\n    let fd = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        SockProtocol::Tcp,\n    )\n    .unwrap();\n    setsockopt(\u0026fd, sockopt::KeepAlive, \u0026true).unwrap();\n    assert!(getsockopt(\u0026fd, sockopt::KeepAlive).unwrap());\n\n    #[cfg(any(linux_android, freebsdlike))]\n    {\n        let x = getsockopt(\u0026fd, sockopt::TcpKeepIdle).unwrap();\n        setsockopt(\u0026fd, sockopt::TcpKeepIdle, \u0026(x + 1)).unwrap();\n        assert_eq!(getsockopt(\u0026fd, sockopt::TcpKeepIdle).unwrap(), x + 1);\n\n        let x = getsockopt(\u0026fd, sockopt::TcpKeepCount).unwrap();\n        setsockopt(\u0026fd, sockopt::TcpKeepCount, \u0026(x + 1)).unwrap();\n        assert_eq!(getsockopt(\u0026fd, sockopt::TcpKeepCount).unwrap(), x + 1);\n\n        let x = getsockopt(\u0026fd, sockopt::TcpKeepInterval).unwrap();\n        setsockopt(\u0026fd, sockopt::TcpKeepInterval, \u0026(x + 1)).unwrap();\n        assert_eq!(getsockopt(\u0026fd, sockopt::TcpKeepInterval).unwrap(), x + 1);\n    }\n}\n\n#[test]\n#[cfg(linux_android)]\n#[cfg_attr(qemu, ignore)]\nfn test_get_mtu() {\n    use nix::sys::socket::{bind, connect, SockaddrIn};\n    use std::net::SocketAddrV4;\n    use std::str::FromStr;\n\n    let std_sa = SocketAddrV4::from_str(\"127.0.0.1:0\").unwrap();\n    let std_sb = SocketAddrV4::from_str(\"127.0.0.1:4002\").unwrap();\n\n    let usock = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        SockProtocol::Udp,\n    )\n    .unwrap();\n\n    // Bind and initiate connection\n    bind(usock.as_raw_fd(), \u0026SockaddrIn::from(std_sa)).unwrap();\n    connect(usock.as_raw_fd(), \u0026SockaddrIn::from(std_sb)).unwrap();\n\n    // Loopback connections have 2^16 - the maximum - MTU\n    assert_eq!(getsockopt(\u0026usock, sockopt::IpMtu), Ok(u16::MAX as i32))\n}\n\n#[test]\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\nfn test_ttl_opts() {\n    let fd4 = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    setsockopt(\u0026fd4, sockopt::Ipv4Ttl, \u00261)\n        .expect(\"setting ipv4ttl on an inet socket should succeed\");\n    let fd6 = socket(\n        AddressFamily::Inet6,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    setsockopt(\u0026fd6, sockopt::Ipv6Ttl, \u00261)\n        .expect(\"setting ipv6ttl on an inet6 socket should succeed\");\n}\n\n#[test]\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\nfn test_multicast_ttl_opts_ipv4() {\n    let fd4 = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    setsockopt(\u0026fd4, sockopt::IpMulticastTtl, \u00262)\n        .expect(\"setting ipmulticastttl on an inet socket should succeed\");\n}\n\n#[test]\n#[cfg(linux_android)]\nfn test_multicast_ttl_opts_ipv6() {\n    let fd6 = socket(\n        AddressFamily::Inet6,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    setsockopt(\u0026fd6, sockopt::IpMulticastTtl, \u00262)\n        .expect(\"setting ipmulticastttl on an inet6 socket should succeed\");\n}\n\n#[test]\nfn test_ipv6_multicast_hops() {\n    let fd6 = socket(\n        AddressFamily::Inet6,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    setsockopt(\u0026fd6, sockopt::Ipv6MulticastHops, \u00267)\n        .expect(\"setting ipv6multicasthops on an inet6 socket should succeed\");\n}\n\n#[test]\n#[cfg(apple_targets)]\nfn test_dontfrag_opts() {\n    let fd4 = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        SockProtocol::Tcp,\n    )\n    .unwrap();\n    setsockopt(\u0026fd4, sockopt::IpDontFrag, \u0026true)\n        .expect(\"setting IP_DONTFRAG on an inet stream socket should succeed\");\n    setsockopt(\u0026fd4, sockopt::IpDontFrag, \u0026false).expect(\n        \"unsetting IP_DONTFRAG on an inet stream socket should succeed\",\n    );\n    let fd4d = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    setsockopt(\u0026fd4d, sockopt::IpDontFrag, \u0026true).expect(\n        \"setting IP_DONTFRAG on an inet datagram socket should succeed\",\n    );\n    setsockopt(\u0026fd4d, sockopt::IpDontFrag, \u0026false).expect(\n        \"unsetting IP_DONTFRAG on an inet datagram socket should succeed\",\n    );\n}\n\n#[test]\n#[cfg(any(linux_android, apple_targets))]\n// Disable the test under emulation because it fails in Cirrus-CI.  Lack\n// of QEMU support is suspected.\n#[cfg_attr(qemu, ignore)]\nfn test_v6dontfrag_opts() {\n    let fd6 = socket(\n        AddressFamily::Inet6,\n        SockType::Stream,\n        SockFlag::empty(),\n        SockProtocol::Tcp,\n    )\n    .unwrap();\n    setsockopt(\u0026fd6, sockopt::Ipv6DontFrag, \u0026true).expect(\n        \"setting IPV6_DONTFRAG on an inet6 stream socket should succeed\",\n    );\n    setsockopt(\u0026fd6, sockopt::Ipv6DontFrag, \u0026false).expect(\n        \"unsetting IPV6_DONTFRAG on an inet6 stream socket should succeed\",\n    );\n    let fd6d = socket(\n        AddressFamily::Inet6,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    setsockopt(\u0026fd6d, sockopt::Ipv6DontFrag, \u0026true).expect(\n        \"setting IPV6_DONTFRAG on an inet6 datagram socket should succeed\",\n    );\n    setsockopt(\u0026fd6d, sockopt::Ipv6DontFrag, \u0026false).expect(\n        \"unsetting IPV6_DONTFRAG on an inet6 datagram socket should succeed\",\n    );\n}\n\n#[test]\n#[cfg(target_os = \"linux\")]\nfn test_so_priority() {\n    let fd = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        SockProtocol::Tcp,\n    )\n    .unwrap();\n    let priority = 3;\n    setsockopt(\u0026fd, sockopt::Priority, \u0026priority).unwrap();\n    assert_eq!(getsockopt(\u0026fd, sockopt::Priority).unwrap(), priority);\n}\n\n#[test]\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\nfn test_ip_tos() {\n    let fd = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        SockProtocol::Tcp,\n    )\n    .unwrap();\n    let tos = 0x80; // CS4\n    setsockopt(\u0026fd, sockopt::Ipv4Tos, \u0026tos).unwrap();\n    assert_eq!(getsockopt(\u0026fd, sockopt::Ipv4Tos).unwrap(), tos);\n}\n\n#[test]\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\n// Disable the test under emulation because it fails in Cirrus-CI.  Lack\n// of QEMU support is suspected.\n#[cfg_attr(qemu, ignore)]\nfn test_ipv6_tclass() {\n    let fd = socket(\n        AddressFamily::Inet6,\n        SockType::Stream,\n        SockFlag::empty(),\n        SockProtocol::Tcp,\n    )\n    .unwrap();\n    let class = 0x80; // CS4\n    setsockopt(\u0026fd, sockopt::Ipv6TClass, \u0026class).unwrap();\n    assert_eq!(getsockopt(\u0026fd, sockopt::Ipv6TClass).unwrap(), class);\n}\n\n#[test]\n#[cfg(target_os = \"freebsd\")]\nfn test_receive_timestamp() {\n    let fd = socket(\n        AddressFamily::Inet6,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    setsockopt(\u0026fd, sockopt::ReceiveTimestamp, \u0026true).unwrap();\n    assert!(getsockopt(\u0026fd, sockopt::ReceiveTimestamp).unwrap());\n}\n\n#[test]\n#[cfg(target_os = \"freebsd\")]\nfn test_ts_clock_realtime_micro() {\n    use nix::sys::socket::SocketTimestamp;\n\n    let fd = socket(\n        AddressFamily::Inet6,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n\n    // FreeBSD setsockopt docs say to set SO_TS_CLOCK after setting SO_TIMESTAMP.\n    setsockopt(\u0026fd, sockopt::ReceiveTimestamp, \u0026true).unwrap();\n\n    setsockopt(\n        \u0026fd,\n        sockopt::TsClock,\n        \u0026SocketTimestamp::SO_TS_REALTIME_MICRO,\n    )\n    .unwrap();\n    assert_eq!(\n        getsockopt(\u0026fd, sockopt::TsClock).unwrap(),\n        SocketTimestamp::SO_TS_REALTIME_MICRO\n    );\n}\n\n#[test]\n#[cfg(target_os = \"freebsd\")]\nfn test_ts_clock_bintime() {\n    use nix::sys::socket::SocketTimestamp;\n\n    let fd = socket(\n        AddressFamily::Inet6,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n\n    // FreeBSD setsockopt docs say to set SO_TS_CLOCK after setting SO_TIMESTAMP.\n    setsockopt(\u0026fd, sockopt::ReceiveTimestamp, \u0026true).unwrap();\n\n    setsockopt(\u0026fd, sockopt::TsClock, \u0026SocketTimestamp::SO_TS_BINTIME).unwrap();\n    assert_eq!(\n        getsockopt(\u0026fd, sockopt::TsClock).unwrap(),\n        SocketTimestamp::SO_TS_BINTIME\n    );\n}\n\n#[test]\n#[cfg(target_os = \"freebsd\")]\nfn test_ts_clock_realtime() {\n    use nix::sys::socket::SocketTimestamp;\n\n    let fd = socket(\n        AddressFamily::Inet6,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n\n    // FreeBSD setsockopt docs say to set SO_TS_CLOCK after setting SO_TIMESTAMP.\n    setsockopt(\u0026fd, sockopt::ReceiveTimestamp, \u0026true).unwrap();\n\n    setsockopt(\u0026fd, sockopt::TsClock, \u0026SocketTimestamp::SO_TS_REALTIME)\n        .unwrap();\n    assert_eq!(\n        getsockopt(\u0026fd, sockopt::TsClock).unwrap(),\n        SocketTimestamp::SO_TS_REALTIME\n    );\n}\n\n#[test]\n#[cfg(target_os = \"freebsd\")]\nfn test_ts_clock_monotonic() {\n    use nix::sys::socket::SocketTimestamp;\n\n    let fd = socket(\n        AddressFamily::Inet6,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n\n    // FreeBSD setsockopt docs say to set SO_TS_CLOCK after setting SO_TIMESTAMP.\n    setsockopt(\u0026fd, sockopt::ReceiveTimestamp, \u0026true).unwrap();\n\n    setsockopt(\u0026fd, sockopt::TsClock, \u0026SocketTimestamp::SO_TS_MONOTONIC)\n        .unwrap();\n    assert_eq!(\n        getsockopt(\u0026fd, sockopt::TsClock).unwrap(),\n        SocketTimestamp::SO_TS_MONOTONIC\n    );\n}\n\n#[test]\n#[cfg(linux_android)]\n// Disable the test under emulation because it fails with ENOPROTOOPT in CI\n// on cross target. Lack of QEMU support is suspected.\n#[cfg_attr(qemu, ignore)]\nfn test_ip_bind_address_no_port() {\n    let fd = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        SockProtocol::Tcp,\n    )\n    .unwrap();\n    setsockopt(\u0026fd, sockopt::IpBindAddressNoPort, \u0026true).expect(\n        \"setting IP_BIND_ADDRESS_NO_PORT on an inet stream socket should succeed\",\n    );\n    assert!(getsockopt(\u0026fd, sockopt::IpBindAddressNoPort).expect(\n        \"getting IP_BIND_ADDRESS_NO_PORT on an inet stream socket should succeed\",\n    ));\n    setsockopt(\u0026fd, sockopt::IpBindAddressNoPort, \u0026false).expect(\n        \"unsetting IP_BIND_ADDRESS_NO_PORT on an inet stream socket should succeed\",\n    );\n    assert!(!getsockopt(\u0026fd, sockopt::IpBindAddressNoPort).expect(\n        \"getting IP_BIND_ADDRESS_NO_PORT on an inet stream socket should succeed\",\n    ));\n}\n\n#[test]\n#[cfg(linux_android)]\nfn test_tcp_fast_open_connect() {\n    let fd = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        SockProtocol::Tcp,\n    )\n    .unwrap();\n    setsockopt(\u0026fd, sockopt::TcpFastOpenConnect, \u0026true).expect(\n        \"setting TCP_FASTOPEN_CONNECT on an inet stream socket should succeed\",\n    );\n    assert!(getsockopt(\u0026fd, sockopt::TcpFastOpenConnect).expect(\n        \"getting TCP_FASTOPEN_CONNECT on an inet stream socket should succeed\",\n    ));\n    setsockopt(\u0026fd, sockopt::TcpFastOpenConnect, \u0026false).expect(\n        \"unsetting TCP_FASTOPEN_CONNECT on an inet stream socket should succeed\",\n    );\n    assert!(!getsockopt(\u0026fd, sockopt::TcpFastOpenConnect).expect(\n        \"getting TCP_FASTOPEN_CONNECT on an inet stream socket should succeed\",\n    ));\n}\n\n#[cfg(linux_android)]\n#[test]\nfn can_get_peercred_on_unix_socket() {\n    use nix::sys::socket::{socketpair, sockopt, SockFlag, SockType};\n\n    let (a, b) = socketpair(\n        AddressFamily::Unix,\n        SockType::Stream,\n        None,\n        SockFlag::empty(),\n    )\n    .unwrap();\n    let a_cred = getsockopt(\u0026a, sockopt::PeerCredentials).unwrap();\n    let b_cred = getsockopt(\u0026b, sockopt::PeerCredentials).unwrap();\n    assert_eq!(a_cred, b_cred);\n    assert_ne!(a_cred.pid(), 0);\n}\n\n#[cfg(target_os = \"linux\")]\nfn pid_from_pidfd(pidfd: OwnedFd) -\u003e u32 {\n    use std::fs::read_to_string;\n\n    let fd = pidfd.as_raw_fd();\n    let fdinfo = read_to_string(format!(\"/proc/self/fdinfo/{fd}\")).unwrap();\n    let pidline = fdinfo.split('\\n').find(|s| s.starts_with(\"Pid:\")).unwrap();\n    pidline.split('\\t').next_back().unwrap().parse().unwrap()\n}\n\n#[cfg(target_os = \"linux\")]\n#[test]\nfn can_get_peerpidfd_on_unix_socket() {\n    use nix::sys::socket::{socketpair, sockopt, SockFlag, SockType};\n\n    let (a, b) = socketpair(\n        AddressFamily::Unix,\n        SockType::Stream,\n        None,\n        SockFlag::empty(),\n    )\n    .unwrap();\n\n    match (\n        getsockopt(\u0026a, sockopt::PeerPidfd),\n        getsockopt(\u0026b, sockopt::PeerPidfd),\n    ) {\n        (Ok(a_pidfd), Ok(b_pidfd)) =\u003e {\n            let a_pid = pid_from_pidfd(a_pidfd);\n            let b_pid = pid_from_pidfd(b_pidfd);\n            assert_eq!(a_pid, b_pid);\n            assert_ne!(a_pid, 0);\n        }\n        (Err(nix::Error::ENOPROTOOPT), Err(nix::Error::ENOPROTOOPT)) =\u003e {\n            // Pidfd can still be unsupported on some CI runners\n        }\n        (Err(err), _) | (_, Err(err)) =\u003e panic!(\"{err:?}\"),\n    };\n}\n\n#[test]\nfn is_socket_type_unix() {\n    use nix::sys::socket::{socketpair, sockopt, SockFlag, SockType};\n\n    let (a, _b) = socketpair(\n        AddressFamily::Unix,\n        SockType::Stream,\n        None,\n        SockFlag::empty(),\n    )\n    .unwrap();\n    let a_type = getsockopt(\u0026a, sockopt::SockType).unwrap();\n    assert_eq!(a_type, SockType::Stream);\n}\n\n#[test]\nfn is_socket_type_dgram() {\n    use nix::sys::socket::{\n        getsockopt, sockopt, AddressFamily, SockFlag, SockType,\n    };\n\n    let s = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    let s_type = getsockopt(\u0026s, sockopt::SockType).unwrap();\n    assert_eq!(s_type, SockType::Datagram);\n}\n\n#[cfg(any(target_os = \"freebsd\", target_os = \"linux\"))]\n#[test]\nfn can_get_listen_on_tcp_socket() {\n    use nix::sys::socket::{\n        getsockopt, listen, socket, sockopt, AddressFamily, Backlog, SockFlag,\n        SockType,\n    };\n\n    let s = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    let s_listening = getsockopt(\u0026s, sockopt::AcceptConn).unwrap();\n    assert!(!s_listening);\n    listen(\u0026s, Backlog::new(10).unwrap()).unwrap();\n    let s_listening2 = getsockopt(\u0026s, sockopt::AcceptConn).unwrap();\n    assert!(s_listening2);\n}\n\n#[cfg(target_os = \"linux\")]\n// Some architectures running under cross don't support `setsockopt(SOL_TCP, TCP_ULP)`\n// because the cross image is based on Ubuntu 16.04 which predates TCP ULP support\n// (it was added in kernel v4.13 released in 2017). For these architectures,\n// the `setsockopt(SOL_TCP, TCP_ULP, \"tls\", sizeof(\"tls\"))` call succeeds\n// but the subsequent `setsockopt(SOL_TLS, TLS_TX, ...)` call fails with `ENOPROTOOPT`.\n// It's as if the first `setsockopt` call enabled some other option, not `TCP_ULP`.\n// For example, `strace` says:\n//\n//     [pid   813] setsockopt(4, SOL_TCP, 0x1f /* TCP_??? */, [7564404], 4) = 0\n//\n// It's not clear why `setsockopt(SOL_TCP, TCP_ULP)` succeeds if the container image libc doesn't support it,\n// but in any case we can't run the test on such an architecture, so skip it.\n#[cfg_attr(qemu, ignore)]\n#[test]\nfn test_ktls() {\n    use nix::sys::socket::{\n        accept, bind, connect, getsockname, listen, Backlog, SockaddrIn,\n    };\n    use std::net::SocketAddrV4;\n    use std::str::FromStr;\n\n    let std_sa = SocketAddrV4::from_str(\"127.0.0.1:0\").unwrap();\n    let mut sock_addr = SockaddrIn::from(std_sa);\n\n    let rsock = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        SockProtocol::Tcp,\n    )\n    .unwrap();\n    bind(rsock.as_raw_fd(), \u0026sock_addr).unwrap();\n    sock_addr = getsockname(rsock.as_raw_fd()).unwrap();\n    listen(\u0026rsock, Backlog::new(10).unwrap()).unwrap();\n\n    let ssock = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        SockProtocol::Tcp,\n    )\n    .unwrap();\n    connect(ssock.as_raw_fd(), \u0026sock_addr).unwrap();\n\n    let _rsess = accept(rsock.as_raw_fd()).unwrap();\n\n    match setsockopt(\u0026ssock, sockopt::TcpUlp::default(), b\"tls\") {\n        Ok(()) =\u003e (),\n\n        // TLS ULP is not enabled, so we can't test kTLS.\n        Err(nix::Error::ENOENT) =\u003e skip!(\"TLS ULP is not enabled\"),\n\n        Err(err) =\u003e panic!(\"{err:?}\"),\n    }\n\n    // In real life we would do a TLS handshake and extract the protocol version and secrets.\n    // For this test we just make some up.\n\n    let tx = sockopt::TlsCryptoInfo::Aes128Gcm(libc::tls12_crypto_info_aes_gcm_128 {\n        info: libc::tls_crypto_info {\n            version: libc::TLS_1_2_VERSION,\n            cipher_type: libc::TLS_CIPHER_AES_GCM_128,\n        },\n        iv: *b\"\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\",\n        key: *b\"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n        salt: *b\"\\x00\\x01\\x02\\x03\",\n        rec_seq: *b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n    });\n    setsockopt(\u0026ssock, sockopt::TcpTlsTx, \u0026tx)\n        .expect(\"setting TLS_TX after enabling TLS ULP should succeed\");\n\n    let rx = sockopt::TlsCryptoInfo::Aes128Gcm(libc::tls12_crypto_info_aes_gcm_128 {\n        info: libc::tls_crypto_info {\n            version: libc::TLS_1_2_VERSION,\n            cipher_type: libc::TLS_CIPHER_AES_GCM_128,\n        },\n        iv: *b\"\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\",\n        key: *b\"\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\",\n        salt: *b\"\\xf0\\xf1\\xf2\\xf3\",\n        rec_seq: *b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\",\n    });\n    match setsockopt(\u0026ssock, sockopt::TcpTlsRx, \u0026rx) {\n        Ok(()) =\u003e (),\n        Err(nix::Error::ENOPROTOOPT) =\u003e {\n            // TLS_TX was added in v4.13 and TLS_RX in v4.17, so we appear to be between that range.\n            // It's good enough that TLS_TX worked, so let the test succeed.\n        }\n        Err(err) =\u003e panic!(\"{err:?}\"),\n    }\n}\n\n#[test]\n#[cfg(apple_targets)]\nfn test_utun_ifname() {\n    skip_if_not_root!(\"test_utun_ifname\");\n\n    use nix::sys::socket::connect;\n    use nix::sys::socket::SysControlAddr;\n\n    let fd = socket(\n        AddressFamily::System,\n        SockType::Datagram,\n        SockFlag::empty(),\n        SockProtocol::KextControl,\n    )\n    .unwrap();\n\n    let unit = 123;\n    let addr = SysControlAddr::from_name(\n        fd.as_raw_fd(),\n        \"com.apple.net.utun_control\",\n        unit,\n    )\n    .unwrap();\n\n    connect(fd.as_raw_fd(), \u0026addr).unwrap();\n\n    let name = getsockopt(\u0026fd, sockopt::UtunIfname)\n        .expect(\"getting UTUN_OPT_IFNAME on a utun interface should succeed\");\n\n    let expected_name = format!(\"utun{}\", unit - 1);\n    assert_eq!(name.into_string(), Ok(expected_name));\n}\n\n#[test]\n#[cfg(target_os = \"freebsd\")]\nfn test_reuseport_lb() {\n    let fd = socket(\n        AddressFamily::Inet6,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    setsockopt(\u0026fd, sockopt::ReusePortLb, \u0026false).unwrap();\n    assert!(!getsockopt(\u0026fd, sockopt::ReusePortLb).unwrap());\n    setsockopt(\u0026fd, sockopt::ReusePortLb, \u0026true).unwrap();\n    assert!(getsockopt(\u0026fd, sockopt::ReusePortLb).unwrap());\n}\n\n#[test]\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\nfn test_ipv4_recv_ttl_opts() {\n    let fd = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        SockProtocol::Tcp,\n    )\n    .unwrap();\n    setsockopt(\u0026fd, sockopt::Ipv4RecvTtl, \u0026true)\n        .expect(\"setting IP_RECVTTL on an inet stream socket should succeed\");\n    setsockopt(\u0026fd, sockopt::Ipv4RecvTtl, \u0026false)\n        .expect(\"unsetting IP_RECVTTL on an inet stream socket should succeed\");\n    let fdd = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    setsockopt(\u0026fdd, sockopt::Ipv4RecvTtl, \u0026true)\n        .expect(\"setting IP_RECVTTL on an inet datagram socket should succeed\");\n    setsockopt(\u0026fdd, sockopt::Ipv4RecvTtl, \u0026false).expect(\n        \"unsetting IP_RECVTTL on an inet datagram socket should succeed\",\n    );\n}\n\n#[test]\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\nfn test_ipv6_recv_hop_limit_opts() {\n    let fd = socket(\n        AddressFamily::Inet6,\n        SockType::Stream,\n        SockFlag::empty(),\n        SockProtocol::Tcp,\n    )\n    .unwrap();\n    setsockopt(\u0026fd, sockopt::Ipv6RecvHopLimit, \u0026true).expect(\n        \"setting IPV6_RECVHOPLIMIT on an inet6 stream socket should succeed\",\n    );\n    setsockopt(\u0026fd, sockopt::Ipv6RecvHopLimit, \u0026false).expect(\n        \"unsetting IPV6_RECVHOPLIMIT on an inet6 stream socket should succeed\",\n    );\n    let fdd = socket(\n        AddressFamily::Inet6,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    setsockopt(\u0026fdd, sockopt::Ipv6RecvHopLimit, \u0026true).expect(\n        \"setting IPV6_RECVHOPLIMIT on an inet6 datagram socket should succeed\",\n    );\n    setsockopt(\u0026fdd, sockopt::Ipv6RecvHopLimit, \u0026false).expect(\n        \"unsetting IPV6_RECVHOPLIMIT on an inet6 datagram socket should succeed\",\n    );\n}\n\n#[test]\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\nfn test_ipv4_recv_tos_opts() {\n    let fd = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        SockProtocol::Tcp,\n    )\n    .unwrap();\n    setsockopt(\u0026fd, sockopt::IpRecvTos, \u0026true)\n        .expect(\"setting IP_RECVTOS on an inet stream socket should succeed\");\n    setsockopt(\u0026fd, sockopt::IpRecvTos, \u0026false)\n        .expect(\"unsetting IP_RECVTOS on an inet stream socket should succeed\");\n    let fdd = socket(\n        AddressFamily::Inet,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    setsockopt(\u0026fdd, sockopt::IpRecvTos, \u0026true)\n        .expect(\"setting IP_RECVTOS on an inet datagram socket should succeed\");\n    setsockopt(\u0026fdd, sockopt::IpRecvTos, \u0026false).expect(\n        \"unsetting IP_RECVTOS on an inet datagram socket should succeed\",\n    );\n}\n\n#[test]\n#[cfg(any(linux_android, target_os = \"freebsd\"))]\nfn test_ipv6_recv_traffic_class_opts() {\n    let fd = socket(\n        AddressFamily::Inet6,\n        SockType::Stream,\n        SockFlag::empty(),\n        SockProtocol::Tcp,\n    )\n    .unwrap();\n    setsockopt(\u0026fd, sockopt::Ipv6RecvTClass, \u0026true).expect(\n        \"setting IPV6_RECVTCLASS on an inet6 stream socket should succeed\",\n    );\n    setsockopt(\u0026fd, sockopt::Ipv6RecvTClass, \u0026false).expect(\n        \"unsetting IPV6_RECVTCLASS on an inet6 stream socket should succeed\",\n    );\n    let fdd = socket(\n        AddressFamily::Inet6,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    setsockopt(\u0026fdd, sockopt::Ipv6RecvTClass, \u0026true).expect(\n        \"setting IPV6_RECVTCLASS on an inet6 datagram socket should succeed\",\n    );\n    setsockopt(\u0026fdd, sockopt::Ipv6RecvTClass, \u0026false).expect(\n        \"unsetting IPV6_RECVTCLASS on an inet6 datagram socket should succeed\",\n    );\n}\n\n#[cfg(apple_targets)]\n#[test]\nfn test_linger_sec() {\n    let fd = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n\n    let set_linger = libc::linger {\n        l_onoff: 1,\n        l_linger: 1,\n    };\n    setsockopt(\u0026fd, sockopt::LingerSec, \u0026set_linger).unwrap();\n\n    let get_linger = getsockopt(\u0026fd, sockopt::Linger).unwrap();\n    assert_eq!(get_linger.l_linger, set_linger.l_linger * 100);\n}\n\n/// Users should be able to define their own sockopts.\nmod sockopt_impl {\n    use nix::sys::socket::{\n        getsockopt, setsockopt, socket, AddressFamily, SockFlag, SockProtocol,\n        SockType,\n    };\n\n    sockopt_impl!(KeepAlive, Both, libc::SOL_SOCKET, libc::SO_KEEPALIVE, bool);\n\n    #[test]\n    fn test_so_tcp_keepalive() {\n        let fd = socket(\n            AddressFamily::Inet,\n            SockType::Stream,\n            SockFlag::empty(),\n            SockProtocol::Tcp,\n        )\n        .unwrap();\n        setsockopt(\u0026fd, KeepAlive, \u0026true).unwrap();\n        assert!(getsockopt(\u0026fd, KeepAlive).unwrap());\n    }\n\n    sockopt_impl!(\n        Linger,\n        Both,\n        libc::SOL_SOCKET,\n        libc::SO_LINGER,\n        libc::linger\n    );\n    #[test]\n    fn test_linger() {\n        let fd = socket(\n            AddressFamily::Inet,\n            SockType::Stream,\n            SockFlag::empty(),\n            None,\n        )\n        .unwrap();\n\n        let set_linger = libc::linger {\n            l_onoff: 1,\n            l_linger: 42,\n        };\n        setsockopt(\u0026fd, Linger, \u0026set_linger).unwrap();\n\n        let get_linger = getsockopt(\u0026fd, Linger).unwrap();\n        assert_eq!(get_linger.l_linger, set_linger.l_linger);\n    }\n}\n\n#[cfg(solarish)]\n#[test]\nfn test_exclbind() {\n    use nix::errno::Errno;\n    use nix::sys::socket::{\n        bind, socket, AddressFamily, SockFlag, SockType, SockaddrIn,\n    };\n    use std::net::SocketAddrV4;\n    use std::str::FromStr;\n    let fd1 = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    let addr = SocketAddrV4::from_str(\"127.0.0.1:8081\").unwrap();\n    let excl = true;\n\n    setsockopt(\u0026fd1, sockopt::ExclBind, \u0026excl).unwrap();\n    bind(fd1.as_raw_fd(), \u0026SockaddrIn::from(addr)).unwrap();\n    assert_eq!(getsockopt(\u0026fd1, sockopt::ExclBind), Ok(true));\n    let fd2 = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    assert_eq!(\n        bind(fd2.as_raw_fd(), \u0026SockaddrIn::from(addr)),\n        Err(Errno::EADDRINUSE)\n    );\n}\n\n#[cfg(target_os = \"illumos\")]\n#[test]\nfn test_solfilter() {\n    use nix::errno::Errno;\n    let s = socket(\n        AddressFamily::Inet,\n        SockType::Stream,\n        SockFlag::empty(),\n        SockProtocol::Tcp,\n    )\n    .unwrap();\n    let data = std::ffi::OsStr::new(\"httpf\");\n    let attach = sockopt::FilterAttach;\n    let detach = sockopt::FilterDetach;\n\n    // These 2 options won't work unless the needed kernel module is installed:\n    // https://github.com/nix-rust/nix/pull/2611#issuecomment-2750237782\n    //\n    // So we only test the binding here\n    assert_eq!(Err(Errno::ENOENT), setsockopt(\u0026s, attach, data));\n    assert_eq!(Err(Errno::ENOENT), setsockopt(\u0026s, detach, data));\n}\n\n#[cfg(target_os = \"linux\")]\n#[test]\npub fn test_so_attach_reuseport_cbpf() {\n    let fd = socket(\n        AddressFamily::Inet6,\n        SockType::Datagram,\n        SockFlag::empty(),\n        None,\n    )\n    .unwrap();\n    setsockopt(\u0026fd, sockopt::ReusePort, \u0026true).unwrap();\n    setsockopt(\u0026fd, sockopt::ReuseAddr, \u0026true).unwrap();\n    let mut flt: [libc::sock_filter; 2] = unsafe { std::mem::zeroed() };\n    flt[0].code = (libc::BPF_LD | libc::BPF_W | libc::BPF_ABS) as u16;\n    flt[0].k = (libc::SKF_AD_OFF + libc::SKF_AD_CPU) as u32;\n    flt[1].code = (libc::BPF_RET | 0x10) as u16;\n    let fp = libc::sock_fprog {\n        len: flt.len() as u16,\n        filter: flt.as_mut_ptr(),\n    };\n    setsockopt(\u0026fd, sockopt::AttachReusePortCbpf, \u0026fp).unwrap_or_else(|e| {\n        assert_eq!(e, nix::errno::Errno::ENOPROTOOPT);\n    });\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_stat.rs"],"content":"#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nuse std::fs;\nuse std::fs::File;\n#[cfg(not(target_os = \"redox\"))]\nuse std::os::unix::fs::symlink;\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nuse std::os::unix::fs::PermissionsExt;\n#[cfg(not(target_os = \"redox\"))]\nuse std::path::Path;\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nuse std::time::{Duration, UNIX_EPOCH};\n\nuse libc::mode_t;\n#[cfg(not(any(target_os = \"netbsd\", target_os = \"redox\")))]\nuse libc::{S_IFLNK, S_IFMT};\n\n#[cfg(not(target_os = \"redox\"))]\nuse nix::errno::Errno;\n#[cfg(not(target_os = \"redox\"))]\nuse nix::fcntl;\n#[cfg(any(\n    target_os = \"linux\",\n    apple_targets,\n    target_os = \"freebsd\",\n    target_os = \"netbsd\"\n))]\nuse nix::sys::stat::lutimes;\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nuse nix::sys::stat::utimensat;\n#[cfg(not(target_os = \"redox\"))]\nuse nix::sys::stat::FchmodatFlags;\nuse nix::sys::stat::Mode;\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nuse nix::sys::stat::UtimensatFlags;\n#[cfg(not(target_os = \"redox\"))]\nuse nix::sys::stat::{self};\nuse nix::sys::stat::{fchmod, stat};\n#[cfg(not(target_os = \"redox\"))]\nuse nix::sys::stat::{fchmodat, mkdirat};\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nuse nix::sys::stat::{futimens, utimes};\n\n#[cfg(not(any(target_os = \"netbsd\", target_os = \"redox\")))]\nuse nix::sys::stat::FileStat;\n\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nuse nix::sys::time::{TimeSpec, TimeVal, TimeValLike};\n#[cfg(not(target_os = \"redox\"))]\nuse nix::unistd::chdir;\n\n#[cfg(not(any(target_os = \"netbsd\", target_os = \"redox\")))]\nuse nix::Result;\n\n#[cfg(not(any(target_os = \"netbsd\", target_os = \"redox\")))]\nfn assert_stat_results(stat_result: Result\u003cFileStat\u003e) {\n    let stats = stat_result.expect(\"stat call failed\");\n    assert!(stats.st_dev \u003e 0); // must be positive integer, exact number machine dependent\n    assert!(stats.st_ino \u003e 0); // inode is positive integer, exact number machine dependent\n    assert!(stats.st_mode \u003e 0); // must be positive integer\n    assert_eq!(stats.st_nlink, 1); // there links created, must be 1\n    assert_eq!(stats.st_size, 0); // size is 0 because we did not write anything to the file\n    assert!(stats.st_blksize \u003e 0); // must be positive integer, exact number machine dependent\n    assert!(stats.st_blocks \u003c= 16); // Up to 16 blocks can be allocated for a blank file\n}\n\n#[cfg(not(any(target_os = \"netbsd\", target_os = \"redox\")))]\n// (Android's st_blocks is ulonglong which is always non-negative.)\n#[cfg_attr(target_os = \"android\", allow(unused_comparisons))]\n#[allow(clippy::absurd_extreme_comparisons)] // Not absurd on all OSes\nfn assert_lstat_results(stat_result: Result\u003cFileStat\u003e) {\n    let stats = stat_result.expect(\"stat call failed\");\n    assert!(stats.st_dev \u003e 0); // must be positive integer, exact number machine dependent\n    assert!(stats.st_ino \u003e 0); // inode is positive integer, exact number machine dependent\n    assert!(stats.st_mode \u003e 0); // must be positive integer\n\n    // st_mode is c_uint (u32 on Android) while S_IFMT is mode_t\n    // (u16 on Android), and that will be a compile error.\n    // On other platforms they are the same (either both are u16 or u32).\n    assert_eq!(\n        (stats.st_mode as usize) \u0026 (S_IFMT as usize),\n        S_IFLNK as usize\n    ); // should be a link\n    assert_eq!(stats.st_nlink, 1); // there links created, must be 1\n    assert!(stats.st_size \u003e 0); // size is \u003e 0 because it points to another file\n    assert!(stats.st_blksize \u003e 0); // must be positive integer, exact number machine dependent\n\n    // st_blocks depends on whether the machine's file system uses fast\n    // or slow symlinks, so just make sure it's not negative\n    assert!(stats.st_blocks \u003e= 0);\n}\n\n#[test]\n#[cfg(not(any(target_os = \"netbsd\", target_os = \"redox\")))]\nfn test_stat_and_fstat() {\n    use nix::sys::stat::fstat;\n\n    let tempdir = tempfile::tempdir().unwrap();\n    let filename = tempdir.path().join(\"foo.txt\");\n    let file = File::create(\u0026filename).unwrap();\n\n    let stat_result = stat(\u0026filename);\n    assert_stat_results(stat_result);\n\n    let fstat_result = fstat(\u0026file);\n    assert_stat_results(fstat_result);\n}\n\n#[test]\n#[cfg(not(any(target_os = \"netbsd\", target_os = \"redox\")))]\nfn test_fstatat() {\n    let tempdir = tempfile::tempdir().unwrap();\n    let filename = tempdir.path().join(\"foo.txt\");\n    File::create(\u0026filename).unwrap();\n    let dirfd =\n        fcntl::open(tempdir.path(), fcntl::OFlag::empty(), stat::Mode::empty())\n            .unwrap();\n\n    let result = stat::fstatat(\u0026dirfd, \u0026filename, fcntl::AtFlags::empty());\n    assert_stat_results(result);\n}\n\n#[test]\n#[cfg(not(any(target_os = \"netbsd\", target_os = \"redox\")))]\nfn test_stat_fstat_lstat() {\n    use nix::sys::stat::{fstat, lstat};\n\n    let tempdir = tempfile::tempdir().unwrap();\n    let filename = tempdir.path().join(\"bar.txt\");\n    let linkname = tempdir.path().join(\"barlink\");\n\n    File::create(\u0026filename).unwrap();\n    symlink(\"bar.txt\", \u0026linkname).unwrap();\n    let link = File::open(\u0026linkname).unwrap();\n\n    // should be the same result as calling stat,\n    // since it's a regular file\n    let stat_result = stat(\u0026filename);\n    assert_stat_results(stat_result);\n\n    let lstat_result = lstat(\u0026linkname);\n    assert_lstat_results(lstat_result);\n\n    let fstat_result = fstat(\u0026link);\n    assert_stat_results(fstat_result);\n}\n\n#[test]\nfn test_fchmod() {\n    let tempdir = tempfile::tempdir().unwrap();\n    let filename = tempdir.path().join(\"foo.txt\");\n    let file = File::create(\u0026filename).unwrap();\n\n    let mut mode1 = Mode::empty();\n    mode1.insert(Mode::S_IRUSR);\n    mode1.insert(Mode::S_IWUSR);\n    fchmod(\u0026file, mode1).unwrap();\n\n    let file_stat1 = stat(\u0026filename).unwrap();\n    assert_eq!(file_stat1.st_mode as mode_t \u0026 0o7777, mode1.bits());\n\n    let mut mode2 = Mode::empty();\n    mode2.insert(Mode::S_IROTH);\n    fchmod(\u0026file, mode2).unwrap();\n\n    let file_stat2 = stat(\u0026filename).unwrap();\n    assert_eq!(file_stat2.st_mode as mode_t \u0026 0o7777, mode2.bits());\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_fchmodat() {\n    let _dr = crate::DirRestore::new();\n    let tempdir = tempfile::tempdir().unwrap();\n    let filename = \"foo.txt\";\n    let fullpath = tempdir.path().join(filename);\n    File::create(\u0026fullpath).unwrap();\n\n    let dirfd =\n        fcntl::open(tempdir.path(), fcntl::OFlag::empty(), stat::Mode::empty())\n            .unwrap();\n\n    let mut mode1 = Mode::empty();\n    mode1.insert(Mode::S_IRUSR);\n    mode1.insert(Mode::S_IWUSR);\n    fchmodat(\u0026dirfd, filename, mode1, FchmodatFlags::FollowSymlink).unwrap();\n\n    let file_stat1 = stat(\u0026fullpath).unwrap();\n    assert_eq!(file_stat1.st_mode as mode_t \u0026 0o7777, mode1.bits());\n\n    chdir(tempdir.path()).unwrap();\n\n    let mut mode2 = Mode::empty();\n    mode2.insert(Mode::S_IROTH);\n    fchmodat(\n        fcntl::AT_FDCWD,\n        filename,\n        mode2,\n        FchmodatFlags::FollowSymlink,\n    )\n    .unwrap();\n\n    let file_stat2 = stat(\u0026fullpath).unwrap();\n    assert_eq!(file_stat2.st_mode as mode_t \u0026 0o7777, mode2.bits());\n}\n\n/// Asserts that the atime and mtime in a file's metadata match expected values.\n///\n/// The atime and mtime are expressed with a resolution of seconds because some file systems\n/// (like macOS's HFS+) do not have higher granularity.\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nfn assert_times_eq(\n    exp_atime_sec: u64,\n    exp_mtime_sec: u64,\n    attr: \u0026fs::Metadata,\n) {\n    assert_eq!(\n        Duration::new(exp_atime_sec, 0),\n        attr.accessed().unwrap().duration_since(UNIX_EPOCH).unwrap()\n    );\n    assert_eq!(\n        Duration::new(exp_mtime_sec, 0),\n        attr.modified().unwrap().duration_since(UNIX_EPOCH).unwrap()\n    );\n}\n\n#[test]\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nfn test_utimes() {\n    let tempdir = tempfile::tempdir().unwrap();\n    let fullpath = tempdir.path().join(\"file\");\n    drop(File::create(\u0026fullpath).unwrap());\n\n    utimes(\u0026fullpath, \u0026TimeVal::seconds(9990), \u0026TimeVal::seconds(5550))\n        .unwrap();\n    assert_times_eq(9990, 5550, \u0026fs::metadata(\u0026fullpath).unwrap());\n}\n\n#[test]\n#[cfg(any(\n    target_os = \"linux\",\n    apple_targets,\n    target_os = \"freebsd\",\n    target_os = \"netbsd\"\n))]\nfn test_lutimes() {\n    let tempdir = tempfile::tempdir().unwrap();\n    let target = tempdir.path().join(\"target\");\n    let fullpath = tempdir.path().join(\"symlink\");\n    drop(File::create(\u0026target).unwrap());\n    symlink(\u0026target, \u0026fullpath).unwrap();\n\n    let exp_target_metadata = fs::symlink_metadata(\u0026target).unwrap();\n    lutimes(\u0026fullpath, \u0026TimeVal::seconds(4560), \u0026TimeVal::seconds(1230))\n        .unwrap();\n    assert_times_eq(4560, 1230, \u0026fs::symlink_metadata(\u0026fullpath).unwrap());\n\n    let target_metadata = fs::symlink_metadata(\u0026target).unwrap();\n    assert_eq!(\n        exp_target_metadata.accessed().unwrap(),\n        target_metadata.accessed().unwrap(),\n        \"atime of symlink target was unexpectedly modified\"\n    );\n    assert_eq!(\n        exp_target_metadata.modified().unwrap(),\n        target_metadata.modified().unwrap(),\n        \"mtime of symlink target was unexpectedly modified\"\n    );\n}\n\n#[test]\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nfn test_futimens() {\n    let tempdir = tempfile::tempdir().unwrap();\n    let fullpath = tempdir.path().join(\"file\");\n    drop(File::create(\u0026fullpath).unwrap());\n\n    let fd = fcntl::open(\u0026fullpath, fcntl::OFlag::empty(), stat::Mode::empty())\n        .unwrap();\n\n    futimens(\u0026fd, \u0026TimeSpec::seconds(10), \u0026TimeSpec::seconds(20)).unwrap();\n    assert_times_eq(10, 20, \u0026fs::metadata(\u0026fullpath).unwrap());\n}\n\n#[test]\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nfn test_utimensat() {\n    let _dr = crate::DirRestore::new();\n    let tempdir = tempfile::tempdir().unwrap();\n    let filename = \"foo.txt\";\n    let fullpath = tempdir.path().join(filename);\n    drop(File::create(\u0026fullpath).unwrap());\n\n    let dirfd =\n        fcntl::open(tempdir.path(), fcntl::OFlag::empty(), stat::Mode::empty())\n            .unwrap();\n\n    utimensat(\n        \u0026dirfd,\n        filename,\n        \u0026TimeSpec::seconds(12345),\n        \u0026TimeSpec::seconds(678),\n        UtimensatFlags::FollowSymlink,\n    )\n    .unwrap();\n    assert_times_eq(12345, 678, \u0026fs::metadata(\u0026fullpath).unwrap());\n\n    chdir(tempdir.path()).unwrap();\n\n    utimensat(\n        fcntl::AT_FDCWD,\n        filename,\n        \u0026TimeSpec::seconds(500),\n        \u0026TimeSpec::seconds(800),\n        UtimensatFlags::FollowSymlink,\n    )\n    .unwrap();\n    assert_times_eq(500, 800, \u0026fs::metadata(\u0026fullpath).unwrap());\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_mkdirat_success_path() {\n    let tempdir = tempfile::tempdir().unwrap();\n    let filename = \"example_subdir\";\n    let dirfd =\n        fcntl::open(tempdir.path(), fcntl::OFlag::empty(), stat::Mode::empty())\n            .unwrap();\n    mkdirat(\u0026dirfd, filename, Mode::S_IRWXU).expect(\"mkdirat failed\");\n    assert!(Path::exists(\u0026tempdir.path().join(filename)));\n}\n\n#[test]\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nfn test_mkdirat_success_mode() {\n    let expected_bits =\n        stat::SFlag::S_IFDIR.bits() | stat::Mode::S_IRWXU.bits();\n    let tempdir = tempfile::tempdir().unwrap();\n    let filename = \"example_subdir\";\n    let dirfd =\n        fcntl::open(tempdir.path(), fcntl::OFlag::empty(), stat::Mode::empty())\n            .unwrap();\n    mkdirat(\u0026dirfd, filename, Mode::S_IRWXU).expect(\"mkdirat failed\");\n    let permissions = fs::metadata(tempdir.path().join(filename))\n        .unwrap()\n        .permissions();\n    let mode = permissions.mode();\n    assert_eq!(mode as mode_t, expected_bits)\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_mkdirat_fail() {\n    let tempdir = tempfile::tempdir().unwrap();\n    let not_dir_filename = \"example_not_dir\";\n    let filename = \"example_subdir_dir\";\n    let dirfd = fcntl::open(\n        \u0026tempdir.path().join(not_dir_filename),\n        fcntl::OFlag::O_CREAT,\n        stat::Mode::empty(),\n    )\n    .unwrap();\n    let result = mkdirat(dirfd, filename, Mode::S_IRWXU).unwrap_err();\n    assert_eq!(result, Errno::ENOTDIR);\n}\n\n#[test]\n#[cfg(not(any(\n    freebsdlike,\n    apple_targets,\n    target_os = \"haiku\",\n    target_os = \"redox\",\n    target_os = \"solaris\"\n)))]\nfn test_mknod() {\n    use stat::{lstat, mknod, SFlag};\n\n    let file_name = \"test_file\";\n    let tempdir = tempfile::tempdir().unwrap();\n    let target = tempdir.path().join(file_name);\n    mknod(\u0026target, SFlag::S_IFREG, Mode::S_IRWXU, 0).unwrap();\n    let mode = lstat(\u0026target).unwrap().st_mode as mode_t;\n    assert_eq!(mode \u0026 libc::S_IFREG, libc::S_IFREG);\n    assert_eq!(mode \u0026 libc::S_IRWXU, libc::S_IRWXU);\n}\n\n#[test]\n#[cfg(not(any(\n    solarish,\n    freebsdlike,\n    apple_targets,\n    target_os = \"haiku\",\n    target_os = \"redox\"\n)))]\nfn test_mknodat() {\n    use fcntl::{AtFlags, OFlag};\n    use nix::dir::Dir;\n    use stat::{fstatat, mknodat, SFlag};\n\n    let file_name = \"test_file\";\n    let tempdir = tempfile::tempdir().unwrap();\n    let target_dir =\n        Dir::open(tempdir.path(), OFlag::O_DIRECTORY, Mode::S_IRWXU).unwrap();\n    mknodat(\u0026target_dir, file_name, SFlag::S_IFREG, Mode::S_IRWXU, 0).unwrap();\n    let mode = fstatat(\u0026target_dir, file_name, AtFlags::AT_SYMLINK_NOFOLLOW)\n        .unwrap()\n        .st_mode as mode_t;\n    assert_eq!(mode \u0026 libc::S_IFREG, libc::S_IFREG);\n    assert_eq!(mode \u0026 libc::S_IRWXU, libc::S_IRWXU);\n}\n\n#[test]\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nfn test_futimens_unchanged() {\n    let tempdir = tempfile::tempdir().unwrap();\n    let fullpath = tempdir.path().join(\"file\");\n    drop(File::create(\u0026fullpath).unwrap());\n    let fd = fcntl::open(\u0026fullpath, fcntl::OFlag::empty(), stat::Mode::empty())\n        .unwrap();\n\n    let old_atime = fs::metadata(fullpath.as_path())\n        .unwrap()\n        .accessed()\n        .unwrap();\n    let old_mtime = fs::metadata(fullpath.as_path())\n        .unwrap()\n        .modified()\n        .unwrap();\n\n    futimens(\u0026fd, \u0026TimeSpec::UTIME_OMIT, \u0026TimeSpec::UTIME_OMIT).unwrap();\n\n    let new_atime = fs::metadata(fullpath.as_path())\n        .unwrap()\n        .accessed()\n        .unwrap();\n    let new_mtime = fs::metadata(fullpath.as_path())\n        .unwrap()\n        .modified()\n        .unwrap();\n    assert_eq!(old_atime, new_atime);\n    assert_eq!(old_mtime, new_mtime);\n}\n\n#[test]\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nfn test_utimensat_unchanged() {\n    let _dr = crate::DirRestore::new();\n    let tempdir = tempfile::tempdir().unwrap();\n    let filename = \"foo.txt\";\n    let fullpath = tempdir.path().join(filename);\n    drop(File::create(\u0026fullpath).unwrap());\n    let dirfd =\n        fcntl::open(tempdir.path(), fcntl::OFlag::empty(), stat::Mode::empty())\n            .unwrap();\n\n    let old_atime = fs::metadata(fullpath.as_path())\n        .unwrap()\n        .accessed()\n        .unwrap();\n    let old_mtime = fs::metadata(fullpath.as_path())\n        .unwrap()\n        .modified()\n        .unwrap();\n    utimensat(\n        \u0026dirfd,\n        filename,\n        \u0026TimeSpec::UTIME_OMIT,\n        \u0026TimeSpec::UTIME_OMIT,\n        UtimensatFlags::NoFollowSymlink,\n    )\n    .unwrap();\n    let new_atime = fs::metadata(fullpath.as_path())\n        .unwrap()\n        .accessed()\n        .unwrap();\n    let new_mtime = fs::metadata(fullpath.as_path())\n        .unwrap()\n        .modified()\n        .unwrap();\n    assert_eq!(old_atime, new_atime);\n    assert_eq!(old_mtime, new_mtime);\n}\n\n// The conversion is not useless on all platforms.\n#[allow(clippy::useless_conversion)]\n#[cfg(target_os = \"freebsd\")]\n#[test]\nfn test_chflags() {\n    use nix::{\n        sys::stat::{fstat, FileFlag},\n        unistd::chflags,\n    };\n    use tempfile::NamedTempFile;\n\n    let f = NamedTempFile::new().unwrap();\n\n    let initial =\n        FileFlag::from_bits_truncate(fstat(\u0026f).unwrap().st_flags.into());\n    // UF_OFFLINE is preserved by all FreeBSD file systems, but not interpreted\n    // in any way, so it's handy for testing.\n    let commanded = initial ^ FileFlag::UF_OFFLINE;\n\n    chflags(f.path(), commanded).unwrap();\n\n    let changed =\n        FileFlag::from_bits_truncate(fstat(\u0026f).unwrap().st_flags.into());\n\n    assert_eq!(commanded, changed);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_statfs.rs"],"content":"use nix::sys::statfs::*;\nuse nix::sys::statvfs::*;\nuse std::fs::File;\nuse std::path::Path;\n\nfn check_fstatfs(path: \u0026str) {\n    if !Path::new(path).exists() {\n        return;\n    }\n    let vfs = statvfs(path.as_bytes()).unwrap();\n    let file = File::open(path).unwrap();\n    let fs = fstatfs(\u0026file).unwrap();\n    assert_fs_equals(fs, vfs);\n}\n\nfn check_statfs(path: \u0026str) {\n    if !Path::new(path).exists() {\n        return;\n    }\n    let vfs = statvfs(path.as_bytes()).unwrap();\n    let fs = statfs(path.as_bytes()).unwrap();\n    assert_fs_equals(fs, vfs);\n}\n\nfn check_fstatfs_strict(path: \u0026str) {\n    if !Path::new(path).exists() {\n        return;\n    }\n    let vfs = statvfs(path.as_bytes());\n    let file = File::open(path).unwrap();\n    let fs = fstatfs(\u0026file);\n    assert_fs_equals_strict(fs.unwrap(), vfs.unwrap())\n}\n\nfn check_statfs_strict(path: \u0026str) {\n    if !Path::new(path).exists() {\n        return;\n    }\n    let vfs = statvfs(path.as_bytes());\n    let fs = statfs(path.as_bytes());\n    assert_fs_equals_strict(fs.unwrap(), vfs.unwrap())\n}\n\n// The cast is not unnecessary on all platforms.\n#[allow(clippy::unnecessary_cast)]\nfn assert_fs_equals(fs: Statfs, vfs: Statvfs) {\n    assert_eq!(fs.blocks() as u64, vfs.blocks() as u64);\n    assert_eq!(fs.block_size() as u64, vfs.fragment_size() as u64);\n}\n\n#[test]\nfn statfs_call() {\n    check_statfs(\"/tmp\");\n    check_statfs(\"/dev\");\n    check_statfs(\"/run\");\n    check_statfs(\"/\");\n}\n\n#[test]\nfn fstatfs_call() {\n    check_fstatfs(\"/tmp\");\n    check_fstatfs(\"/dev\");\n    check_fstatfs(\"/run\");\n    check_fstatfs(\"/\");\n}\n\n// This test is ignored because files_free/blocks_free can change after statvfs call and before\n// statfs call.\n#[test]\n#[ignore]\nfn statfs_call_strict() {\n    check_statfs_strict(\"/tmp\");\n    check_statfs_strict(\"/dev\");\n    check_statfs_strict(\"/run\");\n    check_statfs_strict(\"/\");\n}\n\n// This test is ignored because files_free/blocks_free can change after statvfs call and before\n// fstatfs call.\n#[test]\n#[ignore]\nfn fstatfs_call_strict() {\n    check_fstatfs_strict(\"/tmp\");\n    check_fstatfs_strict(\"/dev\");\n    check_fstatfs_strict(\"/run\");\n    check_fstatfs_strict(\"/\");\n}\n\n// The cast is not unnecessary on all platforms.\n#[allow(clippy::unnecessary_cast)]\nfn assert_fs_equals_strict(fs: Statfs, vfs: Statvfs) {\n    assert_eq!(fs.files_free() as u64, vfs.files_free() as u64);\n    assert_eq!(fs.blocks_free() as u64, vfs.blocks_free() as u64);\n    assert_eq!(fs.blocks_available() as u64, vfs.blocks_available() as u64);\n    assert_eq!(fs.files() as u64, vfs.files() as u64);\n    assert_eq!(fs.blocks() as u64, vfs.blocks() as u64);\n    assert_eq!(fs.block_size() as u64, vfs.fragment_size() as u64);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_statvfs.rs"],"content":"use nix::sys::statvfs::*;\nuse std::fs::File;\n\n#[test]\nfn statvfs_call() {\n    statvfs(\u0026b\"/\"[..]).unwrap();\n}\n\n#[test]\nfn fstatvfs_call() {\n    let root = File::open(\"/\").unwrap();\n    fstatvfs(\u0026root).unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_sysinfo.rs"],"content":"use nix::sys::sysinfo::*;\n\n#[test]\nfn sysinfo_works() {\n    let info = sysinfo().unwrap();\n\n    let (l1, l5, l15) = info.load_average();\n    assert!(l1 \u003e= 0.0);\n    assert!(l5 \u003e= 0.0);\n    assert!(l15 \u003e= 0.0);\n\n    info.uptime(); // just test Duration construction\n\n    assert!(\n        info.swap_free() \u003c= info.swap_total(),\n        \"more swap available than installed (free: {}, total: {})\",\n        info.swap_free(),\n        info.swap_total()\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_termios.rs"],"content":"use std::os::unix::io::AsFd;\nuse tempfile::tempfile;\n\nuse nix::errno::Errno;\nuse nix::fcntl;\nuse nix::pty::openpty;\nuse nix::sys::termios::{self, tcgetattr, BaudRate, LocalFlags, OutputFlags};\nuse nix::unistd::{read, write};\n\n/// Helper function analogous to `std::io::Write::write_all`, but for `Fd`s\nfn write_all\u003cFd: AsFd\u003e(f: Fd, buf: \u0026[u8]) {\n    let mut len = 0;\n    while len \u003c buf.len() {\n        len += write(f.as_fd(), \u0026buf[len..]).unwrap();\n    }\n}\n\n#[test]\nfn test_baudrate_try_from() {\n    assert_eq!(Ok(BaudRate::B0), BaudRate::try_from(libc::B0));\n    #[cfg(not(target_os = \"haiku\"))]\n    BaudRate::try_from(999999999).expect_err(\"assertion failed\");\n    #[cfg(target_os = \"haiku\")]\n    BaudRate::try_from(99).expect_err(\"assertion failed\");\n}\n\n// Test tcgetattr on a terminal\n#[test]\nfn test_tcgetattr_pty() {\n    // openpty uses ptname(3) internally\n    let _m = crate::PTSNAME_MTX.lock();\n\n    let pty = openpty(None, None).expect(\"openpty failed\");\n    termios::tcgetattr(\u0026pty.slave).unwrap();\n}\n\n// Test tcgetattr on something that isn't a terminal\n#[test]\nfn test_tcgetattr_enotty() {\n    let file = tempfile().unwrap();\n    assert_eq!(termios::tcgetattr(\u0026file).err(), Some(Errno::ENOTTY));\n}\n\n// Test modifying output flags\n#[test]\nfn test_output_flags() {\n    // openpty uses ptname(3) internally\n    let _m = crate::PTSNAME_MTX.lock();\n\n    // Open one pty to get attributes for the second one\n    let mut termios = {\n        let pty = openpty(None, None).expect(\"openpty failed\");\n        tcgetattr(\u0026pty.slave).expect(\"tcgetattr failed\")\n    };\n\n    // Make sure postprocessing '\\r' isn't specified by default or this test is useless.\n    assert!(!termios\n        .output_flags\n        .contains(OutputFlags::OPOST | OutputFlags::OCRNL));\n\n    // Specify that '\\r' characters should be transformed to '\\n'\n    // OPOST is specified to enable post-processing\n    termios\n        .output_flags\n        .insert(OutputFlags::OPOST | OutputFlags::OCRNL);\n\n    // Open a pty\n    let pty = openpty(None, \u0026termios).unwrap();\n\n    // Write into the master\n    let string = \"foofoofoo\\r\";\n    write_all(\u0026pty.master, string.as_bytes());\n\n    // Read from the slave verifying that the output has been properly transformed\n    let mut buf = [0u8; 10];\n    crate::read_exact(\u0026pty.slave, \u0026mut buf);\n    let transformed_string = \"foofoofoo\\n\";\n    assert_eq!(\u0026buf, transformed_string.as_bytes());\n}\n\n// Test modifying local flags\n#[test]\n#[cfg(not(target_os = \"solaris\"))]\nfn test_local_flags() {\n    // openpty uses ptname(3) internally\n    let _m = crate::PTSNAME_MTX.lock();\n\n    // Open one pty to get attributes for the second one\n    let mut termios = {\n        let pty = openpty(None, None).unwrap();\n        tcgetattr(\u0026pty.slave).unwrap()\n    };\n\n    // Make sure echo is specified by default or this test is useless.\n    assert!(termios.local_flags.contains(LocalFlags::ECHO));\n\n    // Disable local echo\n    termios.local_flags.remove(LocalFlags::ECHO);\n\n    // Open a new pty with our modified termios settings\n    let pty = openpty(None, \u0026termios).unwrap();\n\n    // Set the master is in nonblocking mode or reading will never return.\n    let flags = fcntl::fcntl(\u0026pty.master, fcntl::F_GETFL).unwrap();\n    let new_flags =\n        fcntl::OFlag::from_bits_truncate(flags) | fcntl::OFlag::O_NONBLOCK;\n    fcntl::fcntl(pty.master.as_fd(), fcntl::F_SETFL(new_flags)).unwrap();\n\n    // Write into the master\n    let string = \"foofoofoo\\r\";\n    write_all(\u0026pty.master, string.as_bytes());\n\n    // Try to read from the master, which should not have anything as echoing was disabled.\n    let mut buf = [0u8; 10];\n    let read = read(\u0026pty.master, \u0026mut buf).unwrap_err();\n    assert_eq!(read, Errno::EAGAIN);\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_time.rs"],"content":"use nix::sys::time::{TimeSpec, TimeVal, TimeValLike};\nuse std::time::Duration;\n\n#[test]\npub fn test_timespec() {\n    assert_ne!(TimeSpec::seconds(1), TimeSpec::zero());\n    assert_eq!(\n        TimeSpec::seconds(1) + TimeSpec::seconds(2),\n        TimeSpec::seconds(3)\n    );\n    assert_eq!(\n        TimeSpec::minutes(3) + TimeSpec::seconds(2),\n        TimeSpec::seconds(182)\n    );\n}\n\n#[test]\npub fn test_timespec_from() {\n    let duration = Duration::new(123, 123_456_789);\n    let timespec = TimeSpec::nanoseconds(123_123_456_789);\n\n    assert_eq!(TimeSpec::from(duration), timespec);\n    assert_eq!(Duration::from(timespec), duration);\n}\n\n#[test]\npub fn test_timespec_neg() {\n    let a = TimeSpec::seconds(1) + TimeSpec::nanoseconds(123);\n    let b = TimeSpec::seconds(-1) + TimeSpec::nanoseconds(-123);\n\n    assert_eq!(a, -b);\n}\n\n#[test]\npub fn test_timespec_ord() {\n    assert_eq!(TimeSpec::seconds(1), TimeSpec::nanoseconds(1_000_000_000));\n    assert!(TimeSpec::seconds(1) \u003c TimeSpec::nanoseconds(1_000_000_001));\n    assert!(TimeSpec::seconds(1) \u003e TimeSpec::nanoseconds(999_999_999));\n    assert!(TimeSpec::seconds(-1) \u003c TimeSpec::nanoseconds(-999_999_999));\n    assert!(TimeSpec::seconds(-1) \u003e TimeSpec::nanoseconds(-1_000_000_001));\n}\n\n#[test]\npub fn test_timespec_fmt() {\n    assert_eq!(TimeSpec::zero().to_string(), \"0 seconds\");\n    assert_eq!(TimeSpec::seconds(42).to_string(), \"42 seconds\");\n    assert_eq!(TimeSpec::milliseconds(42).to_string(), \"0.042 seconds\");\n    assert_eq!(TimeSpec::microseconds(42).to_string(), \"0.000042 seconds\");\n    assert_eq!(TimeSpec::nanoseconds(42).to_string(), \"0.000000042 seconds\");\n    assert_eq!(TimeSpec::seconds(-86401).to_string(), \"-86401 seconds\");\n}\n\n#[test]\npub fn test_timeval() {\n    assert_ne!(TimeVal::seconds(1), TimeVal::zero());\n    assert_eq!(\n        TimeVal::seconds(1) + TimeVal::seconds(2),\n        TimeVal::seconds(3)\n    );\n    assert_eq!(\n        TimeVal::minutes(3) + TimeVal::seconds(2),\n        TimeVal::seconds(182)\n    );\n}\n\n#[test]\npub fn test_timeval_ord() {\n    assert_eq!(TimeVal::seconds(1), TimeVal::microseconds(1_000_000));\n    assert!(TimeVal::seconds(1) \u003c TimeVal::microseconds(1_000_001));\n    assert!(TimeVal::seconds(1) \u003e TimeVal::microseconds(999_999));\n    assert!(TimeVal::seconds(-1) \u003c TimeVal::microseconds(-999_999));\n    assert!(TimeVal::seconds(-1) \u003e TimeVal::microseconds(-1_000_001));\n}\n\n#[test]\npub fn test_timeval_neg() {\n    let a = TimeVal::seconds(1) + TimeVal::microseconds(123);\n    let b = TimeVal::seconds(-1) + TimeVal::microseconds(-123);\n\n    assert_eq!(a, -b);\n}\n\n#[test]\npub fn test_timeval_fmt() {\n    assert_eq!(TimeVal::zero().to_string(), \"0 seconds\");\n    assert_eq!(TimeVal::seconds(42).to_string(), \"42 seconds\");\n    assert_eq!(TimeVal::milliseconds(42).to_string(), \"0.042 seconds\");\n    assert_eq!(TimeVal::microseconds(42).to_string(), \"0.000042 seconds\");\n    assert_eq!(TimeVal::nanoseconds(1402).to_string(), \"0.000001 seconds\");\n    assert_eq!(TimeVal::seconds(-86401).to_string(), \"-86401 seconds\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_timer.rs"],"content":"use nix::sys::signal::{\n    sigaction, SaFlags, SigAction, SigEvent, SigHandler, SigSet, SigevNotify,\n    Signal,\n};\nuse nix::sys::timer::{Expiration, Timer, TimerSetTimeFlags};\nuse nix::time::ClockId;\nuse std::convert::TryFrom;\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse std::thread;\nuse std::time::{Duration, Instant};\n\nconst SIG: Signal = Signal::SIGALRM;\nstatic ALARM_CALLED: AtomicBool = AtomicBool::new(false);\n\npub extern \"C\" fn handle_sigalarm(raw_signal: libc::c_int) {\n    let signal = Signal::try_from(raw_signal).unwrap();\n    if signal == SIG {\n        ALARM_CALLED.store(true, Ordering::Release);\n    }\n}\n\n#[test]\nfn alarm_fires() {\n    // Avoid interfering with other signal using tests by taking a mutex shared\n    // among other tests in this crate.\n    let _m = crate::SIGNAL_MTX.lock();\n    const TIMER_PERIOD: Duration = Duration::from_millis(100);\n\n    //\n    // Setup\n    //\n\n    // Create a handler for the test signal, `SIG`. The handler is responsible\n    // for flipping `ALARM_CALLED`.\n    let handler = SigHandler::Handler(handle_sigalarm);\n    let signal_action =\n        SigAction::new(handler, SaFlags::SA_RESTART, SigSet::empty());\n    let old_handler = unsafe {\n        sigaction(SIG, \u0026signal_action)\n            .expect(\"unable to set signal handler for alarm\")\n    };\n\n    // Create the timer. We use the monotonic clock here, though any would do\n    // really. The timer is set to fire every 250 milliseconds with no delay for\n    // the initial firing.\n    let clockid = ClockId::CLOCK_MONOTONIC;\n    let sigevent = SigEvent::new(SigevNotify::SigevSignal {\n        signal: SIG,\n        si_value: 0,\n    });\n    let mut timer =\n        Timer::new(clockid, sigevent).expect(\"failed to create timer\");\n    let expiration = Expiration::Interval(TIMER_PERIOD.into());\n    let flags = TimerSetTimeFlags::empty();\n    timer.set(expiration, flags).expect(\"could not set timer\");\n\n    //\n    // Test\n    //\n\n    // Determine that there's still an expiration tracked by the\n    // timer. Depending on when this runs either an `Expiration::Interval` or\n    // `Expiration::IntervalDelayed` will be present. That is, if the timer has\n    // not fired yet we'll get our original `expiration`, else the one that\n    // represents a delay to the next expiration. We're only interested in the\n    // timer still being extant.\n    match timer.get() {\n        Ok(Some(exp)) =\u003e assert!(matches!(\n            exp,\n            Expiration::Interval(..) | Expiration::IntervalDelayed(..)\n        )),\n        _ =\u003e panic!(\"timer lost its expiration\"),\n    }\n\n    // Wait for 2 firings of the alarm before checking that it has fired and\n    // been handled at least the once. If we wait for 3 seconds and the handler\n    // is never called something has gone sideways and the test fails.\n    let starttime = Instant::now();\n    loop {\n        thread::sleep(2 * TIMER_PERIOD);\n        if ALARM_CALLED.load(Ordering::Acquire) {\n            break;\n        }\n        if starttime.elapsed() \u003e Duration::from_secs(3) {\n            panic!(\"Timeout waiting for SIGALRM\");\n        }\n    }\n\n    // Cleanup:\n    // 1) deregister the OS's timer.\n    // 2) Wait for a full timer period, since POSIX does not require that\n    //    disabling the timer will clear pending signals, and on NetBSD at least\n    //    it does not.\n    // 2) Replace the old signal handler now that we've completed the test. If\n    //    the test fails this process panics, so the fact we might not get here\n    //    is okay.\n    drop(timer);\n    thread::sleep(TIMER_PERIOD);\n    unsafe {\n        sigaction(SIG, \u0026old_handler).expect(\"unable to reset signal handler\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_timerfd.rs"],"content":"use nix::sys::time::{TimeSpec, TimeValLike};\nuse nix::sys::timerfd::{\n    ClockId, Expiration, TimerFd, TimerFlags, TimerSetTimeFlags,\n};\nuse std::time::Instant;\n\n#[test]\npub fn test_timerfd_oneshot() {\n    let timer =\n        TimerFd::new(ClockId::CLOCK_MONOTONIC, TimerFlags::empty()).unwrap();\n\n    let before = Instant::now();\n\n    timer\n        .set(\n            Expiration::OneShot(TimeSpec::seconds(1)),\n            TimerSetTimeFlags::empty(),\n        )\n        .unwrap();\n\n    timer.wait().unwrap();\n\n    let millis = before.elapsed().as_millis();\n    assert!(millis \u003e 900);\n}\n\n#[test]\npub fn test_timerfd_interval() {\n    let timer =\n        TimerFd::new(ClockId::CLOCK_MONOTONIC, TimerFlags::empty()).unwrap();\n\n    let before = Instant::now();\n    timer\n        .set(\n            Expiration::IntervalDelayed(\n                TimeSpec::seconds(1),\n                TimeSpec::seconds(2),\n            ),\n            TimerSetTimeFlags::empty(),\n        )\n        .unwrap();\n\n    timer.wait().unwrap();\n\n    let start_delay = before.elapsed().as_millis();\n    assert!(start_delay \u003e 900);\n\n    timer.wait().unwrap();\n\n    let interval_delay = before.elapsed().as_millis();\n    assert!(interval_delay \u003e 2900);\n}\n\n#[test]\npub fn test_timerfd_unset() {\n    let timer =\n        TimerFd::new(ClockId::CLOCK_MONOTONIC, TimerFlags::empty()).unwrap();\n\n    timer\n        .set(\n            Expiration::OneShot(TimeSpec::seconds(1)),\n            TimerSetTimeFlags::empty(),\n        )\n        .unwrap();\n\n    timer.unset().unwrap();\n\n    assert!(timer.get().unwrap().is_none());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_uio.rs"],"content":"use nix::sys::uio::*;\nuse nix::unistd::*;\nuse rand::distr::Alphanumeric;\nuse rand::{rng, Rng};\nuse std::fs::OpenOptions;\nuse std::io::IoSlice;\nuse std::{cmp, iter};\n\n#[cfg(not(target_os = \"redox\"))]\nuse std::io::IoSliceMut;\n\nuse tempfile::tempdir;\n#[cfg(not(target_os = \"redox\"))]\nuse tempfile::tempfile;\n\n#[test]\n// On Solaris sometimes wrtitev() returns EINVAL.\n#[cfg(not(target_os = \"solaris\"))]\nfn test_writev() {\n    let mut to_write = Vec::with_capacity(16 * 128);\n    for _ in 0..16 {\n        let s: String = rng()\n            .sample_iter(\u0026Alphanumeric)\n            .map(char::from)\n            .take(128)\n            .collect();\n        let b = s.as_bytes();\n        to_write.extend(b.iter().cloned());\n    }\n    // Allocate and fill iovecs\n    let mut iovecs = Vec::new();\n    let mut consumed = 0;\n    while consumed \u003c to_write.len() {\n        let left = to_write.len() - consumed;\n        let slice_len = if left \u003c= 64 {\n            left\n        } else {\n            rng().random_range(64..cmp::min(256, left))\n        };\n        let b = \u0026to_write[consumed..consumed + slice_len];\n        iovecs.push(IoSlice::new(b));\n        consumed += slice_len;\n    }\n    let (reader, writer) = pipe().expect(\"Couldn't create pipe\");\n    // FileDesc will close its filedesc (reader).\n    let mut read_buf: Vec\u003cu8\u003e = iter::repeat(0u8).take(128 * 16).collect();\n\n    // Blocking io, should write all data.\n    let write_res = writev(\u0026writer, \u0026iovecs);\n    let written = write_res.expect(\"couldn't write\");\n    // Check whether we written all data\n    assert_eq!(to_write.len(), written);\n    let read_res = read(\u0026reader, \u0026mut read_buf[..]);\n    let read = read_res.expect(\"couldn't read\");\n    // Check we have read as much as we written\n    assert_eq!(read, written);\n    // Check equality of written and read data\n    assert_eq!(\u0026to_write, \u0026read_buf);\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_readv() {\n    let s: String = rng()\n        .sample_iter(\u0026Alphanumeric)\n        .map(char::from)\n        .take(128)\n        .collect();\n    let to_write = s.as_bytes().to_vec();\n    let mut storage = Vec::new();\n    let mut allocated = 0;\n    while allocated \u003c to_write.len() {\n        let left = to_write.len() - allocated;\n        let vec_len = if left \u003c= 64 {\n            left\n        } else {\n            rng().random_range(64..cmp::min(256, left))\n        };\n        let v: Vec\u003cu8\u003e = iter::repeat(0u8).take(vec_len).collect();\n        storage.push(v);\n        allocated += vec_len;\n    }\n    let mut iovecs = Vec::with_capacity(storage.len());\n    for v in \u0026mut storage {\n        iovecs.push(IoSliceMut::new(\u0026mut v[..]));\n    }\n    let (reader, writer) = pipe().expect(\"couldn't create pipe\");\n    // Blocking io, should write all data.\n    write(writer, \u0026to_write).expect(\"write failed\");\n\n    let read = readv(\u0026reader, \u0026mut iovecs[..]).expect(\"read failed\");\n    // Check whether we've read all data\n    assert_eq!(to_write.len(), read);\n    // Cccumulate data from iovecs\n    let mut read_buf = Vec::with_capacity(to_write.len());\n    for iovec in \u0026iovecs {\n        read_buf.extend(iovec.iter().cloned());\n    }\n    // Check whether iovecs contain all written data\n    assert_eq!(read_buf.len(), to_write.len());\n    // Check equality of written and read data\n    assert_eq!(\u0026read_buf, \u0026to_write);\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_pwrite() {\n    use std::io::Read;\n\n    let mut file = tempfile().unwrap();\n    let buf = [1u8; 8];\n    assert_eq!(Ok(8), pwrite(\u0026file, \u0026buf, 8));\n    let mut file_content = Vec::new();\n    file.read_to_end(\u0026mut file_content).unwrap();\n    let mut expected = vec![0u8; 8];\n    expected.extend(vec![1; 8]);\n    assert_eq!(file_content, expected);\n}\n\n#[test]\nfn test_pread() {\n    use std::io::Write;\n\n    let tempdir = tempdir().unwrap();\n\n    let path = tempdir.path().join(\"pread_test_file\");\n    let mut file = OpenOptions::new()\n        .write(true)\n        .read(true)\n        .create(true)\n        .truncate(true)\n        .open(path)\n        .unwrap();\n    let file_content: Vec\u003cu8\u003e = (0..64).collect();\n    file.write_all(\u0026file_content).unwrap();\n\n    let mut buf = [0u8; 16];\n    assert_eq!(Ok(16), pread(\u0026file, \u0026mut buf, 16));\n    let expected: Vec\u003c_\u003e = (16..32).collect();\n    assert_eq!(\u0026buf[..], \u0026expected[..]);\n}\n\n#[test]\n#[cfg(not(any(\n    target_os = \"redox\",\n    target_os = \"haiku\",\n    target_os = \"solaris\",\n    target_os = \"cygwin\"\n)))]\nfn test_pwritev() {\n    use std::io::Read;\n\n    let to_write: Vec\u003cu8\u003e = (0..128).collect();\n    let expected: Vec\u003cu8\u003e = [vec![0; 100], to_write.clone()].concat();\n\n    let iovecs = [\n        IoSlice::new(\u0026to_write[0..17]),\n        IoSlice::new(\u0026to_write[17..64]),\n        IoSlice::new(\u0026to_write[64..128]),\n    ];\n\n    let tempdir = tempdir().unwrap();\n\n    // pwritev them into a temporary file\n    let path = tempdir.path().join(\"pwritev_test_file\");\n    let mut file = OpenOptions::new()\n        .write(true)\n        .read(true)\n        .create(true)\n        .truncate(true)\n        .open(path)\n        .unwrap();\n\n    let written = pwritev(\u0026file, \u0026iovecs, 100).ok().unwrap();\n    assert_eq!(written, to_write.len());\n\n    // Read the data back and make sure it matches\n    let mut contents = Vec::new();\n    file.read_to_end(\u0026mut contents).unwrap();\n    assert_eq!(contents, expected);\n}\n\n#[test]\n#[cfg(not(any(\n    target_os = \"redox\",\n    target_os = \"haiku\",\n    target_os = \"solaris\",\n    target_os = \"cygwin\"\n)))]\nfn test_preadv() {\n    use std::io::Write;\n\n    let to_write: Vec\u003cu8\u003e = (0..200).collect();\n    let expected: Vec\u003cu8\u003e = (100..200).collect();\n\n    let tempdir = tempdir().unwrap();\n\n    let path = tempdir.path().join(\"preadv_test_file\");\n\n    let mut file = OpenOptions::new()\n        .read(true)\n        .write(true)\n        .create(true)\n        .truncate(true)\n        .open(path)\n        .unwrap();\n    file.write_all(\u0026to_write).unwrap();\n\n    let mut buffers: Vec\u003cVec\u003cu8\u003e\u003e = vec![vec![0; 24], vec![0; 1], vec![0; 75]];\n\n    {\n        // Borrow the buffers into IoVecs and preadv into them\n        let mut iovecs: Vec\u003c_\u003e = buffers\n            .iter_mut()\n            .map(|buf| IoSliceMut::new(\u0026mut buf[..]))\n            .collect();\n        assert_eq!(Ok(100), preadv(\u0026file, \u0026mut iovecs, 100));\n    }\n\n    let all = buffers.concat();\n    assert_eq!(all, expected);\n}\n\n#[test]\n#[cfg(all(target_os = \"linux\", not(target_env = \"uclibc\")))]\n// uclibc doesn't implement process_vm_readv\n// qemu-user doesn't implement process_vm_readv/writev on most arches\n#[cfg_attr(qemu, ignore)]\nfn test_process_vm_readv() {\n    use crate::*;\n    use nix::sys::signal::*;\n    use nix::sys::wait::*;\n    use nix::unistd::ForkResult::*;\n\n    require_capability!(\"test_process_vm_readv\", CAP_SYS_PTRACE);\n    let _m = crate::FORK_MTX.lock();\n\n    // Pre-allocate memory in the child, since allocation isn't safe\n    // post-fork (~= async-signal-safe)\n    let mut vector = vec![1u8, 2, 3, 4, 5];\n\n    let (r, w) = pipe().unwrap();\n    match unsafe { fork() }.expect(\"Error: Fork Failed\") {\n        Parent { child } =\u003e {\n            drop(w);\n            // wait for child\n            read(\u0026r, \u0026mut [0u8]).unwrap();\n            drop(r);\n\n            let ptr = vector.as_ptr() as usize;\n            let remote_iov = RemoteIoVec { base: ptr, len: 5 };\n            let mut buf = vec![0u8; 5];\n\n            let ret = process_vm_readv(\n                child,\n                \u0026mut [IoSliceMut::new(\u0026mut buf)],\n                \u0026[remote_iov],\n            );\n\n            kill(child, SIGTERM).unwrap();\n            waitpid(child, None).unwrap();\n\n            assert_eq!(Ok(5), ret);\n            assert_eq!(20u8, buf.iter().sum());\n        }\n        Child =\u003e {\n            drop(r);\n            for i in \u0026mut vector {\n                *i += 1;\n            }\n            let _ = write(w, b\"\\0\");\n            loop {\n                pause();\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_utsname.rs"],"content":"#[cfg(target_os = \"linux\")]\n#[test]\npub fn test_uname_linux() {\n    assert_eq!(nix::sys::utsname::uname().unwrap().sysname(), \"Linux\");\n}\n\n#[cfg(apple_targets)]\n#[test]\npub fn test_uname_darwin() {\n    assert_eq!(nix::sys::utsname::uname().unwrap().sysname(), \"Darwin\");\n}\n\n#[cfg(target_os = \"freebsd\")]\n#[test]\npub fn test_uname_freebsd() {\n    assert_eq!(nix::sys::utsname::uname().unwrap().sysname(), \"FreeBSD\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","sys","test_wait.rs"],"content":"use libc::_exit;\nuse nix::errno::Errno;\nuse nix::sys::signal::*;\nuse nix::sys::wait::*;\nuse nix::unistd::ForkResult::*;\nuse nix::unistd::*;\n\n#[test]\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nfn test_wait_signal() {\n    let _m = crate::FORK_MTX.lock();\n\n    // Safe: The child only calls `pause` and/or `_exit`, which are async-signal-safe.\n    match unsafe { fork() }.expect(\"Error: Fork Failed\") {\n        Child =\u003e {\n            pause();\n            unsafe { _exit(123) }\n        }\n        Parent { child } =\u003e {\n            kill(child, Some(SIGKILL)).expect(\"Error: Kill Failed\");\n            assert_eq!(\n                waitpid(child, None),\n                Ok(WaitStatus::Signaled(child, SIGKILL, false))\n            );\n        }\n    }\n}\n\n#[test]\n#[cfg(any(\n    target_os = \"android\",\n    target_os = \"freebsd\",\n    //target_os = \"haiku\",\n    all(target_os = \"linux\", not(target_env = \"uclibc\")),\n))]\n#[cfg(not(any(\n    target_arch = \"mips\",\n    target_arch = \"mips32r6\",\n    target_arch = \"mips64\",\n    target_arch = \"mips64r6\"\n)))]\nfn test_waitid_signal() {\n    let _m = crate::FORK_MTX.lock();\n\n    // Safe: The child only calls `pause` and/or `_exit`, which are async-signal-safe.\n    match unsafe { fork() }.expect(\"Error: Fork Failed\") {\n        Child =\u003e {\n            pause();\n            unsafe { _exit(123) }\n        }\n        Parent { child } =\u003e {\n            kill(child, Some(SIGKILL)).expect(\"Error: Kill Failed\");\n            assert_eq!(\n                waitid(Id::Pid(child), WaitPidFlag::WEXITED),\n                Ok(WaitStatus::Signaled(child, SIGKILL, false)),\n            );\n        }\n    }\n}\n\n#[test]\nfn test_wait_exit() {\n    let _m = crate::FORK_MTX.lock();\n\n    // Safe: Child only calls `_exit`, which is async-signal-safe.\n    match unsafe { fork() }.expect(\"Error: Fork Failed\") {\n        Child =\u003e unsafe {\n            _exit(12);\n        },\n        Parent { child } =\u003e {\n            assert_eq!(waitpid(child, None), Ok(WaitStatus::Exited(child, 12)));\n        }\n    }\n}\n\n#[cfg(not(target_os = \"haiku\"))]\n#[test]\n#[cfg(any(\n    target_os = \"android\",\n    target_os = \"freebsd\",\n    target_os = \"haiku\",\n    all(target_os = \"linux\", not(target_env = \"uclibc\")),\n))]\n#[cfg(not(any(\n    target_arch = \"mips\",\n    target_arch = \"mips32r6\",\n    target_arch = \"mips64\",\n    target_arch = \"mips64r6\"\n)))]\nfn test_waitid_exit() {\n    let _m = crate::FORK_MTX.lock();\n\n    // Safe: Child only calls `_exit`, which is async-signal-safe.\n    match unsafe { fork() }.expect(\"Error: Fork Failed\") {\n        Child =\u003e unsafe {\n            _exit(12);\n        },\n        Parent { child } =\u003e {\n            assert_eq!(\n                waitid(Id::Pid(child), WaitPidFlag::WEXITED),\n                Ok(WaitStatus::Exited(child, 12)),\n            );\n        }\n    }\n}\n\n#[test]\nfn test_waitstatus_from_raw() {\n    let pid = Pid::from_raw(1);\n    assert_eq!(\n        WaitStatus::from_raw(pid, 0x0002),\n        Ok(WaitStatus::Signaled(pid, Signal::SIGINT, false))\n    );\n    assert_eq!(\n        WaitStatus::from_raw(pid, 0x0200),\n        Ok(WaitStatus::Exited(pid, 2))\n    );\n    assert_eq!(WaitStatus::from_raw(pid, 0x7f7f), Err(Errno::EINVAL));\n}\n\n#[test]\nfn test_waitstatus_pid() {\n    let _m = crate::FORK_MTX.lock();\n\n    match unsafe { fork() }.unwrap() {\n        Child =\u003e unsafe { _exit(0) },\n        Parent { child } =\u003e {\n            let status = waitpid(child, None).unwrap();\n            assert_eq!(status.pid(), Some(child));\n        }\n    }\n}\n\n#[test]\n#[cfg(any(\n    target_os = \"android\",\n    target_os = \"freebsd\",\n    target_os = \"haiku\",\n    all(target_os = \"linux\", not(target_env = \"uclibc\")),\n))]\nfn test_waitid_pid() {\n    let _m = crate::FORK_MTX.lock();\n\n    match unsafe { fork() }.unwrap() {\n        Child =\u003e unsafe { _exit(0) },\n        Parent { child } =\u003e {\n            let status = waitid(Id::Pid(child), WaitPidFlag::WEXITED).unwrap();\n            assert_eq!(status.pid(), Some(child));\n        }\n    }\n}\n\n#[cfg(linux_android)]\n// FIXME: qemu-user doesn't implement ptrace on most arches\n#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\nmod ptrace {\n    use crate::*;\n    use libc::_exit;\n    use nix::sys::ptrace::{self, Event, Options};\n    use nix::sys::signal::*;\n    use nix::sys::wait::*;\n    use nix::unistd::ForkResult::*;\n    use nix::unistd::*;\n\n    fn ptrace_child() -\u003e ! {\n        ptrace::traceme().unwrap();\n        // As recommended by ptrace(2), raise SIGTRAP to pause the child\n        // until the parent is ready to continue\n        raise(SIGTRAP).unwrap();\n        unsafe { _exit(0) }\n    }\n\n    fn ptrace_wait_parent(child: Pid) {\n        // Wait for the raised SIGTRAP\n        assert_eq!(\n            waitpid(child, None),\n            Ok(WaitStatus::Stopped(child, SIGTRAP))\n        );\n        // We want to test a syscall stop and a PTRACE_EVENT stop\n        ptrace::setoptions(\n            child,\n            Options::PTRACE_O_TRACESYSGOOD | Options::PTRACE_O_TRACEEXIT,\n        )\n        .expect(\"setoptions failed\");\n\n        // First, stop on the next system call, which will be exit()\n        ptrace::syscall(child, None).expect(\"syscall failed\");\n        assert_eq!(waitpid(child, None), Ok(WaitStatus::PtraceSyscall(child)));\n        // Then get the ptrace event for the process exiting\n        ptrace::cont(child, None).expect(\"cont failed\");\n        assert_eq!(\n            waitpid(child, None),\n            Ok(WaitStatus::PtraceEvent(\n                child,\n                SIGTRAP,\n                Event::PTRACE_EVENT_EXIT as i32\n            ))\n        );\n        // Finally get the normal wait() result, now that the process has exited\n        ptrace::cont(child, None).expect(\"cont failed\");\n        assert_eq!(waitpid(child, None), Ok(WaitStatus::Exited(child, 0)));\n    }\n\n    #[cfg(not(target_env = \"uclibc\"))]\n    fn ptrace_waitid_parent(child: Pid) {\n        // Wait for the raised SIGTRAP\n        //\n        // Unlike waitpid(), waitid() can distinguish trap events from regular\n        // stop events, so unlike ptrace_wait_parent(), we get a PtraceEvent here\n        assert_eq!(\n            waitid(Id::Pid(child), WaitPidFlag::WEXITED),\n            Ok(WaitStatus::PtraceEvent(child, SIGTRAP, 0)),\n        );\n        // We want to test a syscall stop and a PTRACE_EVENT stop\n        ptrace::setoptions(\n            child,\n            Options::PTRACE_O_TRACESYSGOOD | Options::PTRACE_O_TRACEEXIT,\n        )\n        .expect(\"setopts failed\");\n\n        // First, stop on the next system call, which will be exit()\n        ptrace::syscall(child, None).expect(\"syscall failed\");\n        assert_eq!(\n            waitid(Id::Pid(child), WaitPidFlag::WEXITED),\n            Ok(WaitStatus::PtraceSyscall(child)),\n        );\n        // Then get the ptrace event for the process exiting\n        ptrace::cont(child, None).expect(\"cont failed\");\n        assert_eq!(\n            waitid(Id::Pid(child), WaitPidFlag::WEXITED),\n            Ok(WaitStatus::PtraceEvent(\n                child,\n                SIGTRAP,\n                Event::PTRACE_EVENT_EXIT as i32\n            )),\n        );\n        // Finally get the normal wait() result, now that the process has exited\n        ptrace::cont(child, None).expect(\"cont failed\");\n        assert_eq!(\n            waitid(Id::Pid(child), WaitPidFlag::WEXITED),\n            Ok(WaitStatus::Exited(child, 0)),\n        );\n    }\n\n    #[test]\n    fn test_wait_ptrace() {\n        require_capability!(\"test_wait_ptrace\", CAP_SYS_PTRACE);\n        let _m = crate::FORK_MTX.lock();\n\n        match unsafe { fork() }.expect(\"Error: Fork Failed\") {\n            Child =\u003e ptrace_child(),\n            Parent { child } =\u003e ptrace_wait_parent(child),\n        }\n    }\n\n    #[test]\n    #[cfg(not(target_env = \"uclibc\"))]\n    fn test_waitid_ptrace() {\n        require_capability!(\"test_waitid_ptrace\", CAP_SYS_PTRACE);\n        let _m = crate::FORK_MTX.lock();\n\n        match unsafe { fork() }.expect(\"Error: Fork Failed\") {\n            Child =\u003e ptrace_child(),\n            Parent { child } =\u003e ptrace_waitid_parent(child),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","test.rs"],"content":"#[macro_use]\nextern crate cfg_if;\n#[cfg_attr(not(any(target_os = \"redox\")), macro_use)]\nextern crate nix;\n\n#[macro_use]\nmod common;\nmod mount;\nmod sys;\n#[cfg(not(target_os = \"redox\"))]\nmod test_dir;\nmod test_errno;\nmod test_fcntl;\n#[cfg(linux_android)]\nmod test_kmod;\n#[cfg(any(\n    freebsdlike,\n    all(target_os = \"linux\", not(target_env = \"ohos\")),\n    target_os = \"netbsd\"\n))]\nmod test_mq;\n#[cfg(not(target_os = \"redox\"))]\nmod test_net;\nmod test_nix_path;\nmod test_poll;\n#[cfg(not(any(\n    target_os = \"redox\",\n    target_os = \"fuchsia\",\n    target_os = \"haiku\"\n)))]\nmod test_pty;\n#[cfg(any(\n    linux_android,\n    target_os = \"dragonfly\",\n    all(target_os = \"freebsd\", fbsd14),\n))]\nmod test_sched;\n#[cfg(any(linux_android, freebsdlike, apple_targets, solarish))]\nmod test_sendfile;\n#[cfg(any(\n    target_os = \"freebsd\",\n    target_os = \"haiku\",\n    target_os = \"linux\",\n    target_os = \"netbsd\",\n    apple_targets\n))]\nmod test_spawn;\n\nmod test_syslog;\n\nmod test_time;\nmod test_unistd;\n\nuse nix::unistd::{chdir, getcwd, read};\nuse parking_lot::{Mutex, RwLock, RwLockWriteGuard};\nuse std::os::unix::io::AsFd;\nuse std::path::PathBuf;\n\n/// Helper function analogous to `std::io::Read::read_exact`, but for `Fd`s\nfn read_exact\u003cFd: AsFd\u003e(f: Fd, buf: \u0026mut [u8]) {\n    let mut len = 0;\n    while len \u003c buf.len() {\n        // get_mut would be better than split_at_mut, but it requires nightly\n        let (_, remaining) = buf.split_at_mut(len);\n        len += read(\u0026f, remaining).unwrap();\n    }\n}\n\n/// Any test that creates child processes or can be affected by child processes\n/// must grab this mutex, regardless of what it does with those children.\n///\n/// It must hold the mutex until the child processes are waited upon.\npub static FORK_MTX: Mutex\u003c()\u003e = Mutex::new(());\n/// Any test that changes the process's current working directory must grab\n/// the RwLock exclusively.  Any process that cares about the current\n/// working directory must grab it shared.\npub static CWD_LOCK: RwLock\u003c()\u003e = RwLock::new(());\n/// Any test that changes the process's supplementary groups must grab this\n/// mutex\npub static GROUPS_MTX: Mutex\u003c()\u003e = Mutex::new(());\n/// Any tests that loads or unloads kernel modules must grab this mutex\npub static KMOD_MTX: Mutex\u003c()\u003e = Mutex::new(());\n/// Any test that calls ptsname(3) must grab this mutex.\npub static PTSNAME_MTX: Mutex\u003c()\u003e = Mutex::new(());\n/// Any test that alters signal handling must grab this mutex.\npub static SIGNAL_MTX: Mutex\u003c()\u003e = Mutex::new(());\n\n/// RAII object that restores a test's original directory on drop\nstruct DirRestore\u003c'a\u003e {\n    d: PathBuf,\n    _g: RwLockWriteGuard\u003c'a, ()\u003e,\n}\n\nimpl DirRestore\u003c'_\u003e {\n    fn new() -\u003e Self {\n        let guard = crate::CWD_LOCK.write();\n        DirRestore {\n            _g: guard,\n            d: getcwd().unwrap(),\n        }\n    }\n}\n\nimpl Drop for DirRestore\u003c'_\u003e {\n    fn drop(\u0026mut self) {\n        let r = chdir(\u0026self.d);\n        if std::thread::panicking() {\n            r.unwrap();\n        }\n    }\n}\n","traces":[{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","home","acooks","mcr","nix-0.30.1","test","test_clearenv.rs"],"content":"use std::env;\n\n#[test]\nfn clearenv() {\n    env::set_var(\"FOO\", \"BAR\");\n    unsafe { nix::env::clearenv() }.unwrap();\n    assert_eq!(env::var(\"FOO\").unwrap_err(), env::VarError::NotPresent);\n    assert_eq!(env::vars().count(), 0);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","test_dir.rs"],"content":"use nix::dir::{Dir, Type};\nuse nix::fcntl::OFlag;\nuse nix::sys::stat::Mode;\nuse std::fs::File;\nuse tempfile::tempdir;\n\n#[cfg(test)]\nfn flags() -\u003e OFlag {\n    #[cfg(solarish)]\n    let f = OFlag::O_RDONLY | OFlag::O_CLOEXEC;\n\n    #[cfg(not(solarish))]\n    let f = OFlag::O_RDONLY | OFlag::O_CLOEXEC | OFlag::O_DIRECTORY;\n\n    f\n}\n\n#[test]\nfn read() {\n    let tmp = tempdir().unwrap();\n    File::create(tmp.path().join(\"foo\")).unwrap();\n    std::os::unix::fs::symlink(\"foo\", tmp.path().join(\"bar\")).unwrap();\n    let mut dir = Dir::open(tmp.path(), flags(), Mode::empty()).unwrap();\n    let mut entries: Vec\u003c_\u003e = dir.iter().map(|e| e.unwrap()).collect();\n    entries.sort_by(|a, b| a.file_name().cmp(b.file_name()));\n    let entry_names: Vec\u003c_\u003e = entries\n        .iter()\n        .map(|e| e.file_name().to_str().unwrap().to_owned())\n        .collect();\n    assert_eq!(\u0026entry_names[..], \u0026[\".\", \"..\", \"bar\", \"foo\"]);\n\n    // Check file types. The system is allowed to return DT_UNKNOWN (aka None here) but if it does\n    // return a type, ensure it's correct.\n    assert!(\u0026[Some(Type::Directory), None].contains(\u0026entries[0].file_type())); // .: dir\n    assert!(\u0026[Some(Type::Directory), None].contains(\u0026entries[1].file_type())); // ..: dir\n    assert!(\u0026[Some(Type::Symlink), None].contains(\u0026entries[2].file_type())); // bar: symlink\n    assert!(\u0026[Some(Type::File), None].contains(\u0026entries[3].file_type())); // foo: regular file\n}\n\n#[test]\nfn rewind() {\n    let tmp = tempdir().unwrap();\n    let mut dir = Dir::open(tmp.path(), flags(), Mode::empty()).unwrap();\n    let entries1: Vec\u003c_\u003e = dir\n        .iter()\n        .map(|e| e.unwrap().file_name().to_owned())\n        .collect();\n    let entries2: Vec\u003c_\u003e = dir\n        .iter()\n        .map(|e| e.unwrap().file_name().to_owned())\n        .collect();\n    let entries3: Vec\u003c_\u003e = dir\n        .into_iter()\n        .map(|e| e.unwrap().file_name().to_owned())\n        .collect();\n    assert_eq!(entries1, entries2);\n    assert_eq!(entries2, entries3);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","test_errno.rs"],"content":"use nix::errno::Errno;\n\n#[test]\nfn errno_set_and_read() {\n    Errno::ENFILE.set();\n    assert_eq!(Errno::last(), Errno::ENFILE);\n}\n\n#[test]\nfn errno_set_and_clear() {\n    Errno::ENFILE.set();\n    assert_eq!(Errno::last(), Errno::ENFILE);\n\n    Errno::clear();\n    assert_eq!(Errno::last(), Errno::from_raw(0));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","test_fcntl.rs"],"content":"#[cfg(not(target_os = \"redox\"))]\nuse nix::errno::*;\n#[cfg(not(target_os = \"redox\"))]\nuse nix::fcntl::{open, readlink, OFlag};\n#[cfg(not(target_os = \"redox\"))]\nuse nix::fcntl::{openat, readlinkat, renameat};\n\n#[cfg(target_os = \"linux\")]\nuse nix::fcntl::{openat2, OpenHow, ResolveFlag};\n\n#[cfg(all(\n    target_os = \"linux\",\n    target_env = \"gnu\",\n    any(\n        target_arch = \"x86_64\",\n        target_arch = \"powerpc\",\n        target_arch = \"s390x\"\n    )\n))]\nuse nix::fcntl::{renameat2, RenameFlags};\n#[cfg(not(target_os = \"redox\"))]\nuse nix::sys::stat::Mode;\n#[cfg(not(target_os = \"redox\"))]\nuse nix::unistd::read;\n#[cfg(not(target_os = \"redox\"))]\nuse std::fs::File;\n#[cfg(not(target_os = \"redox\"))]\nuse std::io::prelude::*;\n#[cfg(not(target_os = \"redox\"))]\nuse std::os::unix::fs;\n#[cfg(not(target_os = \"redox\"))]\nuse tempfile::NamedTempFile;\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\n// QEMU does not handle openat well enough to satisfy this test\n// https://gitlab.com/qemu-project/qemu/-/issues/829\n#[cfg_attr(qemu, ignore)]\nfn test_openat() {\n    const CONTENTS: \u0026[u8] = b\"abcd\";\n    let mut tmp = NamedTempFile::new().unwrap();\n    tmp.write_all(CONTENTS).unwrap();\n\n    let dirfd =\n        open(tmp.path().parent().unwrap(), OFlag::empty(), Mode::empty())\n            .unwrap();\n    let fd = openat(\n        dirfd,\n        tmp.path().file_name().unwrap(),\n        OFlag::O_RDONLY,\n        Mode::empty(),\n    )\n    .unwrap();\n\n    let mut buf = [0u8; 1024];\n    assert_eq!(4, read(\u0026fd, \u0026mut buf).unwrap());\n    assert_eq!(CONTENTS, \u0026buf[0..4]);\n}\n\n#[test]\n#[cfg(target_os = \"linux\")]\n// QEMU does not handle openat well enough to satisfy this test\n// https://gitlab.com/qemu-project/qemu/-/issues/829\n#[cfg_attr(qemu, ignore)]\nfn test_openat2() {\n    const CONTENTS: \u0026[u8] = b\"abcd\";\n    let mut tmp = NamedTempFile::new().unwrap();\n    tmp.write_all(CONTENTS).unwrap();\n\n    let dirfd =\n        open(tmp.path().parent().unwrap(), OFlag::empty(), Mode::empty())\n            .unwrap();\n\n    let fd = openat2(\n        dirfd,\n        tmp.path().file_name().unwrap(),\n        OpenHow::new()\n            .flags(OFlag::O_RDONLY)\n            .mode(Mode::empty())\n            .resolve(ResolveFlag::RESOLVE_BENEATH),\n    )\n    .unwrap();\n\n    let mut buf = [0u8; 1024];\n    assert_eq!(4, read(\u0026fd, \u0026mut buf).unwrap());\n    assert_eq!(CONTENTS, \u0026buf[0..4]);\n}\n\n#[test]\n#[cfg(target_os = \"linux\")]\n// QEMU does not handle openat well enough to satisfy this test\n// https://gitlab.com/qemu-project/qemu/-/issues/829\n#[cfg_attr(qemu, ignore)]\nfn test_openat2_forbidden() {\n    let mut tmp = NamedTempFile::new().unwrap();\n    tmp.write_all(b\"let me out\").unwrap();\n\n    let dirfd =\n        open(tmp.path().parent().unwrap(), OFlag::empty(), Mode::empty())\n            .unwrap();\n\n    let escape_attempt =\n        tmp.path().parent().unwrap().join(\"../../../hello.txt\");\n\n    let res = openat2(\n        dirfd,\n        \u0026escape_attempt,\n        OpenHow::new()\n            .flags(OFlag::O_RDONLY)\n            .resolve(ResolveFlag::RESOLVE_BENEATH),\n    );\n    assert_eq!(res.unwrap_err(), Errno::EXDEV);\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_renameat() {\n    let old_dir = tempfile::tempdir().unwrap();\n    let old_dirfd =\n        open(old_dir.path(), OFlag::empty(), Mode::empty()).unwrap();\n    let old_path = old_dir.path().join(\"old\");\n    File::create(old_path).unwrap();\n    let new_dir = tempfile::tempdir().unwrap();\n    let new_dirfd =\n        open(new_dir.path(), OFlag::empty(), Mode::empty()).unwrap();\n    renameat(\u0026old_dirfd, \"old\", \u0026new_dirfd, \"new\").unwrap();\n    assert_eq!(\n        renameat(\u0026old_dirfd, \"old\", \u0026new_dirfd, \"new\").unwrap_err(),\n        Errno::ENOENT\n    );\n    assert!(new_dir.path().join(\"new\").exists());\n}\n\n#[test]\n#[cfg(all(\n    target_os = \"linux\",\n    target_env = \"gnu\",\n    any(\n        target_arch = \"x86_64\",\n        target_arch = \"powerpc\",\n        target_arch = \"s390x\"\n    )\n))]\nfn test_renameat2_behaves_like_renameat_with_no_flags() {\n    let old_dir = tempfile::tempdir().unwrap();\n    let old_dirfd =\n        open(old_dir.path(), OFlag::empty(), Mode::empty()).unwrap();\n    let old_path = old_dir.path().join(\"old\");\n    File::create(old_path).unwrap();\n    let new_dir = tempfile::tempdir().unwrap();\n    let new_dirfd =\n        open(new_dir.path(), OFlag::empty(), Mode::empty()).unwrap();\n    renameat2(\u0026old_dirfd, \"old\", \u0026new_dirfd, \"new\", RenameFlags::empty())\n        .unwrap();\n    assert_eq!(\n        renameat2(\u0026old_dirfd, \"old\", \u0026new_dirfd, \"new\", RenameFlags::empty())\n            .unwrap_err(),\n        Errno::ENOENT\n    );\n    assert!(new_dir.path().join(\"new\").exists());\n}\n\n#[test]\n#[cfg(all(\n    target_os = \"linux\",\n    target_env = \"gnu\",\n    any(\n        target_arch = \"x86_64\",\n        target_arch = \"powerpc\",\n        target_arch = \"s390x\"\n    )\n))]\nfn test_renameat2_exchange() {\n    let old_dir = tempfile::tempdir().unwrap();\n    let old_dirfd =\n        open(old_dir.path(), OFlag::empty(), Mode::empty()).unwrap();\n    let old_path = old_dir.path().join(\"old\");\n    {\n        let mut old_f = File::create(\u0026old_path).unwrap();\n        old_f.write_all(b\"old\").unwrap();\n    }\n    let new_dir = tempfile::tempdir().unwrap();\n    let new_dirfd =\n        open(new_dir.path(), OFlag::empty(), Mode::empty()).unwrap();\n    let new_path = new_dir.path().join(\"new\");\n    {\n        let mut new_f = File::create(\u0026new_path).unwrap();\n        new_f.write_all(b\"new\").unwrap();\n    }\n    renameat2(\n        \u0026old_dirfd,\n        \"old\",\n        \u0026new_dirfd,\n        \"new\",\n        RenameFlags::RENAME_EXCHANGE,\n    )\n    .unwrap();\n    let mut buf = String::new();\n    let mut new_f = File::open(\u0026new_path).unwrap();\n    new_f.read_to_string(\u0026mut buf).unwrap();\n    assert_eq!(buf, \"old\");\n    buf = \"\".to_string();\n    let mut old_f = File::open(\u0026old_path).unwrap();\n    old_f.read_to_string(\u0026mut buf).unwrap();\n    assert_eq!(buf, \"new\");\n}\n\n#[test]\n#[cfg(all(\n    target_os = \"linux\",\n    target_env = \"gnu\",\n    any(\n        target_arch = \"x86_64\",\n        target_arch = \"powerpc\",\n        target_arch = \"s390x\"\n    )\n))]\nfn test_renameat2_noreplace() {\n    let old_dir = tempfile::tempdir().unwrap();\n    let old_dirfd =\n        open(old_dir.path(), OFlag::empty(), Mode::empty()).unwrap();\n    let old_path = old_dir.path().join(\"old\");\n    File::create(old_path).unwrap();\n    let new_dir = tempfile::tempdir().unwrap();\n    let new_dirfd =\n        open(new_dir.path(), OFlag::empty(), Mode::empty()).unwrap();\n    let new_path = new_dir.path().join(\"new\");\n    File::create(new_path).unwrap();\n    assert_eq!(\n        renameat2(\n            \u0026old_dirfd,\n            \"old\",\n            \u0026new_dirfd,\n            \"new\",\n            RenameFlags::RENAME_NOREPLACE\n        )\n        .unwrap_err(),\n        Errno::EEXIST\n    );\n    assert!(new_dir.path().join(\"new\").exists());\n    assert!(old_dir.path().join(\"old\").exists());\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_readlink() {\n    let tempdir = tempfile::tempdir().unwrap();\n    let src = tempdir.path().join(\"a\");\n    let dst = tempdir.path().join(\"b\");\n    println!(\"a: {:?}, b: {:?}\", \u0026src, \u0026dst);\n    fs::symlink(src.as_path(), dst.as_path()).unwrap();\n    let dirfd = open(tempdir.path(), OFlag::empty(), Mode::empty()).unwrap();\n    let expected_dir = src.to_str().unwrap();\n\n    assert_eq!(readlink(\u0026dst).unwrap().to_str().unwrap(), expected_dir);\n    assert_eq!(\n        readlinkat(dirfd, \"b\").unwrap().to_str().unwrap(),\n        expected_dir\n    );\n}\n\n/// This test creates a temporary file containing the contents\n/// 'foobarbaz' and uses the `copy_file_range` call to transfer\n/// 3 bytes at offset 3 (`bar`) to another empty file at offset 0. The\n/// resulting file is read and should contain the contents `bar`.\n/// The from_offset should be updated by the call to reflect\n/// the 3 bytes read (6).\n#[cfg(any(\n        linux_android,\n        // Not available until FreeBSD 13.0\n        all(target_os = \"freebsd\", fbsd14),\n))]\n#[test]\n// QEMU does not support copy_file_range. Skip under qemu\n#[cfg_attr(qemu, ignore)]\nfn test_copy_file_range() {\n    use nix::fcntl::copy_file_range;\n\n    const CONTENTS: \u0026[u8] = b\"foobarbaz\";\n\n    let mut tmp1 = tempfile::tempfile().unwrap();\n    let mut tmp2 = tempfile::tempfile().unwrap();\n\n    tmp1.write_all(CONTENTS).unwrap();\n    tmp1.flush().unwrap();\n\n    let mut from_offset: i64 = 3;\n    copy_file_range(\u0026tmp1, Some(\u0026mut from_offset), \u0026tmp2, None, 3).unwrap();\n\n    let mut res: String = String::new();\n    tmp2.rewind().unwrap();\n    tmp2.read_to_string(\u0026mut res).unwrap();\n\n    assert_eq!(res, String::from(\"bar\"));\n    assert_eq!(from_offset, 6);\n}\n\n#[cfg(linux_android)]\nmod linux_android {\n    use libc::loff_t;\n    use std::io::prelude::*;\n    use std::io::IoSlice;\n\n    use nix::fcntl::*;\n    use nix::unistd::{pipe, read, write};\n\n    use tempfile::tempfile;\n    #[cfg(target_os = \"linux\")]\n    use tempfile::NamedTempFile;\n\n    use crate::*;\n\n    #[test]\n    fn test_splice() {\n        const CONTENTS: \u0026[u8] = b\"abcdef123456\";\n        let mut tmp = tempfile().unwrap();\n        tmp.write_all(CONTENTS).unwrap();\n\n        let (rd, wr) = pipe().unwrap();\n        let mut offset: loff_t = 5;\n        let res =\n            splice(tmp, Some(\u0026mut offset), wr, None, 2, SpliceFFlags::empty())\n                .unwrap();\n\n        assert_eq!(2, res);\n\n        let mut buf = [0u8; 1024];\n        assert_eq!(2, read(\u0026rd, \u0026mut buf).unwrap());\n        assert_eq!(b\"f1\", \u0026buf[0..2]);\n        assert_eq!(7, offset);\n    }\n\n    #[test]\n    fn test_tee() {\n        let (rd1, wr1) = pipe().unwrap();\n        let (rd2, wr2) = pipe().unwrap();\n\n        write(wr1, b\"abc\").unwrap();\n        let res = tee(rd1.try_clone().unwrap(), wr2, 2, SpliceFFlags::empty())\n            .unwrap();\n\n        assert_eq!(2, res);\n\n        let mut buf = [0u8; 1024];\n\n        // Check the tee'd bytes are at rd2.\n        assert_eq!(2, read(\u0026rd2, \u0026mut buf).unwrap());\n        assert_eq!(b\"ab\", \u0026buf[0..2]);\n\n        // Check all the bytes are still at rd1.\n        assert_eq!(3, read(\u0026rd1, \u0026mut buf).unwrap());\n        assert_eq!(b\"abc\", \u0026buf[0..3]);\n    }\n\n    #[test]\n    fn test_vmsplice() {\n        let (rd, wr) = pipe().unwrap();\n\n        let buf1 = b\"abcdef\";\n        let buf2 = b\"defghi\";\n        let iovecs = [IoSlice::new(\u0026buf1[0..3]), IoSlice::new(\u0026buf2[0..3])];\n\n        let res = vmsplice(wr, \u0026iovecs[..], SpliceFFlags::empty()).unwrap();\n\n        assert_eq!(6, res);\n\n        // Check the bytes can be read at rd.\n        let mut buf = [0u8; 32];\n        assert_eq!(6, read(\u0026rd, \u0026mut buf).unwrap());\n        assert_eq!(b\"abcdef\", \u0026buf[0..6]);\n    }\n\n    #[cfg(target_os = \"linux\")]\n    #[test]\n    fn test_fallocate() {\n        let tmp = NamedTempFile::new().unwrap();\n\n        fallocate(\u0026tmp, FallocateFlags::empty(), 0, 100).unwrap();\n\n        // Check if we read exactly 100 bytes\n        let mut buf = [0u8; 200];\n        assert_eq!(100, read(\u0026tmp, \u0026mut buf).unwrap());\n    }\n\n    // The tests below are disabled for the listed targets\n    // due to OFD locks not being available in the kernel/libc\n    // versions used in the CI environment, probably because\n    // they run under QEMU.\n\n    #[test]\n    #[cfg(all(target_os = \"linux\", not(target_env = \"musl\")))]\n    #[cfg_attr(target_env = \"uclibc\", ignore)] // uclibc doesn't support OFD locks, but the test should still compile\n    fn test_ofd_write_lock() {\n        use nix::sys::stat::fstat;\n        use std::mem;\n\n        let tmp = NamedTempFile::new().unwrap();\n\n        let statfs = nix::sys::statfs::fstatfs(tmp.as_file()).unwrap();\n        if statfs.filesystem_type() == nix::sys::statfs::OVERLAYFS_SUPER_MAGIC {\n            // OverlayFS is a union file system.  It returns one inode value in\n            // stat(2), but a different one shows up in /proc/locks.  So we must\n            // skip the test.\n            skip!(\"/proc/locks does not work on overlayfs\");\n        }\n        let inode = fstat(\u0026tmp).expect(\"fstat failed\").st_ino as usize;\n\n        let mut flock: libc::flock = unsafe {\n            mem::zeroed() // required for Linux/mips\n        };\n        flock.l_type = libc::F_WRLCK as libc::c_short;\n        flock.l_whence = libc::SEEK_SET as libc::c_short;\n        flock.l_start = 0;\n        flock.l_len = 0;\n        flock.l_pid = 0;\n        fcntl(\u0026tmp, FcntlArg::F_OFD_SETLKW(\u0026flock)).expect(\"write lock failed\");\n        assert_eq!(\n            Some((\"OFDLCK\".to_string(), \"WRITE\".to_string())),\n            lock_info(inode)\n        );\n\n        flock.l_type = libc::F_UNLCK as libc::c_short;\n        fcntl(\u0026tmp, FcntlArg::F_OFD_SETLKW(\u0026flock))\n            .expect(\"write unlock failed\");\n        assert_eq!(None, lock_info(inode));\n    }\n\n    #[test]\n    #[cfg(all(target_os = \"linux\", not(target_env = \"musl\")))]\n    #[cfg_attr(target_env = \"uclibc\", ignore)] // uclibc doesn't support OFD locks, but the test should still compile\n    fn test_ofd_read_lock() {\n        use nix::sys::stat::fstat;\n        use std::mem;\n\n        let tmp = NamedTempFile::new().unwrap();\n\n        let statfs = nix::sys::statfs::fstatfs(tmp.as_file()).unwrap();\n        if statfs.filesystem_type() == nix::sys::statfs::OVERLAYFS_SUPER_MAGIC {\n            // OverlayFS is a union file system.  It returns one inode value in\n            // stat(2), but a different one shows up in /proc/locks.  So we must\n            // skip the test.\n            skip!(\"/proc/locks does not work on overlayfs\");\n        }\n        let inode = fstat(\u0026tmp).expect(\"fstat failed\").st_ino as usize;\n\n        let mut flock: libc::flock = unsafe {\n            mem::zeroed() // required for Linux/mips\n        };\n        flock.l_type = libc::F_RDLCK as libc::c_short;\n        flock.l_whence = libc::SEEK_SET as libc::c_short;\n        flock.l_start = 0;\n        flock.l_len = 0;\n        flock.l_pid = 0;\n        fcntl(\u0026tmp, FcntlArg::F_OFD_SETLKW(\u0026flock)).expect(\"read lock failed\");\n        assert_eq!(\n            Some((\"OFDLCK\".to_string(), \"READ\".to_string())),\n            lock_info(inode)\n        );\n\n        flock.l_type = libc::F_UNLCK as libc::c_short;\n        fcntl(\u0026tmp, FcntlArg::F_OFD_SETLKW(\u0026flock))\n            .expect(\"read unlock failed\");\n        assert_eq!(None, lock_info(inode));\n    }\n\n    #[cfg(all(target_os = \"linux\", not(target_env = \"musl\")))]\n    fn lock_info(inode: usize) -\u003e Option\u003c(String, String)\u003e {\n        use std::{fs::File, io::BufReader};\n\n        let file = File::open(\"/proc/locks\").expect(\"open /proc/locks failed\");\n        let buf = BufReader::new(file);\n\n        for line in buf.lines() {\n            let line = line.unwrap();\n            let parts: Vec\u003c_\u003e = line.split_whitespace().collect();\n            let lock_type = parts[1];\n            let lock_access = parts[3];\n            let ino_parts: Vec\u003c_\u003e = parts[5].split(':').collect();\n            let ino: usize = ino_parts[2].parse().unwrap();\n            if ino == inode {\n                return Some((lock_type.to_string(), lock_access.to_string()));\n            }\n        }\n        None\n    }\n}\n\n#[cfg(any(\n    linux_android,\n    target_os = \"emscripten\",\n    target_os = \"fuchsia\",\n    target_os = \"wasi\",\n    target_env = \"uclibc\",\n    target_os = \"freebsd\"\n))]\nmod test_posix_fadvise {\n    use nix::errno::Errno;\n    use nix::fcntl::*;\n    use nix::unistd::pipe;\n    use tempfile::NamedTempFile;\n\n    #[test]\n    fn test_success() {\n        let tmp = NamedTempFile::new().unwrap();\n        posix_fadvise(\u0026tmp, 0, 100, PosixFadviseAdvice::POSIX_FADV_WILLNEED)\n            .expect(\"posix_fadvise failed\");\n    }\n\n    #[test]\n    fn test_errno() {\n        let (rd, _wr) = pipe().unwrap();\n        let res =\n            posix_fadvise(\u0026rd, 0, 100, PosixFadviseAdvice::POSIX_FADV_WILLNEED);\n        assert_eq!(res, Err(Errno::ESPIPE));\n    }\n}\n\n#[cfg(any(\n    linux_android,\n    freebsdlike,\n    target_os = \"emscripten\",\n    target_os = \"fuchsia\",\n    target_os = \"wasi\",\n))]\nmod test_posix_fallocate {\n\n    use nix::errno::Errno;\n    use nix::fcntl::*;\n    use nix::unistd::pipe;\n    use std::io::Read;\n    use tempfile::NamedTempFile;\n\n    #[test]\n    fn success() {\n        const LEN: usize = 100;\n        let mut tmp = NamedTempFile::new().unwrap();\n        let res = posix_fallocate(\u0026tmp, 0, LEN as libc::off_t);\n        match res {\n            Ok(_) =\u003e {\n                let mut data = [1u8; LEN];\n                assert_eq!(tmp.read(\u0026mut data).expect(\"read failure\"), LEN);\n                assert_eq!(\u0026data[..], \u0026[0u8; LEN][..]);\n            }\n            Err(Errno::EINVAL) =\u003e {\n                // POSIX requires posix_fallocate to return EINVAL both for\n                // invalid arguments (i.e. len \u003c 0) and if the operation is not\n                // supported by the file system.\n                // There's no way to tell for sure whether the file system\n                // supports posix_fallocate, so we must pass the test if it\n                // returns EINVAL.\n            }\n            _ =\u003e res.unwrap(),\n        }\n    }\n\n    #[test]\n    fn errno() {\n        let (rd, _wr) = pipe().unwrap();\n        let err = posix_fallocate(\u0026rd, 0, 100).unwrap_err();\n        match err {\n            Errno::EINVAL | Errno::ENODEV | Errno::ESPIPE | Errno::EBADF =\u003e (),\n            errno =\u003e panic!(\"unexpected errno {errno}\",),\n        }\n    }\n}\n\n#[cfg(any(target_os = \"dragonfly\", target_os = \"netbsd\", apple_targets))]\n#[test]\nfn test_f_get_path() {\n    use nix::fcntl::*;\n    use std::path::PathBuf;\n\n    let tmp = NamedTempFile::new().unwrap();\n    let mut path = PathBuf::new();\n    let res =\n        fcntl(\u0026tmp, FcntlArg::F_GETPATH(\u0026mut path)).expect(\"get path failed\");\n    assert_ne!(res, -1);\n    assert_eq!(\n        path.as_path().canonicalize().unwrap(),\n        tmp.path().canonicalize().unwrap()\n    );\n}\n\n#[cfg(apple_targets)]\n#[test]\nfn test_f_preallocate() {\n    use nix::fcntl::*;\n\n    let tmp = NamedTempFile::new().unwrap();\n    let mut st: libc::fstore_t = unsafe { std::mem::zeroed() };\n\n    st.fst_flags = libc::F_ALLOCATECONTIG as libc::c_uint;\n    st.fst_posmode = libc::F_PEOFPOSMODE;\n    st.fst_length = 1024;\n    let res = fcntl(tmp, FcntlArg::F_PREALLOCATE(\u0026mut st))\n        .expect(\"preallocation failed\");\n\n    assert_eq!(res, 0);\n    assert!(st.fst_bytesalloc \u003e 0);\n}\n\n#[cfg(apple_targets)]\n#[test]\nfn test_f_get_path_nofirmlink() {\n    use nix::fcntl::*;\n    use std::path::PathBuf;\n\n    let tmp = NamedTempFile::new().unwrap();\n    let mut path = PathBuf::new();\n    let res = fcntl(\u0026tmp, FcntlArg::F_GETPATH_NOFIRMLINK(\u0026mut path))\n        .expect(\"get path failed\");\n    let mut tmpstr = String::from(\"/System/Volumes/Data\");\n    tmpstr.push_str(\n        \u0026tmp.path()\n            .canonicalize()\n            .unwrap()\n            .into_os_string()\n            .into_string()\n            .unwrap(),\n    );\n    assert_ne!(res, -1);\n    assert_eq!(\n        path.as_path()\n            .canonicalize()\n            .unwrap()\n            .into_os_string()\n            .into_string()\n            .unwrap(),\n        tmpstr\n    );\n}\n\n#[cfg(all(target_os = \"freebsd\", target_arch = \"x86_64\"))]\n#[test]\nfn test_f_kinfo() {\n    use nix::fcntl::*;\n    use std::path::PathBuf;\n\n    let tmp = NamedTempFile::new().unwrap();\n    // With TMPDIR set with UFS, the vnode name is not entered\n    // into the name cache thus path is always empty.\n    // Therefore, we reopen the tempfile a second time for the test\n    // to pass.\n    let tmp2 = File::open(tmp.path()).unwrap();\n    let mut path = PathBuf::new();\n    let res =\n        fcntl(\u0026tmp2, FcntlArg::F_KINFO(\u0026mut path)).expect(\"get path failed\");\n    assert_ne!(res, -1);\n    assert_eq!(path, tmp.path());\n}\n\n/// Test `Flock` and associated functions.\n///\n#[cfg(not(any(target_os = \"redox\", target_os = \"solaris\")))]\nmod test_flock {\n    use nix::fcntl::*;\n    use tempfile::NamedTempFile;\n\n    /// Verify that `Flock::lock()` correctly obtains a lock, and subsequently unlocks upon drop.\n    #[test]\n    fn lock_and_drop() {\n        // Get 2 `File` handles to same underlying file.\n        let file1 = NamedTempFile::new().unwrap();\n        let file2 = file1.reopen().unwrap();\n        let file1 = file1.into_file();\n\n        // Lock first handle\n        let lock1 = Flock::lock(file1, FlockArg::LockExclusive).unwrap();\n\n        // Attempt to lock second handle\n        let file2 = match Flock::lock(file2, FlockArg::LockExclusiveNonblock) {\n            Ok(_) =\u003e panic!(\"Expected second exclusive lock to fail.\"),\n            Err((f, _)) =\u003e f,\n        };\n\n        // Drop first lock\n        std::mem::drop(lock1);\n\n        // Attempt to lock second handle again (but successfully)\n        if Flock::lock(file2, FlockArg::LockExclusiveNonblock).is_err() {\n            panic!(\"Expected locking to be successful.\");\n        }\n    }\n\n    /// An exclusive lock can be downgraded\n    #[test]\n    fn downgrade() {\n        let file1 = NamedTempFile::new().unwrap();\n        let file2 = file1.reopen().unwrap();\n        let file1 = file1.into_file();\n\n        // Lock first handle\n        let lock1 = Flock::lock(file1, FlockArg::LockExclusive).unwrap();\n\n        // Attempt to lock second handle\n        let file2 = Flock::lock(file2, FlockArg::LockSharedNonblock)\n            .unwrap_err()\n            .0;\n\n        // Downgrade the lock\n        lock1.relock(FlockArg::LockShared).unwrap();\n\n        // Attempt to lock second handle again (but successfully)\n        Flock::lock(file2, FlockArg::LockSharedNonblock)\n            .expect(\"Expected locking to be successful.\");\n    }\n\n    /// Verify that `Flock::unlock()` correctly obtains unlocks.\n    #[test]\n    fn unlock() {\n        // Get 2 `File` handles to same underlying file.\n        let file1 = NamedTempFile::new().unwrap();\n        let file2 = file1.reopen().unwrap();\n        let file1 = file1.into_file();\n\n        // Lock first handle\n        let lock1 = Flock::lock(file1, FlockArg::LockExclusive).unwrap();\n\n        // Unlock and retain file so any erroneous flocks also remain present.\n        let _file1 = lock1.unlock().unwrap();\n\n        // Attempt to lock second handle.\n        if Flock::lock(file2, FlockArg::LockExclusiveNonblock).is_err() {\n            panic!(\"Expected locking to be successful.\");\n        }\n    }\n\n    /// A shared lock can be upgraded\n    #[test]\n    fn upgrade() {\n        let file1 = NamedTempFile::new().unwrap();\n        let file2 = file1.reopen().unwrap();\n        let file3 = file1.reopen().unwrap();\n        let file1 = file1.into_file();\n\n        // Lock first handle\n        let lock1 = Flock::lock(file1, FlockArg::LockShared).unwrap();\n\n        // Attempt to lock second handle\n        {\n            Flock::lock(file2, FlockArg::LockSharedNonblock)\n                .expect(\"Locking should've succeeded\");\n        }\n\n        // Upgrade the lock\n        lock1.relock(FlockArg::LockExclusive).unwrap();\n\n        // Acquiring an additional shared lock should fail\n        Flock::lock(file3, FlockArg::LockSharedNonblock)\n            .expect_err(\"Should not have been able to lock the file\");\n    }\n}\n\n#[cfg(apple_targets)]\n#[test]\nfn test_f_rdadvise() {\n    use nix::fcntl::*;\n\n    let contents = vec![1; 1024];\n    let mut buf = [0; 1024];\n    let mut tmp = NamedTempFile::new().unwrap();\n    tmp.write_all(\u0026contents).unwrap();\n    let fd = open(tmp.path(), OFlag::empty(), Mode::empty()).unwrap();\n    let rad = libc::radvisory {\n        ra_offset: 0,\n        ra_count: contents.len() as _,\n    };\n    let res = fcntl(\u0026tmp, FcntlArg::F_RDADVISE(rad)).expect(\"rdadivse failed\");\n    assert_ne!(res, -1);\n    assert_eq!(contents.len(), read(\u0026fd, \u0026mut buf).unwrap());\n    assert_eq!(contents, \u0026buf[0..contents.len()]);\n}\n\n#[cfg(apple_targets)]\n#[test]\nfn test_f_log2phys() {\n    use nix::fcntl::*;\n\n    const CONTENTS: \u0026[u8] = b\"abcd\";\n    let mut tmp = NamedTempFile::new().unwrap();\n    tmp.write_all(CONTENTS).unwrap();\n    let mut offset: libc::off_t = 0;\n    let mut res = fcntl(\u0026tmp, FcntlArg::F_LOG2PHYS(\u0026mut offset))\n        .expect(\"log2phys failed\");\n    assert_ne!(res, -1);\n    assert_ne!(offset, 0);\n    let mut info: libc::log2phys = unsafe { std::mem::zeroed() };\n    info.l2p_contigbytes = CONTENTS.len() as _;\n    info.l2p_devoffset = 3;\n    res = fcntl(\u0026tmp, FcntlArg::F_LOG2PHYS_EXT(\u0026mut info))\n        .expect(\"log2phys failed\");\n    assert_ne!(res, -1);\n    assert_ne!({ info.l2p_devoffset }, 3);\n}\n\n#[cfg(apple_targets)]\n#[test]\nfn test_f_transferextents() {\n    use nix::fcntl::*;\n    use std::os::fd::AsRawFd;\n\n    let tmp1 = NamedTempFile::new().unwrap();\n    let tmp2 = NamedTempFile::new().unwrap();\n    let res = fcntl(\u0026tmp1, FcntlArg::F_TRANSFEREXTENTS(tmp2.as_raw_fd()))\n        .expect(\"transferextents failed\");\n    assert_ne!(res, -1);\n}\n\n#[cfg(target_os = \"freebsd\")]\n#[test]\nfn test_f_readahead() {\n    use nix::fcntl::*;\n\n    let tmp = NamedTempFile::new().unwrap();\n    let mut res = fcntl(\u0026tmp, FcntlArg::F_READAHEAD(1_000_000))\n        .expect(\"read ahead failed\");\n    assert_ne!(res, -1);\n    res = fcntl(\u0026tmp, FcntlArg::F_READAHEAD(-1024)).expect(\"read ahead failed\");\n    assert_ne!(res, -1);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","test_kmod","mod.rs"],"content":"use crate::*;\nuse std::fs::copy;\nuse std::path::PathBuf;\nuse std::process::Command;\nuse tempfile::{tempdir, TempDir};\n\nfn compile_kernel_module() -\u003e (PathBuf, String, TempDir) {\n    let _m = crate::FORK_MTX.lock();\n\n    let tmp_dir =\n        tempdir().expect(\"unable to create temporary build directory\");\n\n    copy(\n        \"test/test_kmod/hello_mod/hello.c\",\n        tmp_dir.path().join(\"hello.c\"),\n    )\n    .expect(\"unable to copy hello.c to temporary build directory\");\n    copy(\n        \"test/test_kmod/hello_mod/Makefile\",\n        tmp_dir.path().join(\"Makefile\"),\n    )\n    .expect(\"unable to copy Makefile to temporary build directory\");\n\n    let status = Command::new(\"make\")\n        .current_dir(tmp_dir.path())\n        .status()\n        .expect(\"failed to run make\");\n\n    assert!(status.success());\n\n    // Return the relative path of the build kernel module\n    (tmp_dir.path().join(\"hello.ko\"), \"hello\".to_owned(), tmp_dir)\n}\n\nuse nix::errno::Errno;\nuse nix::kmod::{delete_module, DeleteModuleFlags};\nuse nix::kmod::{finit_module, init_module, ModuleInitFlags};\nuse std::ffi::CString;\nuse std::fs::File;\nuse std::io::Read;\n\n#[test]\nfn test_finit_and_delete_module() {\n    require_capability!(\"test_finit_and_delete_module\", CAP_SYS_MODULE);\n    let _m0 = crate::KMOD_MTX.lock();\n    let _m1 = crate::CWD_LOCK.read();\n\n    let (kmod_path, kmod_name, _kmod_dir) = compile_kernel_module();\n\n    let f = File::open(kmod_path).expect(\"unable to open kernel module\");\n    finit_module(\u0026f, \u0026CString::new(\"\").unwrap(), ModuleInitFlags::empty())\n        .expect(\"unable to load kernel module\");\n\n    delete_module(\n        \u0026CString::new(kmod_name).unwrap(),\n        DeleteModuleFlags::empty(),\n    )\n    .expect(\"unable to unload kernel module\");\n}\n\n#[test]\nfn test_finit_and_delete_module_with_params() {\n    require_capability!(\n        \"test_finit_and_delete_module_with_params\",\n        CAP_SYS_MODULE\n    );\n    let _m0 = crate::KMOD_MTX.lock();\n    let _m1 = crate::CWD_LOCK.read();\n\n    let (kmod_path, kmod_name, _kmod_dir) = compile_kernel_module();\n\n    let f = File::open(kmod_path).expect(\"unable to open kernel module\");\n    finit_module(\n        \u0026f,\n        \u0026CString::new(\"who=Rust number=2018\").unwrap(),\n        ModuleInitFlags::empty(),\n    )\n    .expect(\"unable to load kernel module\");\n\n    delete_module(\n        \u0026CString::new(kmod_name).unwrap(),\n        DeleteModuleFlags::empty(),\n    )\n    .expect(\"unable to unload kernel module\");\n}\n\n#[test]\nfn test_init_and_delete_module() {\n    require_capability!(\"test_init_and_delete_module\", CAP_SYS_MODULE);\n    let _m0 = crate::KMOD_MTX.lock();\n    let _m1 = crate::CWD_LOCK.read();\n\n    let (kmod_path, kmod_name, _kmod_dir) = compile_kernel_module();\n\n    let mut f = File::open(kmod_path).expect(\"unable to open kernel module\");\n    let mut contents: Vec\u003cu8\u003e = Vec::new();\n    f.read_to_end(\u0026mut contents)\n        .expect(\"unable to read kernel module content to buffer\");\n    init_module(\u0026contents, \u0026CString::new(\"\").unwrap())\n        .expect(\"unable to load kernel module\");\n\n    delete_module(\n        \u0026CString::new(kmod_name).unwrap(),\n        DeleteModuleFlags::empty(),\n    )\n    .expect(\"unable to unload kernel module\");\n}\n\n#[test]\nfn test_init_and_delete_module_with_params() {\n    require_capability!(\n        \"test_init_and_delete_module_with_params\",\n        CAP_SYS_MODULE\n    );\n    let _m0 = crate::KMOD_MTX.lock();\n    let _m1 = crate::CWD_LOCK.read();\n\n    let (kmod_path, kmod_name, _kmod_dir) = compile_kernel_module();\n\n    let mut f = File::open(kmod_path).expect(\"unable to open kernel module\");\n    let mut contents: Vec\u003cu8\u003e = Vec::new();\n    f.read_to_end(\u0026mut contents)\n        .expect(\"unable to read kernel module content to buffer\");\n    init_module(\u0026contents, \u0026CString::new(\"who=Nix number=2015\").unwrap())\n        .expect(\"unable to load kernel module\");\n\n    delete_module(\n        \u0026CString::new(kmod_name).unwrap(),\n        DeleteModuleFlags::empty(),\n    )\n    .expect(\"unable to unload kernel module\");\n}\n\n#[test]\nfn test_finit_module_invalid() {\n    require_capability!(\"test_finit_module_invalid\", CAP_SYS_MODULE);\n    let _m0 = crate::KMOD_MTX.lock();\n    let _m1 = crate::CWD_LOCK.read();\n\n    let kmod_path = \"/dev/zero\";\n\n    let f = File::open(kmod_path).expect(\"unable to open kernel module\");\n    let result =\n        finit_module(\u0026f, \u0026CString::new(\"\").unwrap(), ModuleInitFlags::empty());\n\n    assert_eq!(result.unwrap_err(), Errno::EINVAL);\n}\n\n#[test]\nfn test_finit_module_twice_and_delete_module() {\n    require_capability!(\n        \"test_finit_module_twice_and_delete_module\",\n        CAP_SYS_MODULE\n    );\n    let _m0 = crate::KMOD_MTX.lock();\n    let _m1 = crate::CWD_LOCK.read();\n\n    let (kmod_path, kmod_name, _kmod_dir) = compile_kernel_module();\n\n    let f = File::open(kmod_path).expect(\"unable to open kernel module\");\n    finit_module(\u0026f, \u0026CString::new(\"\").unwrap(), ModuleInitFlags::empty())\n        .expect(\"unable to load kernel module\");\n\n    let result =\n        finit_module(\u0026f, \u0026CString::new(\"\").unwrap(), ModuleInitFlags::empty());\n\n    assert_eq!(result.unwrap_err(), Errno::EEXIST);\n\n    delete_module(\n        \u0026CString::new(kmod_name).unwrap(),\n        DeleteModuleFlags::empty(),\n    )\n    .expect(\"unable to unload kernel module\");\n}\n\n#[test]\nfn test_delete_module_not_loaded() {\n    require_capability!(\"test_delete_module_not_loaded\", CAP_SYS_MODULE);\n    let _m0 = crate::KMOD_MTX.lock();\n    let _m1 = crate::CWD_LOCK.read();\n\n    let result = delete_module(\n        \u0026CString::new(\"hello\").unwrap(),\n        DeleteModuleFlags::empty(),\n    );\n\n    assert_eq!(result.unwrap_err(), Errno::ENOENT);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","test_mq.rs"],"content":"use cfg_if::cfg_if;\nuse std::str;\n\nuse nix::errno::Errno;\nuse nix::mqueue::{\n    mq_attr_member_t, mq_close, mq_open, mq_receive, mq_send, mq_timedreceive,\n};\nuse nix::mqueue::{MQ_OFlag, MqAttr};\nuse nix::sys::stat::Mode;\nuse nix::sys::time::{TimeSpec, TimeValLike};\nuse nix::time::{clock_gettime, ClockId};\n\n// Defined as a macro such that the error source is reported as the caller's location.\nmacro_rules! assert_attr_eq {\n    ($read_attr:ident, $initial_attr:ident) =\u003e {\n        cfg_if! {\n            if #[cfg(any(target_os = \"dragonfly\", target_os = \"netbsd\"))] {\n                // NetBSD (and others which inherit its implementation) include other flags\n                // in read_attr, such as those specified by oflag. Just make sure at least\n                // the correct bits are set.\n                assert_eq!($read_attr.flags() \u0026 $initial_attr.flags(), $initial_attr.flags());\n                assert_eq!($read_attr.maxmsg(), $initial_attr.maxmsg());\n                assert_eq!($read_attr.msgsize(), $initial_attr.msgsize());\n                assert_eq!($read_attr.curmsgs(), $initial_attr.curmsgs());\n            } else {\n                assert_eq!($read_attr, $initial_attr);\n            }\n        }\n    }\n}\n\n#[test]\nfn test_mq_send_and_receive() {\n    const MSG_SIZE: mq_attr_member_t = 32;\n    let attr = MqAttr::new(0, 10, MSG_SIZE, 0);\n    let mq_name = \"/a_nix_test_queue\";\n\n    let oflag0 = MQ_OFlag::O_CREAT | MQ_OFlag::O_WRONLY;\n    let mode = Mode::S_IWUSR | Mode::S_IRUSR | Mode::S_IRGRP | Mode::S_IROTH;\n    let r0 = mq_open(mq_name, oflag0, mode, Some(\u0026attr));\n    if let Err(Errno::ENOSYS) = r0 {\n        println!(\"message queues not supported or module not loaded?\");\n        return;\n    };\n    let mqd0 = r0.unwrap();\n    let msg_to_send = \"msg_1\";\n    mq_send(\u0026mqd0, msg_to_send.as_bytes(), 1).unwrap();\n\n    let oflag1 = MQ_OFlag::O_CREAT | MQ_OFlag::O_RDONLY;\n    let mqd1 = mq_open(mq_name, oflag1, mode, Some(\u0026attr)).unwrap();\n    let mut buf = [0u8; 32];\n    let mut prio = 0u32;\n    let len = mq_receive(\u0026mqd1, \u0026mut buf, \u0026mut prio).unwrap();\n    assert_eq!(prio, 1);\n\n    mq_close(mqd1).unwrap();\n    mq_close(mqd0).unwrap();\n    assert_eq!(msg_to_send, str::from_utf8(\u0026buf[0..len]).unwrap());\n}\n\n#[test]\nfn test_mq_timedreceive() {\n    const MSG_SIZE: mq_attr_member_t = 32;\n    let attr = MqAttr::new(0, 10, MSG_SIZE, 0);\n    let mq_name = \"/a_nix_test_queue\";\n\n    let oflag0 = MQ_OFlag::O_CREAT | MQ_OFlag::O_WRONLY;\n    let mode = Mode::S_IWUSR | Mode::S_IRUSR | Mode::S_IRGRP | Mode::S_IROTH;\n    let r0 = mq_open(mq_name, oflag0, mode, Some(\u0026attr));\n    if let Err(Errno::ENOSYS) = r0 {\n        println!(\"message queues not supported or module not loaded?\");\n        return;\n    };\n    let mqd0 = r0.unwrap();\n    let msg_to_send = \"msg_1\";\n    mq_send(\u0026mqd0, msg_to_send.as_bytes(), 1).unwrap();\n\n    let oflag1 = MQ_OFlag::O_CREAT | MQ_OFlag::O_RDONLY;\n    let mqd1 = mq_open(mq_name, oflag1, mode, Some(\u0026attr)).unwrap();\n    let mut buf = [0u8; 32];\n    let mut prio = 0u32;\n    let abstime =\n        clock_gettime(ClockId::CLOCK_REALTIME).unwrap() + TimeSpec::seconds(1);\n    let len = mq_timedreceive(\u0026mqd1, \u0026mut buf, \u0026mut prio, \u0026abstime).unwrap();\n    assert_eq!(prio, 1);\n\n    mq_close(mqd1).unwrap();\n    mq_close(mqd0).unwrap();\n    assert_eq!(msg_to_send, str::from_utf8(\u0026buf[0..len]).unwrap());\n}\n\n#[test]\nfn test_mq_getattr() {\n    use nix::mqueue::mq_getattr;\n    const MSG_SIZE: mq_attr_member_t = 32;\n    let initial_attr = MqAttr::new(0, 10, MSG_SIZE, 0);\n    let mq_name = \"/attr_test_get_attr\";\n    let oflag = MQ_OFlag::O_CREAT | MQ_OFlag::O_WRONLY;\n    let mode = Mode::S_IWUSR | Mode::S_IRUSR | Mode::S_IRGRP | Mode::S_IROTH;\n    let r = mq_open(mq_name, oflag, mode, Some(\u0026initial_attr));\n    if let Err(Errno::ENOSYS) = r {\n        println!(\"message queues not supported or module not loaded?\");\n        return;\n    };\n    let mqd = r.unwrap();\n\n    let read_attr = mq_getattr(\u0026mqd).unwrap();\n    assert_attr_eq!(read_attr, initial_attr);\n    mq_close(mqd).unwrap();\n}\n\n// FIXME: Fix failures for mips in QEMU\n#[test]\n#[cfg_attr(\n    all(\n        qemu,\n        any(\n            target_arch = \"mips\",\n            target_arch = \"mips32r6\",\n            target_arch = \"mips64\",\n            target_arch = \"mips64r6\"\n        )\n    ),\n    ignore\n)]\nfn test_mq_setattr() {\n    use nix::mqueue::{mq_getattr, mq_setattr};\n    const MSG_SIZE: mq_attr_member_t = 32;\n    let initial_attr = MqAttr::new(0, 10, MSG_SIZE, 0);\n    let mq_name = \"/attr_test_get_attr\";\n    let oflag = MQ_OFlag::O_CREAT | MQ_OFlag::O_WRONLY;\n    let mode = Mode::S_IWUSR | Mode::S_IRUSR | Mode::S_IRGRP | Mode::S_IROTH;\n    let r = mq_open(mq_name, oflag, mode, Some(\u0026initial_attr));\n    if let Err(Errno::ENOSYS) = r {\n        println!(\"message queues not supported or module not loaded?\");\n        return;\n    };\n    let mqd = r.unwrap();\n\n    let new_attr = MqAttr::new(0, 20, MSG_SIZE * 2, 100);\n    let old_attr = mq_setattr(\u0026mqd, \u0026new_attr).unwrap();\n    assert_attr_eq!(old_attr, initial_attr);\n\n    // No changes here because according to the Linux man page only\n    // O_NONBLOCK can be set (see tests below)\n    #[cfg(not(any(target_os = \"dragonfly\", target_os = \"netbsd\")))]\n    {\n        let new_attr_get = mq_getattr(\u0026mqd).unwrap();\n        assert_ne!(new_attr_get, new_attr);\n    }\n\n    let new_attr_non_blocking = MqAttr::new(\n        MQ_OFlag::O_NONBLOCK.bits() as mq_attr_member_t,\n        10,\n        MSG_SIZE,\n        0,\n    );\n    mq_setattr(\u0026mqd, \u0026new_attr_non_blocking).unwrap();\n    let new_attr_get = mq_getattr(\u0026mqd).unwrap();\n\n    // now the O_NONBLOCK flag has been set\n    #[cfg(not(any(target_os = \"dragonfly\", target_os = \"netbsd\")))]\n    {\n        assert_ne!(new_attr_get, initial_attr);\n    }\n    assert_attr_eq!(new_attr_get, new_attr_non_blocking);\n    mq_close(mqd).unwrap();\n}\n\n// FIXME: Fix failures for mips in QEMU\n#[test]\n#[cfg_attr(\n    all(\n        qemu,\n        any(\n            target_arch = \"mips\",\n            target_arch = \"mips32r6\",\n            target_arch = \"mips64\",\n            target_arch = \"mips64r6\"\n        )\n    ),\n    ignore\n)]\nfn test_mq_set_nonblocking() {\n    use nix::mqueue::{mq_getattr, mq_remove_nonblock, mq_set_nonblock};\n    const MSG_SIZE: mq_attr_member_t = 32;\n    let initial_attr = MqAttr::new(0, 10, MSG_SIZE, 0);\n    let mq_name = \"/attr_test_get_attr\";\n    let oflag = MQ_OFlag::O_CREAT | MQ_OFlag::O_WRONLY;\n    let mode = Mode::S_IWUSR | Mode::S_IRUSR | Mode::S_IRGRP | Mode::S_IROTH;\n    let r = mq_open(mq_name, oflag, mode, Some(\u0026initial_attr));\n    if let Err(Errno::ENOSYS) = r {\n        println!(\"message queues not supported or module not loaded?\");\n        return;\n    };\n    let mqd = r.unwrap();\n    mq_set_nonblock(\u0026mqd).unwrap();\n    let new_attr = mq_getattr(\u0026mqd);\n    let o_nonblock_bits = MQ_OFlag::O_NONBLOCK.bits() as mq_attr_member_t;\n    assert_eq!(new_attr.unwrap().flags() \u0026 o_nonblock_bits, o_nonblock_bits);\n    mq_remove_nonblock(\u0026mqd).unwrap();\n    let new_attr = mq_getattr(\u0026mqd);\n    assert_eq!(new_attr.unwrap().flags() \u0026 o_nonblock_bits, 0);\n    mq_close(mqd).unwrap();\n}\n\n#[test]\nfn test_mq_unlink() {\n    use nix::mqueue::mq_unlink;\n    const MSG_SIZE: mq_attr_member_t = 32;\n    let initial_attr = MqAttr::new(0, 10, MSG_SIZE, 0);\n    let mq_name_opened = \"/mq_unlink_test\";\n    #[cfg(not(any(target_os = \"dragonfly\", target_os = \"netbsd\")))]\n    let mq_name_not_opened = \"/mq_unlink_test\";\n    let oflag = MQ_OFlag::O_CREAT | MQ_OFlag::O_WRONLY;\n    let mode = Mode::S_IWUSR | Mode::S_IRUSR | Mode::S_IRGRP | Mode::S_IROTH;\n    let r = mq_open(mq_name_opened, oflag, mode, Some(\u0026initial_attr));\n    if let Err(Errno::ENOSYS) = r {\n        println!(\"message queues not supported or module not loaded?\");\n        return;\n    };\n    let mqd = r.unwrap();\n\n    let res_unlink = mq_unlink(mq_name_opened);\n    assert_eq!(res_unlink, Ok(()));\n\n    // NetBSD (and others which inherit its implementation) defer removing the message\n    // queue name until all references are closed, whereas Linux and others remove the\n    // message queue name immediately.\n    #[cfg(not(any(target_os = \"dragonfly\", target_os = \"netbsd\")))]\n    {\n        let res_unlink_not_opened = mq_unlink(mq_name_not_opened);\n        assert_eq!(res_unlink_not_opened, Err(Errno::ENOENT));\n    }\n\n    mq_close(mqd).unwrap();\n    let res_unlink_after_close = mq_unlink(mq_name_opened);\n    assert_eq!(res_unlink_after_close, Err(Errno::ENOENT));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","test_net.rs"],"content":"use nix::net::if_::*;\n\n#[cfg(linux_android)]\nconst LOOPBACK: \u0026[u8] = b\"lo\";\n\n#[cfg(not(any(linux_android, target_os = \"haiku\")))]\nconst LOOPBACK: \u0026[u8] = b\"lo0\";\n\n#[cfg(target_os = \"haiku\")]\nconst LOOPBACK: \u0026[u8] = b\"loop\";\n\n#[test]\n#[cfg_attr(target_os = \"cygwin\", ignore)]\nfn test_if_nametoindex() {\n    if_nametoindex(LOOPBACK).expect(\"assertion failed\");\n}\n\n#[test]\n#[cfg_attr(target_os = \"cygwin\", ignore)]\nfn test_if_indextoname() {\n    let loopback_index = if_nametoindex(LOOPBACK).expect(\"assertion failed\");\n    assert_eq!(\n        if_indextoname(loopback_index)\n            .expect(\"assertion failed\")\n            .as_bytes(),\n        LOOPBACK\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","test_nix_path.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","test_poll.rs"],"content":"use nix::{\n    errno::Errno,\n    poll::{poll, PollFd, PollFlags, PollTimeout},\n    unistd::{pipe, write},\n};\nuse std::os::unix::io::{AsFd, BorrowedFd};\n\nmacro_rules! loop_while_eintr {\n    ($poll_expr: expr) =\u003e {\n        loop {\n            match $poll_expr {\n                Ok(nfds) =\u003e break nfds,\n                Err(Errno::EINTR) =\u003e (),\n                Err(e) =\u003e panic!(\"{}\", e),\n            }\n        }\n    };\n}\n\n#[test]\nfn test_poll() {\n    let (r, w) = pipe().unwrap();\n    let mut fds = [PollFd::new(r.as_fd(), PollFlags::POLLIN)];\n\n    // Poll an idle pipe.  Should timeout\n    let nfds = loop_while_eintr!(poll(\u0026mut fds, PollTimeout::from(100u8)));\n    assert_eq!(nfds, 0);\n    assert!(!fds[0].revents().unwrap().contains(PollFlags::POLLIN));\n\n    write(\u0026w, b\".\").unwrap();\n\n    // Poll a readable pipe.  Should return an event.\n    let nfds = poll(\u0026mut fds, PollTimeout::from(100u8)).unwrap();\n    assert_eq!(nfds, 1);\n    assert!(fds[0].revents().unwrap().contains(PollFlags::POLLIN));\n}\n\n// ppoll(2) is the same as poll except for how it handles timeouts and signals.\n// Repeating the test for poll(2) should be sufficient to check that our\n// bindings are correct.\n#[cfg(any(linux_android, freebsdlike))]\n#[test]\nfn test_ppoll() {\n    use nix::poll::ppoll;\n    use nix::sys::signal::SigSet;\n    use nix::sys::time::{TimeSpec, TimeValLike};\n\n    let timeout = TimeSpec::milliseconds(1);\n    let (r, w) = pipe().unwrap();\n    let mut fds = [PollFd::new(r.as_fd(), PollFlags::POLLIN)];\n\n    // Poll an idle pipe.  Should timeout\n    let sigset = SigSet::empty();\n    let nfds = loop_while_eintr!(ppoll(\u0026mut fds, Some(timeout), Some(sigset)));\n    assert_eq!(nfds, 0);\n    assert!(!fds[0].revents().unwrap().contains(PollFlags::POLLIN));\n\n    write(\u0026w, b\".\").unwrap();\n\n    // Poll a readable pipe.  Should return an event.\n    let nfds = ppoll(\u0026mut fds, Some(timeout), None).unwrap();\n    assert_eq!(nfds, 1);\n    assert!(fds[0].revents().unwrap().contains(PollFlags::POLLIN));\n}\n\n#[test]\nfn test_pollfd_events() {\n    let fd_zero = unsafe { BorrowedFd::borrow_raw(0) };\n    let mut pfd = PollFd::new(fd_zero.as_fd(), PollFlags::POLLIN);\n    assert_eq!(pfd.events(), PollFlags::POLLIN);\n    pfd.set_events(PollFlags::POLLOUT);\n    assert_eq!(pfd.events(), PollFlags::POLLOUT);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","test_pty.rs"],"content":"use std::fs::File;\nuse std::io::{stdout, Read, Write};\nuse std::os::unix::prelude::*;\nuse std::path::Path;\n\nuse libc::_exit;\nuse nix::fcntl::{open, OFlag};\nuse nix::pty::*;\nuse nix::sys::stat;\nuse nix::sys::termios::*;\nuse nix::sys::wait::WaitStatus;\nuse nix::unistd::{pause, write};\n\n/// Test equivalence of `ptsname` and `ptsname_r`\n#[test]\n#[cfg(linux_android)]\nfn test_ptsname_equivalence() {\n    let _m = crate::PTSNAME_MTX.lock();\n\n    // Open a new PTY master\n    let master_fd = posix_openpt(OFlag::O_RDWR).unwrap();\n    assert!(master_fd.as_raw_fd() \u003e 0);\n    assert!(master_fd.as_fd().as_raw_fd() == master_fd.as_raw_fd());\n\n    // Get the name of the slave\n    let slave_name = unsafe { ptsname(\u0026master_fd) }.unwrap();\n    let slave_name_r = ptsname_r(\u0026master_fd).unwrap();\n    assert_eq!(slave_name, slave_name_r);\n}\n\n/// Test data copying of `ptsname`\n// TODO need to run in a subprocess, since ptsname is non-reentrant\n#[test]\n#[cfg(linux_android)]\nfn test_ptsname_copy() {\n    let _m = crate::PTSNAME_MTX.lock();\n\n    // Open a new PTTY master\n    let master_fd = posix_openpt(OFlag::O_RDWR).unwrap();\n\n    // Get the name of the slave\n    let slave_name1 = unsafe { ptsname(\u0026master_fd) }.unwrap();\n    let slave_name2 = unsafe { ptsname(\u0026master_fd) }.unwrap();\n    assert_eq!(slave_name1, slave_name2);\n    // Also make sure that the string was actually copied and they point to different parts of\n    // memory.\n    assert_ne!(slave_name1.as_ptr(), slave_name2.as_ptr());\n}\n\n/// Test data copying of `ptsname_r`\n#[test]\n#[cfg(linux_android)]\nfn test_ptsname_r_copy() {\n    // Open a new PTTY master\n    let master_fd = posix_openpt(OFlag::O_RDWR).unwrap();\n\n    // Get the name of the slave\n    let slave_name1 = ptsname_r(\u0026master_fd).unwrap();\n    let slave_name2 = ptsname_r(\u0026master_fd).unwrap();\n    assert_eq!(slave_name1, slave_name2);\n    assert_ne!(slave_name1.as_ptr(), slave_name2.as_ptr());\n}\n\n/// Test that `ptsname` returns different names for different devices\n#[test]\n#[cfg(linux_android)]\nfn test_ptsname_unique() {\n    let _m = crate::PTSNAME_MTX.lock();\n\n    // Open a new PTTY master\n    let master1_fd = posix_openpt(OFlag::O_RDWR).unwrap();\n\n    // Open a second PTTY master\n    let master2_fd = posix_openpt(OFlag::O_RDWR).unwrap();\n\n    // Get the name of the slave\n    let slave_name1 = unsafe { ptsname(\u0026master1_fd) }.unwrap();\n    let slave_name2 = unsafe { ptsname(\u0026master2_fd) }.unwrap();\n    assert_ne!(slave_name1, slave_name2);\n}\n\n/// Common setup for testing PTTY pairs\nfn open_ptty_pair() -\u003e (PtyMaster, File) {\n    let _m = crate::PTSNAME_MTX.lock();\n\n    // Open a new PTTY master\n    let master = posix_openpt(OFlag::O_RDWR).expect(\"posix_openpt failed\");\n\n    // Allow a slave to be generated for it\n    grantpt(\u0026master).expect(\"grantpt failed\");\n    unlockpt(\u0026master).expect(\"unlockpt failed\");\n\n    // Get the name of the slave\n    let slave_name = unsafe { ptsname(\u0026master) }.expect(\"ptsname failed\");\n\n    // Open the slave device\n    let slave_fd =\n        open(Path::new(\u0026slave_name), OFlag::O_RDWR, stat::Mode::empty())\n            .unwrap();\n\n    #[cfg(solarish)]\n    // TODO: rewrite using ioctl!\n    #[allow(clippy::comparison_chain)]\n    {\n        use libc::{ioctl, I_FIND, I_PUSH};\n\n        // On illumos systems, as per pts(7D), one must push STREAMS modules\n        // after opening a device path returned from ptsname().\n        let ptem = b\"ptem\\0\";\n        let ldterm = b\"ldterm\\0\";\n        let r = unsafe { ioctl(slave_fd.as_raw_fd(), I_FIND, ldterm.as_ptr()) };\n        if r \u003c 0 {\n            panic!(\"I_FIND failure\");\n        } else if r == 0 {\n            if unsafe { ioctl(slave_fd.as_raw_fd(), I_PUSH, ptem.as_ptr()) } \u003c 0\n            {\n                panic!(\"I_PUSH ptem failure\");\n            }\n            if unsafe { ioctl(slave_fd.as_raw_fd(), I_PUSH, ldterm.as_ptr()) }\n                \u003c 0\n            {\n                panic!(\"I_PUSH ldterm failure\");\n            }\n        }\n    }\n\n    let slave = File::from(slave_fd);\n\n    (master, slave)\n}\n\n/// Test opening a master/slave PTTY pair\n///\n/// This uses a common `open_ptty_pair` because much of these functions aren't useful by\n/// themselves. So for this test we perform the basic act of getting a file handle for a\n/// master/slave PTTY pair.\n#[test]\nfn test_open_ptty_pair() {\n    let (_, _) = open_ptty_pair();\n}\n\n/// Put the terminal in raw mode.\nfn make_raw\u003cFd: AsFd\u003e(fd: Fd) {\n    let mut termios = tcgetattr(\u0026fd).unwrap();\n    cfmakeraw(\u0026mut termios);\n    tcsetattr(\u0026fd, SetArg::TCSANOW, \u0026termios).unwrap();\n}\n\n/// Test `io::Read` on the PTTY master\n#[test]\n#[cfg(not(target_os = \"solaris\"))]\nfn test_read_ptty_pair() {\n    let (mut master, mut slave) = open_ptty_pair();\n    make_raw(\u0026slave);\n\n    let mut buf = [0u8; 5];\n    slave.write_all(b\"hello\").unwrap();\n    master.read_exact(\u0026mut buf).unwrap();\n    assert_eq!(\u0026buf, b\"hello\");\n\n    let mut master = \u0026master;\n    slave.write_all(b\"hello\").unwrap();\n    master.read_exact(\u0026mut buf).unwrap();\n    assert_eq!(\u0026buf, b\"hello\");\n}\n\n/// Test `io::Write` on the PTTY master\n#[test]\nfn test_write_ptty_pair() {\n    let (mut master, mut slave) = open_ptty_pair();\n    make_raw(\u0026slave);\n\n    let mut buf = [0u8; 5];\n    master.write_all(b\"adios\").unwrap();\n    slave.read_exact(\u0026mut buf).unwrap();\n    assert_eq!(\u0026buf, b\"adios\");\n\n    let mut master = \u0026master;\n    master.write_all(b\"adios\").unwrap();\n    slave.read_exact(\u0026mut buf).unwrap();\n    assert_eq!(\u0026buf, b\"adios\");\n}\n\n#[test]\nfn test_openpty() {\n    // openpty uses ptname(3) internally\n    let _m = crate::PTSNAME_MTX.lock();\n\n    let pty = openpty(None, None).unwrap();\n\n    // Writing to one should be readable on the other one\n    let string = \"foofoofoo\\n\";\n    let mut buf = [0u8; 10];\n    write(\u0026pty.master, string.as_bytes()).unwrap();\n    crate::read_exact(\u0026pty.slave, \u0026mut buf);\n\n    assert_eq!(\u0026buf, string.as_bytes());\n\n    // Read the echo as well\n    let echoed_string = \"foofoofoo\\r\\n\";\n    let mut buf = [0u8; 11];\n    crate::read_exact(\u0026pty.master, \u0026mut buf);\n    assert_eq!(\u0026buf, echoed_string.as_bytes());\n\n    let string2 = \"barbarbarbar\\n\";\n    let echoed_string2 = \"barbarbarbar\\r\\n\";\n    let mut buf = [0u8; 14];\n    write(\u0026pty.slave, string2.as_bytes()).unwrap();\n    crate::read_exact(\u0026pty.master, \u0026mut buf);\n\n    assert_eq!(\u0026buf, echoed_string2.as_bytes());\n}\n\n#[test]\nfn test_openpty_with_termios() {\n    // openpty uses ptname(3) internally\n    let _m = crate::PTSNAME_MTX.lock();\n\n    // Open one pty to get attributes for the second one\n    let mut termios = {\n        let pty = openpty(None, None).unwrap();\n        tcgetattr(\u0026pty.slave).unwrap()\n    };\n    // Make sure newlines are not transformed so the data is preserved when sent.\n    termios.output_flags.remove(OutputFlags::ONLCR);\n\n    let pty = openpty(None, \u0026termios).unwrap();\n    // Must be valid file descriptors\n\n    // Writing to one should be readable on the other one\n    let string = \"foofoofoo\\n\";\n    let mut buf = [0u8; 10];\n    write(\u0026pty.master, string.as_bytes()).unwrap();\n    crate::read_exact(\u0026pty.slave, \u0026mut buf);\n\n    assert_eq!(\u0026buf, string.as_bytes());\n\n    // read the echo as well\n    let echoed_string = \"foofoofoo\\n\";\n    crate::read_exact(\u0026pty.master, \u0026mut buf);\n    assert_eq!(\u0026buf, echoed_string.as_bytes());\n\n    let string2 = \"barbarbarbar\\n\";\n    let echoed_string2 = \"barbarbarbar\\n\";\n    let mut buf = [0u8; 13];\n    write(\u0026pty.slave, string2.as_bytes()).unwrap();\n    crate::read_exact(\u0026pty.master, \u0026mut buf);\n\n    assert_eq!(\u0026buf, echoed_string2.as_bytes());\n}\n\n#[test]\nfn test_forkpty() {\n    use nix::sys::signal::*;\n    use nix::sys::wait::wait;\n    // forkpty calls openpty which uses ptname(3) internally.\n    let _m0 = crate::PTSNAME_MTX.lock();\n    // forkpty spawns a child process\n    let _m1 = crate::FORK_MTX.lock();\n\n    let string = \"naninani\\n\";\n    let echoed_string = \"naninani\\r\\n\";\n    let res = unsafe { forkpty(None, None).unwrap() };\n    match res {\n        ForkptyResult::Child =\u003e {\n            write(stdout(), string.as_bytes()).unwrap();\n            pause(); // we need the child to stay alive until the parent calls read\n            unsafe {\n                _exit(0);\n            }\n        }\n        ForkptyResult::Parent { child, master } =\u003e {\n            let mut buf = [0u8; 10];\n            assert!(child.as_raw() \u003e 0);\n            crate::read_exact(\u0026master, \u0026mut buf);\n            kill(child, SIGTERM).unwrap();\n            let status = wait().unwrap(); // keep other tests using generic wait from getting our child\n            assert_eq!(status, WaitStatus::Signaled(child, SIGTERM, false));\n            assert_eq!(\u0026buf, echoed_string.as_bytes());\n        }\n    }\n}\n","traces":[{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","acooks","mcr","nix-0.30.1","test","test_sched.rs"],"content":"use nix::sched::{sched_getaffinity, sched_getcpu, sched_setaffinity, CpuSet};\nuse nix::unistd::Pid;\n\n#[test]\nfn test_sched_affinity() {\n    // If pid is zero, then the mask of the calling process is returned.\n    let initial_affinity = sched_getaffinity(Pid::from_raw(0)).unwrap();\n    let mut at_least_one_cpu = false;\n    let mut last_valid_cpu = 0;\n    for field in 0..CpuSet::count() {\n        if initial_affinity.is_set(field).unwrap() {\n            at_least_one_cpu = true;\n            last_valid_cpu = field;\n        }\n    }\n    assert!(at_least_one_cpu);\n\n    // Now restrict the running CPU\n    let mut new_affinity = CpuSet::new();\n    new_affinity.set(last_valid_cpu).unwrap();\n    sched_setaffinity(Pid::from_raw(0), \u0026new_affinity).unwrap();\n\n    // And now re-check the affinity which should be only the one we set.\n    let updated_affinity = sched_getaffinity(Pid::from_raw(0)).unwrap();\n    for field in 0..CpuSet::count() {\n        // Should be set only for the CPU we set previously\n        assert_eq!(\n            updated_affinity.is_set(field).unwrap(),\n            field == last_valid_cpu\n        )\n    }\n\n    // Now check that we're also currently running on the CPU in question.\n    let cur_cpu = sched_getcpu().unwrap();\n    assert_eq!(cur_cpu, last_valid_cpu);\n\n    // Finally, reset the initial CPU set\n    sched_setaffinity(Pid::from_raw(0), \u0026initial_affinity).unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","test_sendfile.rs"],"content":"use std::io::prelude::*;\n\nuse libc::off_t;\nuse nix::sys::sendfile::*;\nuse tempfile::tempfile;\n\ncfg_if! {\n    if #[cfg(linux_android)] {\n        use nix::unistd::{pipe, read};\n    } else if #[cfg(any(freebsdlike, apple_targets))] {\n        use std::net::Shutdown;\n        use std::os::unix::net::UnixStream;\n    } else if #[cfg(solarish)] {\n        use std::net::Shutdown;\n        use std::net::{TcpListener, TcpStream};\n    }\n}\n\n#[cfg(linux_android)]\n#[test]\nfn test_sendfile_linux() {\n    const CONTENTS: \u0026[u8] = b\"abcdef123456\";\n    let mut tmp = tempfile().unwrap();\n    tmp.write_all(CONTENTS).unwrap();\n\n    let (rd, wr) = pipe().unwrap();\n    let mut offset: off_t = 5;\n    let res = sendfile(\u0026wr, \u0026tmp, Some(\u0026mut offset), 2).unwrap();\n\n    assert_eq!(2, res);\n\n    let mut buf = [0u8; 1024];\n    assert_eq!(2, read(\u0026rd, \u0026mut buf).unwrap());\n    assert_eq!(b\"f1\", \u0026buf[0..2]);\n    assert_eq!(7, offset);\n}\n\n#[cfg(target_os = \"linux\")]\n#[test]\nfn test_sendfile64_linux() {\n    const CONTENTS: \u0026[u8] = b\"abcdef123456\";\n    let mut tmp = tempfile().unwrap();\n    tmp.write_all(CONTENTS).unwrap();\n\n    let (rd, wr) = pipe().unwrap();\n    let mut offset: libc::off64_t = 5;\n    let res = sendfile64(\u0026wr, \u0026tmp, Some(\u0026mut offset), 2).unwrap();\n\n    assert_eq!(2, res);\n\n    let mut buf = [0u8; 1024];\n    assert_eq!(2, read(\u0026rd, \u0026mut buf).unwrap());\n    assert_eq!(b\"f1\", \u0026buf[0..2]);\n    assert_eq!(7, offset);\n}\n\n#[cfg(target_os = \"freebsd\")]\n#[test]\nfn test_sendfile_freebsd() {\n    // Declare the content\n    let header_strings =\n        [\"HTTP/1.1 200 OK\\n\", \"Content-Type: text/plain\\n\", \"\\n\"];\n    let body = \"Xabcdef123456\";\n    let body_offset = 1;\n    let trailer_strings = [\"\\n\", \"Served by Make Believe\\n\"];\n\n    // Write the body to a file\n    let mut tmp = tempfile().unwrap();\n    tmp.write_all(body.as_bytes()).unwrap();\n\n    // Prepare headers and trailers for sendfile\n    let headers: Vec\u003c\u0026[u8]\u003e =\n        header_strings.iter().map(|s| s.as_bytes()).collect();\n    let trailers: Vec\u003c\u0026[u8]\u003e =\n        trailer_strings.iter().map(|s| s.as_bytes()).collect();\n\n    // Prepare socket pair\n    let (mut rd, wr) = UnixStream::pair().unwrap();\n\n    // Call the test method\n    let (res, bytes_written) = sendfile(\n        \u0026tmp,\n        \u0026wr,\n        body_offset as off_t,\n        None,\n        Some(headers.as_slice()),\n        Some(trailers.as_slice()),\n        SfFlags::empty(),\n        0,\n    );\n    assert!(res.is_ok());\n    wr.shutdown(Shutdown::Both).unwrap();\n\n    // Prepare the expected result\n    let expected_string = header_strings.concat()\n        + \u0026body[body_offset..]\n        + \u0026trailer_strings.concat();\n\n    // Verify the message that was sent\n    assert_eq!(bytes_written as usize, expected_string.len());\n\n    let mut read_string = String::new();\n    let bytes_read = rd.read_to_string(\u0026mut read_string).unwrap();\n    assert_eq!(bytes_written as usize, bytes_read);\n    assert_eq!(expected_string, read_string);\n}\n\n#[cfg(target_os = \"dragonfly\")]\n#[test]\nfn test_sendfile_dragonfly() {\n    // Declare the content\n    let header_strings =\n        [\"HTTP/1.1 200 OK\\n\", \"Content-Type: text/plain\\n\", \"\\n\"];\n    let body = \"Xabcdef123456\";\n    let body_offset = 1;\n    let trailer_strings = [\"\\n\", \"Served by Make Believe\\n\"];\n\n    // Write the body to a file\n    let mut tmp = tempfile().unwrap();\n    tmp.write_all(body.as_bytes()).unwrap();\n\n    // Prepare headers and trailers for sendfile\n    let headers: Vec\u003c\u0026[u8]\u003e =\n        header_strings.iter().map(|s| s.as_bytes()).collect();\n    let trailers: Vec\u003c\u0026[u8]\u003e =\n        trailer_strings.iter().map(|s| s.as_bytes()).collect();\n\n    // Prepare socket pair\n    let (mut rd, wr) = UnixStream::pair().unwrap();\n\n    // Call the test method\n    let (res, bytes_written) = sendfile(\n        \u0026tmp,\n        \u0026wr,\n        body_offset as off_t,\n        None,\n        Some(headers.as_slice()),\n        Some(trailers.as_slice()),\n    );\n    assert!(res.is_ok());\n    wr.shutdown(Shutdown::Both).unwrap();\n\n    // Prepare the expected result\n    let expected_string = header_strings.concat()\n        + \u0026body[body_offset..]\n        + \u0026trailer_strings.concat();\n\n    // Verify the message that was sent\n    assert_eq!(bytes_written as usize, expected_string.len());\n\n    let mut read_string = String::new();\n    let bytes_read = rd.read_to_string(\u0026mut read_string).unwrap();\n    assert_eq!(bytes_written as usize, bytes_read);\n    assert_eq!(expected_string, read_string);\n}\n\n#[cfg(apple_targets)]\n#[test]\nfn test_sendfile_darwin() {\n    // Declare the content\n    let header_strings =\n        vec![\"HTTP/1.1 200 OK\\n\", \"Content-Type: text/plain\\n\", \"\\n\"];\n    let body = \"Xabcdef123456\";\n    let body_offset = 1;\n    let trailer_strings = vec![\"\\n\", \"Served by Make Believe\\n\"];\n\n    // Write the body to a file\n    let mut tmp = tempfile().unwrap();\n    tmp.write_all(body.as_bytes()).unwrap();\n\n    // Prepare headers and trailers for sendfile\n    let headers: Vec\u003c\u0026[u8]\u003e =\n        header_strings.iter().map(|s| s.as_bytes()).collect();\n    let trailers: Vec\u003c\u0026[u8]\u003e =\n        trailer_strings.iter().map(|s| s.as_bytes()).collect();\n\n    // Prepare socket pair\n    let (mut rd, wr) = UnixStream::pair().unwrap();\n\n    // Call the test method\n    let (res, bytes_written) = sendfile(\n        \u0026tmp,\n        \u0026wr,\n        body_offset as off_t,\n        None,\n        Some(headers.as_slice()),\n        Some(trailers.as_slice()),\n    );\n    assert!(res.is_ok());\n    wr.shutdown(Shutdown::Both).unwrap();\n\n    // Prepare the expected result\n    let expected_string = header_strings.concat()\n        + \u0026body[body_offset..]\n        + \u0026trailer_strings.concat();\n\n    // Verify the message that was sent\n    assert_eq!(bytes_written as usize, expected_string.as_bytes().len());\n\n    let mut read_string = String::new();\n    let bytes_read = rd.read_to_string(\u0026mut read_string).unwrap();\n    assert_eq!(bytes_written as usize, bytes_read);\n    assert_eq!(expected_string, read_string);\n}\n\n#[cfg(solarish)]\n#[test]\nfn test_sendfilev() {\n    use std::os::fd::AsFd;\n    // Declare the content\n    let header_strings =\n        [\"HTTP/1.1 200 OK\\n\", \"Content-Type: text/plain\\n\", \"\\n\"];\n    let body = \"Xabcdef123456\";\n    let body_offset = 1usize;\n    let trailer_strings = [\"\\n\", \"Served by Make Believe\\n\"];\n\n    // Write data to files\n    let mut header_data = tempfile().unwrap();\n    header_data\n        .write_all(header_strings.concat().as_bytes())\n        .unwrap();\n    let mut body_data = tempfile().unwrap();\n    body_data.write_all(body.as_bytes()).unwrap();\n    let mut trailer_data = tempfile().unwrap();\n    trailer_data\n        .write_all(trailer_strings.concat().as_bytes())\n        .unwrap();\n    // Create a TCP socket pair (listener and client)\n    let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n    let addr = listener.local_addr().unwrap();\n    let mut rd = TcpStream::connect(addr).unwrap();\n    let (wr, _) = listener.accept().unwrap();\n    let vec: \u0026[SendfileVec] = \u0026[\n        SendfileVec::new(\n            header_data.as_fd(),\n            0,\n            header_strings.iter().map(|s| s.len()).sum(),\n        ),\n        SendfileVec::new(\n            body_data.as_fd(),\n            body_offset as off_t,\n            body.len() - body_offset,\n        ),\n        SendfileVec::new(\n            trailer_data.as_fd(),\n            0,\n            trailer_strings.iter().map(|s| s.len()).sum(),\n        ),\n    ];\n\n    let (res, bytes_written) = sendfilev(\u0026wr, vec);\n    assert!(res.is_ok());\n    wr.shutdown(Shutdown::Write).unwrap();\n\n    // Prepare the expected result\n    let expected_string = header_strings.concat()\n        + \u0026body[body_offset..]\n        + \u0026trailer_strings.concat();\n\n    // Verify the message that was sent\n    assert_eq!(bytes_written, expected_string.as_bytes().len());\n\n    let mut read_string = String::new();\n    let bytes_read = rd.read_to_string(\u0026mut read_string).unwrap();\n    assert_eq!(bytes_written, bytes_read);\n    assert_eq!(expected_string, read_string);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","test_spawn.rs"],"content":"use super::FORK_MTX;\nuse nix::errno::Errno;\nuse nix::spawn::{self, PosixSpawnAttr, PosixSpawnFileActions};\nuse nix::sys::signal;\nuse nix::sys::wait::{waitpid, WaitPidFlag, WaitStatus};\nuse std::ffi::{CStr, CString};\n\n/// Helper function to find a binary in the $PATH\nfn which(exe_name: \u0026str) -\u003e Option\u003cstd::path::PathBuf\u003e {\n    std::env::var_os(\"PATH\").and_then(|paths| {\n        std::env::split_paths(\u0026paths)\n            .filter_map(|dir| {\n                let full_path = dir.join(exe_name);\n                if full_path.is_file() {\n                    Some(full_path)\n                } else {\n                    None\n                }\n            })\n            .next()\n    })\n}\n\n#[test]\nfn spawn_true() {\n    let _guard = FORK_MTX.lock();\n\n    let bin = which(\"true\").unwrap();\n    let args = \u0026[\n        CString::new(\"true\").unwrap(),\n        CString::new(\"story\").unwrap(),\n    ];\n    let vars: \u0026[CString] = \u0026[];\n    let actions = PosixSpawnFileActions::init().unwrap();\n    let attr = PosixSpawnAttr::init().unwrap();\n\n    let pid =\n        spawn::posix_spawn(bin.as_path(), \u0026actions, \u0026attr, args, vars).unwrap();\n\n    let status = waitpid(pid, Some(WaitPidFlag::empty())).unwrap();\n\n    match status {\n        WaitStatus::Exited(wpid, ret) =\u003e {\n            assert_eq!(pid, wpid);\n            assert_eq!(ret, 0);\n        }\n        _ =\u003e {\n            panic!(\"Invalid WaitStatus\");\n        }\n    };\n}\n\n#[test]\nfn spawn_sleep() {\n    let _guard = FORK_MTX.lock();\n\n    let bin = which(\"sleep\").unwrap();\n    let args = \u0026[CString::new(\"sleep\").unwrap(), CString::new(\"30\").unwrap()];\n    let vars: \u0026[CString] = \u0026[];\n    let actions = PosixSpawnFileActions::init().unwrap();\n    let attr = PosixSpawnAttr::init().unwrap();\n\n    let pid =\n        spawn::posix_spawn(bin.as_path(), \u0026actions, \u0026attr, args, vars).unwrap();\n\n    let status =\n        waitpid(pid, WaitPidFlag::from_bits(WaitPidFlag::WNOHANG.bits()))\n            .unwrap();\n    match status {\n        WaitStatus::StillAlive =\u003e {}\n        _ =\u003e {\n            panic!(\"Invalid WaitStatus\");\n        }\n    };\n\n    signal::kill(pid, signal::SIGTERM).unwrap();\n\n    let status = waitpid(pid, Some(WaitPidFlag::empty())).unwrap();\n    match status {\n        WaitStatus::Signaled(wpid, wsignal, _) =\u003e {\n            assert_eq!(pid, wpid);\n            assert_eq!(wsignal, signal::SIGTERM);\n        }\n        _ =\u003e {\n            panic!(\"Invalid WaitStatus\");\n        }\n    };\n}\n\n#[test]\n// `posix_spawn(path_not_exist)` succeeds under QEMU, so ignore the test. No need\n// to investigate the root cause, this test still works in native environments, which\n// is sufficient to test the binding.\n#[cfg_attr(qemu, ignore)]\nfn spawn_cmd_does_not_exist() {\n    let _guard = FORK_MTX.lock();\n\n    let args = \u0026[CString::new(\"buzz\").unwrap()];\n    let envs: \u0026[CString] = \u0026[];\n    let actions = PosixSpawnFileActions::init().unwrap();\n    let attr = PosixSpawnAttr::init().unwrap();\n\n    let bin = \"2b7433c4-523b-470c-abb5-d7ee9fd295d5-fdasf\";\n    let errno =\n        spawn::posix_spawn(bin, \u0026actions, \u0026attr, args, envs).unwrap_err();\n    assert_eq!(errno, Errno::ENOENT);\n}\n\n#[test]\nfn spawnp_true() {\n    let _guard = FORK_MTX.lock();\n\n    let bin = \u0026CString::new(\"true\").unwrap();\n    let args = \u0026[\n        CString::new(\"true\").unwrap(),\n        CString::new(\"story\").unwrap(),\n    ];\n    let vars: \u0026[CString] = \u0026[];\n    let actions = PosixSpawnFileActions::init().unwrap();\n    let attr = PosixSpawnAttr::init().unwrap();\n\n    let pid = spawn::posix_spawnp(bin, \u0026actions, \u0026attr, args, vars).unwrap();\n\n    let status = waitpid(pid, Some(WaitPidFlag::empty())).unwrap();\n\n    match status {\n        WaitStatus::Exited(wpid, ret) =\u003e {\n            assert_eq!(pid, wpid);\n            assert_eq!(ret, 0);\n        }\n        _ =\u003e {\n            panic!(\"Invalid WaitStatus\");\n        }\n    };\n}\n\n#[test]\nfn spawnp_sleep() {\n    let _guard = FORK_MTX.lock();\n\n    let bin = \u0026CString::new(\"sleep\").unwrap();\n    let args = \u0026[CString::new(\"sleep\").unwrap(), CString::new(\"30\").unwrap()];\n    let vars: \u0026[CString] = \u0026[];\n    let actions = PosixSpawnFileActions::init().unwrap();\n    let attr = PosixSpawnAttr::init().unwrap();\n\n    let pid = spawn::posix_spawnp(bin, \u0026actions, \u0026attr, args, vars).unwrap();\n\n    let status =\n        waitpid(pid, WaitPidFlag::from_bits(WaitPidFlag::WNOHANG.bits()))\n            .unwrap();\n    match status {\n        WaitStatus::StillAlive =\u003e {}\n        _ =\u003e {\n            panic!(\"Invalid WaitStatus\");\n        }\n    };\n\n    signal::kill(pid, signal::SIGTERM).unwrap();\n\n    let status = waitpid(pid, Some(WaitPidFlag::empty())).unwrap();\n    match status {\n        WaitStatus::Signaled(wpid, wsignal, _) =\u003e {\n            assert_eq!(pid, wpid);\n            assert_eq!(wsignal, signal::SIGTERM);\n        }\n        _ =\u003e {\n            panic!(\"Invalid WaitStatus\");\n        }\n    };\n}\n\n#[test]\n// `posix_spawnp(bin_not_exist)` succeeds under QEMU, so ignore the test. No need\n// to investigate the root cause, this test still works in native environments, which\n// is sufficient to test the binding.\n#[cfg_attr(qemu, ignore)]\nfn spawnp_cmd_does_not_exist() {\n    let _guard = FORK_MTX.lock();\n\n    let args = \u0026[CString::new(\"buzz\").unwrap()];\n    let envs: \u0026[CString] = \u0026[];\n    let actions = PosixSpawnFileActions::init().unwrap();\n    let attr = PosixSpawnAttr::init().unwrap();\n\n    let bin = CStr::from_bytes_with_nul(\n        \"2b7433c4-523b-470c-abb5-d7ee9fd295d5-fdasf\\0\".as_bytes(),\n    )\n    .unwrap();\n    let errno =\n        spawn::posix_spawnp(bin, \u0026actions, \u0026attr, args, envs).unwrap_err();\n    assert_eq!(errno, Errno::ENOENT);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","test_syslog.rs"],"content":"use nix::syslog::{openlog, syslog, Facility, LogFlags, Severity};\n\n#[test]\nfn test_syslog_hello_world() {\n    let flags = LogFlags::LOG_PID;\n\n    #[cfg(not(target_os = \"linux\"))]\n    openlog(None::\u003c\u0026str\u003e, flags, Facility::LOG_USER).unwrap();\n    #[cfg(target_os = \"linux\")]\n    openlog(None, flags, Facility::LOG_USER).unwrap();\n\n    syslog(Severity::LOG_EMERG, \"Hello, nix!\").unwrap();\n    let name = \"syslog\";\n    syslog(Severity::LOG_NOTICE, \u0026format!(\"Hello, {name}!\")).unwrap();\n}\n\n#[test]\n#[cfg(target_os = \"linux\")]\nfn test_openlog_with_ident() {\n    use std::ffi::CStr;\n\n    const IDENT: \u0026CStr = unsafe {\n        CStr::from_bytes_with_nul_unchecked(b\"test_openlog_with_ident\\0\")\n    };\n\n    let flags = LogFlags::LOG_PID;\n    openlog(Some(IDENT), flags, Facility::LOG_USER).unwrap();\n    syslog(Severity::LOG_EMERG, \"Hello, ident!\").unwrap();\n}\n\n#[test]\n#[cfg(not(target_os = \"linux\"))]\nfn test_openlog_with_ident() {\n    let flags = LogFlags::LOG_PID;\n    openlog(Some(\"test_openlog_with_ident\"), flags, Facility::LOG_USER)\n        .unwrap();\n    syslog(Severity::LOG_EMERG, \"Hello, ident!\").unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","test_time.rs"],"content":"#[cfg(any(freebsdlike, linux_android, target_os = \"emscripten\"))]\nuse nix::time::clock_getcpuclockid;\nuse nix::time::{clock_gettime, ClockId};\n\n#[cfg(not(target_os = \"redox\"))]\n#[test]\npub fn test_clock_getres() {\n    nix::time::clock_getres(ClockId::CLOCK_REALTIME).expect(\"assertion failed\");\n}\n\n#[test]\npub fn test_clock_gettime() {\n    clock_gettime(ClockId::CLOCK_REALTIME).expect(\"assertion failed\");\n}\n\n#[cfg(any(freebsdlike, linux_android, target_os = \"emscripten\"))]\n#[test]\npub fn test_clock_getcpuclockid() {\n    let clock_id = clock_getcpuclockid(nix::unistd::Pid::this()).unwrap();\n    clock_gettime(clock_id).unwrap();\n}\n\n#[cfg(not(target_os = \"redox\"))]\n#[test]\npub fn test_clock_id_res() {\n    ClockId::CLOCK_REALTIME.res().unwrap();\n}\n\n#[test]\npub fn test_clock_id_now() {\n    ClockId::CLOCK_REALTIME.now().unwrap();\n}\n\n#[cfg(any(freebsdlike, linux_android, target_os = \"emscripten\"))]\n#[test]\npub fn test_clock_id_pid_cpu_clock_id() {\n    ClockId::pid_cpu_clock_id(nix::unistd::Pid::this())\n        .map(ClockId::now)\n        .unwrap()\n        .unwrap();\n}\n\n#[cfg(any(\n    linux_android,\n    solarish,\n    freebsdlike,\n    target_os = \"netbsd\",\n    target_os = \"hurd\",\n    target_os = \"aix\"\n))]\n#[test]\npub fn test_clock_nanosleep() {\n    use nix::{\n        sys::time::{TimeSpec, TimeValLike},\n        time::{clock_nanosleep, ClockNanosleepFlags},\n    };\n\n    let sleep_time = TimeSpec::microseconds(1);\n    let res = clock_nanosleep(\n        ClockId::CLOCK_MONOTONIC,\n        ClockNanosleepFlags::empty(),\n        \u0026sleep_time,\n    );\n    let expected = TimeSpec::microseconds(0);\n    assert_eq!(res, Ok(expected));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","nix-0.30.1","test","test_unistd.rs"],"content":"use libc::{_exit, mode_t, off_t};\nuse nix::errno::Errno;\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nuse nix::fcntl::readlink;\nuse nix::fcntl::OFlag;\n#[cfg(not(target_os = \"redox\"))]\nuse nix::fcntl::{self, open};\n#[cfg(not(any(\n    target_os = \"redox\",\n    target_os = \"fuchsia\",\n    target_os = \"haiku\"\n)))]\nuse nix::pty::{grantpt, posix_openpt, ptsname, unlockpt};\n#[cfg(not(target_os = \"redox\"))]\nuse nix::sys::signal::{\n    sigaction, SaFlags, SigAction, SigHandler, SigSet, Signal,\n};\nuse nix::sys::stat::{self, Mode, SFlag};\nuse nix::sys::wait::*;\nuse nix::unistd::ForkResult::*;\nuse nix::unistd::*;\nuse std::env;\n#[cfg(not(any(target_os = \"fuchsia\", target_os = \"redox\")))]\nuse std::ffi::CString;\n#[cfg(not(target_os = \"redox\"))]\nuse std::fs::DirBuilder;\nuse std::fs::{self, File};\nuse std::io::Write;\n#[cfg(not(any(\n    target_os = \"fuchsia\",\n    target_os = \"redox\",\n    target_os = \"haiku\"\n)))]\nuse std::path::Path;\nuse tempfile::{tempdir, tempfile};\n\nuse crate::*;\n\n#[test]\n#[cfg(not(any(target_os = \"netbsd\")))]\nfn test_fork_and_waitpid() {\n    let _m = crate::FORK_MTX.lock();\n\n    // Safe: Child only calls `_exit`, which is signal-safe\n    match unsafe { fork() }.expect(\"Error: Fork Failed\") {\n        Child =\u003e unsafe { _exit(0) },\n        Parent { child } =\u003e {\n            // assert that child was created and pid \u003e 0\n            let child_raw: ::libc::pid_t = child.into();\n            assert!(child_raw \u003e 0);\n            let wait_status = waitpid(child, None);\n            match wait_status {\n                // assert that waitpid returned correct status and the pid is the one of the child\n                Ok(WaitStatus::Exited(pid_t, _)) =\u003e assert_eq!(pid_t, child),\n\n                // panic, must never happen\n                s @ Ok(_) =\u003e {\n                    panic!(\"Child exited {s:?}, should never happen\")\n                }\n\n                // panic, waitpid should never fail\n                Err(s) =\u003e panic!(\"Error: waitpid returned Err({s:?}\"),\n            }\n        }\n    }\n}\n\n#[test]\n#[cfg(target_os = \"freebsd\")]\nfn test_rfork_and_waitpid() {\n    let _m = crate::FORK_MTX.lock();\n\n    // Safe: Child only calls `_exit`, which is signal-safe\n    match unsafe { rfork(RforkFlags::RFPROC | RforkFlags::RFTHREAD) }\n        .expect(\"Error: Rfork Failed\")\n    {\n        Child =\u003e unsafe { _exit(0) },\n        Parent { child } =\u003e {\n            // assert that child was created and pid \u003e 0\n            let child_raw: ::libc::pid_t = child.into();\n            assert!(child_raw \u003e 0);\n            let wait_status = waitpid(child, None);\n            match wait_status {\n                // assert that waitpid returned correct status and the pid is the one of the child\n                Ok(WaitStatus::Exited(pid_t, _)) =\u003e assert_eq!(pid_t, child),\n\n                // panic, must never happen\n                s @ Ok(_) =\u003e {\n                    panic!(\"Child exited {s:?}, should never happen\")\n                }\n\n                // panic, waitpid should never fail\n                Err(s) =\u003e panic!(\"Error: waitpid returned Err({s:?}\"),\n            }\n        }\n    }\n}\n\n#[test]\nfn test_wait() {\n    // Grab FORK_MTX so wait doesn't reap a different test's child process\n    let _m = crate::FORK_MTX.lock();\n\n    // Safe: Child only calls `_exit`, which is signal-safe\n    match unsafe { fork() }.expect(\"Error: Fork Failed\") {\n        Child =\u003e unsafe { _exit(0) },\n        Parent { child } =\u003e {\n            let wait_status = wait();\n\n            // just assert that (any) one child returns with WaitStatus::Exited\n            assert_eq!(wait_status, Ok(WaitStatus::Exited(child, 0)));\n        }\n    }\n}\n\n#[test]\nfn test_mkstemp() {\n    let mut path = env::temp_dir();\n    path.push(\"nix_tempfile.XXXXXX\");\n\n    let result = mkstemp(\u0026path);\n    match result {\n        Ok((_, path)) =\u003e {\n            unlink(path.as_path()).unwrap();\n        }\n        Err(e) =\u003e panic!(\"mkstemp failed: {e}\"),\n    }\n}\n\n#[test]\nfn test_mkstemp_directory() {\n    // mkstemp should fail if a directory is given\n    mkstemp(\u0026env::temp_dir()).expect_err(\"assertion failed\");\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_mkfifo() {\n    let tempdir = tempdir().unwrap();\n    let mkfifo_fifo = tempdir.path().join(\"mkfifo_fifo\");\n\n    mkfifo(\u0026mkfifo_fifo, Mode::S_IRUSR).unwrap();\n\n    let stats = stat::stat(\u0026mkfifo_fifo).unwrap();\n    let typ = stat::SFlag::from_bits_truncate(stats.st_mode as mode_t);\n    assert_eq!(typ, SFlag::S_IFIFO);\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_mkfifo_directory() {\n    // mkfifo should fail if a directory is given\n    mkfifo(\u0026env::temp_dir(), Mode::S_IRUSR).expect_err(\"assertion failed\");\n}\n\n#[test]\n#[cfg(not(any(\n    apple_targets,\n    target_os = \"android\",\n    target_os = \"redox\",\n    target_os = \"haiku\"\n)))]\nfn test_mkfifoat_none() {\n    use nix::fcntl::AT_FDCWD;\n\n    let _m = crate::CWD_LOCK.read();\n\n    let tempdir = tempdir().unwrap();\n    let mkfifoat_fifo = tempdir.path().join(\"mkfifoat_fifo\");\n\n    mkfifoat(AT_FDCWD, \u0026mkfifoat_fifo, Mode::S_IRUSR).unwrap();\n\n    let stats = stat::stat(\u0026mkfifoat_fifo).unwrap();\n    let typ = stat::SFlag::from_bits_truncate(stats.st_mode);\n    assert_eq!(typ, SFlag::S_IFIFO);\n}\n\n#[test]\n#[cfg(not(any(\n    apple_targets,\n    target_os = \"android\",\n    target_os = \"redox\",\n    target_os = \"haiku\"\n)))]\nfn test_mkfifoat() {\n    use nix::fcntl;\n\n    let tempdir = tempdir().unwrap();\n    let dirfd = open(tempdir.path(), OFlag::empty(), Mode::empty()).unwrap();\n    let mkfifoat_name = \"mkfifoat_name\";\n\n    mkfifoat(\u0026dirfd, mkfifoat_name, Mode::S_IRUSR).unwrap();\n\n    let stats =\n        stat::fstatat(\u0026dirfd, mkfifoat_name, fcntl::AtFlags::empty()).unwrap();\n    let typ = stat::SFlag::from_bits_truncate(stats.st_mode);\n    assert_eq!(typ, SFlag::S_IFIFO);\n}\n\n#[test]\n#[cfg(not(any(\n    apple_targets,\n    target_os = \"android\",\n    target_os = \"redox\",\n    target_os = \"haiku\"\n)))]\nfn test_mkfifoat_directory_none() {\n    use nix::fcntl::AT_FDCWD;\n\n    let _m = crate::CWD_LOCK.read();\n\n    // mkfifoat should fail if a directory is given\n    mkfifoat(AT_FDCWD, \u0026env::temp_dir(), Mode::S_IRUSR)\n        .expect_err(\"assertion failed\");\n}\n\n#[test]\n#[cfg(not(any(\n    apple_targets,\n    target_os = \"android\",\n    target_os = \"redox\",\n    target_os = \"haiku\"\n)))]\nfn test_mkfifoat_directory() {\n    // mkfifoat should fail if a directory is given\n    let tempdir = tempdir().unwrap();\n    let dirfd = open(tempdir.path(), OFlag::empty(), Mode::empty()).unwrap();\n    let mkfifoat_dir = \"mkfifoat_dir\";\n    stat::mkdirat(\u0026dirfd, mkfifoat_dir, Mode::S_IRUSR).unwrap();\n\n    mkfifoat(\u0026dirfd, mkfifoat_dir, Mode::S_IRUSR)\n        .expect_err(\"assertion failed\");\n}\n\n#[test]\nfn test_getpid() {\n    let pid: ::libc::pid_t = getpid().into();\n    let ppid: ::libc::pid_t = getppid().into();\n    assert!(pid \u003e 0);\n    assert!(ppid \u003e 0);\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_getsid() {\n    let none_sid: ::libc::pid_t = getsid(None).unwrap().into();\n    let pid_sid: ::libc::pid_t = getsid(Some(getpid())).unwrap().into();\n    assert!(none_sid \u003e 0);\n    assert_eq!(none_sid, pid_sid);\n}\n\n#[cfg(linux_android)]\nmod linux_android {\n    use nix::unistd::gettid;\n\n    #[test]\n    fn test_gettid() {\n        let tid: ::libc::pid_t = gettid().into();\n        assert!(tid \u003e 0);\n    }\n}\n\n#[test]\n// `getgroups()` and `setgroups()` do not behave as expected on Apple platforms\n#[cfg(not(any(\n    apple_targets,\n    target_os = \"redox\",\n    target_os = \"fuchsia\",\n    target_os = \"haiku\"\n)))]\nfn test_setgroups() {\n    // Skip this test when not run as root as `setgroups()` requires root.\n    skip_if_not_root!(\"test_setgroups\");\n\n    let _m = crate::GROUPS_MTX.lock();\n\n    // Save the existing groups\n    let old_groups = getgroups().unwrap();\n\n    // Set some new made up groups\n    let groups = [Gid::from_raw(123), Gid::from_raw(456)];\n    setgroups(\u0026groups).unwrap();\n\n    let new_groups = getgroups().unwrap();\n    assert_eq!(new_groups, groups);\n\n    // Revert back to the old groups\n    setgroups(\u0026old_groups).unwrap();\n}\n\n#[test]\n// `getgroups()` and `setgroups()` do not behave as expected on Apple platforms\n#[cfg(not(any(\n    apple_targets,\n    target_os = \"redox\",\n    target_os = \"fuchsia\",\n    target_os = \"haiku\",\n    solarish\n)))]\nfn test_initgroups() {\n    // Skip this test when not run as root as `initgroups()` and `setgroups()`\n    // require root.\n    skip_if_not_root!(\"test_initgroups\");\n\n    let _m = crate::GROUPS_MTX.lock();\n\n    // Save the existing groups\n    let old_groups = getgroups().unwrap();\n\n    // It doesn't matter if the root user is not called \"root\" or if a user\n    // called \"root\" doesn't exist. We are just checking that the extra,\n    // made-up group, `123`, is set.\n    // FIXME: Test the other half of initgroups' functionality: whether the\n    // groups that the user belongs to are also set.\n    let user = CString::new(\"root\").unwrap();\n    let group = Gid::from_raw(123);\n    let mut group_list = getgrouplist(\u0026user, group).unwrap();\n    assert!(group_list.contains(\u0026group));\n\n    initgroups(\u0026user, group).unwrap();\n\n    let mut new_groups = getgroups().unwrap();\n\n    new_groups.sort_by_key(|gid| gid.as_raw());\n    group_list.sort_by_key(|gid| gid.as_raw());\n    assert_eq!(new_groups, group_list);\n\n    // Revert back to the old groups\n    setgroups(\u0026old_groups).unwrap();\n}\n\n#[cfg(not(any(target_os = \"fuchsia\", target_os = \"redox\")))]\nmacro_rules! execve_test_factory (\n    ($test_name:ident, $syscall:ident, $exe: expr $(, $pathname:expr, $flags:expr)*) =\u003e (\n\n    #[cfg(test)]\n    mod $test_name {\n    use std::ffi::CStr;\n    use super::*;\n\n    const EMPTY: \u0026'static [u8] = b\"\\0\";\n    const DASH_C: \u0026'static [u8] = b\"-c\\0\";\n    const BIGARG: \u0026'static [u8] = b\"echo nix!!! \u0026\u0026 echo foo=$foo \u0026\u0026 echo baz=$baz\\0\";\n    const FOO: \u0026'static [u8] = b\"foo=bar\\0\";\n    const BAZ: \u0026'static [u8] = b\"baz=quux\\0\";\n\n    fn syscall_cstr_ref() -\u003e Result\u003cstd::convert::Infallible, nix::Error\u003e {\n        $syscall(\n            $exe,\n            $(CString::new($pathname).unwrap().as_c_str(), )*\n            \u0026[CStr::from_bytes_with_nul(EMPTY).unwrap(),\n              CStr::from_bytes_with_nul(DASH_C).unwrap(),\n              CStr::from_bytes_with_nul(BIGARG).unwrap()],\n            \u0026[CStr::from_bytes_with_nul(FOO).unwrap(),\n              CStr::from_bytes_with_nul(BAZ).unwrap()]\n            $(, $flags)*)\n    }\n\n    fn syscall_cstring() -\u003e Result\u003cstd::convert::Infallible, nix::Error\u003e {\n        $syscall(\n            $exe,\n            $(CString::new($pathname).unwrap().as_c_str(), )*\n            \u0026[CString::from(CStr::from_bytes_with_nul(EMPTY).unwrap()),\n              CString::from(CStr::from_bytes_with_nul(DASH_C).unwrap()),\n              CString::from(CStr::from_bytes_with_nul(BIGARG).unwrap())],\n            \u0026[CString::from(CStr::from_bytes_with_nul(FOO).unwrap()),\n              CString::from(CStr::from_bytes_with_nul(BAZ).unwrap())]\n            $(, $flags)*)\n    }\n\n    fn common_test(syscall: fn() -\u003e Result\u003cstd::convert::Infallible, nix::Error\u003e) {\n        if \"execveat\" == stringify!($syscall) {\n            // Though undocumented, Docker's default seccomp profile seems to\n            // block this syscall.  https://github.com/nix-rust/nix/issues/1122\n            skip_if_seccomp!($test_name);\n        }\n\n        let m = crate::FORK_MTX.lock();\n        // The `exec`d process will write to `writer`, and we'll read that\n        // data from `reader`.\n        let (reader, writer) = pipe().unwrap();\n\n        // Safe: Child calls `exit`, `dup`, `close` and the provided `exec*` family function.\n        // NOTE: Technically, this makes the macro unsafe to use because you could pass anything.\n        //       The tests make sure not to do that, though.\n        match unsafe{fork()}.unwrap() {\n            Child =\u003e {\n                // Make `writer` be the stdout of the new process.\n                nix::unistd::dup2_stdout(\u0026writer).unwrap();\n                let r = syscall();\n                let _ = std::io::stderr()\n                    .write_all(format!(\"{:?}\", r).as_bytes());\n                // Should only get here in event of error\n                unsafe{ _exit(1) };\n            },\n            Parent { child } =\u003e {\n                // Wait for the child to exit.\n                let ws = waitpid(child, None);\n                drop(m);\n                assert_eq!(ws, Ok(WaitStatus::Exited(child, 0)));\n                // Read 1024 bytes.\n                let mut buf = [0u8; 1024];\n                read(\u0026reader, \u0026mut buf).unwrap();\n                // It should contain the things we printed using `/bin/sh`.\n                let string = String::from_utf8_lossy(\u0026buf);\n                assert!(string.contains(\"nix!!!\"));\n                assert!(string.contains(\"foo=bar\"));\n                assert!(string.contains(\"baz=quux\"));\n            }\n        }\n    }\n\n    // These tests frequently fail on musl, probably due to\n        // https://github.com/nix-rust/nix/issues/555\n    #[cfg_attr(target_env = \"musl\", ignore)]\n    #[test]\n    fn test_cstr_ref() {\n        common_test(syscall_cstr_ref);\n    }\n\n    // These tests frequently fail on musl, probably due to\n        // https://github.com/nix-rust/nix/issues/555\n    #[cfg_attr(target_env = \"musl\", ignore)]\n    #[test]\n    fn test_cstring() {\n        common_test(syscall_cstring);\n    }\n    }\n\n    )\n);\n\ncfg_if! {\n    if #[cfg(target_os = \"android\")] {\n        execve_test_factory!(test_execve, execve, CString::new(\"/system/bin/sh\").unwrap().as_c_str());\n        execve_test_factory!(test_fexecve, fexecve, \u0026File::open(\"/system/bin/sh\").unwrap());\n    } else if #[cfg(any(freebsdlike, target_os = \"linux\", target_os = \"hurd\"))] {\n        // These tests frequently fail on musl, probably due to\n        // https://github.com/nix-rust/nix/issues/555\n        execve_test_factory!(test_execve, execve, CString::new(\"/bin/sh\").unwrap().as_c_str());\n        execve_test_factory!(test_fexecve, fexecve, \u0026File::open(\"/bin/sh\").unwrap());\n    } else if #[cfg(any(solarish, apple_targets, netbsdlike))] {\n        execve_test_factory!(test_execve, execve, CString::new(\"/bin/sh\").unwrap().as_c_str());\n        // No fexecve() on ios, macos, NetBSD, OpenBSD.\n    }\n}\n\n#[cfg(any(\n    target_os = \"haiku\",\n    target_os = \"hurd\",\n    target_os = \"linux\",\n    target_os = \"openbsd\"\n))]\nexecve_test_factory!(test_execvpe, execvpe, \u0026CString::new(\"sh\").unwrap());\n\ncfg_if! {\n    if #[cfg(target_os = \"android\")] {\n        use nix::fcntl::AtFlags;\n        execve_test_factory!(test_execveat_empty, execveat,\n                             \u0026File::open(\"/system/bin/sh\").unwrap(),\n                             \"\", AtFlags::AT_EMPTY_PATH);\n        execve_test_factory!(test_execveat_relative, execveat,\n                             \u0026File::open(\"/system/bin/\").unwrap(),\n                             \"./sh\", AtFlags::empty());\n        execve_test_factory!(test_execveat_absolute, execveat,\n                             \u0026File::open(\"/\").unwrap(),\n                             \"/system/bin/sh\", AtFlags::empty());\n    } else if #[cfg(all(target_os = \"linux\", any(target_arch =\"x86_64\", target_arch =\"x86\")))] {\n        use nix::fcntl::AtFlags;\n        execve_test_factory!(test_execveat_empty, execveat, \u0026File::open(\"/bin/sh\").unwrap(),\n                             \"\", AtFlags::AT_EMPTY_PATH);\n        execve_test_factory!(test_execveat_relative, execveat, \u0026File::open(\"/bin/\").unwrap(),\n                             \"./sh\", AtFlags::empty());\n        execve_test_factory!(test_execveat_absolute, execveat, \u0026File::open(\"/\").unwrap(),\n                             \"/bin/sh\", AtFlags::empty());\n    }\n}\n\n#[test]\n#[cfg(not(target_os = \"fuchsia\"))]\nfn test_fchdir() {\n    // fchdir changes the process's cwd\n    let _dr = crate::DirRestore::new();\n\n    let tmpdir = tempdir().unwrap();\n    let tmpdir_path = tmpdir.path().canonicalize().unwrap();\n    let tmpdir_fd = File::open(\u0026tmpdir_path).unwrap();\n\n    fchdir(\u0026tmpdir_fd).expect(\"assertion failed\");\n    assert_eq!(getcwd().unwrap(), tmpdir_path);\n}\n\n#[test]\nfn test_getcwd() {\n    // chdir changes the process's cwd\n    let _dr = crate::DirRestore::new();\n\n    let tmpdir = tempdir().unwrap();\n    let tmpdir_path = tmpdir.path().canonicalize().unwrap();\n    chdir(\u0026tmpdir_path).expect(\"assertion failed\");\n    assert_eq!(getcwd().unwrap(), tmpdir_path);\n\n    // make path 500 chars longer so that buffer doubling in getcwd\n    // kicks in.  Note: One path cannot be longer than 255 bytes\n    // (NAME_MAX) whole path cannot be longer than PATH_MAX (usually\n    // 4096 on linux, 1024 on macos)\n    let mut inner_tmp_dir = tmpdir_path;\n    for _ in 0..5 {\n        let newdir = \"a\".repeat(100);\n        inner_tmp_dir.push(newdir);\n        mkdir(inner_tmp_dir.as_path(), Mode::S_IRWXU)\n            .expect(\"assertion failed\");\n    }\n    chdir(inner_tmp_dir.as_path()).expect(\"assertion failed\");\n    assert_eq!(getcwd().unwrap(), inner_tmp_dir.as_path());\n}\n\n#[test]\nfn test_chown() {\n    // Testing for anything other than our own UID/GID is hard.\n    let uid = Some(getuid());\n    let gid = Some(getgid());\n\n    let tempdir = tempdir().unwrap();\n    let path = tempdir.path().join(\"file\");\n    {\n        File::create(\u0026path).unwrap();\n    }\n\n    chown(\u0026path, uid, gid).unwrap();\n    chown(\u0026path, uid, None).unwrap();\n    chown(\u0026path, None, gid).unwrap();\n\n    fs::remove_file(\u0026path).unwrap();\n    chown(\u0026path, uid, gid).unwrap_err();\n}\n\n#[test]\nfn test_fchown() {\n    // Testing for anything other than our own UID/GID is hard.\n    let uid = Some(getuid());\n    let gid = Some(getgid());\n\n    let file = tempfile().unwrap();\n\n    fchown(\u0026file, uid, gid).unwrap();\n    fchown(\u0026file, uid, None).unwrap();\n    fchown(\u0026file, None, gid).unwrap();\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_fchownat() {\n    use nix::fcntl::AtFlags;\n    use nix::fcntl::AT_FDCWD;\n\n    let _dr = crate::DirRestore::new();\n    // Testing for anything other than our own UID/GID is hard.\n    let uid = Some(getuid());\n    let gid = Some(getgid());\n\n    let tempdir = tempdir().unwrap();\n    let path = tempdir.path().join(\"file\");\n    {\n        File::create(\u0026path).unwrap();\n    }\n\n    let dirfd = open(tempdir.path(), OFlag::empty(), Mode::empty()).unwrap();\n\n    fchownat(\u0026dirfd, \"file\", uid, gid, AtFlags::empty()).unwrap();\n\n    chdir(tempdir.path()).unwrap();\n    fchownat(AT_FDCWD, \"file\", uid, gid, AtFlags::empty()).unwrap();\n\n    fs::remove_file(\u0026path).unwrap();\n    fchownat(AT_FDCWD, \"file\", uid, gid, AtFlags::empty()).unwrap_err();\n}\n\n#[test]\nfn test_lseek() {\n    const CONTENTS: \u0026[u8] = b\"abcdef123456\";\n    let mut tmp = tempfile().unwrap();\n    tmp.write_all(CONTENTS).unwrap();\n\n    let offset: off_t = 5;\n    lseek(\u0026tmp, offset, Whence::SeekSet).unwrap();\n\n    let mut buf = [0u8; 7];\n    crate::read_exact(\u0026tmp, \u0026mut buf);\n    assert_eq!(b\"f123456\", \u0026buf);\n}\n\n#[cfg(linux_android)]\n#[test]\nfn test_lseek64() {\n    const CONTENTS: \u0026[u8] = b\"abcdef123456\";\n    let mut tmp = tempfile().unwrap();\n    tmp.write_all(CONTENTS).unwrap();\n\n    lseek64(\u0026tmp, 5, Whence::SeekSet).unwrap();\n\n    let mut buf = [0u8; 7];\n    crate::read_exact(\u0026tmp, \u0026mut buf);\n    assert_eq!(b\"f123456\", \u0026buf);\n}\n\ncfg_if! {\n    if #[cfg(linux_android)] {\n        macro_rules! require_acct{\n            () =\u003e {\n                require_capability!(\"test_acct\", CAP_SYS_PACCT);\n            }\n        }\n    } else if #[cfg(target_os = \"freebsd\")] {\n        macro_rules! require_acct{\n            () =\u003e {\n                skip_if_not_root!(\"test_acct\");\n                skip_if_jailed!(\"test_acct\");\n            }\n        }\n    } else if #[cfg(not(any(target_os = \"redox\", target_os = \"fuchsia\", target_os = \"haiku\")))] {\n        macro_rules! require_acct{\n            () =\u003e {\n                skip_if_not_root!(\"test_acct\");\n            }\n        }\n    }\n}\n\n#[test]\n#[cfg(not(any(\n    target_os = \"redox\",\n    target_os = \"fuchsia\",\n    target_os = \"haiku\",\n    target_os = \"cygwin\"\n)))]\nfn test_acct() {\n    use std::process::Command;\n    use std::{thread, time};\n    use tempfile::NamedTempFile;\n\n    let _m = crate::FORK_MTX.lock();\n    require_acct!();\n\n    let file = NamedTempFile::new().unwrap();\n    let path = file.path().to_str().unwrap();\n\n    acct::enable(path).unwrap();\n\n    loop {\n        Command::new(\"echo\").arg(\"Hello world\").output().unwrap();\n        let len = fs::metadata(path).unwrap().len();\n        if len \u003e 0 {\n            break;\n        }\n        thread::sleep(time::Duration::from_millis(10));\n    }\n    acct::disable().unwrap();\n}\n\n#[cfg_attr(target_os = \"hurd\", ignore)]\n#[test]\nfn test_fpathconf_limited() {\n    let f = tempfile().unwrap();\n    // PATH_MAX is limited on most platforms, so it makes a good test\n    let path_max = fpathconf(f, PathconfVar::PATH_MAX);\n    assert!(\n        path_max\n            .expect(\"fpathconf failed\")\n            .expect(\"PATH_MAX is unlimited\")\n            \u003e 0\n    );\n}\n\n#[cfg_attr(target_os = \"hurd\", ignore)]\n#[test]\nfn test_pathconf_limited() {\n    // PATH_MAX is limited on most platforms, so it makes a good test\n    let path_max = pathconf(\"/\", PathconfVar::PATH_MAX);\n    assert!(\n        path_max\n            .expect(\"pathconf failed\")\n            .expect(\"PATH_MAX is unlimited\")\n            \u003e 0\n    );\n}\n\n#[cfg_attr(target_os = \"hurd\", ignore)]\n#[test]\nfn test_sysconf_limited() {\n    // OPEN_MAX is limited on most platforms, so it makes a good test\n    let open_max = sysconf(SysconfVar::OPEN_MAX);\n    assert!(\n        open_max\n            .expect(\"sysconf failed\")\n            .expect(\"OPEN_MAX is unlimited\")\n            \u003e 0\n    );\n}\n\n#[cfg(target_os = \"freebsd\")]\n#[test]\nfn test_sysconf_unsupported() {\n    // I know of no sysconf variables that are unsupported everywhere, but\n    // _XOPEN_CRYPT is unsupported on FreeBSD 11.0, which is one of the platforms\n    // we test.\n    let open_max = sysconf(SysconfVar::_XOPEN_CRYPT);\n    assert!(open_max.expect(\"sysconf failed\").is_none())\n}\n\n#[cfg(any(linux_android, freebsdlike, target_os = \"openbsd\"))]\n#[test]\nfn test_getresuid() {\n    let resuids = getresuid().unwrap();\n    assert_ne!(resuids.real.as_raw(), libc::uid_t::MAX);\n    assert_ne!(resuids.effective.as_raw(), libc::uid_t::MAX);\n    assert_ne!(resuids.saved.as_raw(), libc::uid_t::MAX);\n}\n\n#[cfg(any(linux_android, freebsdlike, target_os = \"openbsd\"))]\n#[test]\nfn test_getresgid() {\n    let resgids = getresgid().unwrap();\n    assert_ne!(resgids.real.as_raw(), libc::gid_t::MAX);\n    assert_ne!(resgids.effective.as_raw(), libc::gid_t::MAX);\n    assert_ne!(resgids.saved.as_raw(), libc::gid_t::MAX);\n}\n\n// Test that we can create a pair of pipes.  No need to verify that they pass\n// data; that's the domain of the OS, not nix.\n#[test]\nfn test_pipe() {\n    let (fd0, fd1) = pipe().unwrap();\n    let m0 = stat::SFlag::from_bits_truncate(\n        stat::fstat(\u0026fd0).unwrap().st_mode as mode_t,\n    );\n    // S_IFIFO means it's a pipe\n    assert_eq!(m0, SFlag::S_IFIFO);\n    let m1 = stat::SFlag::from_bits_truncate(\n        stat::fstat(\u0026fd1).unwrap().st_mode as mode_t,\n    );\n    assert_eq!(m1, SFlag::S_IFIFO);\n}\n\n// pipe2(2) is the same as pipe(2), except it allows setting some flags.  Check\n// that we can set a flag.\n#[cfg(any(\n    linux_android,\n    freebsdlike,\n    solarish,\n    netbsdlike,\n    target_os = \"emscripten\",\n    target_os = \"redox\",\n))]\n#[test]\nfn test_pipe2() {\n    use nix::fcntl::{fcntl, FcntlArg, FdFlag};\n\n    let (fd0, fd1) = pipe2(OFlag::O_CLOEXEC).unwrap();\n    let f0 =\n        FdFlag::from_bits_truncate(fcntl(\u0026fd0, FcntlArg::F_GETFD).unwrap());\n    assert!(f0.contains(FdFlag::FD_CLOEXEC));\n    let f1 =\n        FdFlag::from_bits_truncate(fcntl(\u0026fd1, FcntlArg::F_GETFD).unwrap());\n    assert!(f1.contains(FdFlag::FD_CLOEXEC));\n}\n\n#[test]\n#[cfg(not(any(target_os = \"redox\", target_os = \"fuchsia\")))]\nfn test_truncate() {\n    let tempdir = tempdir().unwrap();\n    let path = tempdir.path().join(\"file\");\n\n    {\n        let mut tmp = File::create(\u0026path).unwrap();\n        const CONTENTS: \u0026[u8] = b\"12345678\";\n        tmp.write_all(CONTENTS).unwrap();\n    }\n\n    truncate(\u0026path, 4).unwrap();\n\n    let metadata = fs::metadata(\u0026path).unwrap();\n    assert_eq!(4, metadata.len());\n}\n\n#[test]\nfn test_ftruncate() {\n    let tempdir = tempdir().unwrap();\n    let path = tempdir.path().join(\"file\");\n\n    let mut file = File::create(\u0026path).unwrap();\n    const CONTENTS: \u0026[u8] = b\"12345678\";\n    file.write_all(CONTENTS).unwrap();\n\n    ftruncate(\u0026file, 2).unwrap();\n    drop(file);\n\n    let metadata = fs::metadata(\u0026path).unwrap();\n    assert_eq!(2, metadata.len());\n}\n\n// Used in `test_alarm`.\n#[cfg(not(target_os = \"redox\"))]\nstatic mut ALARM_CALLED: bool = false;\n\n// Used in `test_alarm`.\n#[cfg(not(target_os = \"redox\"))]\npub extern \"C\" fn alarm_signal_handler(raw_signal: libc::c_int) {\n    assert_eq!(raw_signal, libc::SIGALRM, \"unexpected signal: {raw_signal}\");\n    unsafe { ALARM_CALLED = true };\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_alarm() {\n    use std::{\n        thread,\n        time::{Duration, Instant},\n    };\n\n    // Maybe other tests that fork interfere with this one?\n    let _m = crate::SIGNAL_MTX.lock();\n\n    let handler = SigHandler::Handler(alarm_signal_handler);\n    let signal_action =\n        SigAction::new(handler, SaFlags::SA_RESTART, SigSet::empty());\n    let old_handler = unsafe {\n        sigaction(Signal::SIGALRM, \u0026signal_action)\n            .expect(\"unable to set signal handler for alarm\")\n    };\n\n    // Set an alarm.\n    assert_eq!(alarm::set(60), None);\n\n    // Overwriting an alarm should return the old alarm.\n    assert_eq!(alarm::set(1), Some(60));\n\n    // We should be woken up after 1 second by the alarm, so we'll sleep for 3\n    // seconds to be sure.\n    let starttime = Instant::now();\n    loop {\n        thread::sleep(Duration::from_millis(100));\n        if unsafe { ALARM_CALLED } {\n            break;\n        }\n        if starttime.elapsed() \u003e Duration::from_secs(3) {\n            panic!(\"Timeout waiting for SIGALRM\");\n        }\n    }\n\n    // Reset the signal.\n    unsafe {\n        sigaction(Signal::SIGALRM, \u0026old_handler)\n            .expect(\"unable to set signal handler for alarm\");\n    }\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_canceling_alarm() {\n    let _m = crate::SIGNAL_MTX.lock();\n\n    assert_eq!(alarm::cancel(), None);\n\n    assert_eq!(alarm::set(60), None);\n    assert_eq!(alarm::cancel(), Some(60));\n}\n\n#[test]\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nfn test_symlinkat() {\n    use nix::fcntl::AT_FDCWD;\n\n    let _m = crate::CWD_LOCK.read();\n\n    let tempdir = tempdir().unwrap();\n\n    let target = tempdir.path().join(\"a\");\n    let linkpath = tempdir.path().join(\"b\");\n    symlinkat(\u0026target, AT_FDCWD, \u0026linkpath).unwrap();\n    assert_eq!(\n        readlink(\u0026linkpath).unwrap().to_str().unwrap(),\n        target.to_str().unwrap()\n    );\n\n    let dirfd = open(tempdir.path(), OFlag::empty(), Mode::empty()).unwrap();\n    let target = \"c\";\n    let linkpath = \"d\";\n    symlinkat(target, \u0026dirfd, linkpath).unwrap();\n    assert_eq!(\n        readlink(\u0026tempdir.path().join(linkpath))\n            .unwrap()\n            .to_str()\n            .unwrap(),\n        target\n    );\n}\n\n#[test]\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nfn test_linkat_file() {\n    use nix::fcntl::AtFlags;\n\n    let tempdir = tempdir().unwrap();\n    let oldfilename = \"foo.txt\";\n    let oldfilepath = tempdir.path().join(oldfilename);\n\n    let newfilename = \"bar.txt\";\n    let newfilepath = tempdir.path().join(newfilename);\n\n    // Create file\n    File::create(oldfilepath).unwrap();\n\n    // Get file descriptor for base directory\n    let dirfd =\n        fcntl::open(tempdir.path(), fcntl::OFlag::empty(), stat::Mode::empty())\n            .unwrap();\n\n    // Attempt hard link file at relative path\n    linkat(\n        \u0026dirfd,\n        oldfilename,\n        \u0026dirfd,\n        newfilename,\n        AtFlags::AT_SYMLINK_FOLLOW,\n    )\n    .unwrap();\n    assert!(newfilepath.exists());\n}\n\n#[test]\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\n/// This test is the same as [test_linkat_file], but ensures that two different types can be used\n/// as the path arguments.\nfn test_linkat_pathtypes() {\n    use nix::fcntl::AtFlags;\n\n    let tempdir = tempdir().unwrap();\n    let oldfilename = \"foo.txt\";\n    let oldfilepath = tempdir.path().join(oldfilename);\n\n    let newfilename = \"bar.txt\";\n    let newfilepath = tempdir.path().join(newfilename);\n\n    // Create file\n    File::create(oldfilepath).unwrap();\n\n    // Get file descriptor for base directory\n    let dirfd =\n        fcntl::open(tempdir.path(), fcntl::OFlag::empty(), stat::Mode::empty())\n            .unwrap();\n\n    // Attempt hard link file at relative path\n    linkat(\n        \u0026dirfd,\n        PathBuf::from(oldfilename).as_path(),\n        \u0026dirfd,\n        newfilename,\n        AtFlags::AT_SYMLINK_FOLLOW,\n    )\n    .unwrap();\n    assert!(newfilepath.exists());\n}\n\n#[test]\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nfn test_linkat_olddirfd_none() {\n    use nix::fcntl::AtFlags;\n    use nix::fcntl::AT_FDCWD;\n\n    let _dr = crate::DirRestore::new();\n\n    let tempdir_oldfile = tempdir().unwrap();\n    let oldfilename = \"foo.txt\";\n    let oldfilepath = tempdir_oldfile.path().join(oldfilename);\n\n    let tempdir_newfile = tempdir().unwrap();\n    let newfilename = \"bar.txt\";\n    let newfilepath = tempdir_newfile.path().join(newfilename);\n\n    // Create file\n    File::create(oldfilepath).unwrap();\n\n    // Get file descriptor for base directory of new file\n    let dirfd = fcntl::open(\n        tempdir_newfile.path(),\n        fcntl::OFlag::empty(),\n        stat::Mode::empty(),\n    )\n    .unwrap();\n\n    // Attempt hard link file using curent working directory as relative path for old file path\n    chdir(tempdir_oldfile.path()).unwrap();\n    linkat(\n        AT_FDCWD,\n        oldfilename,\n        \u0026dirfd,\n        newfilename,\n        AtFlags::AT_SYMLINK_FOLLOW,\n    )\n    .unwrap();\n    assert!(newfilepath.exists());\n}\n\n#[test]\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nfn test_linkat_newdirfd_none() {\n    use nix::fcntl::AtFlags;\n    use nix::fcntl::AT_FDCWD;\n\n    let _dr = crate::DirRestore::new();\n\n    let tempdir_oldfile = tempdir().unwrap();\n    let oldfilename = \"foo.txt\";\n    let oldfilepath = tempdir_oldfile.path().join(oldfilename);\n\n    let tempdir_newfile = tempdir().unwrap();\n    let newfilename = \"bar.txt\";\n    let newfilepath = tempdir_newfile.path().join(newfilename);\n\n    // Create file\n    File::create(oldfilepath).unwrap();\n\n    // Get file descriptor for base directory of old file\n    let dirfd = fcntl::open(\n        tempdir_oldfile.path(),\n        fcntl::OFlag::empty(),\n        stat::Mode::empty(),\n    )\n    .unwrap();\n\n    // Attempt hard link file using current working directory as relative path for new file path\n    chdir(tempdir_newfile.path()).unwrap();\n    linkat(\n        \u0026dirfd,\n        oldfilename,\n        AT_FDCWD,\n        newfilename,\n        AtFlags::AT_SYMLINK_FOLLOW,\n    )\n    .unwrap();\n    assert!(newfilepath.exists());\n}\n\n#[test]\n#[cfg(not(any(apple_targets, target_os = \"redox\", target_os = \"haiku\")))]\nfn test_linkat_no_follow_symlink() {\n    use nix::fcntl::AtFlags;\n    use nix::fcntl::AT_FDCWD;\n\n    let _m = crate::CWD_LOCK.read();\n\n    let tempdir = tempdir().unwrap();\n    let oldfilename = \"foo.txt\";\n    let oldfilepath = tempdir.path().join(oldfilename);\n\n    let symoldfilename = \"symfoo.txt\";\n    let symoldfilepath = tempdir.path().join(symoldfilename);\n\n    let newfilename = \"nofollowsymbar.txt\";\n    let newfilepath = tempdir.path().join(newfilename);\n\n    // Create file\n    File::create(\u0026oldfilepath).unwrap();\n\n    // Create symlink to file\n    symlinkat(\u0026oldfilepath, AT_FDCWD, \u0026symoldfilepath).unwrap();\n\n    // Get file descriptor for base directory\n    let dirfd =\n        fcntl::open(tempdir.path(), fcntl::OFlag::empty(), stat::Mode::empty())\n            .unwrap();\n\n    // Attempt link symlink of file at relative path\n    linkat(\n        \u0026dirfd,\n        symoldfilename,\n        \u0026dirfd,\n        newfilename,\n        AtFlags::empty(),\n    )\n    .unwrap();\n\n    // Assert newfile is actually a symlink to oldfile.\n    assert_eq!(\n        readlink(\u0026newfilepath).unwrap().to_str().unwrap(),\n        oldfilepath.to_str().unwrap()\n    );\n}\n\n#[test]\n#[cfg(not(any(target_os = \"redox\", target_os = \"haiku\")))]\nfn test_linkat_follow_symlink() {\n    use nix::fcntl::AtFlags;\n    use nix::fcntl::AT_FDCWD;\n\n    let _m = crate::CWD_LOCK.read();\n\n    let tempdir = tempdir().unwrap();\n    let oldfilename = \"foo.txt\";\n    let oldfilepath = tempdir.path().join(oldfilename);\n\n    let symoldfilename = \"symfoo.txt\";\n    let symoldfilepath = tempdir.path().join(symoldfilename);\n\n    let newfilename = \"nofollowsymbar.txt\";\n    let newfilepath = tempdir.path().join(newfilename);\n\n    // Create file\n    File::create(\u0026oldfilepath).unwrap();\n\n    // Create symlink to file\n    symlinkat(\u0026oldfilepath, AT_FDCWD, \u0026symoldfilepath).unwrap();\n\n    // Get file descriptor for base directory\n    let dirfd =\n        fcntl::open(tempdir.path(), fcntl::OFlag::empty(), stat::Mode::empty())\n            .unwrap();\n\n    // Attempt link target of symlink of file at relative path\n    linkat(\n        \u0026dirfd,\n        symoldfilename,\n        \u0026dirfd,\n        newfilename,\n        AtFlags::AT_SYMLINK_FOLLOW,\n    )\n    .unwrap();\n\n    let newfilestat = stat::stat(\u0026newfilepath).unwrap();\n\n    // Check the file type of the new link\n    assert_eq!(\n        stat::SFlag::from_bits_truncate(newfilestat.st_mode as mode_t)\n            \u0026 SFlag::S_IFMT,\n        SFlag::S_IFREG\n    );\n\n    // Check the number of hard links to the original file\n    assert_eq!(newfilestat.st_nlink, 2);\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_unlinkat_dir_noremovedir() {\n    let tempdir = tempdir().unwrap();\n    let dirname = \"foo_dir\";\n    let dirpath = tempdir.path().join(dirname);\n\n    // Create dir\n    DirBuilder::new().recursive(true).create(dirpath).unwrap();\n\n    // Get file descriptor for base directory\n    let dirfd =\n        fcntl::open(tempdir.path(), fcntl::OFlag::empty(), stat::Mode::empty())\n            .unwrap();\n\n    // Attempt unlink dir at relative path without proper flag\n    let err_result =\n        unlinkat(\u0026dirfd, dirname, UnlinkatFlags::NoRemoveDir).unwrap_err();\n    assert!(err_result == Errno::EISDIR || err_result == Errno::EPERM);\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_unlinkat_dir_removedir() {\n    let tempdir = tempdir().unwrap();\n    let dirname = \"foo_dir\";\n    let dirpath = tempdir.path().join(dirname);\n\n    // Create dir\n    DirBuilder::new().recursive(true).create(\u0026dirpath).unwrap();\n\n    // Get file descriptor for base directory\n    let dirfd =\n        fcntl::open(tempdir.path(), fcntl::OFlag::empty(), stat::Mode::empty())\n            .unwrap();\n\n    // Attempt unlink dir at relative path with proper flag\n    unlinkat(\u0026dirfd, dirname, UnlinkatFlags::RemoveDir).unwrap();\n    assert!(!dirpath.exists());\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_unlinkat_file() {\n    let tempdir = tempdir().unwrap();\n    let filename = \"foo.txt\";\n    let filepath = tempdir.path().join(filename);\n\n    // Create file\n    File::create(\u0026filepath).unwrap();\n\n    // Get file descriptor for base directory\n    let dirfd =\n        fcntl::open(tempdir.path(), fcntl::OFlag::empty(), stat::Mode::empty())\n            .unwrap();\n\n    // Attempt unlink file at relative path\n    unlinkat(\u0026dirfd, filename, UnlinkatFlags::NoRemoveDir).unwrap();\n    assert!(!filepath.exists());\n}\n\n#[test]\nfn test_access_not_existing() {\n    let tempdir = tempdir().unwrap();\n    let dir = tempdir.path().join(\"does_not_exist.txt\");\n    assert_eq!(\n        access(\u0026dir, AccessFlags::F_OK).err().unwrap(),\n        Errno::ENOENT\n    );\n}\n\n#[test]\nfn test_access_file_exists() {\n    let tempdir = tempdir().unwrap();\n    let path = tempdir.path().join(\"does_exist.txt\");\n    let _file = File::create(path.clone()).unwrap();\n    access(\u0026path, AccessFlags::R_OK | AccessFlags::W_OK)\n        .expect(\"assertion failed\");\n}\n\n#[cfg(not(target_os = \"redox\"))]\n#[test]\nfn test_user_into_passwd() {\n    let test_username = if cfg!(target_os = \"haiku\") {\n        // \"nobody\" unavailable on haiku\n        \"user\"\n    } else if cfg!(target_os = \"cygwin\") {\n        // the Windows admin user\n        \"Administrator\"\n    } else {\n        // get the UID of the \"nobody\" user\n        \"nobody\"\n    };\n\n    let nobody = User::from_name(test_username).unwrap().unwrap();\n    let pwd: libc::passwd = nobody.into();\n    let _: User = (\u0026pwd).into();\n}\n\n/// Tests setting the filesystem UID with `setfsuid`.\n#[cfg(linux_android)]\n#[test]\nfn test_setfsuid() {\n    use std::os::unix::fs::PermissionsExt;\n    use std::{fs, io, thread};\n    require_capability!(\"test_setfsuid\", CAP_SETUID);\n\n    // get the UID of the \"nobody\" user\n    let nobody = User::from_name(\"nobody\").unwrap().unwrap();\n\n    // create a temporary file with permissions '-rw-r-----'\n    let file = tempfile::NamedTempFile::new_in(\"/var/tmp\").unwrap();\n    let temp_path = file.into_temp_path();\n    let temp_path_2 = temp_path.to_path_buf();\n    let mut permissions = fs::metadata(\u0026temp_path).unwrap().permissions();\n    permissions.set_mode(0o640);\n\n    // spawn a new thread where to test setfsuid\n    thread::spawn(move || {\n        // set filesystem UID\n        let fuid = setfsuid(nobody.uid);\n        // trying to open the temporary file should fail with EACCES\n        let res = fs::File::open(\u0026temp_path);\n        let err = res.expect_err(\"assertion failed\");\n        assert_eq!(err.kind(), io::ErrorKind::PermissionDenied);\n\n        // assert fuid actually changes\n        let prev_fuid = setfsuid(Uid::from_raw(-1i32 as u32));\n        assert_ne!(prev_fuid, fuid);\n    })\n    .join()\n    .unwrap();\n\n    // open the temporary file with the current thread filesystem UID\n    fs::File::open(temp_path_2).unwrap();\n}\n\n#[test]\n#[cfg(not(any(\n    target_os = \"redox\",\n    target_os = \"fuchsia\",\n    target_os = \"haiku\"\n)))]\nfn test_ttyname() {\n    use std::os::fd::AsRawFd;\n\n    let fd = posix_openpt(OFlag::O_RDWR).expect(\"posix_openpt failed\");\n    assert!(fd.as_raw_fd() \u003e 0);\n\n    // on linux, we can just call ttyname on the pty master directly, but\n    // apparently osx requires that ttyname is called on a slave pty (can't\n    // find this documented anywhere, but it seems to empirically be the case)\n    grantpt(\u0026fd).expect(\"grantpt failed\");\n    unlockpt(\u0026fd).expect(\"unlockpt failed\");\n    let sname = unsafe { ptsname(\u0026fd) }.expect(\"ptsname failed\");\n    let fds = fs::OpenOptions::new()\n        .read(true)\n        .write(true)\n        .open(Path::new(\u0026sname))\n        .expect(\"open failed\");\n\n    let name = ttyname(fds).expect(\"ttyname failed\");\n    assert!(name.starts_with(\"/dev\"));\n}\n\n#[test]\n#[cfg(not(any(target_os = \"redox\", target_os = \"fuchsia\")))]\nfn test_ttyname_not_pty() {\n    let fd = File::open(\"/dev/zero\").unwrap();\n    assert_eq!(ttyname(fd), Err(Errno::ENOTTY));\n}\n\n#[test]\n#[cfg(bsd)]\nfn test_getpeereid() {\n    use std::os::unix::net::UnixStream;\n    let (sock_a, sock_b) = UnixStream::pair().unwrap();\n\n    let (uid_a, gid_a) = getpeereid(sock_a).unwrap();\n    let (uid_b, gid_b) = getpeereid(sock_b).unwrap();\n\n    let uid = geteuid();\n    let gid = getegid();\n\n    assert_eq!(uid, uid_a);\n    assert_eq!(gid, gid_a);\n    assert_eq!(uid_a, uid_b);\n    assert_eq!(gid_a, gid_b);\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_faccessat_none_not_existing() {\n    use nix::fcntl::AtFlags;\n    use nix::fcntl::AT_FDCWD;\n\n    let tempdir = tempfile::tempdir().unwrap();\n    let dir = tempdir.path().join(\"does_not_exist.txt\");\n    assert_eq!(\n        faccessat(AT_FDCWD, \u0026dir, AccessFlags::F_OK, AtFlags::empty())\n            .err()\n            .unwrap(),\n        Errno::ENOENT\n    );\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_faccessat_not_existing() {\n    use nix::fcntl::AtFlags;\n\n    let tempdir = tempfile::tempdir().unwrap();\n    let dirfd = open(tempdir.path(), OFlag::empty(), Mode::empty()).unwrap();\n    let not_exist_file = \"does_not_exist.txt\";\n    assert_eq!(\n        faccessat(\u0026dirfd, not_exist_file, AccessFlags::F_OK, AtFlags::empty(),)\n            .err()\n            .unwrap(),\n        Errno::ENOENT\n    );\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_faccessat_none_file_exists() {\n    use nix::fcntl::AtFlags;\n    use nix::fcntl::AT_FDCWD;\n\n    let tempdir = tempfile::tempdir().unwrap();\n    let path = tempdir.path().join(\"does_exist.txt\");\n    let _file = File::create(path.clone()).unwrap();\n    assert!(faccessat(\n        AT_FDCWD,\n        \u0026path,\n        AccessFlags::R_OK | AccessFlags::W_OK,\n        AtFlags::empty(),\n    )\n    .is_ok());\n}\n\n#[test]\n#[cfg(not(target_os = \"redox\"))]\nfn test_faccessat_file_exists() {\n    use nix::fcntl::AtFlags;\n\n    let tempdir = tempfile::tempdir().unwrap();\n    let dirfd = open(tempdir.path(), OFlag::empty(), Mode::empty()).unwrap();\n    let exist_file = \"does_exist.txt\";\n    let path = tempdir.path().join(exist_file);\n    let _file = File::create(path.clone()).unwrap();\n    assert!(faccessat(\n        \u0026dirfd,\n        \u0026path,\n        AccessFlags::R_OK | AccessFlags::W_OK,\n        AtFlags::empty(),\n    )\n    .is_ok());\n}\n\n#[test]\n#[cfg(any(all(target_os = \"linux\", not(target_env = \"uclibc\")), freebsdlike))]\nfn test_eaccess_not_existing() {\n    let tempdir = tempdir().unwrap();\n    let dir = tempdir.path().join(\"does_not_exist.txt\");\n    assert_eq!(\n        eaccess(\u0026dir, AccessFlags::F_OK).err().unwrap(),\n        Errno::ENOENT\n    );\n}\n\n#[test]\n#[cfg(any(all(target_os = \"linux\", not(target_env = \"uclibc\")), freebsdlike))]\nfn test_eaccess_file_exists() {\n    let tempdir = tempdir().unwrap();\n    let path = tempdir.path().join(\"does_exist.txt\");\n    let _file = File::create(path.clone()).unwrap();\n    eaccess(\u0026path, AccessFlags::R_OK | AccessFlags::W_OK)\n        .expect(\"assertion failed\");\n}\n\n#[test]\n#[cfg(bsd)]\nfn test_group_from() {\n    let group = Group::from_name(\"wheel\").unwrap().unwrap();\n    assert!(group.name == \"wheel\");\n    let group_id = group.gid;\n    let group = Group::from_gid(group_id).unwrap().unwrap();\n    assert_eq!(group.gid, group_id);\n    assert_eq!(group.name, \"wheel\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","src","control_client.rs"],"content":"use anyhow::Result;\nuse clap::Parser;\nuse multicast_relay::OutputDestination;\nuse std::net::Ipv4Addr;\nuse std::path::PathBuf;\n\n#[derive(Parser, Debug)]\n#[command(author, version, about, long_about = None)]\nstruct Args {\n    #[clap(subcommand)]\n    command: CliCommand,\n\n    /// Path to the control socket\n    #[arg(long, default_value = \"/tmp/multicast_relay_control.sock\")]\n    socket_path: PathBuf,\n}\n\n#[derive(Parser, Debug)]\nenum CliCommand {\n    /// Add a new forwarding rule\n    Add {\n        #[arg(long)]\n        input_interface: String,\n        #[arg(long)]\n        input_group: Ipv4Addr,\n        #[arg(long)]\n        input_port: u16,\n        #[arg(long, value_parser = parse_output_destination)]\n        outputs: Vec\u003cOutputDestination\u003e,\n    },\n    /// Remove a forwarding rule\n    Remove {\n        #[arg(long)]\n        input_group: Ipv4Addr,\n        #[arg(long)]\n        input_port: u16,\n    },\n    /// List all forwarding rules\n    List,\n    /// Get statistics for all flows\n    Stats,\n}\n\nfn parse_output_destination(s: \u0026str) -\u003e Result\u003cOutputDestination, String\u003e {\n    let parts: Vec\u003c\u0026str\u003e = s.split(':').collect();\n    if parts.len() != 3 \u0026\u0026 parts.len() != 4 {\n        return Err(\"Invalid format. Expected group:port:interface[:dtls]\".to_string());\n    }\n    let group = parts[0]\n        .parse()\n        .map_err(|e| format!(\"Invalid group IP: {}\", e))?;\n    let port = parts[1]\n        .parse()\n        .map_err(|e| format!(\"Invalid port: {}\", e))?;\n    let interface = parts[2]\n        .parse()\n        .map_err(|e| format!(\"Invalid interface IP: {}\", e))?;\n    let dtls_enabled = if parts.len() == 4 {\n        parts[3]\n            .parse()\n            .map_err(|e| format!(\"Invalid dtls flag: {}\", e))?\n    } else {\n        false\n    };\n    Ok(OutputDestination {\n        group,\n        port,\n        interface,\n        dtls_enabled,\n    })\n}\n\n#[cfg(not(test))]\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    use clap::Parser;\n    use multicast_relay::{Command, Response};\n    use tokio::io::{AsyncReadExt, AsyncWriteExt};\n    use tokio::net::UnixStream;\n\n    let args = Args::parse();\n\n    let command = match args.command {\n        CliCommand::Add {\n            input_interface,\n            input_group,\n            input_port,\n            outputs,\n        } =\u003e Command::AddRule {\n            input_interface,\n            input_group,\n            input_port,\n            outputs,\n            dtls_enabled: false,\n        },\n        CliCommand::Remove {\n            input_group,\n            input_port,\n        } =\u003e Command::RemoveRule {\n            input_group,\n            input_port,\n        },\n        CliCommand::List =\u003e Command::ListRules,\n        CliCommand::Stats =\u003e Command::GetStats,\n    };\n\n    let mut stream = UnixStream::connect(args.socket_path).await?;\n    let command_bytes = serde_json::to_vec(\u0026command)?;\n    stream.write_all(\u0026command_bytes).await?;\n\n    let mut response_bytes = Vec::new();\n    stream.read_to_end(\u0026mut response_bytes).await?;\n\n    let response: Response = serde_json::from_slice(\u0026response_bytes)?;\n    println!(\"{}\", serde_json::to_string_pretty(\u0026response)?);\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_output_destination() {\n        let s = \"224.0.0.1:5000:127.0.0.1\";\n        let dest = parse_output_destination(s).unwrap();\n        assert_eq!(dest.group, \"224.0.0.1\".parse::\u003cIpv4Addr\u003e().unwrap());\n        assert_eq!(dest.port, 5000);\n        assert_eq!(dest.interface, \"127.0.0.1\".to_string());\n        assert!(!dest.dtls_enabled);\n\n        let s = \"224.0.0.1:5000:127.0.0.1:true\";\n        let dest = parse_output_destination(s).unwrap();\n        assert!(dest.dtls_enabled);\n\n        let s = \"224.0.0.1:5000:127.0.0.1:false\";\n        let dest = parse_output_destination(s).unwrap();\n        assert!(!dest.dtls_enabled);\n\n        let s = \"invalid\";\n        assert!(parse_output_destination(s).is_err());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","src","lib.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::net::Ipv4Addr;\n\npub mod supervisor;\npub mod worker;\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]\npub struct OutputDestination {\n    pub group: Ipv4Addr,\n    pub port: u16,\n    pub interface: String,\n    pub dtls_enabled: bool,\n}\n\n#[derive(Debug, Serialize, Deserialize, PartialEq)]\npub enum Command {\n    AddRule {\n        input_interface: String,\n        input_group: Ipv4Addr,\n        input_port: u16,\n        outputs: Vec\u003cOutputDestination\u003e,\n        #[serde(default)]\n        dtls_enabled: bool,\n    },\n    RemoveRule {\n        input_group: Ipv4Addr,\n        input_port: u16,\n    },\n    ListRules,\n    GetStats,\n}\n\n#[derive(Debug, Serialize, Deserialize, PartialEq)]\npub enum Response {\n    Success(String),\n    Error(String),\n    Rules(Vec\u003cForwardingRule\u003e),\n    Stats(Vec\u003cFlowStats\u003e),\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, Hash)]\npub struct ForwardingRule {\n    pub input_interface: String,\n    pub input_group: Ipv4Addr,\n    pub input_port: u16,\n    pub outputs: Vec\u003cOutputDestination\u003e,\n    pub dtls_enabled: bool,\n}\n\n#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]\npub struct FlowStats {\n    pub input_group: Ipv4Addr,\n    pub input_port: u16,\n    pub packets_relayed: u64,\n    pub bytes_relayed: u64,\n    pub packets_per_second: f64,\n    pub bits_per_second: f64,\n}\n\n#[derive(Debug, Clone)]\npub enum RelayCommand {\n    AddRule(ForwardingRule),\n    RemoveRule {\n        input_group: Ipv4Addr,\n        input_port: u16,\n    },\n}\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_command_serialization() {\n        let command = Command::AddRule {\n            input_interface: \"eth0\".to_string(),\n            input_group: \"224.0.0.1\".parse().unwrap(),\n            input_port: 5000,\n            outputs: vec![OutputDestination {\n                group: \"224.0.0.2\".parse().unwrap(),\n                port: 5001,\n                interface: \"127.0.0.1\".parse().unwrap(),\n                dtls_enabled: true,\n            }],\n            dtls_enabled: false,\n        };\n        let json = serde_json::to_string(\u0026command).unwrap();\n        let deserialized: Command = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(command, deserialized);\n    }\n\n    #[test]\n    fn test_response_serialization() {\n        let response = Response::Success(\"OK\".to_string());\n        let json = serde_json::to_string(\u0026response).unwrap();\n        let deserialized: Response = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(response, deserialized);\n\n        let stats = FlowStats {\n            input_group: \"224.0.0.1\".parse().unwrap(),\n            input_port: 5000,\n            packets_relayed: 100,\n            bytes_relayed: 12345,\n            packets_per_second: 10.0,\n            bits_per_second: 12345.0 * 8.0,\n        };\n        let response = Response::Stats(vec![stats]);\n        let json = serde_json::to_string(\u0026response).unwrap();\n        let deserialized: Response = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(response, deserialized);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","src","main.rs"],"content":"use anyhow::Result;\nuse clap::Parser;\nuse multicast_relay::{supervisor, worker};\n\n#[derive(Parser, Debug)]\n#[command(author, version, about, long_about = None)]\nstruct Args {\n    #[command(subcommand)]\n    command: Command,\n}\n\n#[derive(Parser, Debug, PartialEq)]\nenum Command {\n    /// Run the supervisor process\n    Supervisor,\n    /// Run the worker process (intended to be called by the supervisor)\n    Worker {\n        #[arg(long, default_value = \"nobody\")]\n        user: String,\n        #[arg(long, default_value = \"nogroup\")]\n        group: String,\n    },\n}\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    let args = Args::parse();\n\n    match args.command {\n        Command::Supervisor =\u003e {\n            supervisor::run().await?;\n        }\n        Command::Worker { user, group } =\u003e {\n            // D1, D7: The worker process uses a `tokio-uring` runtime\n            // to drive the high-performance data plane.\n            tokio_uring::start(async {\n                if let Err(e) = worker::run(user, group).await {\n                    eprintln!(\"Worker process failed: {}\", e);\n                    std::process::exit(1);\n                }\n            });\n        }\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_arg_parsing() {\n        let args = Args::parse_from([\"multicast_relay\", \"supervisor\"]);\n        assert_eq!(args.command, Command::Supervisor);\n\n        let args = Args::parse_from([\n            \"multicast_relay\",\n            \"worker\",\n            \"--user\",\n            \"test\",\n            \"--group\",\n            \"test\",\n        ]);\n        assert_eq!(\n            args.command,\n            Command::Worker {\n                user: \"test\".to_string(),\n                group: \"test\".to_string()\n            }\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","src","supervisor.rs"],"content":"use anyhow::Result;\nuse std::process::Command;\nuse std::time::Duration;\nuse tokio::time::sleep;\n\npub async fn run() -\u003e Result\u003c()\u003e {\n    println!(\"Supervisor starting.\");\n\n    let current_exe = std::env::current_exe()?;\n\n    loop {\n        println!(\"Supervisor: Spawning worker process.\");\n        let mut child = Command::new(\u0026current_exe)\n            .arg(\"worker\")\n            .arg(\"--user\")\n            .arg(\"nobody\")\n            .arg(\"--group\")\n            .arg(\"nogroup\")\n            .spawn()?;\n\n        let status = child.wait()?;\n\n        println!(\"Supervisor: Worker process exited with status: {}\", status);\n        println!(\"Supervisor: Restarting worker in 5 seconds...\");\n        sleep(Duration::from_secs(5)).await;\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn placeholder_test() {\n        // This test does nothing, but is here to increase coverage.\n        assert_eq!(2 + 2, 4);\n    }\n}\n","traces":[{"line":6,"address":[80792,80747,80640,82396,81161,80673],"length":1,"stats":{"Line":0}},{"line":7,"address":[80721,80834],"length":1,"stats":{"Line":0}},{"line":9,"address":[80853,81089],"length":1,"stats":{"Line":0}},{"line":12,"address":[81498,81055],"length":1,"stats":{"Line":0}},{"line":13,"address":[82369,81530,81811,81753],"length":1,"stats":{"Line":0}},{"line":21,"address":[81924,82319],"length":1,"stats":{"Line":0}},{"line":23,"address":[82073],"length":1,"stats":{"Line":0}},{"line":24,"address":[82149],"length":1,"stats":{"Line":0}},{"line":25,"address":[81217,80774,81192,82199],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":9},{"path":["/","home","acooks","mcr","src","traffic_generator.rs"],"content":"use clap::Parser;\nuse std::net::Ipv4Addr;\n\n#[derive(Parser, Debug)]\n#[command(author, version, about, long_about = None)]\nstruct Args {\n    /// Multicast group IP address to send to\n    #[arg(long)]\n    group: Ipv4Addr,\n\n    /// Port to send to\n    #[arg(long)]\n    port: u16,\n\n    /// Local interface IP address to send from\n    #[arg(long)]\n    interface: Ipv4Addr,\n\n    /// Packet rate in packets per second\n    #[arg(long, default_value_t = 1000)]\n    rate: u64,\n\n    /// Packet size in bytes\n    #[arg(long, default_value_t = 1024)]\n    size: usize,\n}\n\n#[cfg(not(test))]\n#[tokio::main]\nasync fn main() -\u003e anyhow::Result\u003c()\u003e {\n    use socket2::{Domain, Protocol, Socket, Type};\n    use std::net::SocketAddrV4;\n    use tokio::net::UdpSocket;\n    use tokio::time::{self, Duration};\n\n    let args = Args::parse();\n\n    let dest_addr = SocketAddrV4::new(args.group, args.port);\n\n    let sender_std_socket = Socket::new(Domain::IPV4, Type::DGRAM, Some(Protocol::UDP))?;\n    sender_std_socket.set_multicast_if_v4(\u0026args.interface)?;\n    sender_std_socket.bind(\u0026SocketAddrV4::new(args.interface, 0).into())?;\n    sender_std_socket.set_nonblocking(true)?;\n    let sender_socket = UdpSocket::from_std(sender_std_socket.into())?;\n\n    println!(\n        \"Sending to {}:{} from interface {} at {} pps with size {}\",\n        args.group, args.port, args.interface, args.rate, args.size\n    );\n\n    let packet = vec![0u8; args.size];\n    let interval = Duration::from_secs_f64(1.0 / args.rate as f64);\n    let mut interval_timer = time::interval(interval);\n\n    loop {\n        interval_timer.tick().await;\n        if let Err(e) = sender_socket.send_to(\u0026packet, dest_addr).await {\n            eprintln!(\"Error sending packet: {}\", e);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","src","worker","args.rs"],"content":"use clap::Parser;\nuse std::net::{Ipv4Addr, SocketAddr};\n\n#[derive(Parser, Debug)]\n#[command(author, version, about, long_about = None)]\npub struct Args {\n    #[arg(long)]\n    pub input_group: Option\u003cIpv4Addr\u003e,\n    #[arg(long)]\n    pub input_port: Option\u003cu16\u003e,\n    #[arg(long)]\n    pub output_group: Option\u003cIpv4Addr\u003e,\n    #[arg(long)]\n    pub output_port: Option\u003cu16\u003e,\n    #[arg(long)]\n    pub output_interface: Option\u003cIpv4Addr\u003e,\n    #[arg(long)]\n    pub input_interface_name: Option\u003cString\u003e,\n    #[arg(long, default_value_t = 5)]\n    pub reporting_interval: u64,\n    #[arg(long, default_value = \"127.0.0.1:9090\")]\n    pub prometheus_addr: SocketAddr,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acooks","mcr","src","worker","control_plane.rs"],"content":"use anyhow::Result;\nuse std::collections::HashMap;\nuse std::fs;\nuse std::net::Ipv4Addr;\nuse std::path::Path;\nuse std::sync::Arc;\nuse tokio::io::{AsyncReadExt, AsyncWriteExt};\nuse tokio::net::UnixListener;\nuse tokio::sync::Mutex;\nuse tokio::sync::mpsc;\n\nuse crate::{Command, FlowStats, ForwardingRule, RelayCommand, Response};\n\ntype SharedFlows = Arc\u003cMutex\u003cHashMap\u003c(Ipv4Addr, u16), (ForwardingRule, FlowStats)\u003e\u003e\u003e;\n\npub async fn control_plane_task(\n    socket_path: \u0026Path,\n    relay_command_tx: mpsc::Sender\u003cRelayCommand\u003e,\n    shared_flows: SharedFlows,\n) -\u003e Result\u003c()\u003e {\n    if socket_path.exists() {\n        fs::remove_file(socket_path)?;\n    }\n    let listener = UnixListener::bind(socket_path)?;\n    loop {\n        let (mut stream, _) = listener.accept().await?;\n        let relay_command_tx = relay_command_tx.clone();\n        let shared_flows = shared_flows.clone();\n        tokio::spawn(async move {\n            let mut buffer = Vec::new();\n            if stream.read_to_end(\u0026mut buffer).await.is_err() {\n                return;\n            }\n            let command: Result\u003cCommand, _\u003e = serde_json::from_slice(\u0026buffer);\n            let response = match command {\n                Ok(cmd) =\u003e match cmd {\n                    Command::AddRule {\n                        input_interface,\n                        input_group,\n                        input_port,\n                        outputs,\n                        dtls_enabled,\n                    } =\u003e {\n                        let rule = ForwardingRule {\n                            input_interface,\n                            input_group,\n                            input_port,\n                            outputs,\n                            dtls_enabled,\n                        };\n                        if relay_command_tx\n                            .send(RelayCommand::AddRule(rule))\n                            .await\n                            .is_ok()\n                        {\n                            Response::Success(\"Rule added\".to_string())\n                        } else {\n                            Response::Error(\"Failed to add rule\".to_string())\n                        }\n                    }\n                    Command::RemoveRule {\n                        input_group,\n                        input_port,\n                    } =\u003e {\n                        if relay_command_tx\n                            .send(RelayCommand::RemoveRule {\n                                input_group,\n                                input_port,\n                            })\n                            .await\n                            .is_ok()\n                        {\n                            Response::Success(\"Rule removed\".to_string())\n                        } else {\n                            Response::Error(\"Failed to remove rule\".to_string())\n                        }\n                    }\n                    Command::ListRules =\u003e {\n                        let flows = shared_flows.lock().await;\n                        Response::Rules(flows.values().map(|(r, _)| r.clone()).collect())\n                    }\n                    Command::GetStats =\u003e {\n                        let flows = shared_flows.lock().await;\n                        Response::Stats(flows.values().map(|(_, s)| s.clone()).collect())\n                    }\n                },\n                Err(e) =\u003e Response::Error(e.to_string()),\n            };\n            let response_bytes = serde_json::to_vec(\u0026response).unwrap();\n            let _ = stream.write_all(\u0026response_bytes).await;\n        });\n    }\n}\n","traces":[{"line":16,"address":[618000],"length":1,"stats":{"Line":0}},{"line":21,"address":[675879,675975,676141],"length":1,"stats":{"Line":0}},{"line":22,"address":[676026,676353],"length":1,"stats":{"Line":0}},{"line":24,"address":[676162,676321,675991],"length":1,"stats":{"Line":0}},{"line":25,"address":[677159],"length":1,"stats":{"Line":0}},{"line":26,"address":[676290,676666,676394,677285,676415,675917,677180],"length":1,"stats":{"Line":0}},{"line":27,"address":[676905,676830],"length":1,"stats":{"Line":0}},{"line":28,"address":[676921,676980],"length":1,"stats":{"Line":0}},{"line":29,"address":[677488,679569,676988,677610,677527,677963,679745],"length":1,"stats":{"Line":0}},{"line":30,"address":[677592],"length":1,"stats":{"Line":0}},{"line":31,"address":[677893,677810,677997,677640],"length":1,"stats":{"Line":0}},{"line":34,"address":[678308],"length":1,"stats":{"Line":0}},{"line":35,"address":[678382],"length":1,"stats":{"Line":0}},{"line":36,"address":[678469],"length":1,"stats":{"Line":0}},{"line":38,"address":[678586],"length":1,"stats":{"Line":0}},{"line":39,"address":[678616],"length":1,"stats":{"Line":0}},{"line":40,"address":[678629],"length":1,"stats":{"Line":0}},{"line":41,"address":[678644],"length":1,"stats":{"Line":0}},{"line":42,"address":[678674],"length":1,"stats":{"Line":0}},{"line":44,"address":[678687],"length":1,"stats":{"Line":0}},{"line":51,"address":[680323,678780,679987,680192,679068,680423],"length":1,"stats":{"Line":0}},{"line":52,"address":[678784],"length":1,"stats":{"Line":0}},{"line":53,"address":[680115,679835,677661,679101,679053],"length":1,"stats":{"Line":0}},{"line":54,"address":[680137,680206],"length":1,"stats":{"Line":0}},{"line":56,"address":[680328],"length":1,"stats":{"Line":0}},{"line":58,"address":[680228],"length":1,"stats":{"Line":0}},{"line":62,"address":[678882],"length":1,"stats":{"Line":0}},{"line":63,"address":[678895],"length":1,"stats":{"Line":0}},{"line":65,"address":[679154,680793,680588,680924,681024,678910],"length":1,"stats":{"Line":0}},{"line":66,"address":[678914],"length":1,"stats":{"Line":0}},{"line":70,"address":[680436,677682,680716,679187,679139],"length":1,"stats":{"Line":0}},{"line":71,"address":[680738,680807],"length":1,"stats":{"Line":0}},{"line":73,"address":[680929],"length":1,"stats":{"Line":0}},{"line":75,"address":[680829],"length":1,"stats":{"Line":0}},{"line":79,"address":[678988,677703,679225,681037],"length":1,"stats":{"Line":0}},{"line":80,"address":[682544,682577,681304,681239],"length":1,"stats":{"Line":0}},{"line":83,"address":[677724,679331,679018,681432],"length":1,"stats":{"Line":0}},{"line":84,"address":[681634,681699,682641,682608],"length":1,"stats":{"Line":0}},{"line":87,"address":[678423,679424],"length":1,"stats":{"Line":0}},{"line":89,"address":[681874,679544],"length":1,"stats":{"Line":0}},{"line":90,"address":[681911,682016,677745],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":41},{"path":["/","home","acooks","mcr","src","worker","data_plane.rs"],"content":"use crate::{FlowStats, ForwardingRule};\nuse anyhow::Result;\nuse socket2::{Domain, Protocol, Socket, Type};\nuse std::ffi::CString;\nuse std::net::{Ipv4Addr, SocketAddrV4};\nuse std::os::unix::io::{AsRawFd, FromRawFd, OwnedFd};\nuse std::rc::Rc;\nuse std::sync::Arc;\nuse tokio::sync::mpsc;\nuse tokio::task;\nuse tokio_uring::fs::File;\nuse tokio_uring::net::UdpSocket;\n\npub fn setup_ingress_socket(interface_name: \u0026str) -\u003e Result\u003cOwnedFd\u003e {\n    let if_name = CString::new(interface_name)?;\n    let if_index = unsafe { libc::if_nametoindex(if_name.as_ptr()) };\n    if if_index == 0 {\n        return Err(anyhow::anyhow!(\"Interface '{}' not found\", interface_name));\n    }\n\n    let fd = unsafe {\n        libc::socket(\n            libc::AF_PACKET,\n            libc::SOCK_RAW,\n            (libc::ETH_P_ALL as u16).to_be() as i32,\n        )\n    };\n    if fd \u003c 0 {\n        return Err(anyhow::anyhow!(\"Failed to create AF_PACKET socket\"));\n    }\n\n    let mut sockaddr_ll: libc::sockaddr_ll = unsafe { std::mem::zeroed() };\n    sockaddr_ll.sll_family = libc::AF_PACKET as u16;\n    sockaddr_ll.sll_protocol = (libc::ETH_P_ALL as u16).to_be();\n    sockaddr_ll.sll_ifindex = if_index as i32;\n\n    let bind_result = unsafe {\n        libc::bind(\n            fd,\n            \u0026sockaddr_ll as *const _ as *const libc::sockaddr,\n            std::mem::size_of::\u003clibc::sockaddr_ll\u003e() as u32,\n        )\n    };\n    if bind_result \u003c 0 {\n        return Err(anyhow::anyhow!(\n            \"Failed to bind to interface '{}'\",\n            interface_name\n        ));\n    }\n\n    Ok(unsafe { OwnedFd::from_raw_fd(fd) })\n}\n\nuse pnet::packet::Packet;\nuse pnet::packet::ethernet::{EtherTypes, EthernetPacket};\nuse pnet::packet::ip::IpNextHeaderProtocols;\nuse pnet::packet::ipv4::Ipv4Packet;\nuse pnet::packet::udp::UdpPacket;\n\n// ... (imports and setup_ingress_socket remain the same) ...\n\npub async fn run_flow_task(\n    rule: ForwardingRule,\n    raw_fd: Arc\u003cOwnedFd\u003e,\n    _stats_tx: mpsc::Sender\u003c(ForwardingRule, FlowStats)\u003e,\n) -\u003e Result\u003c()\u003e {\n    let uring_file = unsafe { File::from_raw_fd(raw_fd.as_raw_fd()) };\n\n    // --- Egress Setup ---\n    let mut output_sockets = Vec::new();\n    for output in \u0026rule.outputs {\n        let socket = Socket::new(Domain::IPV4, Type::DGRAM, Some(Protocol::UDP))?;\n\n        // Bind the socket to the specified output interface.\n        let if_name = CString::new(output.interface.clone())?;\n        socket.bind_device(Some(if_name.as_bytes()))?;\n\n        // It's important to bind the socket to a local address.\n        // We'll use an ephemeral port on the unspecified address.\n        let local_addr = SocketAddrV4::new(Ipv4Addr::UNSPECIFIED, 0);\n        socket.bind(\u0026local_addr.into())?;\n\n        // Convert the std socket to a tokio_uring socket.\n        let udp_socket = Rc::new(UdpSocket::from_std(socket.into()));\n        output_sockets.push((udp_socket, output.clone()));\n    }\n\n    let mut buffer = vec![0u8; 2048]; // MTU\n\n    loop {\n        let (res, b) = uring_file.read_at(buffer, 0).await;\n        buffer = b;\n        let bytes_read = res?;\n\n        if bytes_read \u003e 0 {\n            let raw_packet = \u0026buffer[..bytes_read];\n\n            // --- Packet Parsing \u0026 Filtering ---\n            #[allow(clippy::collapsible_if)]\n            if let Some(ethernet_packet) = EthernetPacket::new(raw_packet) {\n                if ethernet_packet.get_ethertype() == EtherTypes::Ipv4 {\n                    if let Some(ipv4_packet) = Ipv4Packet::new(ethernet_packet.payload()) {\n                        if ipv4_packet.get_next_level_protocol() == IpNextHeaderProtocols::Udp {\n                            if let Some(udp_packet) = UdpPacket::new(ipv4_packet.payload()) {\n                                if ipv4_packet.get_destination() == rule.input_group\n                                    \u0026\u0026 udp_packet.get_destination() == rule.input_port\n                                {\n                                    // --- Egress Forwarding ---\n                                    for (socket, dest) in \u0026output_sockets {\n                                        let packet_data = udp_packet.payload().to_vec();\n                                        let dest_addr = SocketAddrV4::new(dest.group, dest.port);\n                                        let socket_clone = Rc::clone(socket);\n                                        task::spawn_local(async move {\n                                            let _ = socket_clone\n                                                .send_to(packet_data, dest_addr.into())\n                                                .await;\n                                        });\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":14,"address":[829898,829904,828816],"length":1,"stats":{"Line":0}},{"line":15,"address":[828843],"length":1,"stats":{"Line":0}},{"line":16,"address":[829147,829076],"length":1,"stats":{"Line":0}},{"line":17,"address":[829181],"length":1,"stats":{"Line":0}},{"line":18,"address":[829186,829230],"length":1,"stats":{"Line":0}},{"line":25,"address":[829215,829398],"length":1,"stats":{"Line":0}},{"line":28,"address":[829428],"length":1,"stats":{"Line":0}},{"line":29,"address":[829455,829836],"length":1,"stats":{"Line":0}},{"line":32,"address":[829433],"length":1,"stats":{"Line":0}},{"line":33,"address":[829484],"length":1,"stats":{"Line":0}},{"line":34,"address":[829499],"length":1,"stats":{"Line":0}},{"line":35,"address":[829528],"length":1,"stats":{"Line":0}},{"line":41,"address":[829535],"length":1,"stats":{"Line":0}},{"line":44,"address":[829583],"length":1,"stats":{"Line":0}},{"line":45,"address":[829610,829679],"length":1,"stats":{"Line":0}},{"line":51,"address":[829592,829643],"length":1,"stats":{"Line":0}},{"line":62,"address":[829920],"length":1,"stats":{"Line":0}},{"line":67,"address":[752610,752491],"length":1,"stats":{"Line":0}},{"line":70,"address":[752670],"length":1,"stats":{"Line":0}},{"line":71,"address":[752830,752743,754488],"length":1,"stats":{"Line":0}},{"line":72,"address":[753197,754629,752940],"length":1,"stats":{"Line":0}},{"line":75,"address":[754579,753317,753384],"length":1,"stats":{"Line":0}},{"line":76,"address":[753679,753596,754542],"length":1,"stats":{"Line":0}},{"line":80,"address":[753821],"length":1,"stats":{"Line":0}},{"line":81,"address":[754507,753929],"length":1,"stats":{"Line":0}},{"line":84,"address":[754188],"length":1,"stats":{"Line":0}},{"line":85,"address":[754305],"length":1,"stats":{"Line":0}},{"line":88,"address":[752988],"length":1,"stats":{"Line":0}},{"line":90,"address":[753070,755385],"length":1,"stats":{"Line":0}},{"line":91,"address":[755003,756915,754698,752535,753085,754728],"length":1,"stats":{"Line":0}},{"line":92,"address":[755083],"length":1,"stats":{"Line":0}},{"line":93,"address":[755160,755268,756976],"length":1,"stats":{"Line":0}},{"line":95,"address":[755363],"length":1,"stats":{"Line":0}},{"line":96,"address":[755406],"length":1,"stats":{"Line":0}},{"line":100,"address":[755487],"length":1,"stats":{"Line":0}},{"line":101,"address":[755575,755642],"length":1,"stats":{"Line":0}},{"line":102,"address":[755722],"length":1,"stats":{"Line":0}},{"line":103,"address":[755841,755900],"length":1,"stats":{"Line":0}},{"line":104,"address":[755973],"length":1,"stats":{"Line":0}},{"line":105,"address":[756092,756159],"length":1,"stats":{"Line":0}},{"line":106,"address":[756243],"length":1,"stats":{"Line":0}},{"line":109,"address":[756282,756872],"length":1,"stats":{"Line":0}},{"line":110,"address":[756454,756516],"length":1,"stats":{"Line":0}},{"line":111,"address":[756548,756645],"length":1,"stats":{"Line":0}},{"line":112,"address":[756696],"length":1,"stats":{"Line":0}},{"line":113,"address":[757964,758259,757424,756721,757548,757457],"length":1,"stats":{"Line":0}},{"line":114,"address":[757510,757821,758128,757893],"length":1,"stats":{"Line":0}},{"line":115,"address":[757853,757775,757634,757932],"length":1,"stats":{"Line":0}},{"line":116,"address":[758215,757917,758001,757575,757881],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":49},{"path":["/","home","acooks","mcr","src","worker","mod.rs"],"content":"mod args;\nmod control_plane;\nmod data_plane;\nmod stats;\n\nuse anyhow::Result;\nuse metrics::{describe_counter, describe_gauge};\nuse metrics_exporter_prometheus::PrometheusBuilder;\nuse privdrop::PrivDrop;\nuse std::collections::HashMap;\nuse std::net::Ipv4Addr;\nuse std::path::Path;\nuse std::sync::Arc;\nuse tokio::sync::{Mutex, mpsc};\n\nuse self::args::Args;\nuse self::control_plane::control_plane_task;\nuse self::stats::{monitoring_task, stats_aggregator_task};\nuse crate::{FlowStats, ForwardingRule, OutputDestination, RelayCommand};\nuse clap::Parser;\nuse tokio::task::{self, JoinHandle};\n\ntype SharedFlows = Arc\u003cMutex\u003cHashMap\u003c(Ipv4Addr, u16), (ForwardingRule, FlowStats)\u003e\u003e\u003e;\n\npub async fn run(user: String, group: String) -\u003e Result\u003c()\u003e {\n    let args = Args::parse();\n\n    let ingress_socket_fd = if let Some(interface_name) = \u0026args.input_interface_name {\n        Some(Arc::new(data_plane::setup_ingress_socket(interface_name)?))\n    } else {\n        None\n    };\n\n    println!(\n        \"Worker process started. Attempting to drop privileges to user '{}' and group '{}'.\",\n        user, group\n    );\n\n    PrivDrop::default()\n        .user(\u0026user)\n        .group(\u0026group)\n        .apply()\n        .map_err(|e| anyhow::anyhow!(\"Failed to drop privileges: {}\", e))?;\n\n    println!(\"Successfully dropped privileges.\");\n\n    let builder = PrometheusBuilder::new();\n    builder.with_http_listener(args.prometheus_addr).install()?;\n    describe_counter!(\"packets_relayed_total\", \"Total packets relayed\");\n    describe_gauge!(\"memory_usage_bytes\", \"Current memory usage\");\n\n    let shared_flows: SharedFlows = Arc::new(Mutex::new(HashMap::new()));\n    let (relay_command_tx, mut relay_command_rx) = mpsc::channel(100);\n    let (stats_tx, stats_rx) = mpsc::channel(100);\n\n    let initial_rule = if let (\n        Some(iin),\n        Some(ig),\n        Some(ip),\n        Some(og),\n        Some(op),\n        Some(oi),\n    ) = (\n        args.input_interface_name.clone(),\n        args.input_group,\n        args.input_port,\n        args.output_group,\n        args.output_port,\n        args.output_interface,\n    ) {\n        Some(ForwardingRule {\n            input_interface: iin,\n            input_group: ig,\n            input_port: ip,\n            outputs: vec![OutputDestination {\n                group: og,\n                port: op,\n                interface: oi.to_string(),\n                dtls_enabled: false,\n            }],\n            dtls_enabled: false,\n        })\n    } else {\n        None\n    };\n\n    let control_socket_path = Path::new(\"/tmp/multicast_relay_control.sock\");\n\n    // Spawn the static, long-running tasks locally.\n    task::spawn_local(stats_aggregator_task(stats_rx, shared_flows.clone()));\n    task::spawn_local(control_plane_task(\n        control_socket_path,\n        relay_command_tx.clone(),\n        shared_flows.clone(),\n    ));\n    task::spawn_local(monitoring_task(\n        shared_flows.clone(),\n        args.reporting_interval,\n    ));\n\n    // Handle for the dynamic, replaceable flow task.\n    let mut flow_task_handle: Option\u003cJoinHandle\u003c()\u003e\u003e = None;\n\n    // Start the initial flow task if a rule was provided via CLI args.\n    if let (Some(rule), Some(fd)) = (initial_rule, \u0026ingress_socket_fd) {\n        let stats_tx_clone = stats_tx.clone();\n        let fd_clone = Arc::clone(fd);\n        flow_task_handle = Some(task::spawn_local(async move {\n            if let Err(e) = data_plane::run_flow_task(rule.clone(), fd_clone, stats_tx_clone).await\n            {\n                eprintln!(\"Flow task failed: {}\", e);\n            }\n        }));\n    }\n\n    let igmp_socket = std::net::UdpSocket::bind(\"0.0.0.0:0\")?;\n    let mut joined_groups = HashMap::new();\n\n    // Main event loop: listen for commands to manage the flow task.\n    loop {\n        if let Some(command) = relay_command_rx.recv().await {\n            match command {\n                RelayCommand::AddRule(rule) =\u003e {\n                    println!(\"Received AddRule command.\");\n                    if let Some(handle) = flow_task_handle.take() {\n                        println!(\"Aborting previous flow task.\");\n                        handle.abort();\n                    }\n\n                    if let Some(_interface_name) = \u0026args.input_interface_name {\n                        let interface_addr = Ipv4Addr::UNSPECIFIED; // Let the OS choose\n                        igmp_socket.join_multicast_v4(\u0026rule.input_group, \u0026interface_addr)?;\n                        joined_groups.insert((rule.input_group, rule.input_port), ());\n                    }\n\n                    if let Some(fd) = \u0026ingress_socket_fd {\n                        println!(\"Spawning new flow task.\");\n                        let stats_tx_clone = stats_tx.clone();\n                        let fd_clone = Arc::clone(fd);\n                        flow_task_handle = Some(task::spawn_local(async move {\n                            if let Err(e) =\n                                data_plane::run_flow_task(rule.clone(), fd_clone, stats_tx_clone)\n                                    .await\n                            {\n                                eprintln!(\"Flow task failed: {}\", e);\n                            }\n                        }));\n                    }\n                }\n                RelayCommand::RemoveRule {\n                    input_group,\n                    input_port,\n                } =\u003e {\n                    println!(\"Received RemoveRule command.\");\n                    if let Some(handle) = flow_task_handle.take() {\n                        println!(\"Aborting flow task.\");\n                        handle.abort();\n                    }\n\n                    if joined_groups.remove(\u0026(input_group, input_port)).is_some() {\n                        let interface_addr = Ipv4Addr::UNSPECIFIED; // Let the OS choose\n                        igmp_socket.leave_multicast_v4(\u0026input_group, \u0026interface_addr)?;\n                    }\n                }\n            }\n        } else {\n            // The command channel was closed, which means the control plane\n            // task has died. We should exit gracefully.\n            println!(\"Command channel closed. Worker shutting down.\");\n            break;\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":25,"address":[672496,672499],"length":1,"stats":{"Line":0}},{"line":26,"address":[723156],"length":1,"stats":{"Line":0}},{"line":28,"address":[723372,723266],"length":1,"stats":{"Line":0}},{"line":29,"address":[723330,723445,723650],"length":1,"stats":{"Line":0}},{"line":31,"address":[723361],"length":1,"stats":{"Line":0}},{"line":34,"address":[723588,723735],"length":1,"stats":{"Line":0}},{"line":39,"address":[728182,723982,724060,723847],"length":1,"stats":{"Line":0}},{"line":40,"address":[723862],"length":1,"stats":{"Line":0}},{"line":41,"address":[723897],"length":1,"stats":{"Line":0}},{"line":43,"address":[724044,731520,723959,731530],"length":1,"stats":{"Line":0}},{"line":45,"address":[724085],"length":1,"stats":{"Line":0}},{"line":47,"address":[724130],"length":1,"stats":{"Line":0}},{"line":48,"address":[728141,724157],"length":1,"stats":{"Line":0}},{"line":49,"address":[724358],"length":1,"stats":{"Line":0}},{"line":50,"address":[724365],"length":1,"stats":{"Line":0}},{"line":52,"address":[724380],"length":1,"stats":{"Line":0}},{"line":53,"address":[724481,724587],"length":1,"stats":{"Line":0}},{"line":54,"address":[724707,724601],"length":1,"stats":{"Line":0}},{"line":56,"address":[725128,725108,725190,725210,725226,725246,726086],"length":1,"stats":{"Line":0}},{"line":57,"address":[725254],"length":1,"stats":{"Line":0}},{"line":58,"address":[725294],"length":1,"stats":{"Line":0}},{"line":59,"address":[725308],"length":1,"stats":{"Line":0}},{"line":60,"address":[725332],"length":1,"stats":{"Line":0}},{"line":61,"address":[725346],"length":1,"stats":{"Line":0}},{"line":62,"address":[725370],"length":1,"stats":{"Line":0}},{"line":64,"address":[724729],"length":1,"stats":{"Line":0}},{"line":65,"address":[724795],"length":1,"stats":{"Line":0}},{"line":66,"address":[724821],"length":1,"stats":{"Line":0}},{"line":67,"address":[724835],"length":1,"stats":{"Line":0}},{"line":68,"address":[724861],"length":1,"stats":{"Line":0}},{"line":69,"address":[724875],"length":1,"stats":{"Line":0}},{"line":71,"address":[725815],"length":1,"stats":{"Line":0}},{"line":72,"address":[725384],"length":1,"stats":{"Line":0}},{"line":75,"address":[725532,725493,725426,725572,726030],"length":1,"stats":{"Line":0}},{"line":78,"address":[725517],"length":1,"stats":{"Line":0}},{"line":84,"address":[726061],"length":1,"stats":{"Line":0}},{"line":87,"address":[726179,725982],"length":1,"stats":{"Line":0}},{"line":90,"address":[726217,728072,726270],"length":1,"stats":{"Line":0}},{"line":91,"address":[726600,726639],"length":1,"stats":{"Line":0}},{"line":93,"address":[726427,726500],"length":1,"stats":{"Line":0}},{"line":94,"address":[726516],"length":1,"stats":{"Line":0}},{"line":96,"address":[726761],"length":1,"stats":{"Line":0}},{"line":97,"address":[726708],"length":1,"stats":{"Line":0}},{"line":98,"address":[726746],"length":1,"stats":{"Line":0}},{"line":102,"address":[726841],"length":1,"stats":{"Line":0}},{"line":105,"address":[727720,727082,726852],"length":1,"stats":{"Line":0}},{"line":106,"address":[727186,727273],"length":1,"stats":{"Line":0}},{"line":107,"address":[727350,727289],"length":1,"stats":{"Line":0}},{"line":108,"address":[731953,731761,727358,732381,732370,731632,727538,731665],"length":1,"stats":{"Line":0}},{"line":109,"address":[732221,731718,731984,731788,731843],"length":1,"stats":{"Line":0}},{"line":111,"address":[732214,732270],"length":1,"stats":{"Line":0}},{"line":116,"address":[727619,727822,728021],"length":1,"stats":{"Line":0}},{"line":117,"address":[727978,727913],"length":1,"stats":{"Line":0}},{"line":121,"address":[728256,728226,730678,723197,728547,727988],"length":1,"stats":{"Line":0}},{"line":122,"address":[728610],"length":1,"stats":{"Line":0}},{"line":123,"address":[728742],"length":1,"stats":{"Line":0}},{"line":124,"address":[728814,728881],"length":1,"stats":{"Line":0}},{"line":125,"address":[728908],"length":1,"stats":{"Line":0}},{"line":126,"address":[729115,728987],"length":1,"stats":{"Line":0}},{"line":127,"address":[729142],"length":1,"stats":{"Line":0}},{"line":130,"address":[729021,729184],"length":1,"stats":{"Line":0}},{"line":131,"address":[729192],"length":1,"stats":{"Line":0}},{"line":132,"address":[729203,729309,729533],"length":1,"stats":{"Line":0}},{"line":133,"address":[729412],"length":1,"stats":{"Line":0}},{"line":136,"address":[729250,730088,729629],"length":1,"stats":{"Line":0}},{"line":137,"address":[729637,729682],"length":1,"stats":{"Line":0}},{"line":138,"address":[729773,729709],"length":1,"stats":{"Line":0}},{"line":139,"address":[729789,729844],"length":1,"stats":{"Line":0}},{"line":140,"address":[732528,732657,732561,730026,732849,733266,733277,729852],"length":1,"stats":{"Line":0}},{"line":141,"address":[733117,733070],"length":1,"stats":{"Line":0}},{"line":142,"address":[732614,732739,733020,733047,732809],"length":1,"stats":{"Line":0}},{"line":143,"address":[732833,732797,733036,732880,732684],"length":1,"stats":{"Line":0}},{"line":145,"address":[733110,733166],"length":1,"stats":{"Line":0}},{"line":150,"address":[728692],"length":1,"stats":{"Line":0}},{"line":154,"address":[728713,730157],"length":1,"stats":{"Line":0}},{"line":155,"address":[730184],"length":1,"stats":{"Line":0}},{"line":156,"address":[730394,730263],"length":1,"stats":{"Line":0}},{"line":157,"address":[730421],"length":1,"stats":{"Line":0}},{"line":160,"address":[730657,730454,730302],"length":1,"stats":{"Line":0}},{"line":161,"address":[730507],"length":1,"stats":{"Line":0}},{"line":162,"address":[730518,730748],"length":1,"stats":{"Line":0}},{"line":169,"address":[731150,728649],"length":1,"stats":{"Line":0}},{"line":174,"address":[731177],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":83},{"path":["/","home","acooks","mcr","src","worker","stats.rs"],"content":"use anyhow::Result;\nuse metrics::gauge;\nuse std::collections::HashMap;\nuse std::net::Ipv4Addr;\nuse std::sync::Arc;\nuse std::time::Duration;\nuse sysinfo::{Pid, System};\nuse tokio::sync::Mutex;\nuse tokio::sync::mpsc;\n\nuse crate::{FlowStats, ForwardingRule};\n\ntype SharedFlows = Arc\u003cMutex\u003cHashMap\u003c(Ipv4Addr, u16), (ForwardingRule, FlowStats)\u003e\u003e\u003e;\n\npub async fn stats_aggregator_task(\n    mut stats_rx: mpsc::Receiver\u003c(ForwardingRule, FlowStats)\u003e,\n    shared_flows: SharedFlows,\n) -\u003e Result\u003c()\u003e {\n    while let Some((rule, stats)) = stats_rx.recv().await {\n        let mut flows = shared_flows.lock().await;\n        flows.insert((rule.input_group, rule.input_port), (rule, stats));\n    }\n    Ok(())\n}\n\npub async fn monitoring_task(_shared_flows: SharedFlows, reporting_interval: u64) {\n    let mut sys = System::new_all();\n    let pid = Pid::from(std::process::id() as usize);\n    loop {\n        tokio::time::sleep(Duration::from_secs(reporting_interval)).await;\n        sys.refresh_process(pid);\n        if let Some(process) = sys.process(pid) {\n            gauge!(\"cpu_usage_percent\").set(process.cpu_usage() as f64);\n            gauge!(\"memory_usage_bytes\").set(process.memory() as f64);\n        }\n    }\n}\n","traces":[{"line":15,"address":[210944],"length":1,"stats":{"Line":0}},{"line":19,"address":[685316,686167,686053,685266,685236,685213,686109],"length":1,"stats":{"Line":0}},{"line":20,"address":[685251,686661,685343,686618,685367],"length":1,"stats":{"Line":0}},{"line":21,"address":[685610,685669],"length":1,"stats":{"Line":0}},{"line":26,"address":[210976,210989],"length":1,"stats":{"Line":0}},{"line":27,"address":[687038],"length":1,"stats":{"Line":0}},{"line":28,"address":[687192,687126],"length":1,"stats":{"Line":0}},{"line":30,"address":[688047,687238,687279,687307,687072],"length":1,"stats":{"Line":0}},{"line":31,"address":[687463],"length":1,"stats":{"Line":0}},{"line":32,"address":[687492],"length":1,"stats":{"Line":0}},{"line":33,"address":[687590],"length":1,"stats":{"Line":0}},{"line":34,"address":[687793],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":12},{"path":["/","home","acooks","mcr","tests","control_plane.rs"],"content":"use multicast_relay::{ForwardingRule, RelayCommand};\nuse tokio::sync::mpsc;\n\n#[tokio::test]\nasync fn test_control_plane_logic() {\n    let (relay_command_tx, mut relay_command_rx) = mpsc::channel(100);\n\n    let rule = ForwardingRule {\n        input_interface: \"eth0\".to_string(),\n        input_group: \"224.0.0.1\".parse().unwrap(),\n        input_port: 5000,\n        outputs: vec![],\n        dtls_enabled: false,\n    };\n\n    let add_cmd = RelayCommand::AddRule(rule.clone());\n    relay_command_tx.send(add_cmd).await.unwrap();\n\n    let received = relay_command_rx.recv().await;\n    assert!(received.is_some());\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, ''),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e(
        'code',
        {
          className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        },
        line,
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = '';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = '';
    }
  });
})();
</script>
</body>
</html>