# GEM Architecture v2

## 1. Overview

This document describes the v2 architecture for Group Encrypted Multicast (GEM), a decentralized system for securing multicast traffic over untrusted networks. This design is the synthesis of a structured analysis of the initial sketch, incorporating principles of resilience and security.

The core innovation of GEM is the ability to transport encrypted multicast traffic **natively as multicast**, without resorting to unicast encapsulation for the data plane.

## 2. The Two-Plane Architecture

GEM is composed of two distinct planes: a secure Control Plane for establishing identity and distributing keys, and a Data Plane for transporting the encrypted multicast traffic.

### 2.1. The Control Plane: Babel over IPsec

The control plane's function is to create a secure, resilient, and decentralized routing domain for MCR instances to exchange identity and keying information.

*   **Transport Security (IPsec):**
    *   The entire control plane is secured at the transport layer using **IPsec ESP tunnels**.
    *   A symmetric **Bootstrap Key (BK)**, ideally stored in a Hardware Security Module (HSM), is used as the Pre-Shared Key (PSK) to establish these tunnels.
    *   Tunnels are established between the **IPv6 link-local addresses** of neighboring MCR instances, allowing the control plane to form without routable IP configuration.
    *   This IPsec layer provides confidentiality, integrity, and **built-in anti-replay protection** for all control plane traffic.

*   **Routing & Information Propagation (Babel):**
    *   The **Babel distance-vector routing protocol** runs exclusively over the secure IPsec tunnels.
    *   Babel is responsible for peer discovery, route propagation, and ensuring the eventual consistency of the control plane state.
    *   Its use provides inherent resilience against packet loss, node restarts (via "Full Table Request"), and network partitions.

*   **Custom Information Exchange (Babel TLVs):**
    *   We will define custom Type-Length-Value (TLV) structures to be carried by Babel:
        1.  **Public Key TLV:** Associates a node's routable IP address with its long-term **Node Public Key** (the public part of an asymmetric key pair stored on the HSM). This establishes a network-wide trusted identity map.
        2.  **SEK Announce TLV:** Used by a source to announce the key for a specific stream.

### 2.2. The Data Plane: Source-Encrypted Multicast

The data plane is responsible for the high-performance encryption and forwarding of the user's multicast traffic.

*   **Traffic Format:** The data traffic remains as standards-compliant multicast (e.g., UDP/RTP). The IP headers are preserved; only the payload is encrypted.
*   **Encryption:** Each source MCR instance generates a unique, symmetric **Source Encryption Key (SEK)** for each multicast stream it originates.
*   **Per-Packet Authorization:** Each encrypted data packet is appended with a **signature (HMAC)** created with the symmetric **Group Authorization Key (GAK)**. This allows receivers to quickly verify that a packet is from an authorized group member before attempting decryption.

## 3. Key Hierarchy and Provisioning

The security of the system is rooted in a clear, multi-layered key hierarchy, ideally managed by an HSM on each node.

1.  **Node Private/Public Key (Asymmetric):** The permanent, unique identity of the MCR instance. Stored on the HSM.
2.  **Bootstrap Key (BK) (Symmetric):** Pre-shared key for the IPsec control plane. Provisioned to all nodes in the secure domain.
3.  **Group Authorization Key (GAK) (Symmetric):** Pre-shared key for a specific multicast group (e.g., "Broadcast Video"). Provisioned only to nodes authorized for that group. Used for signing/verifying control messages and data packets.
4.  **Source Encryption Key (SEK) (Symmetric):** Temporary key generated by a source for a single stream. Distributed via the control plane, used for data encryption.

## 4. Detailed Workflow

1.  **Initialization:**
    *   MCR instances start. They use their BK to establish IPsec tunnels with their link-local neighbors.
    *   The Babel protocol starts, running over these tunnels.
    *   Nodes exchange Babel routes, including **Public Key TLVs**, building a map of all trusted peer identities.

2.  **Source Begins Stream:**
    *   `MCR-A` wants to send a stream to group `239.1.1.1`. It generates a new **SEK-A**.
    *   `MCR-A` creates an **SEK Announce TLV** containing its identity, the group, and **SEK-A**.
    *   It calculates an **HMAC** of this TLV using the **GAK** for that group.
    *   It injects the `[TLV + HMAC]` into its local Babel daemon.
    *   Babel reliably propagates this announcement to all other nodes.

3.  **Receiver Learns Key:**
    *   `MCR-B` receives the SEK Announce TLV from its Babel neighbor.
    *   It checks if it has the **GAK** for that group. If not, it ignores the TLV.
    *   If it does, it verifies the **HMAC**. If valid, it stores `(Source: MCR-A, Group: 239.1.1.1) -> SEK-A` in its key cache.

4.  **Data Transmission:**
    *   `MCR-A` encrypts its multicast packets for `239.1.1.1` with **SEK-A**.
    *   For each packet, it calculates an **HMAC** of the encrypted payload using the **GAK**.
    *   It sends the multicast packet as `[Encrypted Payload] + [HMAC]`.

5.  **Data Reception:**
    *   `MCR-B` receives the multicast packet.
    *   It first verifies the per-packet **HMAC** using its **GAK**. If invalid, the packet is dropped.
    *   If the HMAC is valid, it looks up the correct key (`SEK-A`) from its cache based on the packet's source IP.
    *   It decrypts the payload with **SEK-A** and forwards the original data to its local network.

---
